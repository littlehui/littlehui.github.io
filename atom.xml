<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Littlehui&#39;s Notes</title>
  
  <subtitle>天地那么大，世界那么辽阔。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.lilhui.com/"/>
  <updated>2017-11-20T03:01:44.450Z</updated>
  <id>http://www.lilhui.com/</id>
  
  <author>
    <name>Littlehui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux自动删除N天日志</title>
    <link href="http://www.lilhui.com/2017/11/20/linux/linux_1/"/>
    <id>http://www.lilhui.com/2017/11/20/linux/linux_1/</id>
    <published>2017-11-20T02:38:07.000Z</published>
    <updated>2017-11-20T03:01:44.450Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>web在部署到linux环境后，一般都是把日志等级设置加高。只输出Error信息或者直接关闭Log。但是某些系统需要搜集容器的access日志来做数据分析。<br>如果本地存储的话，日子久了，日志就越来越大。占用大量磁盘资源，直接影响到系统的正常运行。所以，这种情况下，对日志做定期清理，是成本最低的方法了。</p></blockquote><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="删除文件脚本"><a href="#删除文件脚本" class="headerlink" title="删除文件脚本"></a>删除文件脚本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find 对应目录 -mtime +天数 -name &quot;文件名&quot; -exec rm -rf &#123;&#125; \;</div></pre></td></tr></table></figure><p>例如:删除3天前 /opt/logs下 search开头的日志。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find /opt/logs/ -mtime +3 -name &quot;search*.log&quot; exec rm -rf &#123;&#125; \;</div></pre></td></tr></table></figure></p><p>说明：<br>find：linux的查找命令，用户查找指定条件的文件<br>/opt/logs/：想要进行清理的任意目录；<br>-mtime：标准语句写法；<br>+3：查找30天前的文件，这里用数字代表天数；<br>“search*.log”：支持范式匹配<br>-exec：执行<br>rm -rf：强制删除命令<br>{} \; ：固定写法，一对大括号+空格++; </p><h4 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h4><p>将以上命令放置到可执行shell脚本中再通过cron调度执行。<br>创建shell:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">touch ~/bin/auto-del-30-days-ago-log.sh</div><div class="line">chmod +x auto-del-30-days-ago-log.sh</div></pre></td></tr></table></figure></p><p>编辑shell脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim auto-del-3-days-ago-log.sh</div></pre></td></tr></table></figure></p><p>内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line">find /opt/logs/ -mtime +3 -name &quot;search*.log&quot; exec rm -rf &#123;&#125; \;</div></pre></td></tr></table></figure></p><p>添加计划调度：<br>执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">10 0 * * * ~/auto-del-3-days-ago-log.sh &gt;/dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure></p><p>设置是每天凌晨0点10分执行auto-del-7-days-ago-log.sh文件进行数据清理任务了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>THE END.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;web在部署到linux环境后，一般都是把日志等级设置加高。只输出Error信息或者直接关闭Log。但是某些系统需
      
    
    </summary>
    
      <category term="linux" scheme="http://www.lilhui.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.lilhui.com/tags/linux/"/>
    
      <category term="系统维护" scheme="http://www.lilhui.com/tags/%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title>设计模式系列：装饰器模式</title>
    <link href="http://www.lilhui.com/2017/11/09/java/patterndesign/patterndesign_7/"/>
    <id>http://www.lilhui.com/2017/11/09/java/patterndesign/patterndesign_7/</id>
    <published>2017-11-09T02:24:29.000Z</published>
    <updated>2017-11-09T02:30:55.722Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;h3 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现&lt;/h3&gt;&lt;h3 id
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="设计模式" scheme="http://www.lilhui.com/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.lilhui.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式系列:桥接模式</title>
    <link href="http://www.lilhui.com/2017/11/09/java/patterndesign/patterndesign_10/"/>
    <id>http://www.lilhui.com/2017/11/09/java/patterndesign/patterndesign_10/</id>
    <published>2017-11-09T02:24:29.000Z</published>
    <updated>2017-11-20T03:00:29.481Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;h3 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现&lt;/h3&gt;&lt;h3 id
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="设计模式" scheme="http://www.lilhui.com/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.lilhui.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式系列：外观模式</title>
    <link href="http://www.lilhui.com/2017/11/09/java/patterndesign/patterndesign_9/"/>
    <id>http://www.lilhui.com/2017/11/09/java/patterndesign/patterndesign_9/</id>
    <published>2017-11-09T02:24:29.000Z</published>
    <updated>2017-11-09T02:30:55.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;h3 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现&lt;/h3&gt;&lt;h3 id
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="设计模式" scheme="http://www.lilhui.com/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.lilhui.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式系列：代理模式</title>
    <link href="http://www.lilhui.com/2017/11/09/java/patterndesign/patterndesign_8/"/>
    <id>http://www.lilhui.com/2017/11/09/java/patterndesign/patterndesign_8/</id>
    <published>2017-11-09T02:24:29.000Z</published>
    <updated>2017-11-09T02:30:55.707Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;h3 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现&lt;/h3&gt;&lt;h3 id
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="设计模式" scheme="http://www.lilhui.com/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.lilhui.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式系列:组合模式</title>
    <link href="http://www.lilhui.com/2017/11/09/java/patterndesign/patterndesign_11/"/>
    <id>http://www.lilhui.com/2017/11/09/java/patterndesign/patterndesign_11/</id>
    <published>2017-11-09T02:24:29.000Z</published>
    <updated>2017-11-09T02:30:55.711Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;h3 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现&lt;/h3&gt;&lt;h3 id
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="设计模式" scheme="http://www.lilhui.com/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.lilhui.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式系列:享元模式</title>
    <link href="http://www.lilhui.com/2017/11/09/java/patterndesign/patterndesign_12/"/>
    <id>http://www.lilhui.com/2017/11/09/java/patterndesign/patterndesign_12/</id>
    <published>2017-11-09T02:24:29.000Z</published>
    <updated>2017-11-09T02:30:55.715Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;h3 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现&lt;/h3&gt;&lt;h3 id
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="设计模式" scheme="http://www.lilhui.com/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.lilhui.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式系列：适配器模式</title>
    <link href="http://www.lilhui.com/2017/11/09/java/patterndesign/patterndesign_6/"/>
    <id>http://www.lilhui.com/2017/11/09/java/patterndesign/patterndesign_6/</id>
    <published>2017-11-09T02:21:00.000Z</published>
    <updated>2017-11-09T05:49:14.247Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;h3 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现&lt;/h3&gt;&lt;h3 id
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="设计模式" scheme="http://www.lilhui.com/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.lilhui.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式系列：概况</title>
    <link href="http://www.lilhui.com/2017/10/25/java/patterndesign/parterndesign_0/"/>
    <id>http://www.lilhui.com/2017/10/25/java/patterndesign/parterndesign_0/</id>
    <published>2017-10-25T03:59:47.000Z</published>
    <updated>2017-11-09T02:38:33.090Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h3><blockquote><p>设计模式是对于Java变成过程中遇到的特定抽象场景总结出的一套通用方法,常用的用23种几年模式。</p></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>总体来说设计模式分为三大类：</p><ul><li>创建型模式，共五种： <ol><li>工厂方法模式<br> 定义一个创建对象的接口，让子类决定将哪一个类实例化。使一个类实例化延迟到子类。</li><li>抽象工厂模式<br> 提供一个创建一系列产品或相互依赖对象接口无需指定具体的类。 </li><li>单例模式<br> 保证一个类仅有一个实例，并提供一个访问它的全局访问。</li><li>建造者模式<br> 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</li><li>原型模式<br> 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。</li></ol></li><li>结构型模式，共七种：<ol><li>适配器模式<br> 将一个类的接口转换成客户希望的另一个接口，Adapter使原本由于接口不兼容而不能正常工作的类可以正常工作。</li><li>装饰器模式<br> 动态地给一个对象添加一些额外的职责，就扩展功能而言，它比生成子类方式更加灵活。</li><li>代理模式<br> 为其他对象提供一个代理以控制对这个对象的访问。</li><li>外观模式<br> 为子系统中的一组接口提供一个一致的界面，Facade模式定义一个高层接口，这个接口使得这一子系统更加容易使用。</li><li>桥接模式<br> 将抽象部分与实现部分分离，使它们可以独立变化。</li><li>组合模式<br> 将对象组合成树形结构以表示 “部分-整体”的层次结构。它使得客户对单个对象和符合对象的使用具有一致性。</li><li>享元模式<br> 运用共享技术有效支持大量细粒度对象。</li></ol></li><li>行为型模式，共十一种：<ol><li>策略模式<br> 定义一系列算法，把他们封装起来，并且使它们可以相互替换，本模式使得算法的变化可以独立与使用它的客户端。</li><li>模板方法模式<br> 定义一个操作中的算法骨架，而将一些步骤延迟到子类，Template Method使得子类可以不改变一个算法结构即可重新定义该算法某些特定步骤。</li><li>观察者模式<br> 定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。</li><li>迭代器模式<br> 提供一种方法顺序访问一个聚合对象中各个元素而又不暴露该对象内部表示。</li><li>责任链模式<br> 为接触请求的发送者和接受者之间的耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条连传递该请求，知道有一个对象处理。</li><li>命令模式<br> 将一个请求封装为一个对象，从而使可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可取消操作。</li><li>备忘录模式<br> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象回复到保存的状态。</li><li>状态模式<br> 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎属于一个新的类。</li><li>访问者模式<br> 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</li><li>中介者模式<br>用一个中介对象来封装一系列对象交互，中介者使各对象不需要显示的相互引用，从而使得其耦合松散，而且可以独立的改变他们之间的交互。</li><li>解释器模式<br>给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中句子。<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3></li></ol></li></ul><ol><li>开闭原则（Open Close Principle）<br> 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。</li><li>里氏代换原则（Liskov Substitution Principle）   <ol><li>子类的能力必须大于等于父类，即父类可以使用的方法，子类都可以使用。</li><li>返回值也是同样的道理。假设一个父类方法返回一个List，子类返回一个ArrayList，这当然可以。<br>如果父类方法返回一个ArrayList，子类返回一个List，就说不通了。这里子类返回值的能力是比父类小的。</li><li>还有抛出异常的情况。任何子类方法可以声明抛出父类方法声明异常的子类。<br>而不能声明抛出父类没有声明的异常。<br>一句话理解：所有使用父类的地方都可以被子类替换</li></ol></li><li>依赖倒转原则（Dependence Inversion Principle）<br> 面向接口编程，依赖于抽象而不依赖于具体。</li><li>接口隔离原则（Interface Segregation Principle）<br> 使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，<br> 从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</li><li>迪米特法则（最少知道原则）（Demeter Principle）<br>一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</li><li>合成复用原则（Composite Reuse Principle）<br> 当聚合和继成都可以实现时候，应该使用聚合。聚合由于继承。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>上面提到的23种是经典和常用的模式。在实际生产中按照需求总结提取使用。有利于提高代码和程序功能的扩展维护性。然而也不能一味的以使用模式而是用，这就本末倒置了。随着更深入的理解和学习设计模式，会渐渐意识到：设计模式<br>真正的的模式是 “无模式”。看似无招胜似有招。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概况&quot;&gt;&lt;a href=&quot;#概况&quot; class=&quot;headerlink&quot; title=&quot;概况&quot;&gt;&lt;/a&gt;概况&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;设计模式是对于Java变成过程中遇到的特定抽象场景总结出的一套通用方法,常用的用23种几年模式。&lt;/p&gt;
&lt;/bl
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="设计模式" scheme="http://www.lilhui.com/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://www.lilhui.com/tags/java/"/>
    
      <category term="设计模式" scheme="http://www.lilhui.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式系列：原型模式</title>
    <link href="http://www.lilhui.com/2017/10/25/java/patterndesign/parterndesign_5/"/>
    <id>http://www.lilhui.com/2017/10/25/java/patterndesign/parterndesign_5/</id>
    <published>2017-10-25T03:55:44.000Z</published>
    <updated>2017-11-08T10:25:24.931Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>原型模式是特殊的创建模式，它创建对象不通过直接new的方式产生，而是通过已有的对象复制。</p></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>Product<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String value;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ProductB productB;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ProductB <span class="title">getProductB</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> productB;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProductB</span><span class="params">(ProductB productB)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.productB = productB;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"product name:"</span> + <span class="keyword">this</span>.name);</div><div class="line">        System.out.println(<span class="string">"product value:"</span> + <span class="keyword">this</span>.value);</div><div class="line">        System.out.println(<span class="string">"productB name:"</span> + <span class="keyword">this</span>.productB.getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">deepClone</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ByteArrayOutputStream bo = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">            ObjectOutputStream oo = <span class="keyword">new</span> ObjectOutputStream(bo);</div><div class="line">            oo.writeObject(<span class="keyword">this</span>);</div><div class="line">            ByteArrayInputStream bi = <span class="keyword">new</span> ByteArrayInputStream(bo.toByteArray());</div><div class="line">            ObjectInputStream oi = <span class="keyword">new</span> ObjectInputStream(bi);</div><div class="line">            <span class="keyword">return</span> (Product)oi.readObject();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</div><div class="line">            <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">            e.printStackTrace();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ProductB<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Client<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Product product = <span class="keyword">new</span> Product();</div><div class="line">        ProductB productB = <span class="keyword">new</span> ProductB();</div><div class="line">        productB.setName(<span class="string">"B"</span>);</div><div class="line">        product.setName(<span class="string">"X"</span>);</div><div class="line">        product.setValue(<span class="string">"XX"</span>);</div><div class="line">        product.setProductB(productB);</div><div class="line">        Product clone = product.deepClone();</div><div class="line">        clone.getProductB().setName(<span class="string">"newXX"</span>);</div><div class="line">        product.display();</div><div class="line">        clone.display();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br>Connected to the target VM, address: ‘127.0.0.1:58904’, transport: ‘socket’<br>product name:X<br>product value:XX<br>productB name:B<br>product name:X<br>product value:XX<br>productB name:newXX<br>Disconnected from the target VM, address: ‘127.0.0.1:58904’, transport: ‘socket’</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>Product<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String value;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ProductB productB;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ProductB <span class="title">getProductB</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> productB;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProductB</span><span class="params">(ProductB productB)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.productB = productB;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"product name:"</span> + <span class="keyword">this</span>.name);</div><div class="line">        System.out.println(<span class="string">"product value:"</span> + <span class="keyword">this</span>.value);</div><div class="line">        System.out.println(<span class="string">"productB name:"</span> + <span class="keyword">this</span>.productB.getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> (Product)<span class="keyword">super</span>.clone();</div><div class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ProductB<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Client<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Product product = <span class="keyword">new</span> Product();</div><div class="line">        ProductB productB = <span class="keyword">new</span> ProductB();</div><div class="line">        productB.setName(<span class="string">"B"</span>);</div><div class="line">        product.setName(<span class="string">"X"</span>);</div><div class="line">        product.setValue(<span class="string">"XX"</span>);</div><div class="line">        product.setProductB(productB);</div><div class="line">        Product clone = product.clone();</div><div class="line">        clone.getProductB().setName(<span class="string">"newXX"</span>);</div><div class="line">        product.display();</div><div class="line">        clone.display();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>执行结果：<br>Connected to the target VM, address: ‘127.0.0.1:58962’, transport: ‘socket’<br>product name:X<br>product value:XX<br>productB name:newXX<br>product name:X<br>product value:XX<br>productB name:newXX<br>Disconnected from the target VM, address: ‘127.0.0.1:58962’, transport: ‘socket’</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>浅拷贝 拷贝后的对象如果有嵌套的复杂对象，那么改变嵌套对象会跟着改变。只拷贝表层的对象信息。<br>深拷贝，是所有的都拷贝，包括嵌套对象。这里的实现是通过序列化的方式实现。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;原型模式是特殊的创建模式，它创建对象不通过直接new的方式产生，而是通过已有的对象复制。&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="设计模式" scheme="http://www.lilhui.com/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.lilhui.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式系列：建造者模式</title>
    <link href="http://www.lilhui.com/2017/10/25/java/patterndesign/parterndesign_4/"/>
    <id>http://www.lilhui.com/2017/10/25/java/patterndesign/parterndesign_4/</id>
    <published>2017-10-25T03:55:32.000Z</published>
    <updated>2017-11-08T10:13:34.593Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>当要创建的对象相对复杂，可以将复杂对象的创建过程分离成若干过程。此时只要改变不同过程中的参数就可以产生不同的实例。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3></blockquote><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1510133972021.png?imageView2/2/w/593/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>Builder<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildProductPartA</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildProductPartB</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildProductPartC</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">buildProduct</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Director<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">constructProduct</span><span class="params">(Builder productBuilder)</span></span>&#123;</div><div class="line">        productBuilder.buildProductPartA();</div><div class="line">        productBuilder.buildProductPartB();</div><div class="line">        productBuilder.buildProductPartC();</div><div class="line">        <span class="keyword">return</span> productBuilder.buildProduct();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ProductBuilder<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Product product;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildProductPartA</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildProductPartB</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildProductPartC</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">buildProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Product<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Client<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Director director = <span class="keyword">new</span> Director();</div><div class="line">        director.constructProduct(<span class="keyword">new</span> ProductBuilder());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>我们看饮料机的工作步骤可以分为 倒入水，倒入饮料剂，制造饮料。定义一个饮料机就可以当做建造饮料的过程。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>建造者模式的核心是把类的创建过程分解成一个个过程。每个过程是一个单独的执行流程，可以通过不同参数指定流程的结果。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;当要创建的对象相对复杂，可以将复杂对象的创建过程分离成若干过程。此时只要改变不同过程中的参数就可以产生不同的实例。
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="设计模式" scheme="http://www.lilhui.com/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.lilhui.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式系列：抽象工厂模式</title>
    <link href="http://www.lilhui.com/2017/10/25/java/patterndesign/parterndesign_3/"/>
    <id>http://www.lilhui.com/2017/10/25/java/patterndesign/parterndesign_3/</id>
    <published>2017-10-25T03:54:58.000Z</published>
    <updated>2017-11-08T10:28:26.389Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>抽象工厂模式在原有的工厂方法模式上扩展，在工厂方面进行了抽象。从而增加产品规格的需求，可以更高地抽象成增加工厂类型。降低了耦合。</p></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1510131441764.png?imageView2/2/w/744/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>Factory<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createSoftProduct</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createHardProduct</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>FactoryA<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactoryA</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createSoftProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"工厂A:"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SoftProductA();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createHardProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"工厂A:"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HardProductA();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>FactoryB<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactoryB</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createSoftProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"工厂B:"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SoftProductB();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createHardProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"工厂B:"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HardProductB();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Product<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ProductB<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"我是产品B"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>SoftProductB<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftProductB</span> <span class="keyword">extends</span> <span class="title">ProductB</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoftProductB</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"创建 产品B:特性:柔软"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getName() + <span class="string">"柔软"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HardProductB<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HardProductB</span> <span class="keyword">extends</span> <span class="title">ProductB</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HardProductB</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"创建 产品B:特性:坚硬"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getName() + <span class="string">"坚硬"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ProductA<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"我是产品A"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>SoftProductA<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftProductA</span> <span class="keyword">extends</span> <span class="title">ProductA</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoftProductA</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"创建 产品A:特性:柔软"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getName() + <span class="string">"柔软"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HardProductA<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HardProductA</span> <span class="keyword">extends</span> <span class="title">ProductA</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HardProductA</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"创建 产品A:特性:坚硬"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getName() + <span class="string">"坚硬"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Client<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Factory factoryA = <span class="keyword">new</span> ProductFactoryA();</div><div class="line">        Factory factoryB = <span class="keyword">new</span> ProductFactoryB();</div><div class="line">        Product productAHard = factoryA.createHardProduct();</div><div class="line">        System.out.println(productAHard.getName());</div><div class="line">        Product productBHard = factoryB.createHardProduct();</div><div class="line">        System.out.println(productBHard.getName());</div><div class="line">        Product productASoft = factoryA.createSoftProduct();</div><div class="line">        System.out.println(productASoft.getName());</div><div class="line">        Product productBSoft = factoryB.createSoftProduct();</div><div class="line">        System.out.println(productBSoft.getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>如上产品 族 A B都有两个子类型，或者说特性。Hard or Soft。如果某个时候业务需求添加产品族C。此时扩展就很方便了，只要实现产品C的工厂类，就可以。<br>不用修改原来的代码，耦合度低。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>抽象工厂<br>优点: 扩展产品族（类型）容易<br>缺点: 扩展产品族下的子产品难，需要整体结构调整。  </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;抽象工厂模式在原有的工厂方法模式上扩展，在工厂方面进行了抽象。从而增加产品规格的需求，可以更高地抽象成增加工厂类型
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="设计模式" scheme="http://www.lilhui.com/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.lilhui.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式系列：工厂方法模式</title>
    <link href="http://www.lilhui.com/2017/10/25/java/patterndesign/parterndesign_2/"/>
    <id>http://www.lilhui.com/2017/10/25/java/patterndesign/parterndesign_2/</id>
    <published>2017-10-25T03:54:44.000Z</published>
    <updated>2017-11-08T10:28:26.384Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>工厂与一类产品的关系。用于调用端从复杂的构造逻辑中解耦。</p></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>简单工厂模式<br>产品：<br>Product<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ProductA<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.print(<span class="string">"A产品方法1"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.print(<span class="string">"A产品方法2"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ProductB<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.print(<span class="string">"B产品方法1"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.print(<span class="string">"B产品方法2"</span>);</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>工厂：<br>Factory<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(String type)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>SimpleFactory<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(String type)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (type) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">"A"</span>: </div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</div><div class="line">            <span class="keyword">case</span> <span class="string">"B"</span>: </div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</div><div class="line">            <span class="keyword">default</span>: </div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><pre><code>PS：这里用Java7的写法，switch支持String。</code></pre><p>客户端：<br>Client<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Factory factory = <span class="keyword">new</span> SimpleFactory();</div><div class="line">        Product product = factory.createProduct(<span class="string">"A"</span>);</div><div class="line">        product.methodOne();</div><div class="line">        product.methodTwo();</div><div class="line">        <span class="comment">//业务代码 </span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>A是一个接口，它的实现由 ClassA1,ClassA2,ClassA3。<br>B是一段业务代码，需要new一个A1并且进行操作。这时候就可以用工厂模式。某天业务的修改，需操作到另外一个ClassA2的方法。在工厂类进行修改就可以了。业务端代码就不用修改。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>工厂方法模式有良好的封装性，代码结构清晰。扩展性非常优秀。在增加产品类的情况下，只要适当地修改具体或扩展工厂类即可。调用者它只需要关心产品的接口。 可以对调用端调用复杂的构造逻辑进行解耦。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;工厂与一类产品的关系。用于调用端从复杂的构造逻辑中解耦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;实现
      
    
    </summary>
    
      <category term="Java" scheme="http://www.lilhui.com/categories/Java/"/>
    
      <category term="设计模式" scheme="http://www.lilhui.com/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="工厂方法" scheme="http://www.lilhui.com/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="设计模式" scheme="http://www.lilhui.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>多线程系列：volatile关键字</title>
    <link href="http://www.lilhui.com/2017/10/25/java/multithread/multithread_1/"/>
    <id>http://www.lilhui.com/2017/10/25/java/multithread/multithread_1/</id>
    <published>2017-10-25T03:42:41.000Z</published>
    <updated>2017-10-26T06:55:55.425Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式系列：单例模式</title>
    <link href="http://www.lilhui.com/2017/10/23/java/patterndesign/parterndesign_1/"/>
    <id>http://www.lilhui.com/2017/10/23/java/patterndesign/parterndesign_1/</id>
    <published>2017-10-23T08:23:02.000Z</published>
    <updated>2017-10-26T09:23:42.206Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>单例模式，顾名思义就是在Java应用中，类的实例保证只有一个在JVM中。他有几个好处</p><ul><li>减少创建开销</li><li>减少内存使用频率，GC压力</li><li>保证流程独立</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="第一种-饿汉法"><a href="#第一种-饿汉法" class="headerlink" title="第一种 饿汉法"></a>第一种 饿汉法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSignleton</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码简单，但是无法延迟加载。</p><h4 id="第二种-单线程安全"><a href="#第二种-单线程安全" class="headerlink" title="第二种 单线程安全"></a>第二种 单线程安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </div><div class="line">            instance = <span class="keyword">new</span> Singleton();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种方式可以实现基本要求，但是在多线程情况下就会出现可能New出多个实例的情况。由此引入synchronized关键字，我们有如下实现：</p><h4 id="第三种-多线程安全"><a href="#第三种-多线程安全" class="headerlink" title="第三种 多线程安全"></a>第三种 多线程安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;  </div><div class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </div><div class="line">                    instance = <span class="keyword">new</span> Singleton();  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第二种方法引入了syncronized 关键字，在调用getInstance方法的时候进行了并发处理。然而在多线程情况下仍然有问题<br>情况如下：  </p><pre><code>a&gt;A、B线程同时进入了第一个if判断b&gt;A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton();c&gt;在new对象的过程中，由于JVM的优化，指令进行重排序，JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块。d&gt;B进入synchronized块，由于instance此时不是null，因此它马上离开了synchronized块并将结果返回给调用该方法的程序。e&gt;此时B线程打算使用Singleton实例，却发现它没有被初始化，于是错误发生了。</code></pre><p>这里引入volatile关键字禁止对instance操作的指令重排。</p><h4 id="第四种-多线程安全”多重锁检查””"><a href="#第四种-多线程安全”多重锁检查””" class="headerlink" title="第四种 多线程安全”多重锁检查””"></a>第四种 多线程安全”多重锁检查””</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;  </div><div class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </div><div class="line">                    instance = <span class="keyword">new</span> Singleton();  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种方法就是有名的DCL的单利模式。基本已经完善多线程下的单例模式。需要提醒的是， volatile屏蔽指令重排的语义在JDK 1.5中才被修复，所以JDK1.5之前的JAVA无法使用这一方式。</p><h4 id="第五种-静态内部类方法"><a href="#第五种-静态内部类方法" class="headerlink" title="第五种 静态内部类方法"></a>第五种 静态内部类方法</h4><p>静态类方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">         </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> Holder.singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>类只加载一次，所以这中方式也是线程安全的。<br>不过以上的方法都存在一些问题：</p><ul><li>进行序列化时需要额外的工作进行序列化(Serializable,transient,readResolve())等操作。否则每次序列化都是创建一个新的实例。</li><li>构造器虽然是私有的，但是还是可以通过反射来强行调用创建实例。一个方法是在构造器里判断已经创建过实例抛异常。<br>如何更优雅地解决以上两个缺陷呢，我们可以使用枚举单例。</li></ul><h4 id="第六种-枚举方法"><a href="#第六种-枚举方法" class="headerlink" title="第六种 枚举方法"></a>第六种 枚举方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</div><div class="line">    INSTANCE;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>枚举不仅线程安全，防止反射强行调用构造器外。还提供了自动化序列机制，繁殖序列化的时候创建新对象。<br>更接近与”完美”的单利模式。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>程序执行时候只需要一个实例执行的时候就可以用单例来：经典的场景有:<br>线程池，驱动管理，通用的计算模块，工具类代码等等</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>单例模式既熟悉，又陌生。看起来简单的功能，算法，要写好，无瑕疵，还是需要很大专研精神。避免遇到快很多坑。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;单例模式，顾名思义就是在Java应用中，类的实例保证只有一个在JVM中。他有几个好处&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少创建开销&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="Java" scheme="http://www.lilhui.com/categories/Java/"/>
    
      <category term="设计模式" scheme="http://www.lilhui.com/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例" scheme="http://www.lilhui.com/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B/"/>
    
    
      <category term="设计模式，单例" scheme="http://www.lilhui.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%8D%95%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM系列：JVM内存优化实例</title>
    <link href="http://www.lilhui.com/2017/10/11/java/jvm/jvm_3/"/>
    <id>http://www.lilhui.com/2017/10/11/java/jvm/jvm_3/</id>
    <published>2017-10-11T08:22:09.000Z</published>
    <updated>2017-10-11T09:27:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="优化实例"><a href="#优化实例" class="headerlink" title="优化实例"></a>优化实例</h3><p>java application项目（非web项目）</p><p>改进前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">-Xms128m</div><div class="line">-Xmx128m</div><div class="line">-XX:NewSize=64m</div><div class="line">-XX:PermSize=64m</div><div class="line">-XX:+UseConcMarkSweepGC</div><div class="line">-XX:CMSInitiatingOccupancyFraction=78</div><div class="line">-XX:ThreadStackSize=128</div><div class="line">-Xloggc:logs/gc.log</div><div class="line">-Dsun.rmi.dgc.server.gcInterval=3600000</div><div class="line">-Dsun.rmi.dgc.client.gcInterval=3600000</div><div class="line">-Dsun.rmi.server.exceptionTrace=true</div></pre></td></tr></table></figure></p><p>问题:<br>permsize 设置较小,很容易达到报警范围(0.8)<br>没有设置MaxPermSize，堆增长会带来额外压力。<br>NewSize较大，old gen 剩余空间64m，一方面可能会带来old区容易增长到报警范围（监控数据显示oldgenused长期在50m左右，接近78%，容易出现full gc）,另一方面也存在promontion fail风险<br>改进后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">-Xms128m</div><div class="line">-Xmx128m</div><div class="line">-Xmn24m</div><div class="line">-XX:PermSize=80m</div><div class="line">-XX:MaxPermSize=80m</div><div class="line">-Xss256k</div><div class="line">-XX:SurvivorRatio=1</div><div class="line">-XX:MaxTenuringThreshold=20</div><div class="line">-XX:+UseParNewGC</div><div class="line">-XX:+UseConcMarkSweepGC</div><div class="line">-XX:CMSInitiatingOccupancyFraction=75</div><div class="line">-XX:+UseCMSCompactAtFullCollection</div><div class="line">-XX:+CMSParallelRemarkEnabled</div><div class="line">-XX:CMSFullGCsBeforeCompaction=2</div><div class="line">-XX:SoftRefLRUPolicyMSPerMB=0</div><div class="line">-XX:+PrintClassHistogram</div><div class="line">-XX:+PrintGCDetails</div><div class="line">-XX:+PrintGCTimeStamps</div><div class="line">-XX:+PrintHeapAtGC</div><div class="line">-Xloggc:logs/gc.log</div><div class="line">-Dsun.rmi.dgc.server.gcInterval=3600000</div><div class="line">-Dsun.rmi.dgc.client.gcInterval=3600000</div><div class="line">-Dsun.rmi.server.exceptionTrace=true</div></pre></td></tr></table></figure></p><p>修改点：<br>PermSize与MaxPermSize都设置为80，一方面避免non heap warn(报警阀值0.8 非对内存一般占用到60M以内），一方面避免堆伸缩带来的压力<br>通过设置Xmn=24M及SurvivorRatio=1 使得Eden区=from space=to  space=8M,降低了Eden区大小，降低YGC的时间(降低到3-4ms左右),同时通过设MaxTenuringThreshold=20，使得old gen的增长很缓慢。带来的问题是YGC的次数明显提高了很多。<br>其他参数优化 修改后带来的好处见JVM参数设置<br>再次改进后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">-Xms128m</div><div class="line">-Xmx128m</div><div class="line">-Xmn36m</div><div class="line">-XX:PermSize=80m</div><div class="line">-XX:MaxPermSize=80m</div><div class="line">-Xss256k</div><div class="line">-XX:SurvivorRatio=1</div><div class="line">-XX:MaxTenuringThreshold=20</div><div class="line">-XX:+UseParNewGC</div><div class="line">-XX:+UseConcMarkSweepGC</div><div class="line">-XX:CMSInitiatingOccupancyFraction=73</div><div class="line">-XX:+UseCMSCompactAtFullCollection</div><div class="line">-XX:+CMSParallelRemarkEnabled</div><div class="line">-XX:CMSFullGCsBeforeCompaction=2</div><div class="line">-XX:SoftRefLRUPolicyMSPerMB=0</div><div class="line">-XX:+PrintClassHistogram</div><div class="line">-XX:+PrintGCDetails</div><div class="line">-XX:+PrintGCTimeStamps</div><div class="line">-XX:+PrintHeapAtGC</div><div class="line">-Xloggc:logs/gc.log</div><div class="line">-Dsun.rmi.dgc.server.gcInterval=3600000</div><div class="line">-Dsun.rmi.dgc.client.gcInterval=3600000</div><div class="line">-Dsun.rmi.server.exceptionTrace=true</div></pre></td></tr></table></figure></p><p>修改点：<br>      在上面的基础上调整Xmn大小到36M，设置CMSInitiatingOccupancyFraction=73。</p><pre><code>Dden区与Survivor区大小都增加到12M，通过CMSInitiatingOccupancyFraction计算公式,计算得出value为73是，可以避免promotion faild问题，同时满足堆内存监控报警值在80%：内存大小128M*80%=102.4M 102.4M-36M=66.4M(老生代达到此值报警） 老生代达到67.15M（92M*0.73）将发生Full GC，所以在老生代大小达到66.4M时也就是WARN报警时将很有可能出现Full GC。 增大了Eden和Survivor区的值，会减小YGC的次数，但由于空间变大理论上也会相应的增加YGC的时间，不过由于新生代本身就很小（才36M）这点儿变化可以忽略掉。实际的监控值显示YGC的时间在4-5ms之间。是可以接受范围。SurvivorRatio 这个值还得在仔细考虑下,有待优化中</code></pre><p>网上某个牛人的配置 :每天几百万pv一点问题都没有，网站没有停顿<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">$JAVA_ARGS</div><div class="line">.=</div><div class="line">&quot;</div><div class="line">-Dresin.home=$SERVER_ROOT</div><div class="line">-server</div><div class="line">-Xms6000M</div><div class="line">-Xmx6000M</div><div class="line">-Xmn500M</div><div class="line">-XX:PermSize=500M</div><div class="line">-XX:MaxPermSize=500M</div><div class="line">-XX:SurvivorRatio=65536</div><div class="line">-XX:MaxTenuringThreshold=0</div><div class="line">-Xnoclassgc</div><div class="line">-XX:+DisableExplicitGC</div><div class="line">-XX:+UseParNewGC</div><div class="line">-XX:+UseConcMarkSweepGC</div><div class="line">-XX:+UseCMSCompactAtFullCollection</div><div class="line">-XX:CMSFullGCsBeforeCompaction=0</div><div class="line">-XX:+CMSClassUnloadingEnabled</div><div class="line">-XX:-CMSParallelRemarkEnabled</div><div class="line">-XX:CMSInitiatingOccupancyFraction=90</div><div class="line">-XX:SoftRefLRUPolicyMSPerMB=0</div><div class="line">-XX:+PrintClassHistogram</div><div class="line">-XX:+PrintGCDetails</div><div class="line">-XX:+PrintGCTimeStamps</div><div class="line">-XX:+PrintHeapAtGC</div><div class="line">-Xloggc:log/gc.log</div><div class="line">&quot;;</div></pre></td></tr></table></figure></p><p>说明一下， -XX:SurvivorRatio=65536 -XX:MaxTenuringThreshold=0就是去掉了救助空间；<br>-Xnoclassgc禁用类垃圾回收，性能会高一点；<br>-XX:+DisableExplicitGC禁止System.gc()，免得程序员误调用gc方法影响性能；<br>-XX:+UseParNewGC，对年轻代采用多线程并行回收，这样收得快；<br>带CMS参数的都是和并发回收相关的，不明白的可以上网搜索；<br>CMSInitiatingOccupancyFraction，这个参数设置有很大技巧，基本上满足(Xmx-Xmn)<em>(100-CMSInitiatingOccupancyFraction)/100&gt;=Xmn就不会出现promotion failed。在我的应用中Xmx是6000，Xmn是500，那么Xmx-Xmn是5500兆，也就是年老代有5500兆，CMSInitiatingOccupancyFraction=90说明年老代到90%满的时候开始执行对年老代的并发垃圾回收（CMS），这时还剩10%的空间是5500</em>10%=550兆，所以即使Xmn（也就是年轻代共500兆）里所有对象都搬到年老代里，550兆的空间也足够了，所以只要满足上面的公式，就不会出现垃圾回收时的promotion failed；<br>SoftRefLRUPolicyMSPerMB这个参数我认为可能有点用，官方解释是softly reachable objects will remain alive for some amount of time after the last time they were referenced. The default value is one second of lifetime per free megabyte in the heap，我觉得没必要等1秒；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">-Xmx4000M</div><div class="line">-Xms4000M</div><div class="line">-Xmn600M</div><div class="line">-XX:PermSize=500M</div><div class="line">-XX:MaxPermSize=500M</div><div class="line">-Xss256K</div><div class="line">-XX:+DisableExplicitGC</div><div class="line">-XX:SurvivorRatio=1</div><div class="line">-XX:+UseConcMarkSweepGC</div><div class="line">-XX:+UseParNewGC</div><div class="line">-XX:+CMSParallelRemarkEnabled</div><div class="line">-XX:+UseCMSCompactAtFullCollection</div><div class="line">-XX:CMSFullGCsBeforeCompaction=0</div><div class="line">-XX:+CMSClassUnloadingEnabled</div><div class="line">-XX:LargePageSizeInBytes=128M</div><div class="line">-XX:+UseFastAccessorMethods</div><div class="line">-XX:+UseCMSInitiatingOccupancyOnly</div><div class="line">-XX:CMSInitiatingOccupancyFraction=80</div><div class="line">-XX:SoftRefLRUPolicyMSPerMB=0</div><div class="line">-XX:+PrintClassHistogram</div><div class="line">-XX:+PrintGCDetails</div><div class="line">-XX:+PrintGCTimeStamps</div><div class="line">-XX:+PrintHeapAtGC</div><div class="line">-Xloggc:log/gc.log</div></pre></td></tr></table></figure></p><p>改进方案：<br>上面方法不太好，因为没有用到救助空间，所以年老代容易满，CMS执行会比较频繁。我改善了一下，还是用救助空间，但是把救助空间加大，这样也不会有promotion failed。<br>具体操作上，32位Linux和64位Linux好像不一样，64位系统似乎只要配置MaxTenuringThreshold参数，CMS还是有暂停。为了解决暂停问题和promotion failed问题，最后我设置-XX:SurvivorRatio=1 ，并把MaxTenuringThreshold去掉，这样即没有暂停又不会有promotoin failed，而且更重要的是，年老代和永久代上升非常慢（因为好多对象到不了年老代就被回收了），所以CMS执行频率非常低，好几个小时才执行一次，这样，服务器都不用重启了。<br>某网友:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">$JAVA_ARGS</div><div class="line">.=</div><div class="line">&quot;</div><div class="line">-Dresin.home=$SERVER_ROOT</div><div class="line">-server</div><div class="line">-Xmx3000M</div><div class="line">-Xms3000M</div><div class="line">-Xmn600M</div><div class="line">-XX:PermSize=500M</div><div class="line">-XX:MaxPermSize=500M</div><div class="line">-Xss256K</div><div class="line">-XX:+DisableExplicitGC</div><div class="line">-XX:SurvivorRatio=1</div><div class="line">-XX:+UseConcMarkSweepGC</div><div class="line">-XX:+UseParNewGC</div><div class="line">-XX:+CMSParallelRemarkEnabled</div><div class="line">-XX:+UseCMSCompactAtFullCollection</div><div class="line">-XX:CMSFullGCsBeforeCompaction=0</div><div class="line">-XX:+CMSClassUnloadingEnabled</div><div class="line">-XX:LargePageSizeInBytes=128M</div><div class="line">-XX:+UseFastAccessorMethods</div><div class="line">-XX:+UseCMSInitiatingOccupancyOnly</div><div class="line">-XX:CMSInitiatingOccupancyFraction=70</div><div class="line">-XX:SoftRefLRUPolicyMSPerMB=0</div><div class="line">-XX:+PrintClassHistogram</div><div class="line">-XX:+PrintGCDetails</div><div class="line">-XX:+PrintGCTimeStamps</div><div class="line">-XX:+PrintHeapAtGC</div><div class="line">-Xloggc:log/gc.log</div><div class="line">&quot;;</div></pre></td></tr></table></figure></p><pre><code>64位jdk参考设置，年老代涨得很慢，CMS执行频率变小，CMS没有停滞，也不会有promotion failed问题，内存回收得很干净</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>打印并分析进行垃圾回收的时间，内容，具体数值。如果有OOM导出OOM时内存使用情况。</li><li>分析垃圾回收时候的数据信息，（年轻区，年老区，方法区）查看OOM时内存使用情况。 </li><li>优化的权重顺序可以按照，FullGc&gt;频繁YGC</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;优化实例&quot;&gt;&lt;a href=&quot;#优化实例&quot; class=&quot;headerlink&quot; title=&quot;优化实例&quot;&gt;&lt;/a&gt;优化实例&lt;/h3&gt;&lt;p&gt;java application项目（非web项目）&lt;/p&gt;
&lt;p&gt;改进前：&lt;br&gt;&lt;figure class=&quot;highl
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="jvm" scheme="http://www.lilhui.com/categories/java/jvm/"/>
    
    
      <category term="java" scheme="http://www.lilhui.com/tags/java/"/>
    
      <category term="jvm调优" scheme="http://www.lilhui.com/tags/jvm%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM系列：JVM内存优化建议</title>
    <link href="http://www.lilhui.com/2017/10/09/java/jvm/jvm_2/"/>
    <id>http://www.lilhui.com/2017/10/09/java/jvm/jvm_2/</id>
    <published>2017-10-09T09:21:09.000Z</published>
    <updated>2017-10-11T08:22:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h3><p>JAVA程序在运行时  </p><ol><li>加快GC速度</li><li>减少FullGC</li><li>减少停顿</li><li>杜绝GC出错<blockquote><p>GC优化的策略本质上JVM运行中通过参数的变换调和达到运行平衡的过程。it is an art.</p><h3 id="经验配置"><a href="#经验配置" class="headerlink" title="经验配置"></a>经验配置</h3></blockquote></li></ol><h4 id="垃圾搜集器"><a href="#垃圾搜集器" class="headerlink" title="垃圾搜集器"></a>垃圾搜集器</h4><p>新生代收集器：有Serial收集器、ParNew收集器、Parallel Scavenge收集器<br>老生代收集器：Serial Old收集器、Parallel Old收集器、CMS收集器、G1收集器<br>以上所有的垃圾收集器都会发生STW，只不过FGC的STW时间更长。</p><h5 id="常用搜集器："><a href="#常用搜集器：" class="headerlink" title="常用搜集器："></a>常用搜集器：</h5><ul><li>CMSGC<br>  CMS(Concurrent Mark-Sweep)是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合，因此我们又叫它低延迟垃圾收集器。在启动JVM参数加上-XX:+UseConcMarkSweepGC ，这个参数表示对于老年代的回收采用CMS，注意此时新生代默认使用的是ParNew。CMS采用的基础算法是：标记—清除。</li><li>MSCGC vs CMSGC<br>  和普通序列化整理（MSC）区别在于有三个mark阶段（实际上还有个预清理过程，但对于解释清楚CMSGC没有帮助就忽略了）。CMSGC的精髓在于因为做到了不STW的情况下进行mark，我们得到了更短的总STW时间，代价是因为并行mark产生了『脏数据』即在mark的同时又生成了需要mark的对象，我们必须再进行一次STW，并收尾（remark）。<br>同时，我们要注意到得到更短的STW的同时，我们牺牲了系统吞吐量，CMSGC总吞吐量比ParOld要更低。</li><li>G1GC<br>  作为最新的垃圾收集器，有可能在jdk9中成为默认的垃圾收集器。<br>主要思路是将新生代老生代进一步分为多个region，每次gc可以针对部分region而不是整个堆内存。由此可以降低stw的单次最长时间，代价是可能在总时间上会更高。<br>G1GC让系统在整体吞吐量略降的情况下变得更加平滑稳定。</li></ul><h4 id="响应时间优先的应用"><a href="#响应时间优先的应用" class="headerlink" title="响应时间优先的应用"></a>响应时间优先的应用</h4><ul><li>年轻代选择<br>尽可能设大,直到接近系统的最低响应时间限制(根据实际情况选择).在此种情况下,年轻代收集发生的频率也是最小的.同时,减少到达年老代的对象.</li><li>年老代选择<br>年老代使用并发收集器,所以其大小需要小心设置,一般要考虑并发会话率和会话持续时间等一些参数.如果堆设置小了,可以会造成内存碎片,高回收频率以及应用暂停而使用传统的标记清除方式;如果堆大了,则需要较长的收集时间.最优化的方案,一般需要参考以下数据获得:<ol><li>并发垃圾收集信息.</li><li>持久代并发收集次数.</li><li>传统GC信息.</li><li>花在年轻代和年老代回收上的时间比例。<h4 id="吞吐量优先的应用"><a href="#吞吐量优先的应用" class="headerlink" title="吞吐量优先的应用"></a>吞吐量优先的应用</h4></li></ol></li><li>年轻代选择<br>尽可能的设置大,可能到达Gbit的程度.因为对响应时间没有要求,垃圾收集可以并行进行,一般适合8CPU以上的应用.<br>避免设置过小.当新生代设置过小时会导致:<ol><li>YGC次数更加频繁 </li><li>可能导致YGC对象直接进入旧生代,如果此时旧生代满了,会触发FGC.</li></ol></li><li>年老代选择<br>一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代.这样可以尽可能回收掉大部分短期对象,减少中期的对象,而年老代尽存放长期存活对象.</li></ul><h4 id="碎片问题"><a href="#碎片问题" class="headerlink" title="碎片问题"></a>碎片问题</h4><p>因为年老代的并发收集器使用标记,清除算法,所以不会对堆进行压缩.当收集器回收时,他会把相邻的空间进行合并,这样可以分配给较大的对象.但是,当堆空间较小时,运行一段时间以后,就会出现”碎片”,如果并发收集器找不到足够的空间,那么并发收集器将会停止,然后使用传统的标记,清除方式进行回收.如果出现”碎片”,可能需要进行如下配置:</p><blockquote><p>-XX:+UseCMSCompactAtFullCollection:使用并发收集器时,开启对年老代的压缩.<br>-XX:CMSFullGCsBeforeCompaction=0:上面配置开启的情况下,这里设置多少次Full GC后,对年老代进行压缩</p></blockquote><h4 id="promotion-failed问题"><a href="#promotion-failed问题" class="headerlink" title="promotion failed问题"></a>promotion failed问题</h4><p>可能是两种原因产生：</p><pre><code>1. 第一个原因是救助空间不够，救助空间里的对象还不应该被移动到年老代，但年轻代又有很多对象需要放入救助空间。2. 第二个原因是年老代没有足够的空间接纳来自年轻代的对象；这两种情况都会转向Full GC，网站停顿时间较长。</code></pre><p>用64位操作系统，Linux下64位的jdk比32位jdk要慢一些，但是吃得内存更多，吞吐量更大<br>XMX和XMS设置一样大，MaxPermSize和MinPermSize设置一样大，这样可以减轻伸缩堆大小带来的压力</p><ul><li>使用CMS的好处是用尽量少的新生代，经验值是128M－256M， 老生代利用CMS并行收集，这样能保证系统低延迟的吞吐效率。 </li><li>cms的收集停顿时间非常的短，2G的内存， 大约20－80ms的应用程序停顿时间<br>系统停顿的时候可能是GC的问题也可能是程序的问题，多用jmap和jstack查看，或者killall -3 java，然后查看java控制台日志，能看出很多问题。</li><li>如果用了缓存，那么年老代应该大一些，缓存的HashMap不应该无限制长，建议采用LRU算法的Map做缓存，LRUMap的最大长度也要根据实际情况设定。</li><li>采用并发回收时，年轻代小一点，年老代要大，因为年老大用的是并发回收，即使时间长点也不会影响其他程序继续运行，网站不会停顿<br>JVM参数的设置(特别是 –Xmx –Xms –Xmn -XX:SurvivorRatio  -XX:MaxTenuringThreshold等参数的设置没有一个固定的公式，需要根据PV old区实际数据 YGC次数等多方面来衡量。为了避免promotion faild可能会导致xmn设置偏小，也意味着YGC的次数会增多，处理并发访问的能力下降等问题。每个参数的调整都需要经过详细的性能测试，才能找到特定应用的最佳配置。</li></ul><p>解决方方案一：<br>    第一个原因最终解决办法是去掉救助空间，设置-XX:SurvivorRatio=65536 -XX:MaxTenuringThreshold=0即可，<br>    第二个原因我的解决办法是设置CMSInitiatingOccupancyFraction为某个值（假设70），这样年老代空间到70%时就开始执行CMS，年老代有足够的空间接纳来自年轻代的对象。<br>解决方案一的改进方案：</p><p>又有改进了，上面方法不太好，因为没有用到救助空间，所以年老代容易满，CMS执行会比较频繁。我改善了一下，还是用救助空间，但是把救助空间加大，这样也不会有promotion failed。具体操作上，32位Linux和64位Linux好像不一样，64位系统似乎只要配置MaxTenuringThreshold参数，CMS还是有暂停。为了解决暂停问题和promotion failed问题，最后我设置-XX:SurvivorRatio=1 ，并把MaxTenuringThreshold去掉，这样即没有暂停又不会有promotoin failed，而且更重要的是，年老代和永久代上升非常慢（因为好多对象到不了年老代就被回收了），所以CMS执行频率非常低，好几个小时才执行一次，这样，服务器都不用重启了。</p><p>-Xmx4000M -Xms4000M -Xmn600M -XX:PermSize=500M -XX:MaxPermSize=500M -Xss256K -XX:+DisableExplicitGC -XX:SurvivorRatio=1 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSClassUnloadingEnabled -XX:LargePageSizeInBytes=128M -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=80 -XX:SoftRefLRUPolicyMSPerMB=0 -XX:+PrintClassHistogram -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -Xloggc:log/gc.log</p><p>CMSInitiatingOccupancyFraction值与Xmn的关系公式</p><p>上面介绍了promontion faild产生的原因是EDEN空间不足的情况下将EDEN与From survivor中的存活对象存入To survivor区时,To survivor区的空间不足，再次晋升到old gen区，而old gen区内存也不够的情况下产生了promontion faild从而导致full gc.那可以推断出：eden+from survivor &lt; old gen区剩余内存时，不会出现promontion faild的情况，即：<br>(Xmx-Xmn)*(1-CMSInitiatingOccupancyFraction/100)&gt;=(Xmn-Xmn/(SurvivorRatior+2))  进而推断出：</p><p>CMSInitiatingOccupancyFraction &lt;=((Xmx-Xmn)-(Xmn-Xmn/(SurvivorRatior+2)))/(Xmx-Xmn)*100</p><p>例如：</p><p>当xmx=128 xmn=36 SurvivorRatior=1时 CMSInitiatingOccupancyFraction&lt;=((128.0-36)-(36-36/(1+2)))/(128-36)*100 =73.913</p><p>当xmx=128 xmn=24 SurvivorRatior=1时 CMSInitiatingOccupancyFraction&lt;=((128.0-24)-(24-24/(1+2)))/(128-24)*100=84.615…</p><p>当xmx=3000 xmn=600 SurvivorRatior=1时  CMSInitiatingOccupancyFraction&lt;=((3000.0-600)-(600-600/(1+2)))/(3000-600)*100=83.33</p><p>CMSInitiatingOccupancyFraction低于70% 需要调整xmn或SurvivorRatior值。</p><p>令：</p><p>网上一童鞋推断出的公式是：:(Xmx-Xmn)*(100-CMSInitiatingOccupancyFraction)/100&gt;=Xmn 这个公式个人认为不是很严谨，在内存小的时候会影响xmn的计算。</p><p>参考：<br><a href="http://www.cnblogs.com/redcreen/archive/2011/05/05/2038331.html" target="_blank" rel="external">http://www.cnblogs.com/redcreen/archive/2011/05/05/2038331.html</a><br><a href="http://www.jianshu.com/p/c9ac99b87d56" target="_blank" rel="external">http://www.jianshu.com/p/c9ac99b87d56</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;优化原则&quot;&gt;&lt;a href=&quot;#优化原则&quot; class=&quot;headerlink&quot; title=&quot;优化原则&quot;&gt;&lt;/a&gt;优化原则&lt;/h3&gt;&lt;p&gt;JAVA程序在运行时  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加快GC速度&lt;/li&gt;
&lt;li&gt;减少FullGC&lt;/li&gt;
&lt;li&gt;减少
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="jvm" scheme="http://www.lilhui.com/categories/java/jvm/"/>
    
    
      <category term="java" scheme="http://www.lilhui.com/tags/java/"/>
    
      <category term="jvm调优" scheme="http://www.lilhui.com/tags/jvm%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM系列：基础概念</title>
    <link href="http://www.lilhui.com/2017/09/28/java/jvm/jvm_1/"/>
    <id>http://www.lilhui.com/2017/09/28/java/jvm/jvm_1/</id>
    <published>2017-09-28T08:15:39.000Z</published>
    <updated>2017-10-11T10:26:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>jvm内存区域分三种：栈，堆，方法区。设计上Java还可以使用到直接内存，在Java NIO包里使用DirectBuffer可以显示地调用申请堆外内存。</p></blockquote><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>   栈是基于线程执行而言的，它描述的是一个线程执行的流程路线。并且在整个业务执行流程中需要用到的各种局部变量（简单类型保存值，对象保存地址），以及基本类型。<br>    这个路线可以认为是通过方法区的程序执行流程，按照帧（Stack Frame)的方式一压入内存，在JVM内存<br>    看起来就是Stack的存储。</p><h4 id="栈的配置"><a href="#栈的配置" class="headerlink" title="栈的配置"></a>栈的配置</h4><p>   JVM通过 -XSS指定配置每个线程所拥有栈大小。默认值随着虚拟机版本以及操作系统影响，官网上指定：</p><blockquote><p>In Java SE 6, the default on Sparc is 512k in the 32-bit VM, and 1024k in the 64-bit VM. On x86 Solaris/Linux it is 320k in the 32-bit VM and 1024k in the 64-bit VM.<br>     。  </p></blockquote><p>   栈的大小直接影响可以创建的线程数量。</p><pre><code>线程数 = （系统空闲内存-堆内存（-Xms, -Xmx）- perm方法区内存(-XX:MaxPermSize)) / 线程栈大小(-Xss)</code></pre><p>   如上我们可知栈设置越小，可以创建的线程数就越多，但是也是有限制的。限制有两个方便：</p><p>   操作系统配置也可以限制数量。例如ubuntu里/proc/sys/kernel/threads-max设置最大线程数。</p><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>   调用链太长，栈不够时会抛出StackOverFlow。一般是发生了递归而产生。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>   堆是JVM最大的内存部分，它负责存放对象实例，JVM所有对象实例都在这里。（变量，对象属性但是不包括方法里的简单类型变量）。它保存了执行所需要的<br>   各种东西。</p><h3 id="堆的配置"><a href="#堆的配置" class="headerlink" title="堆的配置"></a>堆的配置</h3><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>其他</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td><td>物理内存的1/64(&lt;1GB)</td><td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td></tr><tr><td>-Xmx</td><td>最大堆大小</td><td>物理内存的1/4(&lt;1GB)</td><td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td></tr><tr><td>-Xmn</td><td>年轻代大小</td><td>(1.4or lator)</td><td>注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td></tr><tr><td>-XX:NewSize</td><td>设置年轻代大小(for 1.3/1.4)</td><td></td></tr><tr><td>-XX:MaxNewSize</td><td>年轻代最大值(for 1.3/1.4)</td><td></td></tr><tr><td>-XX:PermSize</td><td>设置持久代(perm gen)初始值</td><td>物理内存的1/64     </td></tr><tr><td>-XX:MaxPermSize</td><td>设置持久代最大值</td><td>物理内存的1/4     </td></tr><tr><td>-Xss</td><td>每个线程的堆栈大小</td><td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右</td><td>一般小的应用，如果栈不很深， 应该是128k够用的大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:”-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了</td></tr><tr><td>-XX:ThreadStackSize</td><td>Thread Stack Size</td><td>(0 means use default stack size) [Sparc: 512; Solaris x86: 320 (was 256 prior in 5.0 and earlier); Sparc 64 bit: 1024; Linux amd64: 1024 (was 0 in 5.0 and earlier); all others 0.]</td></tr><tr><td>-XX:NewRatio</td><td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td><td>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5</td><td>Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td></tr><tr><td>-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td><td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td></tr><tr><td>-XX:LargePageSizeInBytes</td><td>内存页的大小</td><td>不可设置过大， 会影响Perm的大小         =128m</td></tr><tr><td>-XX:+UseFastAccessorMethods</td><td>原始类型的快速优化</td><td></td></tr><tr><td>-XX:+DisableExplicitGC</td><td>关闭System.gc()</td><td>这个参数需要严格的测试</td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>垃圾最大年龄</td><td>如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率该参数只有在串行GC时才有效.</td></tr><tr><td>-XX:+AggressiveOpts</td><td>加快编译          </td></tr><tr><td>-XX:+UseBiasedLocking</td><td>锁机制的性能改善          </td></tr><tr><td>-Xnoclassgc</td><td>禁用垃圾回收          </td></tr><tr><td>-XX:SoftRefLRUPolicyMSPerMB</td><td>每兆堆空闲空间中SoftReference的存活时间</td><td>1s    softly reachable objects will remain alive for some amount of time after the last time they were referenced. The default value is one second of lifetime per free megabyte in the heap</td></tr><tr><td>-XX:PretenureSizeThreshold</td><td>对象超过多大是直接在旧生代分配</td><td>0</td><td>单位字节 新生代采用Parallel Scavenge GC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td></tr><tr><td>-XX:TLABWasteTargetPercent</td><td>TLAB占eden区的百分比</td><td>1%     </td></tr><tr><td>-XX:+CollectGen0First</td><td>FullGC时是否先YGC</td><td>false     </td></tr></tbody></table><h4 id="并行收集器相关参数"><a href="#并行收集器相关参数" class="headerlink" title="并行收集器相关参数"></a>并行收集器相关参数</h4><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>其他</th></tr></thead><tbody><tr><td>-XX:+UseParallelGC</td><td>Full GC采用parallel MSC</td><td></td><td>选择垃圾收集器为并行收集器.此配置仅对年轻代有效.即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集.(此项待验证)</td></tr><tr><td>-XX:+UseParNewGC</td><td>设置年轻代为并行收集</td><td>可与CMS收集同时使用</td><td>JDK5.0以上,JVM会根据系统配置自行设置,所以无需再设置此值</td></tr><tr><td>-XX:ParallelGCThreads</td><td>并行收集器的线程数</td><td>此值最好配置与处理器数目相等</td><td>同样适用于CMS</td></tr><tr><td>-XX:+UseParallelOldGC</td><td>年老代垃圾收集方式为并行收集(Parallel Compacting)</td><td></td><td>这个是JAVA 6出现的参数选项</td></tr><tr><td>-XX:MaxGCPauseMillis</td><td>每次年轻代垃圾回收的最长时间(最大暂停时间)</td><td></td><td>如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.</td></tr><tr><td>-XX:+UseAdaptiveSizePolicy</td><td>自动选择年轻代区大小和相应的Survivor区比例</td><td></td><td>设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例,以达到目标系统规定的最低相应时间或者收集频率等,此值建议使用并行收集器时,一直打开.</td></tr><tr><td>-XX:GCTimeRatio</td><td>设置垃圾回收时间占程序运行时间的百分比</td><td>公式为1/(1+n)</td></tr><tr><td>-XX:+ScavengeBeforeFullGC</td><td>Full GC前调用YGC</td><td>true</td><td>Do young generation GC prior to a full GC. (Introduced in 1.4.1.)</td></tr></tbody></table><h4 id="CMS相关参数"><a href="#CMS相关参数" class="headerlink" title="CMS相关参数"></a>CMS相关参数</h4><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>其他</th></tr></thead><tbody><tr><td>-XX:+UseConcMarkSweepGC</td><td>使用CMS内存收集</td><td></td><td>测试中配置这个以后,-XX:NewRatio=4的配置失效了,原因不明.所以,此时年轻代大小最好用-Xmn设置.???</td></tr><tr><td>-XX:+AggressiveHeap</td><td>试图是使用大量的物理内存</td><td></td><td>长时间大内存使用的优化，能检查计算资源（内存， 处理器数量）至少需要256MB内存大量的CPU／内存， （在1.4.1在4CPU的机器上已经显示有提升）</td></tr><tr><td>-XX:CMSFullGCsBeforeCompaction</td><td>多少次后进行内存压缩</td><td></td><td>由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生”碎片”,使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理.</td></tr><tr><td>-XX:+CMSParallelRemarkEnabled</td><td>降低标记停顿</td><td></td></tr><tr><td>-XX+UseCMSCompactAtFullCollection</td><td>在FULL GC的时候， 对年老代的压缩         CMS是不会移动内存的， 因此， 这个非常容易产生碎片， 导致内存不够用， 因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。</td><td></td><td>可能会影响性能,但是可以消除碎片</td></tr><tr><td>-XX:+UseCMSInitiatingOccupancyOnly</td><td>使用手动定义初始化定义开始CMS收集         禁止hostspot自行触发CMS GC</td><td></td><td></td></tr><tr><td>-XX:CMSInitiatingOccupancyFraction=70</td><td>使用cms作为垃圾回收</td></tr><tr><td>使用70％后开始CMS收集</td><td>92</td><td>为了保证不出现promotion failed(见下面介绍)错误,该值的设置需要满足以下公式CMSInitiatingOccupancyFraction计算公式</td></tr><tr><td>-XX:CMSInitiatingPermOccupancyFraction</td><td>设置Perm Gen使用到达多少比率时触发</td><td>92     </td></tr><tr><td>-XX:+CMSIncrementalMode</td><td>设置为增量模式</td><td>用于单CPU情况</td></tr><tr><td>-XX:+CMSClassUnloadingEnabled</td><td></td></tr></tbody></table><h4 id="辅助信息"><a href="#辅助信息" class="headerlink" title="辅助信息"></a>辅助信息</h4><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>其他</th></tr></thead><tbody><tr><td>-XX:+PrintGC</td><td></td><td></td><td>输出形式:[GC 118250K-&gt;113543K(130112K), 0.0094143secs][Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</td></tr><tr><td>-XX:+PrintGCDetails</td><td></td><td></td><td>输出形式:[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs][GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs]</td></tr><tr><td>-XX:+PrintGCTimeStamps</td><td></td><td></td><td></td></tr><tr><td>-XX:+PrintGC:PrintGCTimeStamps</td><td>可与-XX:+PrintGC -XX:+PrintGCDetails混合使用</td><td></td><td>输出形式:11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs]</td></tr><tr><td>-XX:+PrintGCApplicationStoppedTime</td><td>打印垃圾回收期间程序暂停的时间.可与上面混合使用</td><td></td><td>输出形式:Total time for which application threads were stopped: 0.0468229 seconds</td></tr><tr><td>-XX:+PrintGCApplicationConcurrentTime</td><td>打印每次垃圾回收前,程序未中断的执行时间.可与上面混合使用</td><td></td><td>输出形式:Application time: 0.5291524 seconds</td></tr><tr><td>-XX:+PrintHeapAtGC</td><td>打印GC前后的详细堆栈信息          </td></tr><tr><td>-Xloggc:filename</td><td>把相关日志信息记录到文件以便分析.与上面几个配合使用          </td></tr><tr><td>-XX:+PrintClassHistogram</td><td>garbage collects before printing the histogram.         </td></tr><tr><td>-XX:+PrintTLAB</td><td>查看TLAB空间的使用情况          </td></tr><tr><td>XX:+PrintTenuringDistribution</td><td>查看每次minor GC后新的存活周期的阈值</td><td>Desired survivor size 1048576 bytes, new threshold 7 (max 15)</td><td>new threshold 7即标识新的存活周期的阈值为7。</td></tr></tbody></table><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>   又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量；方法区中包含的都是在程序中永远的唯一的元素。特别说明的是枚举<br>   是存放在方法区，而单例是某个类在内存中唯一的对象实例，是存放在堆中的。</p><h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><p> -XX:PermSize=10M -XX:MaxPermSize=10M</p><ul><li>值得一提的是 JAVA8 将方法区 改成了 MateSpace (元数据区。) 同时 PerSize MaxPermSize参数也移除了。<br>带来了几个新的参数：<ol><li>-XX:MetaspaceSize，class metadata的初始空间配额，以bytes为单位，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当的降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize（如果设置了的话），适当的提高该值。</li><li>-XX:MaxMetaspaceSize，可以为class metadata分配的最大空间。默认是没有限制的。</li><li>-XX:MinMetaspaceFreeRatio,在GC之后，最小的Metaspace剩余空间容量的百分比，减少为class metadata分配空间导致的垃圾收集</li><li>-XX:MaxMetaspaceFreeRatio,在GC之后，最大的Metaspace剩余空间容量的百分比，减少为class metadata释放空间导致的垃圾收集XX:MaxMetaspaceSize<h3 id="总结图"><a href="#总结图" class="headerlink" title="总结图"></a>总结图</h3></li></ol></li></ul><p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1507544256116.png?imageView2/2/w/730/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;jvm内存区域分三种：栈，堆，方法区。设计上Java还可以使用到直接内存，在Java NIO包里使用DirectBuffer可以显示地调用申请堆外内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="jvm" scheme="http://www.lilhui.com/categories/java/jvm/"/>
    
    
      <category term="java" scheme="http://www.lilhui.com/tags/java/"/>
    
      <category term="jvm调优" scheme="http://www.lilhui.com/tags/jvm%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>redis简介</title>
    <link href="http://www.lilhui.com/2017/09/26/redis/redis_2/"/>
    <id>http://www.lilhui.com/2017/09/26/redis/redis_2/</id>
    <published>2017-09-26T10:12:59.000Z</published>
    <updated>2017-09-26T10:13:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><blockquote><p>Redis 是一个非常快速的非关系内存型数据库。Redis非常有区分度的是它提供的5种不同类型的数据结构，其数据结构是有针对地为解决问题而生的数据结构，区分于其他数据库的一个显著特点。可以说，Redis核心问题和功能都围绕着五种数据结构展开的，另外，它方便的扩展功能，可以支持到数百GB级数据。</p></blockquote><h3 id="与其他数据库和软件的对比"><a href="#与其他数据库和软件的对比" class="headerlink" title="与其他数据库和软件的对比"></a>与其他数据库和软件的对比</h3><p> Redis的特点决定了它在存储工具里的定位，它经常被用来与其他数据库进行对比。这里，我们介于内存键值存储 Memcached 与MongoDB对Redis进行一次比较。</p><table><thead><tr><th>名称</th><th>类型</th><th>存储</th><th>查询</th><th>附加功能</th></tr></thead><tbody><tr><td>Redis</td><td>内存存储（in-memmory)的非关系数据库</td><td>字符串,列表，集合，散列表，有序集合</td><td>每种数据类型都有自己的专属命令，还有批操作和不完整的事务支持</td><td>发布与订阅，主从复制，持久化，脚本</td></tr><tr><td>Memcached</td><td>使用内存存储的键值缓存</td><td>键值之间的映射</td><td>创建，读取，更新删除等命令</td><td>多线程服务支持</td></tr><tr><td>MongoDB</td><td>硬盘存储的非关系文档存储</td><td>每个数据库可以包含多个个表，每个表包含多个schema 的BSON文档</td><td>更新，读取，删除，条件查询等命令</td><td>支持map-reduce操作，主从复制，分片，空间索引（spatial index）</td><td></td></tr></tbody></table><h3 id="使用Redis的理由"><a href="#使用Redis的理由" class="headerlink" title="使用Redis的理由"></a>使用Redis的理由</h3><p>Redis之于缓存界：使用memcached 时，没有原生的列表结构，只能用Append命令将数据添加到已有字符串末尾。可以认为那个字符串就是一个列表。但是删除这些就比较困难了。memcached采用的办法是通过黑名单来隐藏列表里的元素，从而避免对元素进行读取，更新，写入。相反地，Redis的LIST和SET允许用户直接添加或者删除元素。</p><hr><p>Redis之于数据库：当数据库用于存储长期数据报告，报表。并将这些数据作为固定时间范围内聚合。数据库的做法是：将各个行插入一个报表中，通过扫描这些行进行聚合数据。这样就要频繁地对表里数据进行</p><hr><p>读，写。Redis可以使用原子的INCR命令来进行聚合计算。并且Redis存储在内存里。并且查询不通过数据库的分析器，查询优化器等，所以对Redis存储的数据行随机写的速度是非常迅速的。<br>Redis之于NoSql数据库：避免写入不必要的临时数据。免去了临时数据进行扫描删除的麻烦。可以改上程序的性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis简介&quot;&gt;&lt;a href=&quot;#Redis简介&quot; class=&quot;headerlink&quot; title=&quot;Redis简介&quot;&gt;&lt;/a&gt;Redis简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Redis 是一个非常快速的非关系内存型数据库。Redis非常有区分度的是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HttpURLConnection Post请求自动重传机制</title>
    <link href="http://www.lilhui.com/2017/09/26/java/java_1/"/>
    <id>http://www.lilhui.com/2017/09/26/java/java_1/</id>
    <published>2017-09-26T10:01:22.000Z</published>
    <updated>2017-09-27T10:21:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景故事"><a href="#背景故事" class="headerlink" title="背景故事"></a>背景故事</h2><blockquote><p>之前负责的一个商城项目，需要从供应商库进行订单下单同步，服务器间通讯通过http请求。 加密方式采用DES加密方式。在运行初期一切正常，几个月后<br>供应商发现有重复订单存在，而客户端这边接收到异常生成订单异常信息，订单生成不同步。供应商的处理逻辑我们无从得知，只能从自身角度思考为什么会有这<br>种问题，在排除了一系列原因后，定位到一个问题。那就是 HttpURLConnection的post请求重发机制。</p></blockquote><h2 id="场景再现"><a href="#场景再现" class="headerlink" title="场景再现"></a>场景再现</h2><p>Http请求是通过HttpUrlConnection封装的一套Java请求客户端 部分源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> <span class="comment">//请求的header如下</span></div><div class="line"> <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">getDefaultHeaders</span><span class="params">()</span> </span>&#123;</div><div class="line">     Map&lt;String, Object&gt; defaultHeaders = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">     defaultHeaders.put(<span class="string">"Accept"</span>, <span class="string">"*/*"</span>);</div><div class="line">     defaultHeaders.put(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</div><div class="line">     defaultHeaders.put(<span class="string">"User-Agent"</span>, <span class="string">"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1)"</span>);</div><div class="line">     defaultHeaders.put(<span class="string">"Accept-Charset"</span>, <span class="string">"utf-8"</span>);</div><div class="line">     defaultHeaders.put(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded;charset=utf-8"</span>);</div><div class="line">     headers = defaultHeaders;</div><div class="line">     <span class="keyword">return</span> headers;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="comment">//初始化 httpConnection</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">     <span class="keyword">if</span> (<span class="string">"POST"</span>.equals(method)) &#123;</div><div class="line">         <span class="keyword">this</span>.url = <span class="keyword">new</span> URL(getUrl);</div><div class="line">         <span class="keyword">this</span>.postJson = JsonUtil.toJson(param);</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         <span class="keyword">this</span>.url = <span class="keyword">new</span> URL(getUrl + urlParams);</div><div class="line">     &#125;</div><div class="line">     httpConnection = (HttpURLConnection) url.openConnection();</div><div class="line">     <span class="keyword">for</span> (String keyset : headers.keySet()) &#123;</div><div class="line">         httpConnection.setRequestProperty(keyset, headers.get(keyset).toString());</div><div class="line">     &#125;</div><div class="line">     <span class="comment">/**</span></div><div class="line"><span class="comment">      * 然后把连接设为输出模式。URLConnection通常作为输入来使用，比如下载一个Web页。</span></div><div class="line"><span class="comment">      * 通过把URLConnection设为输出，你可以把数据向你个Web页传送。：</span></div><div class="line"><span class="comment">      */</span></div><div class="line">     httpConnection.setRequestMethod(method);</div><div class="line">     httpConnection.setUseCaches(<span class="keyword">false</span>);</div><div class="line">     <span class="keyword">if</span> (<span class="string">"POST"</span>.equals(method)) &#123;</div><div class="line">         httpConnection.setDoOutput(<span class="keyword">true</span>);</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         httpConnection.setDoOutput(<span class="keyword">true</span>);</div><div class="line">     &#125;</div><div class="line">     httpConnection.setDoInput(<span class="keyword">true</span>);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="comment">//执行Http请求</span></div><div class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">doRequest</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">this</span>.toUrlParams();</div><div class="line">     OutputStreamWriter out = <span class="keyword">null</span>;</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">         <span class="keyword">this</span>.initConnection();</div><div class="line">         <span class="comment">// 一旦发送成功，用以下方法就可以得到服务器的回应：</span></div><div class="line">         String sTotalString;</div><div class="line">         InputStream urlStream;</div><div class="line">         out = <span class="keyword">new</span> OutputStreamWriter(httpConnection.getOutputStream(), charSet);</div><div class="line">         <span class="keyword">if</span> (method.equals(<span class="string">"POST"</span>)) &#123;</div><div class="line">             out.write(<span class="keyword">this</span>.postJson); <span class="comment">//向页面传递数据。post的关键所在！</span></div><div class="line">         &#125;</div><div class="line">         <span class="comment">// remember to clean up</span></div><div class="line">         out.flush();</div><div class="line">         urlStream = httpConnection.getInputStream();</div><div class="line">         logger.debug(<span class="string">"连接状态:"</span> + urlStream.available());</div><div class="line">         <span class="comment">//new InputStreamReader(l_urlStream,)</span></div><div class="line">         sTotalString = IOUtil.in2Str(urlStream, charSet);</div><div class="line">         <span class="keyword">return</span> sTotalString;</div><div class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(e);</div><div class="line">     &#125; <span class="keyword">finally</span> &#123;</div><div class="line">         <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</div><div class="line">             <span class="keyword">try</span> &#123;</div><div class="line">                 out.close();</div><div class="line">             &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                 e.printStackTrace();</div><div class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(e);</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">         httpConnection.disconnect();</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>Java代码调用doRequest通过HttpUrlConnection模拟一个Post请求。结果服务端会收到两次请求。</p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>HttpURLConnection 采用 Sun 私有的一个 HTTP 协议实现类： HttpClient.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">parseHTTP</span><span class="params">(MessageHeader var1, ProgressSource var2, HttpURLConnection var3)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">this</span>.serverInput = <span class="keyword">this</span>.serverSocket.getInputStream();</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.capture != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">this</span>.serverInput = <span class="keyword">new</span> HttpCaptureInputStream(<span class="keyword">this</span>.serverInput, <span class="keyword">this</span>.capture);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">this</span>.serverInput = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">this</span>.serverInput);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.parseHTTPHeader(var1, var2, var3);</div><div class="line">        &#125; <span class="keyword">catch</span> (SocketTimeoutException var6) &#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.ignoreContinue) &#123;</div><div class="line">                <span class="keyword">this</span>.closeServer();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">throw</span> var6;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException var7) &#123;</div><div class="line">            <span class="keyword">this</span>.closeServer();</div><div class="line">            <span class="keyword">this</span>.cachedHttpClient = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">if</span>(!<span class="keyword">this</span>.failedOnce &amp;&amp; <span class="keyword">this</span>.requests != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">this</span>.failedOnce = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">if</span>(!<span class="keyword">this</span>.getRequestMethod().equals(<span class="string">"CONNECT"</span>) &amp;&amp; !<span class="keyword">this</span>.streaming &amp;&amp; (!var3.getRequestMethod().equals(<span class="string">"POST"</span>) || retryPostProp)) &#123;</div><div class="line">                    <span class="keyword">this</span>.openServer();</div><div class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>.needsTunneling()) &#123;</div><div class="line">                        MessageHeader var5 = <span class="keyword">this</span>.requests;</div><div class="line">                        var3.doTunneling();</div><div class="line">                        <span class="keyword">this</span>.requests = var5;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">this</span>.afterConnect();</div><div class="line">                    <span class="keyword">this</span>.writeRequests(<span class="keyword">this</span>.requests, <span class="keyword">this</span>.poster);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.parseHTTP(var1, var2, var3);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">throw</span> var7;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>当发生IOException就会执行判断是否进行重试。<br>failedOnce 默认是 false，表示是否已经失败过一次了。这也就限制了最多发送 2 次请求。<br>var3 是请求信息<br>retryPostProp 默认是 true ，可以通过命令行参数( -Dsun.net.http.retryPost=false )来指定值。<br>streaming：默认 false 。 true if we are in streaming mode (fixed length or chunked) 。</p><p>bug链接：<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6427251" target="_blank" rel="external">http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6427251</a><br>这个Bug很早就有了，归根结底原因就是sun提供的实现与Http对于Post请求的规范有不同。Http协议里Post不是幂等的，不能进行重试。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>使用Apache Client请求</li><li>修改JVM启动参数 添加：-Dsun.net.http.retryPost=false</li></ol><p><a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6427251" target="_blank" rel="external">http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6427251</a></p><h2 id="总结心得"><a href="#总结心得" class="headerlink" title="总结心得"></a>总结心得</h2><ul><li>http协议方面：http规定的部分是规范，实现有千种方法。有的符合协议，有的又有所区别，在对接过程中，指定接入方式，形成书面文档规范。有利于后续<br>问题职责归属。</li><li>在寻找问题方面，无法完整获取所有信息时，从已掌握的信息出发，避免任何一点得出结论的依据。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景故事&quot;&gt;&lt;a href=&quot;#背景故事&quot; class=&quot;headerlink&quot; title=&quot;背景故事&quot;&gt;&lt;/a&gt;背景故事&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;之前负责的一个商城项目，需要从供应商库进行订单下单同步，服务器间通讯通过http请求。 加密方式采
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
    
      <category term="java" scheme="http://www.lilhui.com/tags/java/"/>
    
      <category term="http" scheme="http://www.lilhui.com/tags/http/"/>
    
  </entry>
  
</feed>
