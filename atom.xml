<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Littlehui&#39;s Notes</title>
  
  <subtitle>天地那么大，世界那么辽阔。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.lilhui.com/"/>
  <updated>2018-07-27T03:28:00.670Z</updated>
  <id>http://www.lilhui.com/</id>
  
  <author>
    <name>Littlehui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【好文】滴滴出行技术总监：关于技术选型的那些事儿</title>
    <link href="http://www.lilhui.com/2018/07/27/article/article_1/"/>
    <id>http://www.lilhui.com/2018/07/27/article/article_1/</id>
    <published>2018-07-27T03:20:40.000Z</published>
    <updated>2018-07-27T03:28:00.670Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://news.cnblogs.com/n/563792/" target="_blank" rel="external">https://news.cnblogs.com/n/563792/</a></p><blockquote><p>杜欢，滴滴出行技术总监，负责滴滴小巴业务的技术管理工作。在互联网领域已经有十年工作经验，曾就职于微软、百度，也曾自主创业两次，来到滴滴之后也经历过很多项目和业务的变化，是一个“什么都懂”工程师，对前端、客户端、服务端、运维等方面都有不少实战经验。平时是一个 ACG 宅，也喜欢阅读各种技术和非技术的文章扩大视野，不愿主动交谈，但一旦放松了就聊到停不下来。</p></blockquote><h3 id="技术选型案例"><a href="#技术选型案例" class="headerlink" title="技术选型案例"></a>技术选型案例</h3><p>　　今天会聊技术选型这个话题，主要就是因为我经历相对比较丰富，亲历过不少项目选型的过程，自己也做过不少靠谱或者不靠谱的决策，在这个方面也有些自己的思考。我想先从几个案例开始，像讲故事一样聊聊选型背后的事，作为话题的开始。<br>　　在我刚开始工作时就经历过一次很大的选型事件，我是这件事情的旁观者。当时公司希望做一个非常酷炫的手机界面系统，恰逢 Windows Vista 一系列新技术的发布，包括 WPF、Silverlight、C# 这些技术非常火，公司对它们抱有极高的期望，所以就想第一时间用在新一代 Windows Mobile 上面。确实界面开发和各种效果可以做的很酷炫也节省了界面开发时间，但是很尴尬的遇到了另外一个问题，性能问题。<br>　　这些东西都是跑在移动设备上面，当年的移动设备内存能有 32MB，CPU 能到 1GHz 就很不错了，根本不能很好的支撑这一整套界面系统对性能的要求。后来，当公司发现确实在当时的硬件环境下突破性能问题，就对所有界面做了一次重写，回到了用 C++ 和各种 API 传统写界面方式上才解决问题，这里面涉及到将近一千名工程师一年多的时间，可以说是个很大的人力和时间的损失。<br>　　当时我还不是很理解，为什么公司不能更早一点止损，后来我慢慢发现，这真的是当局者迷，当一个决策作出之后大家就天然的希望能通过努力来解决眼前的问题，结果反而越陷越深。这也意味着最初选型的时候得十分谨慎，特别是选型影响面巨大时保守点会更好。<br>　　后来加入了真正的互联网公司，我看到了技术选型是稳定压倒一切。比如 gcc、linux 内核这些非常底层和关键的东西，在互联网公司里基本不会去追最新版，只是保持了解和跟进，非常克制的将一些 patch 和功能引入到线上环境，真正上线也会经历相当久的灰度验证过程。<br>　　我印象挺深的是当年（2009 年）对 lighttpd 和 apache 的选型，当时 lighttpd 单机性能明显优于 apache，同时也支持 php 扩展，能够以 mod 形式运行 php，看起来使用 lighttpd 全面替换 apache 就好了，但实际上为了业务稳定性，真正的用法是将 lighttpd 做反向代理，后面还是使用 apache + mod_php 来提供服务。这里面的思考就是对于一个新技术的天然不信任，在技术接受程度还不够高且公司内没有人能吃透这个技术的情况下，不愿意让自己的业务做第一个吃螃蟹的人。<br>　　谨慎确实是个美德，不过如果在一个非常追求速度的业务里，这可能也意味着过于保守，会延误时机。<br>　　我在自己创业的过程中选型就比较激进，也玩的比较 high。<br>　　比如我会积极的使用 MongoDB，我对它灵活的数据结构、强大的查询语句和内置的高可用机制等非常认可，当它刚刚 1.0 的时候就将它用在一些不重要的数据上，后来等到 2.x 发布后就开始尝试用在新业务上作为核心数据库。我也曾经遇到一些严重的坑，比如数据损坏、扩容不及时造成停机等，但是由于业务对这些问题容忍度较高，同时也有一些兜底方案，所以还不至于成为业务瓶颈，总体来说利大于弊，可以节省业务开发人员的宝贵时间。<br>　　我也曾决策使用 Node.js 作为主力服务器开发工具，当时（2013 年）因为客户端要使用 Javascript 作为主力语言，服务端和客户端会有不少能够复用的代码，所以挺想使用 Node.js 来提升开发效率。<br>　　为了验证 Node.js 是否靠谱，我自己通读了源码、阅读了不少相关文章、看了下官方 release note 及社区活跃程度（github issues、stackoverflow 讨论等）、还做了一些基本的压测，最后的结论是，它的性能可以满足要求，在稳定性方面基本合格，考虑到只是用它做无状态服务，且单台服务器上都会跑多个实例（当时使用 supervisord 管理），简单的崩溃不会对系统有明显影响，再加上当时确实也有些公司将它作为主力服务，所以最终选择了它。<br>　　后来加入滴滴后，我在技术选型方面综合了以前所有的经验，有做得好的，也有犯错的时候。<br>　　2015 年滴滴有一个很大的内部代码重构项目，涉及到服务端和客户端大量代码。客户端的技术选型做的相对较好，针对当时代码库多业务耦合严重，大家开发时候模块间冲突频繁的问题，评估并引入了 cocoapods 和 maven/gradle 作为 iOS 和 Android 的项目拆分工具，并且通过代码重构，将客户端项目分成几个独立的仓库，可以让业务独立开发的同时，也能通过构建脚本轻松的整合成一个完成的 app。<br>　　服务端的选型则比较错误，当时考虑到滴滴的业务模式非常类似于 erlang 的 actor 模型，一个叫车流程会涉及到非常多可复用的 actor，如果我们直接实现一个分布式的 actor 模型和数据流管理机制，那么很多问题就迎刃而解了。可是当时并不存在一套这样的机制，我们自己在实现的时候采用 Go + kafka 分别实现 actor 和数据流存储，过程中遇到了 kafka 消息丢失不好定位、actor 模型过于抽象不容易在整个团队贯彻执行等问题，最终放弃了整个方案。</p><h3 id="技术选型方法论"><a href="#技术选型方法论" class="headerlink" title="技术选型方法论"></a>技术选型方法论</h3><p>技术选型关键需要思考三个角度：技术、业务和人。</p><h4 id="角度之一：技术"><a href="#角度之一：技术" class="headerlink" title="角度之一：技术"></a>角度之一：技术</h4><p>　　技术选型首先考虑的当然是技术本身，这里提到的技术包括语言、框架、工具、设计模式、开发模式等。<br>　　在选择技术时有两个大原则。第一，要取其长避其短；第二，要关注技术的发展前景。<br>　　每种技术都是有它特定的适用场景的，“没有银弹”。开发者经常犯的错误就是盲目追新，当一个新语言、框架、工具出现后，特别是开发者自己学会了这种新技术后，就会有种“拿着锤子找钉子”的感觉，将新技术滥用于各种项目。<br>　　比如最近几年 Go 在国内很火，我自己也非常使用它开发项目，但绝对不应该将它用于所有项目。Go 的优点是上手快、运行时性能高、方便的使用多核运算能力等，经常被提起的特性是超轻线程 goroutine、内置的内存队列 chan、极快的编译速度，非常适合于编写各种无状态应用服务，无需使用任何的第三方框架都能轻松写出一个高性能的 http 服务。<br>　　但它的缺点也非常明显，最痛的一点是 gc。Go 在设计之初就号称要实现一个世界上最优秀的 gc，可惜直到今天也还差的较远，最近一年才实现了 jvm 几年前就做到的并发 gc，并且没有很好的方法解决内存碎片和对象过多带来的性能问题。这些缺陷使得 Go 不太适合做有状态服务，特别不适合做内存管理相关的服务，在这些场景里面还是 C/C++ 更加可靠。<br>　　技术的发展前景也是一个重要考虑因素。有些技术设计的很好，比如我个人挺喜欢一个叫做 Io 的语言，但我不会把它用于真实项目，因为这个语言缺乏社区和长期支持，就算设计理念写的再好，里面也必然有各种 bug 和不足，如果没人能够解决就会带来严重的问题。技术的“前景”可以从几个维度来判断，有没有长期规划、有没有持续投入的人或者社区、问题解决的速度如何、业界使用案例及口碑、源码质量。<br>　　选择一个技术最低限的标准是，技术的生命周期必须显著长于项目的生命周期。想象一下，如果项目还没做完这个技术就不被维护了，那将是怎样一种窘境。拿去年很火的 Vue.js 来说，尤大在规划、投入和解决问题速度方面都没有问题，这是这个技术能火起来的基本保障，再加上设计优雅、源码确实写的不错，它的成功并不偶然。可以预见，随着尤大全职开发这个框架并且社区贡献者越来越多，Vue.js 能持续几年应该问题不大。<br>　　滴滴的 web app，比如微信钱包里面的滴滴入口，就在去年年底全面改用 Vue.js 重构了一版，我们就是看中了 Vue.js 在移动应用开发中的优势再加上对它的前景有信心。在重构前，我们为了确认 Vue.js 真的能承担如此大任，公共前端团队在 2016 年花了半年的时间整体梳理和评估了 Vue.js 1.0 和 2.0 的全部源码，为此还出了一本书，在公司大规模使用前也在滴滴小巴业务和行程分享功能里做了试点，效果非常不错，最终才真正下定决心广泛推广。<br>　　技术的发展前景是动态变化的，当一个技术走向了末路，我们也应该勇敢的扬弃。拿 jQuery 为例，最开始它是前端开发的必需品，当时很多前端同学离开了 $ 函数就不会写代码了，它在简化 DOM 操作、抹平浏览器间差异做出了极其重要的贡献。但是随着浏览器越来越标准和趋同，jQuery 的亮点已经不再吸引人，它的插件开发模式逐步被模块化开发给取代，再加上各种历史包袱，它所适用的项目也会变得越来越少，新项目在选型的时候就不推荐优先考虑 jQuery 了。<br>　　对于一家大型公司来说，其核心业务的技术选型更需谨慎，看前景时甚至需要考虑技术的独立性。依然把 Go 当做一个例子，当前核心 Go Authors 基本都受雇于 Google，也没有一个独立运作的基金会来负责语言的长期维护，更没有一个公开透明的决策机制来决定语言的未来，假如 Google 出于某种原因停止投入或者改变语言的发展方向，那么这对一家大型公司来说可能会是毁灭性打击。立志于成为一家千亿美元规模的公司，或者是 Google 的潜在竞争对手，在选择使用 Go 时就应该更加谨慎，不要盲从。</p><h4 id="角度之二：业务"><a href="#角度之二：业务" class="headerlink" title="角度之二：业务"></a>角度之二：业务</h4><p>　　技术选型必须贴着业务来选择，不同业务阶段会有不同的选型方式。<br>　　处于初创期的业务，选型的关键词是“灵活”。只要一个技术够用且开发效率足够高，那么就可以选择它。初创的业务往往带有风险性和不确定性，朝令夕改、反复试错是常态，技术必须适应业务的节奏，然后才是其他方面。MongoDB 是一个很好的例子，相比 MySQL，它的数据结构灵活多变，相比一般的 KV 存储，它又具有类似 SQL 的复杂查询能力，再加上它内置的傻瓜式高可用和水平扩展机制，让它能够很好的适应初创业务对效率的追求。<br>　　等业务进入稳定期，选型的关键词是“可靠”。技术始终是业务的基石，当业务稳定了技术不稳，那就会成为业务的一块短板，就必须要修正。当年 Twitter 放弃 RoR 选择 Java 系框架，这就是个很好的例子。RoR 以快速开发著称，但同时 ruby 的性能非常有限，Twitter 工程团队针对 ruby 虚拟机做了非常多性能优化可是依然不能达到预期，再加上当时的 Twitter 为了提升前端体验，全面使用模块化和异步化的方法加载页面，服务端已经基本不怎么负责渲染页面，而专注于提供各种 RESTful API，RoR 的优势也不太明显了。<br>　　当业务步入维护期，选型的关键词是“妥协”。代码永远有变乱的趋势，一般经过一两年就有必要对代码来一次大一点的重构。在这种时候，必须得正视各种遗留代码的迁移成本，如果改变技术选型会带来遗留代码重写，这背后带来的代价业务无法承受，那么我们就不得不考虑在现有技术选型之上做一些小修小补或者螺旋式上升的重构。<br>　　正因为技术选型和业务相关，我们能够观察到一些很明显的现象：新技术往往被早期创业团队或大公司的新兴业务使用；中大型公司的核心业务则更倾向于用一些稳定了几年的技术；一个公司如果长期使用一种技术，就会倾向于一直使用下去，甚至连版本都不更新的使用下去。这现象背后都是有道理的。</p><h4 id="角度之三：人"><a href="#角度之三：人" class="headerlink" title="角度之三：人"></a>角度之三：人</h4><p>　　技术选型过程中最终影响决策的还是人本身，这里要强调一下，我说的“人”是指的个人，而不是团队。<br>　　技术选型的决策流程一定得专制。决策者可以在调研的时候体恤民情，并把团队现状当做一个因素考虑进来，但绝对不能采用类似“少数服从多数”、“按着大家习惯来”的方式选型。专制可以使技术选型更加的客观，考虑的更加全面，并且使得权责统一。<br>　　并不是每个人都懂得怎么为项目负责，一个基层的开发人员思考的更多的可能是技术是否有挑战、能否做出彩、甚至未来好不好找工作，这些主观因素可能会给选型带来灾难性的后果。专制也使得“螺旋式上升”成为可能，很多时候我们没法一蹴而就的使用某种技术，这时候需要有一个领路人，带着大家坚定的朝一条曲折的路线前进才能获得成功。<br>　　技术选型也非常依赖于人的能力。选型是一件很难被标准化的过程，选型的决策质量跟人的眼界、经验、业务敏感度、逻辑性等息息相关。就我自己来说，我在面临一个选型问题时首先考虑的是去学习，看看公司内外类似的问题如何解决的，避免自己闭门造车，然后思考所有的可能性，列举最核心需要考虑的因素，心里列一个方案优劣对比，最后将这些逻辑整理清楚，落地成一个决策。<br>　　滴滴在决策客户端动态化方向时就是以这样的方式来进行的，我们将业界所有可能的方案都拿出来，理解他们的优缺点，然后在某次会议上几个核心同学在白板上列了一张表格，以考虑的因素为行，可能的方案为列，分别评估各个方案在每种因素里的优劣势，最终确定了一个结论。我们选择的路是偏向于客户端开发的动态化方案，在保留所有代码和工具链的前提下做到对开发者透明的动态化，这样能让整体迁移和维护代价变得最小，当然，这条路开发难度也相当大，幸好我们当时也找到了最合适的人，我们依然可以在能接受的时间里实现整个方案。<br>　　培养技术选型的能力<br>　　可以看到，要想做好技术选型还是挺难的，要想做好得有足够的知识积累和实际踩坑的经历才行。如果一个不太懂得如何选型的新人想学着做好这件事，那可以先从小项目开始做尝试，慢慢积累经验。技术选型对人来说最重要的还是“逻辑性”，每一个决策背后都藏着许多假设和事实，我们通过不断挑战这些背后的东西来逐步成长。<br>　　比如在需要使用缓存来加快数据访问速度的场景中，我们可能会很自然的选择 redis 作为缓存服务。这看似“直觉”的决策，背后也是由一系列假设和事实组成。可以问自己一连串问题，看看在具体的场景下这个决策是不是真的正确，例如，缓存服务有没有 redis 之外的选项、是否可以在内存里直接缓存、redis 是否稳定、redis 性能是否满足需求、数据库访问速度瓶颈究竟在哪等等问题，很可能最终结果还是“ 使用 redis 做缓存”这个直观方案，但正因为有分析的过程，让我们在下一次做决策可以更迅速、更自信。<br>　　如何保持敏感性和广度<br>　　技术选型是个很需要经验的活，得有大量的信息积累和输入，再根据具体现实情况输出一个结果。我们在选型的时候最忌讳的是临时抱佛脚、用网上收集一些碎片知识来决策，这是非常危险的，我们得确保自己所有思考都是基于以前的事实，还要弄清楚这些事实背后的假设，这都需要让知识内化形成经验。<br>　　我一直在想，“经验”的本质是什么，有什么方法能够确定自己的经验增长了，而不是不断在重复一些很熟悉的东西。我现在的结论是，经验等于“知识索引”的完备程度。<br>　　我们一生中会积累很多的知识，如果把我们的大脑比作数据库的话，那我们一定有一部分脑存储贡献给了内容的索引，它能帮助我们将关联知识更快的取出来，并且辅助决策。经验增长等同于我们知识索引的增长，意味着我们能轻易的调动更多的关联知识来做更全面的决策。<br>　　要想建立好这个知识索引，我们得保持技术敏感性和广度，也就是要做到持续的信息输入、内化，并发现信息之间的关联性，建立索引，记下来。说起来容易，做起来还是挺有难度的。<br>　　首先难在信息输入量大，忘记了怎么办。我们的大脑不是磁盘，不常用的知识就会忘记，忘记了就跟没看过是一回事。我的经验是一定要对知识进行压缩，记住的是最关键的细节，并且反复的去回味这个细节。<br>　　比如我学习各种语言的时候就会非常留意一些最有特色的语法特性和应用场景，像 C++，我一直记得很早以前看过的细节，像编译器默认会生成哪些类方法，默认析构、拷贝构造、operator = 等，默认生成的类方法有哪些场景需要显示禁用，什么时候要在构造函数用 explicit 等，我看这些细节已经超过十五年的时间了，依然记忆尤新。<br>　　看起来好像有点难度，实际上不难，大家想想自己学过的英文单词，再怎么样最常见的几百个英文单词还是能清楚的记得含义的，而技术的知识点其实压缩之后会远小于英文单词的个数，记忆负担不会有想象中那么大。<br>　　然后难在信息更新速度太快，跟不上技术发展怎么办。我学习了非常多技术之后就会发现这确实是个难解的问题，像前端开发，每年都会有新的框架和开发方式出现，ES7 的语法如果不去提前了解，过两年可能连 Javascript 语法都看不懂了。<br>　　我在这个问题上也是有些焦虑的，不过多少还是有应对的方式，就是坚持碎片化学习，增量更新过时的内容，只要形成习惯也还是能够慢慢的找到自己的节奏。如果有些技术实在细节太多，比如 Node.js 这种，我以前曾经通读过源码，仔细研究过内部设计，但随着它不断发展现在我也不太敢说对它内部有多熟悉，那我会考虑大胆的放弃追新，等着我可能需要用它的时候再统一更新到最新的知识。<br>　　最后难在信息究竟如何存入知识索引，知识太零散形成不了体系，建不了索引怎么办。最入门的做法是看书，看别人是怎么将知识变成一个个章节的信息。要想掌握建立索引背后的方法论，我的经验是先从两个相近的技术开始，找到建索引的感觉，然后再铺开去学习更多知识。有这样困惑的开发者往往在学习方面有些贪心，觉得自己记性好可以囫囵吞枣式的将知识强行内化，这样做短期可以，长期还是会遗忘，也形成不了经验。<br>　　其实技术知识之间非常像，有很多共性的点可以挖掘。比如客户端和前端开发，各个框架在 View 生命周期管理、消息派发机制等方面非常像，后端开发则更加的套路化，无论用那种语言，最基本的分布式服务原理、缓存、队列、数据库等基础组件原理，都万变不离其宗。<br>　　如果我们更宏观的看每个领域，甚至于都能发现领域之间的知识体系划分也很类似。作为表现层的前端和客户端，知识体系都可以分为语言、API、工程化、框架和设计模式。比如前端的语言包括 HTML、CSS、Javascript 和一些稍小众的 TypeScript、CoffeeScript 等，API 就是各种标准、接口的使用、能够实现的效果、平台限制等，工程化就是各种打包工具、代码转化工具、辅助开发工具等，框架就是像 Vue、React 等，设计模式就是像 PWA、redux 等。<br>　　相应的，刚刚说的这些知识都能找到在 iOS 或 Android 里几乎对应的知识，无非换了一些细节，这里我就不继续展开了。服务端也是这样，知识体系最顶层的部分也很少，具体到细节，只是要了解每一个实现背后的优劣。<br>　　总结一下，技术选型依赖于经验，经验又来源于知识索引的建设，这依赖于平时的总结和不断的新知识输入，技术是一辈子的事，必须得投入大量时间维持状态。学无止尽，大家一起共勉。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;a href=&quot;https://news.cnblogs.com/n/563792/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://news.cnblogs.com/n/563792/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="好文" scheme="http://www.lilhui.com/categories/%E5%A5%BD%E6%96%87/"/>
    
    
      <category term="技术选型" scheme="http://www.lilhui.com/tags/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>许式伟、张宴——系统架构运维思路对话</title>
    <link href="http://www.lilhui.com/2018/07/10/java/java_4/"/>
    <id>http://www.lilhui.com/2018/07/10/java/java_4/</id>
    <published>2018-07-10T10:52:17.000Z</published>
    <updated>2018-07-12T09:22:49.654Z</updated>
    
    <content type="html"><![CDATA[<h3 id="许式伟：作为系统架构师，您一般会从哪些方面来保证网站的高可用性（降低故障时间）？"><a href="#许式伟：作为系统架构师，您一般会从哪些方面来保证网站的高可用性（降低故障时间）？" class="headerlink" title="许式伟：作为系统架构师，您一般会从哪些方面来保证网站的高可用性（降低故障时间）？"></a>许式伟：作为系统架构师，您一般会从哪些方面来保证网站的高可用性（降低故障时间）？</h3><p>张宴：很多因素都会导致网站发生故障，从而影响网站的高可用性，比如服务器硬件故障、软件系统故障、IDC机房故障、程序上线前测试未发现的Bug、遭受分布式攻击、突发访问人数剧增等。</p><p>一套良好的网站系统架构，应该尽可能地避免只有一台服务器、一个数据库、一套软件节点等单点故障的存在。单点故障一旦发生，将直接导致网站服务不可用，恢复正常服务所需的时间也比较长，甚至还可能无法恢复。负载均衡集群、双节点热备、分布式处理等都可以用来解决单点故障，比如提供相同业务的Web服务器、MySQL数据库从库，都可以构建负载均衡集群。一旦集群中的一台服务器、一个服务出现故障，自动实时摘除，对用户来说是不可感知的，不会影响到整个网站的访问，可以为运维工程师留下足够的时间去排查和解决故障。</p><p>对于重要的MySQL数据库主库，我们习惯于从硬件层和软件层来实现热备，避免单点。越是复杂的设备，发生故障的概率越大。在磁盘没有损坏的情况下，应用程序导致服务器宕机的概率，远高于简单的磁盘阵列宕机的概率。所以，从硬件层解决的话，可以在两台服务器上安装相同的数据库版本、进行相同的配置，用SAS或SCSI线连接一台磁盘阵列，将数据库数据文件存放到盘阵上。正常情况下用服务器A挂载盘阵分区，启动MySQL，绑定虚拟IP；如果服务器A宕机，则用服务器B挂载盘阵分区，启动MySQL，接管虚拟IP。从软件层解决的话，则可以借助DRBD等软件做镜像。（主从同步，负载均衡、高可用、缓存）</p><p>IDC机房发生故障的概率较小，但如果发生的话，影响面也是最大的。如果所有服务器都托管在一个IDC机房，一旦该机房遭遇长时间流量攻击、断电、断网、地方政策性封网等，通常只能联系IDC去处理，除此之外束手无策，解决时间也比较长。如果成本允许，将网站服务器分布在两个以上的IDC机房，当某个IDC发生故障时，可以临时切换DNS域名解析来优先恢复服务。</p><p>虽然程序代码上线前，经过了测试人员的严格测试，但测试环境和生产环境毕竟有差异，所以一些会急剧影响性能、正常服务的Bug往往在程序上线之后，才会被发现，这就要求我们在发现Bug后，能够迅速回滚到上一正常版本。我们在SVN的基础上，开发了Web代码发布系统，会将每个发布版本之间的文件变更记录下来，一键实现程序代码在多台Web服务器上的发布和回滚。</p><p>遭遇DDOS分布式拒绝服务攻击，使用防火墙来对付半连接、假IP，还算比较容易。而那种专挑复杂动态应用程序URL进行的分布式CC攻击，来源为真实IP、真实HTTP请求，具有模拟正规浏览器User-Agent、单个IP的每秒请求数不高、有成千上万个攻击源等特征，很难与正常访问区分开，比较难对付。但是，正常通过浏览器访问一个URL，会加载该URL中引入的JavaScript脚本、CSS样式、图片等文件。遇到CC攻击，需要及时分析日志，找出访问量异常上涨的URL，然后用事先写好的shell脚本找出哪些IP的请求只访问了该URL，而不加载该URL引入的文件，对这些IP进行自动封锁。</p><p>系统架构设计时，需要事先考虑到高于目前访问量多少倍的突发访问。对于网游站点来说，访问量受广告集中时间段投放、线上活动的影响较大，带宽峰值时间不固定，对于静态内容，可以使用商业CDN，按实际使用量计费。对于动态内容，如果遇到突发访问人数剧增，超过现有服务器处理能力，最简单的临时处理办法就是增加服务器。上架新服务器需要时间，但是，同一个IDC机房内，可以借助其他业务的服务器，在不同端口开启一组新进程，加入到原有负载均衡池中。另外，可以临时关闭一些Web中的次要功能，来减少服务器消耗。</p><h3 id="许式伟：您在任务切分上，有什么经验分享？您通过哪些手段保证任务的独立性？"><a href="#许式伟：您在任务切分上，有什么经验分享？您通过哪些手段保证任务的独立性？" class="headerlink" title="许式伟：您在任务切分上，有什么经验分享？您通过哪些手段保证任务的独立性？"></a>许式伟：您在任务切分上，有什么经验分享？您通过哪些手段保证任务的独立性？</h3><p>张宴：相信很多人都遇到过这种情况：在一个老项目上修改、增加一些新功能所花费的时间，不比重新来做一个包含所有功能的新项目时间用得少。一个需要长期维护的项目，不可避免地会面临老员工的离职、新员工的接手，很多时候，项目代码的可维护性将决定一个项目的生存周期。让一个新员工在规定开发时间的压力下，去面对一个文档不够详细、陌生的、功能复杂的庞大项目，短时间弄明白所有功能逻辑不是一件容易的事。所以，任务需要切分，将一个大的任务切分成一个个小模块之后，各模块之间可以做到代码独立，互不影响，可维护性也大大增强。</p><p>关于任务切分，我以本人今年负责的两个重要项目架构设计为例来介绍一下。在第一个项目：金山游戏官网的《用户行为分析系统》中，由于数据挖掘计算需要消耗较高的内存、CPU资源，一台服务器的处理能力不够，而商业的分布式数据仓库价格又太贵，所以，只有从程序应用中下手，进行任务切分。我们先按需要挖掘的数据指标，将整个数据挖掘任务切分成多个数据挖掘插件，每个插件可以在不同的服务器上运行，多个插件可以同时在多台服务器上。多个数据挖掘插件之间，如果用到相同的某项数据，那么，就将该项数据以冗余方式，复制几份提供给需要的插件，从而实现插件之间无交互、无关联，保证了超大数据量下插件的运算速度。</p><p>在第二个项目：金山游戏新版运营管理系统中，则将整个任务切分成了PHP Web管理界面、PHP Web API功能接口、C/C++中间件引擎三部分。这是一种分层结构切分，最上层的“PHP Web管理界面”调用“PHP Web API功能接口”，“PHP Web API功能接口”调用运行在游戏服务器端的“C/C++中间件引擎”，“C/C++中间件引擎”与“游戏服务器端进程”通过TCP、UDP二进制协议、信号、命令行等多种方式通信。四者之间相对独立，代码无关联，通过一层层API接口实现交互。“PHP Web管理界面”负责通用界面实现。“PHP Web API功能接口”内部，又按接入的游戏模块、子功能模块进行了更细的切分，各功能模块之间通过内部API交互。“C/C++中间件引擎”大而全，不处理具体指令，但兼容TCP、UDP、HTTP、HTTPS/SSL、信号、命令行等大多数通信方式，负责和各种类型的游戏服务端交互。这是一套完全由API接口驱动的系统架构，一款新游戏接入运营管理系统时，只需在“PHP Web API功能接口”中增加一个模块；一个游戏新管理功能的增加，只需要在“PHP Web API功能接口”中增加一个子模块。通过任务切分，将复杂功能简单化，也将原来接入一款新游戏所需要的几个月时间，缩短为1~2周。</p><h3 id="许式伟：您通过哪些手段，来保障产品的质量？您倾向于多久更新一次您的网站？"><a href="#许式伟：您通过哪些手段，来保障产品的质量？您倾向于多久更新一次您的网站？" class="headerlink" title="许式伟：您通过哪些手段，来保障产品的质量？您倾向于多久更新一次您的网站？"></a>许式伟：您通过哪些手段，来保障产品的质量？您倾向于多久更新一次您的网站？</h3><p>张宴：Web产品质量主要体现在架构、功能、性能、安全、代码唯一性、兼容性等方面。</p><p>架构方面，我会先设计一套架构方案，然后让和项目相关的人员、专家组成员参与进来，一起探讨和论证架构的利弊，提出改进意见，保证架构的可行性。所有重要项目的技术方案需要经过专家组的评估。</p><p>功能、性能方面，则会由专门的测试人员进行功能测试、压力测试、安全扫描，测试环境分为线下测试环境、线上准测试环境。</p><p>在代码唯一性方面，我们开发了一个Web配置信息管理平台及相关PHP扩展，提供给系统工程师，用于配置信息的统一管理。在新项目中，PHP程序配置文件中将不再出现MySQL、Memcached等各类IP和端口信息，统一用Web配置信息管理平台给出的变量代替。从“开发环境→线下测试环境→线上测试环境→线上正式环境”，连接的数据库各不相同，导致PHP开发工程师经常搞混淆或忘了修改，通过Web配置信息管理平台，使得PHP代码中的配置文件，在四个环境中无须作任何修改，保证了代码的一致性，降低了出错率，从而确保了产品质量。</p><p>在兼容性方面，我们从操作系统到PHP、MySQL版本，都保持开发环境、测试环境、线上环境的统一，所有的Web服务运行在CentOS Linux系统上。由于大多数PHP程序员习惯于在Windows上编写代码，而我们的程序中调用的一些接口、PHP扩展，只能在Linux下运行。为此，我们开发了一个小工具，可以将多名程序员在各自本机Windows上搭建的nginx虚拟主机、编写的程序文件，映射到一台Linux服务器，用Linux上的php-cgi执行Windows上的PHP代码。这样，PHP程序员修改完本机代码，保存一下，即可调试，多人之间互不影响。自己调试通过后，可以在Windows直接点击鼠标右键，将修改的代码提交到SVN版本库。</p><p>Web 2.0时代，讲究网站更新的实时性，动态网站不用说，静态网站的内容发布也要保证实时。我们开发了一款名为Sersync的开源软件（<a href="http://code.google.com/p/sersync/），使用Linux" target="_blank" rel="external">http://code.google.com/p/sersync/），使用Linux</a> 2.6内核的inotify监控Linux文件系统事件，被监听目录下如果有文件发生修改，Sersync将通过内核自动捕获到事件，并将该文件利用rsync同步到CDN源站服务器。Sersync仅仅同步发生增、删、改事件的单个文件或目录，不像rsync镜像同步那样需要比对双方服务器整个目录下数千万的文件，并且支持多线程同步，因此效率非常高。金山游戏官网的CMS内容发布系统，无论网站编辑通过Web还是FTP上传图片、视频、附件，还是系统工程师直接去CMS发布服务器上增加、修改、删除文件，干完这些事情后不用做任何处理，Sersync 会自动将发生增、删、改事件的文件同步到CDN源站服务器，并可以在文件同步完成后，自动调用CDN缓存刷新接口，主动刷新发生修改、删除的文件的访问URL。</p><h3 id="许式伟：您在面试时，通常关注应聘者的哪些方面？哪些问题经常会问呢？"><a href="#许式伟：您在面试时，通常关注应聘者的哪些方面？哪些问题经常会问呢？" class="headerlink" title="许式伟：您在面试时，通常关注应聘者的哪些方面？哪些问题经常会问呢？"></a>许式伟：您在面试时，通常关注应聘者的哪些方面？哪些问题经常会问呢？</h3><p>张宴：第一，需要具备岗位要求的基础技能知识，这方面我不再详述。</p><p>第二，注重项目经验与积累，不看重学历与工作年限。做一个项目，犹如打一场战役，身经百战，积累下来的成功经验可以让工作更得心应手，失败经验可以避免走很多弯路。</p><p>第三，能够在1~2个以上技术领域精通。所谓术业有专攻，能够在某几项技术领域做到精通的人，相信对于新的技术领域或者从未有过相关经验的新项目，也能够轻松胜任，做到尽善尽美。</p><p>第四，关注应聘者的知识广度。如今的项目，已经告别个人英雄时代，讲究团队的协作。知识面越广，尽管在非专攻领域的深度可能不够，但是，知己知彼，可以站在一个更高的角度上看问题，这对于团队协作开发、项目融合的益处是显而易见的。</p><p>第五，具备良好的领悟能力、思考能力、设计能力、创新能力。基础技能知识不够可以学习，经验不足可以积累，技术不精通可以钻研，知识面不广可以开拓，但要培养这四项能力，是一件非常困难的事。要打造一支优秀的团队，这四项能力不可缺少，它们的重要度甚至超过以上的四方面要求。</p><p>我不会经常去问固定的问题，但所问的问题，几乎都跟以上的这些方面相关。</p><h3 id="许式伟：您曾尝试开放自己的程序代码吗？您对中国国内开源社区的现状有何看法？"><a href="#许式伟：您曾尝试开放自己的程序代码吗？您对中国国内开源社区的现状有何看法？" class="headerlink" title="许式伟：您曾尝试开放自己的程序代码吗？您对中国国内开源社区的现状有何看法？"></a>许式伟：您曾尝试开放自己的程序代码吗？您对中国国内开源社区的现状有何看法？</h3><p>张宴：是否开源自己的程序代码，跟所在公司或部门的性质有着密切的关系。如果是在研发驱动型企业或部门，程序代码是公司生存的命脉，需要与竞争对手拼技术和保持技术领先的优势，因此，很难支持开源事业。反之，如果是在运营驱动型企业或部门，技术是用来提高运营质量、运营水平的工具之一。将纯粹的技术代码或产品，从公司的业务产品中提取出来，进行开<br>源，可以按照开源产品的要求，提高公司内部技术产品的规范化、标准化，还可以引用更广大用户的使用、反馈和意见，解决未发现的潜在Bug，改进代码质量，提升技术水平。对于提高运营质量、运营水平来说，益处多多。我也尝试开源自己的一些代码，例如简单消息队列服务HTTPSQS（<a href="http://code.google.com/p/httpsqs/）、MySQL" target="_blank" rel="external">http://code.google.com/p/httpsqs/）、MySQL</a> HTTP/REST客户端MySQL-UDF-HTTP（<a href="http://code.google.com/p/mysql-udf-http/），同时，也鼓励团队成员尝试开源，例如刚才提到的自动同步软件Sersync。" target="_blank" rel="external">http://code.google.com/p/mysql-udf-http/），同时，也鼓励团队成员尝试开源，例如刚才提到的自动同步软件Sersync。</a></p><p>国内的开源社区在不断壮大，很多知名互联网公司都开源了自己的一些产品，但大多数还只停留在开源产品的使用、技术交流、汉化层面，真正参与到开源产品编码中的人还是较少，很多开源产品最终还是由原作者或原公司团队维护。国内开源社区的道路仍然漫长。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;许式伟：作为系统架构师，您一般会从哪些方面来保证网站的高可用性（降低故障时间）？&quot;&gt;&lt;a href=&quot;#许式伟：作为系统架构师，您一般会从哪些方面来保证网站的高可用性（降低故障时间）？&quot; class=&quot;headerlink&quot; title=&quot;许式伟：作为系统架构师，
      
    
    </summary>
    
      <category term="转载" scheme="http://www.lilhui.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="java" scheme="http://www.lilhui.com/tags/java/"/>
    
      <category term="架构" scheme="http://www.lilhui.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>软件设计原则</title>
    <link href="http://www.lilhui.com/2018/07/06/java/java_3/"/>
    <id>http://www.lilhui.com/2018/07/06/java/java_3/</id>
    <published>2018-07-06T07:59:00.000Z</published>
    <updated>2018-07-06T09:10:29.905Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一些软件设计的原则"><a href="#一些软件设计的原则" class="headerlink" title="一些软件设计的原则"></a>一些软件设计的原则</h3><pre><code>软件设计的原则不单单只是软件开发，可能推广到其他生产活动中。甚至我们生活中遇到问题的思考。</code></pre><h4 id="Don’t-Repeat-Yourself-DRY"><a href="#Don’t-Repeat-Yourself-DRY" class="headerlink" title="Don’t Repeat Yourself(DRY)"></a>Don’t Repeat Yourself(DRY)</h4><pre><code>DRY是最简单法则。它关注的是我们在两个地方发现一些相似代码后。我们需要把他们共性抽离出来，形成一个唯一的方法。并改变现有地方的代码，以适合的参数调用新的方法。</code></pre><h4 id="Keep-It-Simple-Stupid"><a href="#Keep-It-Simple-Stupid" class="headerlink" title="Keep It Simple,Stupid"></a>Keep It Simple,Stupid</h4><pre><code>KISS原则在设计上是备受推崇的。在家装，界面，操作设计上。它的哲学是：把一个简单的事情搞复杂是一件简单的事情，但是把一个复杂的事情变简单，是件复杂的事情。</code></pre><h4 id="面向接口变成，非面向实现编程"><a href="#面向接口变成，非面向实现编程" class="headerlink" title="面向接口变成，非面向实现编程"></a>面向接口变成，非面向实现编程</h4><pre><code>注重接口而不是实现，依赖接口而不是实现。这是由于接口的抽象是稳定的，实现则是多样化的。稳定的事物在操作起来更有安全感。</code></pre><h4 id="你可能不真正需要它原则"><a href="#你可能不真正需要它原则" class="headerlink" title="你可能不真正需要它原则"></a>你可能不真正需要它原则</h4><pre><code>只考虑设计必须的功能，避免过度设计。实现目前需要的功能，在以后考虑需要更多功能时候，再进行添加。如无必要，无增加复杂性。软件开发是一场沟通博弈。</code></pre><h4 id="迪米特法则（Law-of-Demeter"><a href="#迪米特法则（Law-of-Demeter" class="headerlink" title="迪米特法则（Law of Demeter)"></a>迪米特法则（Law of Demeter)</h4><pre><code>迪米特法则又称之为 &quot;最少知识原则&quot; 它来源于1987年荷兰大学的一个Demeter项目。又被称作&quot;不要和陌生人说话&quot;如果你想让你的狗跑的话 ，你会对狗狗说还是要对四条腿说？如果你去买东西，你是把钱缴费电源，还是把钱包交给店员让他自己拿？简言之，在对象调用对象的时候只出现一个&quot;.&quot; dog.run() 而非 dog.getFouLeg().move()</code></pre><h4 id="面向对象的S-O-L-I-D法则"><a href="#面向对象的S-O-L-I-D法则" class="headerlink" title="面向对象的S O L I D法则"></a>面向对象的S O L I D法则</h4><pre><code>一般来说这是面向对象的五大设计原则。但是，我们可以把这些原则用于所有的软件开发。</code></pre><h5 id="Simple-Responsiblility-Principle-SRP-职责单一原则"><a href="#Simple-Responsiblility-Principle-SRP-职责单一原则" class="headerlink" title="Simple Responsiblility Principle(SRP) - 职责单一原则"></a>Simple Responsiblility Principle(SRP) - 职责单一原则</h5><pre><code>其核心思想是：一个类，只做一件事。并把事做好。它只有一个引起它变化的原因。它可以看做是低耦合高内聚的在面向对象上的引申，将职责定义为引发变化的原因，提高内聚性来减少引起变化的外因。职责过多，引起变化的原因就变多。一般情况下设计成引起变化的因素只有一类就好。职责与职责之间不产生依赖。从而降低了耦合度。正向例子：Unix/Linux反向例子：Windows</code></pre><h4 id="Open-Closed-Principle（OCP-开闭原则"><a href="#Open-Closed-Principle（OCP-开闭原则" class="headerlink" title="Open/Closed Principle（OCP)-开闭原则"></a>Open/Closed Principle（OCP)-开闭原则</h4><pre><code>核心思想是：模块是可以扩展的，不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。对扩展开放：意味着有新的需求或者变化时，可以对现有代码进行扩展。以适应新的业务需求。对修改封闭：意味着一旦设计完成，就可以独立完成其工作。而不要对类进行任何修改。</code></pre><h4 id="Likov-substitution-principle-LSP-里氏代换原则"><a href="#Likov-substitution-principle-LSP-里氏代换原则" class="headerlink" title="Likov substitution principle(LSP) - 里氏代换原则"></a>Likov substitution principle(LSP) - 里氏代换原则</h4><pre><code>子类必须能够被替换成他们的基类。既：子类在任何地方时候都可以被他们的基类替换，代码还能正常工作。不应该在代码里进行if/else对子类的类型进行判断的条件。LSP是开闭原则的一个重要保证。它也是我们进行类设计的重要思考条件。就像&quot;蜗牛不是牛&quot;，&quot;鲸鱼是鱼&quot;其判断条件方式就是里氏族代换原则来的。</code></pre><h4 id="Interface-Segregation-Principle-ISP-接口隔离原则"><a href="#Interface-Segregation-Principle-ISP-接口隔离原则" class="headerlink" title="Interface Segregation Principle(ISP) - 接口隔离原则"></a>Interface Segregation Principle(ISP) - 接口隔离原则</h4><pre><code>接口隔离是把功能实现在接口中，而不是类中，使用多个专门的接口比使用单一的总接口要好。例子：电脑有很多使用方式。比如：看电影，聊天，看电影，上网，变成等等。如果把这些都申明在电脑的抽象类里。那么我们的上网本，PC机，服务器这些都要实现所有的这些接口。就太复杂了。所以，我们把这些功能都隔离开，比如：看电影接口，聊天接口，上网接口。这样不同功能的电脑就可以有选择地进行继承实现这些接口。这个原则让我们可以使用&quot;搭积木&quot;的方式进行软件开发。 Java中的Event listener 和Adapter就是用这种原则实现的。</code></pre><h4 id="Dependency-Inversion-Priciple-DIP-依赖倒置原则"><a href="#Dependency-Inversion-Priciple-DIP-依赖倒置原则" class="headerlink" title="Dependency Inversion Priciple(DIP) - 依赖倒置原则"></a>Dependency Inversion Priciple(DIP) - 依赖倒置原则</h4><pre><code>高层不应该依赖低层的实现。而是依赖于高层抽象。墙面的开关不应该依赖于点灯的开关实现，而是依赖于一个抽象开关标准接口。当我们扩展程序时候，我们的开关同样可以控制其他不同的等，甚至不同的电器。也就是说点灯和其他电器集成并实现我们的标准开关接口，我们的开关产商可以不需要关于要控制什么样的设备，只需要关心哪个标准开关就行。这就是依赖倒置原则。</code></pre><h4 id="Common-Closure-Principle-CCP-共同封闭原则"><a href="#Common-Closure-Principle-CCP-共同封闭原则" class="headerlink" title="Common Closure Principle(CCP) - 共同封闭原则"></a>Common Closure Principle(CCP) - 共同封闭原则</h4><pre><code>一个包中所有的类应该对同一种类型的变化关闭。一个变化影响一个包。便影响了包中的所有类。一个简单的说法是:一起修改的类，应该组合在一起（同个包里）如果有需要改代码，我们希望所有的修改发生在意个包里，而不是分布在很多包里CCP实际上是对包的只能的相似进行聚合。对包的分配有指导作用。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一些软件设计的原则&quot;&gt;&lt;a href=&quot;#一些软件设计的原则&quot; class=&quot;headerlink&quot; title=&quot;一些软件设计的原则&quot;&gt;&lt;/a&gt;一些软件设计的原则&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;软件设计的原则不单单只是软件开发，可能推广到其他生产活动中。甚至我们
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="设计" scheme="http://www.lilhui.com/categories/java/%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="设计原则" scheme="http://www.lilhui.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>solr tlog详解</title>
    <link href="http://www.lilhui.com/2018/07/02/search/solr_4/"/>
    <id>http://www.lilhui.com/2018/07/02/search/solr_4/</id>
    <published>2018-07-02T10:38:39.000Z</published>
    <updated>2018-07-02T10:47:49.080Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="搜索" scheme="http://www.lilhui.com/categories/%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="solr" scheme="http://www.lilhui.com/tags/solr/"/>
    
      <category term="tlog" scheme="http://www.lilhui.com/tags/tlog/"/>
    
  </entry>
  
  <entry>
    <title>linux手动修改/etc/shadow和/etc/passwd中的用户密码</title>
    <link href="http://www.lilhui.com/2018/07/02/linux/linux_4/"/>
    <id>http://www.lilhui.com/2018/07/02/linux/linux_4/</id>
    <published>2018-07-02T09:11:19.000Z</published>
    <updated>2018-07-02T09:22:16.123Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在玩GameShell这小玩意儿，发现没有root权限。于是想办法获取到。发现官方有提供img镜像下载。</p><h3 id="img操作"><a href="#img操作" class="headerlink" title="img操作"></a>img操作</h3><p>1：查看img信息:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[ 17:15:11-root@hadoop214:img ]<span class="comment">#fdisk -lu clockworkos_v0.1.img</span></div><div class="line"></div><div class="line">Disk clockworkos_v0.1.img: 7948 MB, 7948206080 bytes, 15523840 sectors</div><div class="line">Units = sectors of 1 * 512 = 512 bytes</div><div class="line">Sector size (logical/physical): 512 bytes / 512 bytes</div><div class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</div><div class="line">Disk label <span class="built_in">type</span>: dos</div><div class="line">Disk identifier: 0x9d1726e4</div><div class="line"></div><div class="line">               Device Boot      Start         End      Blocks   Id  System</div><div class="line">clockworkos_v0.1.img1            8192       93814       42811+   c  W95 FAT32 (LBA)</div><div class="line">clockworkos_v0.1.img2           94208    15523839     7714816   83  Linux</div></pre></td></tr></table></figure></p><p>可以看到linxu文件从 94208 开始 扇区大小512k<br>所以<br>94208*512=48234496<br>2：挂载img<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount -o loop,offset=48234496 clockworkos_v0.1.img /home/gameshell/img/clockpi</div></pre></td></tr></table></figure></p><h3 id="密码修改"><a href="#密码修改" class="headerlink" title="密码修改"></a>密码修改</h3><p>1.手动修改/etc/shadow中的用户密码<br>/etc/shadow文件说明：</p><ul><li>第一字段：用户名（也被称为登录名），在/etc/shadow中，用户名和/etc/passwd 是相同的，这样就把passwd 和shadow中用的用户记录联系在一起；这个字段是非空的；</li><li>第二字段：密码（已被加密），这个字段是非空的；</li><li>第三字段：上次修改口令的时间；这个时间是从1970年01月01日算起到最近一次修改口令的时间间隔（天数），您可以通过passwd 来修改用户的密码，然后查看/etc/shadow中此字段的变化；</li><li>第四字段：两次修改口令间隔最少的天数；如果这个字段的值为空，帐号永久可用；</li><li>第五字段：两次修改口令间隔最多的天数；如果这个字段的值为空，帐号永久可用；</li><li>第六字段：提前多少天警告用户口令将过期；如果这个字段的值为空，帐号永久可用；</li><li>第七字段：在口令过期之后多少天禁用此用户；如果这个字段的值为空，帐号永久可用；</li><li>第八字段：用户过期日期；此字段指定了用户作废的天数（从1970年的1月1日开始的天数），如果这个字段的值为空，帐号永久可用；</li><li>第九字段：保留字段，目前为空，以备将来发展之用；</li></ul><p>/etc/shadow中格式如下</p><p>#testaccount:$1$acQMceF9$1SaCpG2qiKKA3eGolU4Fp0:13402:0:99999:7:::<br>彩色段为加密后的密码，$1$表示采用的是md5加密，绿色段是简单的字符串，蓝色段为加密后的密码</p><p>只要删除 $1$acQMceF9$1SaCpG2qiKKA3eGolU4Fp0 它后，就删除了密码</p><p>2.linux忘记登陆密码修改/etc/passwd也可以</p><p>很简单的一个技巧，给大家介绍一下<br>在这个界面 按任意键<br>按 e键(编辑命令之前启动)<br>选择第二项 在按e键(修改选定的命令在启动)<br>输入single (注意空格)进入单用户模式<br>选择b 启动<br>输入 vi /etc/passwd<br>root:x:0:0:root:/root:/bin/bash<br>光标移至x下面按delete 键 删除它<br>输入：x！<br>输入reboot重启<br>重启后你会发现 没让你输密码，破译成功</p><p>原理解释：<br>在 /etc/passwd 的文件里 保存着用户的信息文件 root:x:0:0:Administrator:/root:/bin/bash</p><p>在这一句中</p><p>root就是用户名，</p><p>x是密码标志，只是说明密码的存放位置，具体呢是放在/etc/passwd的 至于密码别想了 全 是密文保存，看不懂的</p><p>0 用户id号</p><p>0 组id号</p><p>administrator估计是我在装系统的时候，原来的名字没改（虚拟机默认用户名），是用户说 明的意思，</p><p>root 用户的家目录</p><p>/bin/bash 记录着用户登陆后所拥有的权限，即所拥有的shell</p><p>那么我们把密码标示删掉之后，自然就不会有问你密码的对话框了</p><p>当然</p><p>GRUB这个引导装载程序是可以设密码的</p><p>不过 设密码 我们可以光启 ，用安装光盘进入安全模式，在把密码清除</p><p>光启 是可以设BIOS密码的，</p><p>BIOS 密码是可以拆机箱 扣电池的</p><p>那这么说来 传说中的linux岂不是很不安全，通常所说的安全是基于网络的 ，意思是连接互联网后，对方通过网络途径入侵你的linux计算机是很困难的，这种破译的方法只是以防万一，在万一你忘记密码的时候使用的，至于物理安全，那就看你怎么保护了.</p><p>本文转载于：<a href="http://blog.chinaunix.net/uid-15797451-id-3041560.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-15797451-id-3041560.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近在玩GameShell这小玩意儿，发现没有root权限。于是想办法获取到。发现官方有提供img镜像下载。&lt;/p&gt;
&lt;h3 id=&quot;img
      
    
    </summary>
    
      <category term="linux" scheme="http://www.lilhui.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>solr 跨数据中心复制 CDCR升级过程</title>
    <link href="http://www.lilhui.com/2018/06/14/search/solr_3/"/>
    <id>http://www.lilhui.com/2018/06/14/search/solr_3/</id>
    <published>2018-06-14T01:50:16.000Z</published>
    <updated>2018-07-02T10:47:49.086Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>公司使用solr作为底层搜索引擎已经运行好多年了。从solr的 4.*版本到现在的 6.4.1经历了若干个大版本的修改和升级。稳定性一直在提高。</p></blockquote><h3 id="SOLR-CDCR简介"><a href="#SOLR-CDCR简介" class="headerlink" title="SOLR CDCR简介"></a>SOLR CDCR简介</h3><pre><code>跨数据中心复制。是solr从6.0开始的新功能。其目标是实现两个数据集群间的备份。通过合理的二次开发，可以实现异地容灾的功能。</code></pre><h3 id="原有架构"><a href="#原有架构" class="headerlink" title="原有架构"></a>原有架构</h3><h3 id="升级后架构"><a href="#升级后架构" class="headerlink" title="升级后架构"></a>升级后架构</h3><h3 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程</h3><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;公司使用solr作为底层搜索引擎已经运行好多年了。从solr的 4.*版本到现在的 6.4.1经历了若干个大版本的
      
    
    </summary>
    
      <category term="搜索" scheme="http://www.lilhui.com/categories/%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="solr" scheme="http://www.lilhui.com/tags/solr/"/>
    
      <category term="cdcr" scheme="http://www.lilhui.com/tags/cdcr/"/>
    
  </entry>
  
  <entry>
    <title>秒杀系统架构优化思路</title>
    <link href="http://www.lilhui.com/2018/05/17/http/http_2/"/>
    <id>http://www.lilhui.com/2018/05/17/http/http_2/</id>
    <published>2018-05-17T07:47:28.000Z</published>
    <updated>2018-05-17T07:55:29.861Z</updated>
    
    <content type="html"><![CDATA[<p>本文曾在“架构师之路”上发布过，近期支援Qcon-AS大会，在微信群里分享了该话题，故对原文进行重新整理与发布。</p><h3 id="一、秒杀业务为什么难做"><a href="#一、秒杀业务为什么难做" class="headerlink" title="一、秒杀业务为什么难做"></a>一、秒杀业务为什么难做</h3><p>1）im系统，例如qq或者微博，每个人都读自己的数据（好友列表、群列表、个人信息）；</p><p>2）微博系统，每个人读你关注的人的数据，一个人读多个人的数据；</p><p>3）秒杀系统，库存只有一份，所有人会在集中的时间读和写这些数据，多个人读一个数据。</p><p>例如：小米手机每周二的秒杀，可能手机只有1万部，但瞬时进入的流量可能是几百几千万。</p><p>又例如：12306抢票，票是有限的，库存一份，瞬时流量非常多，都读相同的库存。读写冲突，锁非常严重，这是秒杀业务难的地方。那我们怎么优化秒杀业务的架构呢？</p><h3 id="二、优化方向"><a href="#二、优化方向" class="headerlink" title="二、优化方向"></a>二、优化方向</h3><p>优化方向有两个（今天就讲这两个点）：</p><p>（1）将请求尽量拦截在系统上游（不要让锁冲突落到数据库上去）。传统秒杀系统之所以挂，请求都压倒了后端数据层，数据读写锁冲突严重，并发高响应慢，几乎所有请求都超时，流量虽大，下单成功的有效流量甚小。以12306为例，一趟火车其实只有2000张票，200w个人来买，基本没有人能买成功，请求有效率为0。</p><p>（2）充分利用缓存，秒杀买票，这是一个典型的读多些少的应用场景，大部分请求是车次查询，票查询，下单和支付才是写请求。一趟火车其实只有2000张票，200w个人来买，最多2000个人下单成功，其他人都是查询库存，写比例只有0.1%，读比例占99.9%，非常适合使用缓存来优化。好，后续讲讲怎么个“将请求尽量拦截在系统上游”法，以及怎么个“缓存”法，讲讲细节。</p><h3 id="三、常见秒杀架构"><a href="#三、常见秒杀架构" class="headerlink" title="三、常见秒杀架构"></a>三、常见秒杀架构</h3><p>常见的站点架构基本是这样的（绝对不画忽悠类的架构图）</p><p>（1）浏览器端，最上层，会执行到一些JS代码</p><p>（2）站点层，这一层会访问后端数据，拼html页面返回给浏览器</p><p>（3）服务层，向上游屏蔽底层数据细节，提供数据访问</p><p>（4）数据层，最终的库存是存在这里的，mysql是一个典型（当然还有会缓存）</p><p>这个图虽然简单，但能形象的说明大流量高并发的秒杀业务架构，大家要记得这一张图。</p><p>后面细细解析各个层级怎么优化。</p><h3 id="四、各层次优化细节"><a href="#四、各层次优化细节" class="headerlink" title="四、各层次优化细节"></a>四、各层次优化细节</h3><h4 id="第一层，客户端怎么优化（浏览器层，APP层）"><a href="#第一层，客户端怎么优化（浏览器层，APP层）" class="headerlink" title="第一层，客户端怎么优化（浏览器层，APP层）"></a>第一层，客户端怎么优化（浏览器层，APP层）</h4><p>问大家一个问题，大家都玩过微信的摇一摇抢红包对吧，每次摇一摇，就会往后端发送请求么？回顾我们下单抢票的场景，点击了“查询”按钮之后，系统那个卡呀，进度条涨的慢呀，作为用户，我会不自觉的再去点击“查询”，对么？继续点，继续点，点点点。。。有用么？平白无故的增加了系统负载，一个用户点5次，80%的请求是这么多出来的，怎么整？</p><p>（a）产品层面，用户点击“查询”或者“购票”后，按钮置灰，禁止用户重复提交请求；</p><p>（b）JS层面，限制用户在x秒之内只能提交一次请求；</p><p>APP层面，可以做类似的事情，虽然你疯狂的在摇微信，其实x秒才向后端发起一次请求。这就是所谓的“将请求尽量拦截在系统上游”，越上游越好，浏览器层，APP层就给拦住，这样就能挡住80%+的请求，这种办法只能拦住普通用户（但99%的用户是普通用户）对于群内的高端程序员是拦不住的。firebug一抓包，http长啥样都知道，js是万万拦不住程序员写for循环，调用http接口的，这部分请求怎么处理？</p><h4 id="第二层，站点层面的请求拦截"><a href="#第二层，站点层面的请求拦截" class="headerlink" title="第二层，站点层面的请求拦截"></a>第二层，站点层面的请求拦截</h4><p>怎么拦截？怎么防止程序员写for循环调用，有去重依据么？ip？cookie-id？…想复杂了，这类业务都需要登录，用uid即可。在站点层面，对uid进行请求计数和去重，甚至不需要统一存储计数，直接站点层内存存储（这样计数会不准，但最简单）。一个uid，5秒只准透过1个请求，这样又能拦住99%的for循环请求。</p><p>5s只透过一个请求，其余的请求怎么办？缓存，页面缓存，同一个uid，限制访问频度，做页面缓存，x秒内到达站点层的请求，均返回同一页面。同一个item的查询，例如车次，做页面缓存，x秒内到达站点层的请求，均返回同一页面。如此限流，既能保证用户有良好的用户体验（没有返回404）又能保证系统的健壮性（利用页面缓存，把请求拦截在站点层了）。</p><p>页面缓存不一定要保证所有站点返回一致的页面，直接放在每个站点的内存也是可以的。优点是简单，坏处是http请求落到不同的站点，返回的车票数据可能不一样，这是站点层的请求拦截与缓存优化。</p><p>好，这个方式拦住了写for循环发http请求的程序员，有些高端程序员（黑客）控制了10w个肉鸡，手里有10w个uid，同时发请求（先不考虑实名制的问题，小米抢手机不需要实名制），这下怎么办，站点层按照uid限流拦不住了。</p><h4 id="第三层-服务层来拦截（反正就是不要让请求落到数据库上去）"><a href="#第三层-服务层来拦截（反正就是不要让请求落到数据库上去）" class="headerlink" title="第三层 服务层来拦截（反正就是不要让请求落到数据库上去）"></a>第三层 服务层来拦截（反正就是不要让请求落到数据库上去）</h4><p>服务层怎么拦截？大哥，我是服务层，我清楚的知道小米只有1万部手机，我清楚的知道一列火车只有2000张车票，我透10w个请求去数据库有什么意义呢？没错，请求队列！</p><p>对于写请求，做请求队列，每次只透有限的写请求去数据层（下订单，支付这样的写业务）</p><p>1w部手机，只透1w个下单请求去db</p><p>3k张火车票，只透3k个下单请求去db</p><p>如果均成功再放下一批，如果库存不够则队列里的写请求全部返回“已售完”。</p><p>对于读请求，怎么优化？cache抗，不管是memcached还是redis，单机抗个每秒10w应该都是没什么问题的。如此限流，只有非常少的写请求，和非常少的读缓存mis的请求会透到数据层去，又有99.9%的请求被拦住了。</p><p>当然，还有业务规则上的一些优化。回想12306所做的，分时分段售票，原来统一10点卖票，现在8点，8点半，9点，…每隔半个小时放出一批：将流量摊匀。</p><p>其次，数据粒度的优化：你去购票，对于余票查询这个业务，票剩了58张，还是26张，你真的关注么，其实我们只关心有票和无票？流量大的时候，做一个粗粒度的“有票”“无票”缓存即可。</p><p>第三，一些业务逻辑的异步：例如下单业务与 支付业务的分离。这些优化都是结合 业务 来的，我之前分享过一个观点“一切脱离业务的架构设计都是耍流氓”架构的优化也要针对业务。</p><p>好了，最后是数据库层</p><p>浏览器拦截了80%，站点层拦截了99.9%并做了页面缓存，服务层又做了写请求队列与数据缓存，每次透到数据库层的请求都是可控的。db基本就没什么压力了，闲庭信步，单机也能扛得住，还是那句话，库存是有限的，小米的产能有限，透这么多请求来数据库没有意义。</p><p>全部透到数据库，100w个下单，0个成功，请求有效率0%。透3k个到数据，全部成功，请求有效率100%。</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>上文应该描述的非常清楚了，没什么总结了，对于秒杀系统，再次重复下我个人经验的两个架构优化思路：</p><p>（1）尽量将请求拦截在系统上游（越上游越好）；</p><p>（2）读多写少的常用多使用缓存（缓存抗读压力）；</p><p>浏览器和APP：做限速</p><p>站点层：按照uid做限速，做页面缓存</p><p>服务层：按照业务做写请求队列控制流量，做数据缓存</p><p>数据层：闲庭信步</p><p>并且：结合业务做优化</p><h3 id="六、Q-amp-A"><a href="#六、Q-amp-A" class="headerlink" title="六、Q&amp;A"></a>六、Q&amp;A</h3><p>问题1、按你的架构，其实压力最大的反而是站点层，假设真实有效的请求数有1000万，不太可能限制请求连接数吧，那么这部分的压力怎么处理？</p><p>答：每秒钟的并发可能没有1kw，假设有1kw，解决方案2个：</p><p>（1）站点层是可以通过加机器扩容的，最不济1k台机器来呗。</p><p>（2）如果机器不够，抛弃请求，抛弃50%（50%直接返回稍后再试），原则是要保护系统，不能让所有用户都失败。</p><p>问题2、“控制了10w个肉鸡，手里有10w个uid，同时发请求” 这个问题怎么解决哈？</p><p>答：上面说了，服务层写请求队列控制</p><p>问题3：限制访问频次的缓存，是否也可以用于搜索？例如A用户搜索了“手机”，B用户搜索“手机”，优先使用A搜索后生成的缓存页面？</p><p>答：这个是可以的，这个方法也经常用在“动态”运营活动页，例如短时间推送4kw用户app-push运营活动，做页面缓存。</p><p>问题4：如果队列处理失败，如何处理？肉鸡把队列被撑爆了怎么办？</p><p>答：处理失败返回下单失败，让用户再试。队列成本很低，爆了很难吧。最坏的情况下，缓存了若干请求之后，后续请求都直接返回“无票”（队列里已经有100w请求了，都等着，再接受请求也没有意义了）</p><p>问题5：站点层过滤的话，是把uid请求数单独保存到各个站点的内存中么？如果是这样的话，怎么处理多台服务器集群经过负载均衡器将相同用户的响应分布到不同服务器的情况呢？还是说将站点层的过滤放到负载均衡前？</p><p>答：可以放在内存，这样的话看似一台服务器限制了5s一个请求，全局来说（假设有10台机器），其实是限制了5s 10个请求，解决办法：</p><p>1）加大限制（这是建议的方案，最简单）</p><p>2）在nginx层做7层均衡，让一个uid的请求尽量落到同一个机器上</p><p>问题6：服务层过滤的话，队列是服务层统一的一个队列？还是每个提供服务的服务器各一个队列？如果是统一的一个队列的话，需不需要在各个服务器提交的请求入队列前进行锁控制？</p><p>答：可以不用统一一个队列，这样的话每个服务透过更少量的请求（总票数/服务个数），这样简单。统一一个队列又复杂了。</p><p>问题7：秒杀之后的支付完成，以及未支付取消占位，如何对剩余库存做及时的控制更新？</p><p>答：数据库里一个状态，未支付。如果超过时间，例如45分钟，库存会重新会恢复（大家熟知的“回仓”），给我们抢票的启示是，开动秒杀后，45分钟之后再试试看，说不定又有票哟~</p><p>问题8：不同的用户浏览同一个商品 落在不同的缓存实例显示的库存完全不一样 请问老师怎么做缓存数据一致或者是允许脏读？</p><p>答：目前的架构设计，请求落到不同的站点上，数据可能不一致（页面缓存不一样），这个业务场景能接受。但数据库层面真实数据是没问题的。</p><p>问题9：就算处于业务把优化考虑“3k张火车票，只透3k个下单请求去db”那这3K个订单就不会发生拥堵了吗？</p><p>答：（1）数据库抗3k个写请求还是ok的；（2）可以数据拆分；（3）如果3k扛不住，服务层可以控制透过去的并发数量，根据压测情况来吧，3k只是举例；</p><p>问题10；如果在站点层或者服务层处理后台失败的话，需不需要考虑对这批处理失败的请求做重放？还是就直接丢弃？</p><p>答：别重放了，返回用户查询失败或者下单失败吧，架构设计原则之一是“fail fast”。</p><p>问题11.对于大型系统的秒杀，比如12306，同时进行的秒杀活动很多，如何分流？</p><p>答：垂直拆分</p><p>问题12、额外又想到一个问题。这套流程做成同步还是异步的？如果是同步的话，应该还存在会有响应反馈慢的情况。但如果是异步的话，如何控制能够将响应结果返回正确的请求方？</p><p>答：用户层面肯定是同步的（用户的http请求是夯住的），服务层面可以同步可以异步。</p><p>问题13、秒杀群提问：减库存是在那个阶段减呢？如果是下单锁库存的话，大量恶意用户下单锁库存而不支付如何处理呢？</p><p>答：数据库层面写请求量很低，还好，下单不支付，等时间过完再“回仓”，之前提过了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文曾在“架构师之路”上发布过，近期支援Qcon-AS大会，在微信群里分享了该话题，故对原文进行重新整理与发布。&lt;/p&gt;
&lt;h3 id=&quot;一、秒杀业务为什么难做&quot;&gt;&lt;a href=&quot;#一、秒杀业务为什么难做&quot; class=&quot;headerlink&quot; title=&quot;一、秒杀业务
      
    
    </summary>
    
      <category term="系统架构" scheme="http://www.lilhui.com/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="秒杀，高并发" scheme="http://www.lilhui.com/tags/%E7%A7%92%E6%9D%80%EF%BC%8C%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>网站QPS,TPS 预估方法</title>
    <link href="http://www.lilhui.com/2018/05/17/http/http_tps/"/>
    <id>http://www.lilhui.com/2018/05/17/http/http_tps/</id>
    <published>2018-05-17T07:41:49.000Z</published>
    <updated>2018-05-17T07:55:29.846Z</updated>
    
    <content type="html"><![CDATA[<h4 id="QPS-TPS是每秒响应的查询数量或处理的事务数量"><a href="#QPS-TPS是每秒响应的查询数量或处理的事务数量" class="headerlink" title="QPS/TPS是每秒响应的查询数量或处理的事务数量"></a>QPS/TPS是每秒响应的查询数量或处理的事务数量</h4><h4 id="一、TPS："><a href="#一、TPS：" class="headerlink" title="一、TPS："></a>一、TPS：</h4><p>Transactions Per Second（每秒传输的事物处理个数），即服务器每秒处理的事务数。TPS包括一条消息入和一条消息出，加上一次用户数据库访问。（业务TPS = CAPS × 每个呼叫平均TPS）</p><p>TPS是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</p><p>一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。系统整体处理能力取决于处理能力较低模块的TPS值。</p><h4 id="二、QPS："><a href="#二、QPS：" class="headerlink" title="二、QPS："></a>二、QPS：</h4><p>每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。</p><p>对应fetches/sec，即每秒的响应请求数，也即是较大吞吐能力</p><p>======================================================================================================</p><p>QPS = req/sec = 请求数/秒</p><p>【QPS计算PV和机器的方式】</p><p>QPS统计方式 [一般使用 http_load 进行统计]<br>QPS = 总请求数 / ( 进程总数 *   请求时间 )<br>QPS: 单个进程每秒请求服务器的成功次数</p><p>单台服务器每天PV计算<br>公式1：每天总PV = QPS <em> 3600 </em> 6<br>公式2：每天总PV = QPS <em> 3600 </em> 8</p><p>服务器计算<br>服务器数量 =   ceil( 每天总PV / 单台服务器每天总PV )</p><p>【峰值QPS和机器计算公式】</p><p>原理：每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间<br>公式：( 总PV数 <em> 80% ) / ( 每天秒数 </em> 20% ) = 峰值时间每秒请求数(QPS)<br>机器：峰值时间每秒QPS / 单台机器的QPS   = 需要的机器</p><ul><li>问：每天300w PV 的在单台机器上，这台机器需要多少QPS？<br>答：( 3000000 <em> 0.8 ) / (86400 </em> 0.2 ) = 139 (QPS)</li></ul><p>问：如果一台机器的QPS是58，需要几台机器来支持？<br>答：139 / 58 = 3</p><p>PS：下面是性能测试的主要概念和计算公式，记录下：<br>一．系统吞度量要素：<br>  一个系统的吞度量（承压能力）与request对CPU的消耗、外部接口、IO等等紧密关联。单个reqeust 对CPU消耗越高，外部系统接口、IO影响速度越慢，系统吞吐能力越低，反之越高。<br>系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间<br>        QPS（TPS）：每秒钟request/事务 数量<br>        并发数： 系统同时处理的request/事务数<br>        响应时间：  一般取平均响应时间<br>（很多人经常会把并发数和TPS理解混淆）<br>理解了上面三个要素的意义之后，就能推算出它们之间的关系：<br>QPS（TPS）= 并发数/平均响应时间    或者   并发数 = QPS<em>平均响应时间<br>        一个典型的上班签到系统，早上8点上班，7点半到8点的30分钟的时间里用户会登录签到系统进行签到。公司员工为1000人，平均每个员上登录签到系统的时长为5分钟。可以用下面的方法计算。<br>QPS = 1000/(30</em>60) 事务/秒<br>平均响应时间为 = 5<em>60  秒<br>并发数= QPS</em>平均响应时间 = 1000/(30<em>60) </em>(5*60)=166.7<br>        一个系统吞吐量通常由QPS（TPS）、并发数两个因素决定，每套系统这两个值都有一个相对极限值，在应用场景访问压力下，只要某一项达到系统较高值，系统的吞吐量就上不去了，如果压力继续增大，系统的吞吐量反而会下降，原因是系统超负荷工作，上下文切换、内存等等其它消耗导致系统性能下降。<br>决定系统响应时间要素<br>我们做项目要排计划，可以多人同时并发做多项任务，也可以一个人或者多个人串行工作，始终会有一条关键路径，这条路径就是项目的工期。<br>系统一次调用的响应时间跟项目计划一样，也有一条关键路径，这个关键路径是就是系统影响时间；<br>关键路径是有CPU运算、IO、外部系统响应等等组成。<br>二．系统吞吐量评估：<br>我们在做系统设计的时候就需要考虑CPU运算、IO、外部系统响应因素造成的影响以及对系统性能的初步预估。<br>而通常境况下，我们面对需求，我们评估出来的出来QPS、并发数之外，还有另外一个维度：日PV。<br>通过观察系统的访问日志发现，在用户量很大的情况下，各个时间周期内的同一时间段的访问流量几乎一样。比如工作日的每天早上。只要能拿到日流量图和QPS我们就可以推算日流量。<br>通常的技术方法：</p><pre><code>1. 找出系统的较高TPS和日PV，这两个要素有相对比较稳定的关系（除了放假、季节性因素影响之外）2. 通过压力测试或者经验预估，得出较高TPS，然后跟进1的关系，计算出系统较高的日吞吐量。B2B中文和淘宝面对的客户群不一样，这两个客户群的网络行为不应用，他们之间的TPS和PV关系比例也不一样。</code></pre><p>A)淘宝<br>淘宝流量图：</p><p>淘宝的TPS和PV之间的关系通常为  较高TPS：PV大约为 1 : 11<em>3600 （相当于按较高TPS访问11个小时，这个是商品详情的场景，不同的应用场景会有一些不同）<br>B) B2B中文站<br>B2B的TPS和PV之间的关系不同的系统不同的应用场景比例变化比较大，粗略估计在1 : 8个小时左右的关系（09年对offerdetail的流量分析数据）。旺铺和offerdetail这两个比例相差很大，可能是因为爬虫暂的比例较高的原因导致。<br>在淘宝环境下，假设我们压力测试出的TPS为100，那么这个系统的日吞吐量=100</em>11*3600=396万<br>这个是在简单（单一url）的情况下，有些页面，一个页面有多个request，系统的实际吞吐量还要小。<br>无论有无思考时间（T_think），测试所得的TPS值和并发虚拟用户数(U_concurrent)、Loadrunner读取的交易响应时间（T_response）之间有以下关系（稳定运行情况下）：<br>TPS=U_concurrent / (T_response+T_think)。<br>并发数、QPS、平均响应时间三者之间关系</p><p>   上图横坐标是并发用户数。绿线是CPU使用率；紫线是吞吐量，即QPS；蓝线是时延。<br>    开始，系统只有一个用户，CPU工作肯定是不饱合的。一方面该服务器可能有多个cpu，但是只处理单个进程，另一方面，在处理一个进程中，有些阶段可能是IO阶段，这个时候会造成CPU等待，但是有没有其他请 求进程可以被处理）。随着并发用户数的增加，CPU利用率上升，QPS相应也增加（公式为QPS=并发用户数/平均响应时间。）随着并发用户数的增加，平均响应时间也在增加，而且平均响应时间的增加是一个指数增加曲线。而当并发数增加到很大时，每秒钟都会有很多请求需要处理，会造成进程（线程）频繁切换，反正真正用于处理请求的时间变少，每秒能够处 理的请求数反而变少，同时用户的请求等待时间也会变大，甚至超过用户的心理底线。<br>来源：<a href="http://www.cnblogs.com/jackei/" target="_blank" rel="external">http://www.cnblogs.com/jackei/</a><br>软件性能测试的基本概念和计算公式<br>一、软件性能的关注点<br>对一个软件做性能测试时需要关注那些性能呢？<br>我们想想在软件设计、部署、使用、维护中一共有哪些角色的参与，然后再考虑这些角色各自关注的性能点是什么，作为一个软件性能测试工程师，我们又该关注什么？<br>首先，开发软件的目的是为了让用户使用，我们先站在用户的角度分析一下，用户需要关注哪些性能。<br>对于用户来说，当点击一个按钮、链接或发出一条指令开始，到系统把结果已用户感知的形式展现出来为止，这个过程所消耗的时间是用户对这个软件性能的直观印象。也就是我们所说的响应时间，当相应时间较小时，用户体验是很好的，当然用户体验的响应时间包括个人主观因素和客观响应时间，在设计软件时，我们就需要考虑到如何更好地结合这两部分达到用户较佳的体验。如：用户在大数据量查询时，我们可以将先提取出来的数据展示给用户，在用户看的过程中继续进行数据检索，这时用户并不知道我们后台在做什么。<br>用户关注的是用户操作的相应时间。<br>其次，我们站在管理员的角度考虑需要关注的性能点。<br>1、 相应时间<br>2、 服务器资源使用情况是否合理<br>3、 应用服务器和数据库资源使用是否合理<br>4、 系统能否实现扩展<br>5、 系统最多支持多少用户访问、系统较大业务处理量是多少<br>6、 系统性能可能存在的瓶颈在哪里<br>7、 更换那些设备可以提高性能<br>8、 系统能否支持7×24小时的业务访问<br>再次，站在开发（设计）人员角度去考虑。<br>1、 架构设计是否合理<br>2、 数据库设计是否合理<br>3、 代码是否存在性能方面的问题<br>4、 系统中是否有不合理的内存使用方式<br>5、 系统中是否存在不合理的线程同步方式<br>6、 系统中是否存在不合理的资源竞争<br>那么站在性能测试工程师的角度，我们要关注什么呢？<br>一句话，我们要关注以上所有的性能点。<br>二、软件性能的几个主要术语<br>1、响应时间：对请求作出响应所需要的时间<br>网络传输时间：N1+N2+N3+N4<br>应用服务器处理时间：A1+A3<br>数据库服务器处理时间：A2<br>响应时间=N1+N2+N3+N4+A1+A3+A2<br>2、并发用户数的计算公式<br>系统用户数：系统额定的用户数量，如一个OA系统，可能使用该系统的用户总数是5000个，那么这个数量，就是系统用户数。<br>同时在线用户数：在一定的时间范围内，较大的同时在线用户数量。<br>同时在线用户数=每秒请求数RPS（吞吐量）+并发连接数+平均用户思考时间<br>平均并发用户数的计算：C=nL / T<br>其中C是平均的并发用户数，n是平均每天访问用户数（login session），L是一天内用户从登录到退出的平均时间（login session的平均时间），T是考察时间长度（一天内多长时间有用户使用系统）<br>并发用户数峰值计算：C^约等于C + 3<em>根号C<br>其中C^是并发用户峰值，C是平均并发用户数，该公式遵循泊松分布理论。<br>3、吞吐量的计算公式<br>指单位时间内系统处理用户的请求数<br>从业务角度看，吞吐量可以用：请求数/秒、页面数/秒、人数/天或处理业务数/小时等单位来衡量<br>从网络角度看，吞吐量可以用：字节/秒来衡量<br>对于交互式应用来说，吞吐量指标反映的是服务器承受的压力，他能够说明系统的负载能力<br>以不同方式表达的吞吐量可以说明不同层次的问题，例如，以字节数/秒方式可以表示数要受网络基础设施、服务器架构、应用服务器制约等方面的瓶颈；已请求数/秒的方式表示主要是受应用服务器和应用代码的制约体现出的瓶颈。<br>当没有遇到性能瓶颈的时候，吞吐量与虚拟用户数之间存在一定的联系，可以采用以下公式计算：F=VU </em> R /<br>其中F为吞吐量，VU表示虚拟用户个数，R表示每个虚拟用户发出的请求数，T表示性能测试所用的时间<br>4、性能计数器<br>是描述服务器或操作系统性能的一些数据指标，如使用内存数、进程时间，在性能测试中发挥着“监控和分析”的作用，尤其是在分析统统可扩展性、进行新能瓶颈定位时有着非常关键的作用。<br>资源利用率：指系统各种资源的使用情况，如cpu占用率为68%，内存占用率为55%，一般使用“资源实际使用/总的资源可用量”形成资源利用率。<br>5、思考时间的计算公式<br>Think Time，从业务角度来看，这个时间指用户进行操作时每个请求之间的时间间隔，而在做新能测试时，为了模拟这样的时间间隔，引入了思考时间这个概念，来更加真实的模拟用户的操作。<br>在吞吐量这个公式中F=VU <em> R / T说明吞吐量F是VU数量、每个用户发出的请求数R和时间T的函数，而其中的R又可以用时间T和用户思考时间TS来计算：R = T / TS<br>下面给出一个计算思考时间的一般步骤：<br>A、首先计算出系统的并发用户数<br>C=nL / T F=R×C<br>B、统计出系统平均的吞吐量<br>F=VU </em> R / T R×C = VU <em> R / T<br>C、统计出平均每个用户发出的请求数量<br>R=u</em>C*T/VU<br>D、根据公式计算出思考时间<br>TS=T/R</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;QPS-TPS是每秒响应的查询数量或处理的事务数量&quot;&gt;&lt;a href=&quot;#QPS-TPS是每秒响应的查询数量或处理的事务数量&quot; class=&quot;headerlink&quot; title=&quot;QPS/TPS是每秒响应的查询数量或处理的事务数量&quot;&gt;&lt;/a&gt;QPS/TPS是每秒响
      
    
    </summary>
    
      <category term="系统架构" scheme="http://www.lilhui.com/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="高并发" scheme="http://www.lilhui.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="TPS" scheme="http://www.lilhui.com/tags/TPS/"/>
    
  </entry>
  
  <entry>
    <title>git使用场景集锦</title>
    <link href="http://www.lilhui.com/2018/05/07/tools/tools_0/"/>
    <id>http://www.lilhui.com/2018/05/07/tools/tools_0/</id>
    <published>2018-05-07T08:10:56.000Z</published>
    <updated>2018-05-08T06:26:17.685Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h3><h4 id="安装之后第一步"><a href="#安装之后第一步" class="headerlink" title="安装之后第一步"></a>安装之后第一步</h4><p>安装 Git 之后，你要做的第一件事情就是去配置你的名字和邮箱，因为每一次提交都需要这些信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name &quot;bukas&quot;</div><div class="line">git config --global user.email &quot;bukas@gmail.com&quot;</div></pre></td></tr></table></figure><p>获取Git配置信息，执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --list</div></pre></td></tr></table></figure><h4 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h4><p>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir testgit &amp;&amp; cd testgit</div><div class="line">git init</div></pre></td></tr></table></figure><p>瞬间Git就把仓库建好了，细心的读者可以发现当前目录下多了一个.git的目录，默认是隐藏的，用ls -ah命令就可以看见。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git-init</div></pre></td></tr></table></figure><h4 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">touch readme.md</div><div class="line">git add readme.md</div></pre></td></tr></table></figure><p>然后用命令git commit告诉Git把文件提交到仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m &quot;wrote a readme file&quot;</div></pre></td></tr></table></figure><p>简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p>一次可以add多个不同的文件，以空格分隔：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add a.txt b.txt c.txt</div></pre></td></tr></table></figure><h4 id="仓库状态"><a href="#仓库状态" class="headerlink" title="仓库状态"></a>仓库状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git status</div></pre></td></tr></table></figure><p>git status命令可以让我们时刻掌握仓库当前的状态。</p><p>但如果能看看具体修改了什么内容就更好了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git diff readme.md</div></pre></td></tr></table></figure><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>每次提交git都会形成以个commit。我们通过git log可以查看到各个提交的历史。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log</div></pre></td></tr></table></figure></p><p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1525681039891.png?imageView2/2/w/666/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p><p>git log –pretty=oneline 参数可以简化显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log --pretty=oneline</div></pre></td></tr></table></figure><p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1525681121417.png?imageView2/2/w/672/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p><p>在 Git中，用HEAD表示当前版本，也就是最新的提交commit id，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p><p>现在我们要把当前版本回退到上一个版本，就可以使用git reset命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --hard HEAD^</div></pre></td></tr></table></figure><p>然我们用git log再看看现在版本库的状态，最新的那个版本已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p><p>git-reset</p><p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，假设找到那个commit id是2e70fdf…，于是就可以指定回到未来的某个版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --hard 2e70fdf</div></pre></td></tr></table></figure><p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p><p>Git提供了一个命令git reflog用来记录你的每一次命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reflog</div></pre></td></tr></table></figure><p>终于舒了口气，于是你看到的commit id是2e70fdf，现在，你又可以乘坐时光机回到未来了。</p><h4 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h4><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p><p>工作区就是你在电脑里能看到的目录，比如我的testgit文件夹就是一个工作区。</p><p>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向 master的一个指针叫HEAD。</p><p>前面讲了我们把文件往 Git 版本库里添加的时候，是分两步执行的：</p><p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以现在git commit就是往master分支上提交更改。</p><p>你可以简单理解为，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后执行git commit就可以一次性把暂存区的所有修改提交到分支。</p><p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。</p><h4 id="修改与撤销"><a href="#修改与撤销" class="headerlink" title="修改与撤销"></a>修改与撤销</h4><p>用git diff HEAD – readme.md命令可以查看工作区和版本库里面最新版本的区别。</p><p>git checkout – file可以丢弃工作区的修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -- readme.md</div></pre></td></tr></table></figure><p>命令git checkout – readme.md意思就是，把readme.md文件在工作区的修改全部撤销，即让这个文件回到最近一次git commit或git add时的状态。</p><p>当然也可以用git reset命令。</p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm readme.md</div></pre></td></tr></table></figure><p>这个时候，Git 知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了。</p><p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git rm readme.md</div><div class="line">git commit -m &quot;remove readme.md&quot;</div></pre></td></tr></table></figure><p>现在，文件就从版本库中被删除了。</p><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -- readme.md</div></pre></td></tr></table></figure><h4 id="生成SSH-key"><a href="#生成SSH-key" class="headerlink" title="生成SSH key"></a>生成SSH key</h4><p>创建 SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开 Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</div></pre></td></tr></table></figure><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可。</p><p>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p><p>然后登录GitHub（或者其它Git代码托管平台），打开Account settings，SSH Keys页面，点Add SSH Key，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。</p><p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p><p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p><p>远程服务器<br>Git 最强大的功能之一是可以有一个以上的远程服务器（另一个事实，你总是可以运行一个本地仓库）。你不一定总是需要写访问权限，你可以从多个服务器中读取（用于合并），然后写到另一个服务器中。添加一个远程服务器很简单：</p><p>git remote add origin(别名，根据爱好命名) git@github.com:bukas/bukas.git<br>如果你想查看远程服务器的相关信息，你可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># shows URLs of each remote server</div><div class="line">git remote -v</div><div class="line"></div><div class="line"># gives more details about origin</div><div class="line">git remote show origin(别名)</div></pre></td></tr></table></figure><p>下一步，就可以把本地库的所有内容推送到远程库上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push -u origin master</div></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。</p><p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>从现在起，只要本地作了提交，就可以通过命令把本地master分支的最新修改推送至GitHub：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin master</div></pre></td></tr></table></figure><h4 id="SSH警告"><a href="#SSH警告" class="headerlink" title="SSH警告"></a>SSH警告</h4><p>当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">The authenticity of host ‘github.com (xx.xx.xx.xx)’ can’t be established.</div><div class="line"></div><div class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</div><div class="line"></div><div class="line">Are you sure you want to continue connecting (yes/no)?</div></pre></td></tr></table></figure><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认 GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。</p><p>从远程库克隆</p><p>当已经有一个远程库的时候，我们可以用命令git clone克隆一个本地库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone git@github.com:test/testgit.git</div></pre></td></tr></table></figure><p>你也许还注意到，GitHub给出的地址不止一个，还可以用<a href="https://github.com/test/testgit.git这样的地址。实际上Git支持多种协议，默认的git://使用ssh，但也可以使用" target="_blank" rel="external">https://github.com/test/testgit.git这样的地址。实际上Git支持多种协议，默认的git://使用ssh，但也可以使用</a> https等其他协议。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</p><p>创建与合并分支<br>首先我们创建dev分支，然后切换到dev分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b dev</div></pre></td></tr></table></figure><p>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git branch dev</div><div class="line">git checkout dev</div></pre></td></tr></table></figure><p>然后用git branch命令查看当前分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch</div></pre></td></tr></table></figure><p>我们在dev分支上进行添加修改操作，然后我们把dev分支的工作成果合并到master分支上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout master</div><div class="line">git merge dev</div></pre></td></tr></table></figure><p>git merge命令用于合并指定分支到当前分支。</p><p>注意到git merge的信息里面可能有Fast-forward字样，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p><p>当然也不是每次合并都能Fast-forward。</p><p>合并完成后，就可以放心地删除dev分支了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d dev</div></pre></td></tr></table></figure><p>如果要丢弃一个没有被合并过的分支，可以通过git branch -D <branch>强行删除。</branch></p><p>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</p><p>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；</p><p>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p><p>有时候我们进行合并的时候，会提示有冲突出现CONFLICT (content)，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件。</p><p>打开冲突文件我们会看到Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改后提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add readme.md</div><div class="line">git commit -m &quot;conflict fixed&quot;</div></pre></td></tr></table></figure><p>用带参数的git log也可以看到分支的合并情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log --graph --pretty=oneline --abbrev-commit</div></pre></td></tr></table></figure><h4 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h4><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p>下面我们实战一下–no-ff方式的git merge：</p><p>首先，仍然创建并切换dev分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b dev</div></pre></td></tr></table></figure><p>修改readme.md文件，并提交一个新的commit：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add readme.md</div><div class="line">git commit -m &quot;add merge&quot;</div></pre></td></tr></table></figure><p>现在，我们切换回master：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout master</div></pre></td></tr></table></figure><p>准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge --no-ff -m &quot;merge with no-ff&quot; dev</div></pre></td></tr></table></figure><h4 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h4><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交。</p><p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p><p>幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git stash</div></pre></td></tr></table></figure><p>现在，用git status查看工作区，就是干净的（除非有没有被 Git 管理的文件），因此可以放心地创建分支来修复bug。</p><p>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout master</div><div class="line">git checkout -b issue-101</div></pre></td></tr></table></figure><p>现在修复bug，然后提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add readme.md</div><div class="line">git commit -m &quot;fix bug 101&quot;</div></pre></td></tr></table></figure><p>修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">git checkout master</div><div class="line">git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</div></pre></td></tr></table></figure><p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout dev</div><div class="line">git status</div></pre></td></tr></table></figure><p>工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git stash list</div></pre></td></tr></table></figure><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><p>一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</p><p>另一种方式是用git stash pop，恢复的同时把stash内容也删了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git stash pop</div></pre></td></tr></table></figure><p>再用git stash list查看，就看不到任何stash内容了。</p><p>你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git stash apply stash@&#123;0&#125;</div></pre></td></tr></table></figure><h4 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h4><p>发布一个版本时，我们通常先在版本库中打一个标签，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><p>命令git tag <tagname>用于新建一个标签，默认为HEAD，也可以指定一个commit id。</tagname></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息。</div></pre></td></tr></table></figure><p>还可以通过-s用私钥签名一个标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag -s v0.5 -m &quot;signed version 0.2 released&quot; fec145a</div></pre></td></tr></table></figure><p>git tag可以查看所有标签。</p><p>用命令git show <tagname>可以查看某个标签的详细信息。</tagname></p><p>如果标签打错了，也可以删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag -d v0.1</div></pre></td></tr></table></figure><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>如果要推送某个标签到远程，使用命令git push origin <tagname>：</tagname></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin v1.0</div></pre></td></tr></table></figure><p>或者，一次性推送全部尚未推送到远程的本地标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin --tags</div></pre></td></tr></table></figure></p><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag -d v0.9</div></pre></td></tr></table></figure><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin :refs/tags/v0.9</div></pre></td></tr></table></figure><p>####忽略特殊文件</p><p>在安装Git一节中，我们已经配置了user.name 和user.email，实际上，Git还有很多可配置项。</p><p>比如，让Git显示颜色，会让命令输出看起来更醒目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global color.ui true</div></pre></td></tr></table></figure><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次git status都会显示Untracked files…，有强迫症的童鞋心里肯定不爽。</p><p>好在Git考虑到了大家的感受，这个问题解决起来也很简单，在 Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p><p>不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore" target="_blank" rel="external">https://github.com/github/gitignore</a></p><p>当然也可以配置全局忽略的文件，这样就不用每个项目都加gitignore了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global core.excludesfile &apos;~/.gitignore&apos;</div></pre></td></tr></table></figure><h4 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h4><p>有没有经常敲错命令？比如git status？status这个单词真心不好记。</p><p>如果敲git st就表示git status那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p><p>我们只需要敲一行命令，告诉Git，以后st就表示status：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global alias.st status</div></pre></td></tr></table></figure></p><p>当然还有别的命令可以简写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git config --global alias.co checkout</div><div class="line">git config --global alias.ci commit</div><div class="line">git config --global alias.br branch</div></pre></td></tr></table></figure><p>–global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p><p>在撤销修改一节中，我们知道，命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global alias.unstage &apos;reset HEAD&apos;</div></pre></td></tr></table></figure><p>配置一个git last，让其显示最后一次提交信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global alias.last &apos;log -1&apos;</div></pre></td></tr></table></figure><p>甚至还有人把lg配置成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</div></pre></td></tr></table></figure><p>####配置文件</p><p>配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p><p>配置文件放哪了？每个仓库的Git配置文件都放在.git/config文件中。</p><p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Git使用&quot;&gt;&lt;a href=&quot;#Git使用&quot; class=&quot;headerlink&quot; title=&quot;Git使用&quot;&gt;&lt;/a&gt;Git使用&lt;/h3&gt;&lt;h4 id=&quot;安装之后第一步&quot;&gt;&lt;a href=&quot;#安装之后第一步&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="git" scheme="http://www.lilhui.com/categories/git/"/>
    
    
      <category term="git" scheme="http://www.lilhui.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>swagger2 注解说明</title>
    <link href="http://www.lilhui.com/2018/04/04/spring/swagger/swagger_1/"/>
    <id>http://www.lilhui.com/2018/04/04/spring/swagger/swagger_1/</id>
    <published>2018-04-04T01:36:56.000Z</published>
    <updated>2018-04-04T03:12:45.932Z</updated>
    
    <content type="html"><![CDATA[<h3 id="整体说明"><a href="#整体说明" class="headerlink" title="整体说明"></a>整体说明</h3><blockquote><p>swagger2的在线文档功能异常强大。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">@Api：用在请求的类上，表示对类的说明</div><div class="line">    tags=&quot;说明该类的作用，可以在UI界面上看到的注解&quot;</div><div class="line">    value=&quot;该参数没什么意义，在UI界面上也看到，所以不需要配置&quot;</div><div class="line"></div><div class="line">@ApiOperation：用在请求的方法上，说明方法的用途、作用</div><div class="line">    value=&quot;说明方法的用途、作用&quot;</div><div class="line">    notes=&quot;方法的备注说明&quot;</div><div class="line"></div><div class="line">@ApiImplicitParams：用在请求的方法上，表示一组参数说明</div><div class="line">    @ApiImplicitParam：用在@ApiImplicitParams注解中，指定一个请求参数的各个方面</div><div class="line">        name：参数名</div><div class="line">        value：参数的汉字说明、解释</div><div class="line">        required：参数是否必须传</div><div class="line">        paramType：参数放在哪个地方</div><div class="line">            · header --&gt; 请求参数的获取：@RequestHeader</div><div class="line">            · query --&gt; 请求参数的获取：@RequestParam</div><div class="line">            · path（用于restful接口）--&gt; 请求参数的获取：@PathVariable</div><div class="line">            · body（不常用）</div><div class="line">            · form（不常用）    </div><div class="line">        dataType：参数类型，默认String，其它值dataType=&quot;Integer&quot;       </div><div class="line">        defaultValue：参数的默认值</div><div class="line"></div><div class="line">@ApiResponses：用在请求的方法上，表示一组响应</div><div class="line">    @ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息</div><div class="line">        code：数字，例如400</div><div class="line">        message：信息，例如&quot;请求参数没填好&quot;</div><div class="line">        response：抛出异常的类</div><div class="line"></div><div class="line">@ApiModel：用于响应类上，表示一个返回响应数据的信息</div><div class="line">            （这种一般用在post创建的时候，使用@RequestBody这样的场景，</div><div class="line">            请求参数无法使用@ApiImplicitParam注解进行描述的时候）</div><div class="line">    @ApiModelProperty：用在属性上，描述响应类的属性</div></pre></td></tr></table></figure><h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><ol><li>@Api：用在请求的类上，说明该类的作用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Api：用在请求的类上，说明该类的作用</div><div class="line">    tags=&quot;说明该类的作用&quot;</div><div class="line">    value=&quot;该参数没什么意义，所以不需要配置&quot;</div></pre></td></tr></table></figure><ol><li>@ApiOperation：用在请求的方法上，说明方法的作用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@ApiOperation：&quot;用在请求的方法上，说明方法的作用&quot;</div><div class="line">    value=&quot;说明方法的作用&quot;</div><div class="line">    notes=&quot;方法的备注说明</div></pre></td></tr></table></figure><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@ApiOperation(value=&quot;用户注册&quot;,notes=&quot;手机号、密码都是必输项，年龄随边填，但必须是数字&quot;)</div></pre></td></tr></table></figure></p><ol><li>@ApiImplicitParams：用在请求的方法上，包含一组参数说明</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@ApiImplicitParams：用在请求的方法上，包含一组参数说明</div><div class="line">    @ApiImplicitParam：用在 @ApiImplicitParams 注解中，指定一个请求参数的配置信息       </div><div class="line">        name：参数名</div><div class="line">        value：参数的汉字说明、解释</div><div class="line">        required：参数是否必须传</div><div class="line">        paramType：参数放在哪个地方</div><div class="line">            · header --&gt; 请求参数的获取：@RequestHeader</div><div class="line">            · query --&gt; 请求参数的获取：@RequestParam</div><div class="line">            · path（用于restful接口）--&gt; 请求参数的获取：@PathVariable</div><div class="line">            · body（不常用）</div><div class="line">            · form（不常用）    </div><div class="line">        dataType：参数类型，默认String，其它值dataType=&quot;Integer&quot;       </div><div class="line">        defaultValue：参数的默认值</div></pre></td></tr></table></figure><p>示列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@ApiImplicitParams(&#123;</div><div class="line">    @ApiImplicitParam(name=&quot;mobile&quot;,value=&quot;手机号&quot;,required=true,paramType=&quot;form&quot;),</div><div class="line">    @ApiImplicitParam(name=&quot;password&quot;,value=&quot;密码&quot;,required=true,paramType=&quot;form&quot;),</div><div class="line">    @ApiImplicitParam(name=&quot;age&quot;,value=&quot;年龄&quot;,required=true,paramType=&quot;form&quot;,dataType=&quot;Integer&quot;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><ol><li>@ApiResponses：用于请求的方法上，表示一组响应</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@ApiResponses：用于请求的方法上，表示一组响应</div><div class="line">    @ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息</div><div class="line">        code：数字，例如400</div><div class="line">        message：信息，例如&quot;请求参数没填好&quot;</div><div class="line">        response：抛出异常的类</div></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@ApiOperation(value = &quot;select1请求&quot;,notes = &quot;多个参数，多种的查询参数类型&quot;)</div><div class="line">@ApiResponses(&#123;</div><div class="line">    @ApiResponse(code=400,message=&quot;请求参数没填好&quot;),</div><div class="line">    @ApiResponse(code=404,message=&quot;请求路径没有或页面跳转路径不对&quot;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><ol><li>@ApiModel：用于响应类上，表示一个返回响应数据的信息</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@ApiModel：用于响应类上，表示一个返回响应数据的信息</div><div class="line">            （这种一般用在post创建的时候，使用@RequestBody这样的场景，</div><div class="line">            请求参数无法使用@ApiImplicitParam注解进行描述的时候）</div><div class="line">    @ApiModelProperty：用在属性上，描述响应类的属性</div></pre></td></tr></table></figure><p>示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</div><div class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"></div><div class="line"><span class="meta">@ApiModel</span>(description= <span class="string">"返回响应数据"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestMessage</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"是否成功"</span>)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> success=<span class="keyword">true</span>;</div><div class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"返回对象"</span>)</div><div class="line">    <span class="keyword">private</span> Object data;</div><div class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"错误编号"</span>)</div><div class="line">    <span class="keyword">private</span> Integer errCode;</div><div class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"错误信息"</span>)</div><div class="line">    <span class="keyword">private</span> String message;</div><div class="line"></div><div class="line">    <span class="comment">/* getter/setter */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;整体说明&quot;&gt;&lt;a href=&quot;#整体说明&quot; class=&quot;headerlink&quot; title=&quot;整体说明&quot;&gt;&lt;/a&gt;整体说明&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;swagger2的在线文档功能异常强大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure cl
      
    
    </summary>
    
      <category term="spring" scheme="http://www.lilhui.com/categories/spring/"/>
    
      <category term="swagger" scheme="http://www.lilhui.com/categories/spring/swagger/"/>
    
    
      <category term="swagger" scheme="http://www.lilhui.com/tags/swagger/"/>
    
  </entry>
  
  <entry>
    <title>Socket,WebSocket,HTML5</title>
    <link href="http://www.lilhui.com/2018/02/06/http/hexo/"/>
    <id>http://www.lilhui.com/2018/02/06/http/hexo/</id>
    <published>2018-02-06T02:19:18.000Z</published>
    <updated>2018-02-06T06:55:27.180Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>对Web项目来讲，一般都用http请求来解决。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>Socket 和 WebSocket 有哪些区别和联系？</li><li>WebSocket 和 HTML5 是什么关系？</li><li>必须在浏览器中才能使用 WebSocket 吗？</li><li>WebSocket 能和 Socket 一样传输 raw 数据么？</li><li>WebSocket 和 Socket 相比会多耗费流量么？</li></ul><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>选择了 WebSocket 技术之后，不可避免的，我要将它和其他协议以及技术做一下比较。最常见的，就是需要比较 WebSocket 与 HTTP、Socket 技术的异同。</p><p>WebSocket 是为了满足基于 Web 的日益增长的实时通信需求而产生的。在传统的 Web 中，要实现实时通信，通用的方式是采用 HTTP 协议不断发送请求。但这种方式即浪费带宽（HTTP HEAD 是比较大的），又消耗服务器 CPU 占用（没有信息也要接受请求）。（下图来自 WebSocket.org）</p><p>Latency comparison between the polling and WebSocket applications</p><p>而是用 WebSocket 技术，则会大幅降低上面提到的消耗：（下图来自websocket.org）</p><p>Comparison of the unnecessary network throughput overhead between the polling and the WebSocket applications</p><p>关于更详细的描述，尹立的这篇文章讲得非常好：WebSocket（2）–为什么引入WebSocket协议 。</p><p>那么，WebSocket 到底与 HTTP 协议到底是一个什么样的关系呢？它和 Socket 又有什么联系？这就要讲到 OSI 模型和 TCP/IP 协议族。</p><h3 id="OSI-模型与-TCP-IP"><a href="#OSI-模型与-TCP-IP" class="headerlink" title="OSI 模型与 TCP/IP"></a>OSI 模型与 TCP/IP</h3><p>以下是 维基百科 中关于OSI 模型的说明：</p><p>开放式系统互联通信参考模型（英语：Open System Interconnection Reference Model，ISO/IEC 7498-1），简称为OSI模型（OSI model），一种概念模型，由国际标准化组织（ISO）提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。</p><p>而 TCP/IP 协议可以看做是对 OSI 模型的一种简化（以下内容来自 维基百科）：</p><p>它将软件通信过程抽象化为四个抽象层，采取协议堆叠的方式，分别实作出不同通信协议。协议套组下的各种协议，依其功能不同，被分别归属到这四个阶层之中7，常被视为是简化的七层OSI模型。</p><p>这里有一张图详细介绍了 TCP/IP 协议族中的各个协议在 OSI模型 中的分布，一图胜千言（下图来自 科来）：</p><p>TCP/IP 和 OSI 模型</p><p>TCP/IP 协议和 OSI 模型的内容，在互联网上有很多。我没有必要再次介绍它们。在这里，我们只需要知道，HTTP、WebSocket 等协议都是处于 OSI 模型的最高层： 应用层 。而 IP 协议工作在网络层（第3层），TCP 协议工作在传输层（第4层）。</p><p>至于 OSI 模型的各个层次都有什么系统和它们对应，这里有篇很好的文章可以满足大家的求知欲：OSI七层模型详解 。</p><ol><li>WebSocket、HTTP 与 TCP<br>从上面的图中可以看出，HTTP、WebSocket 等应用层协议，都是基于 TCP 协议来传输数据的。我们可以把这些高级协议理解成对 TCP 的封装。</li></ol><p>既然大家都使用 TCP 协议，那么大家的连接和断开，都要遵循 TCP 协议中的三次握手和四次握手 ，只是在连接之后发送的内容不同，或者是断开的时间不同。</p><p>更详细内容可阅读：wireshark抓包图解 TCP三次握手/四次挥手详解</p><p>对于 WebSocket 来说，它必须依赖 HTTP 协议进行一次握手 ，握手成功后，数据就直接从 TCP 通道传输，与 HTTP 无关了。</p><ol><li>Socket 与 WebScoket<br>Socket 其实并不是一个协议。它工作在 OSI 模型会话层（第5层），是为了方便大家直接使用更底层协议（一般是 TCP 或 UDP ）而存在的一个抽象层。</li></ol><p>最早的一套 Socket API 是 Berkeley sockets ，采用 C 语言实现。它是 Socket 的事实标准，POSIX sockets 是基于它构建的，多种编程语言都遵循这套 API，在 JAVA、Python 中都能看到这套 API 的影子。</p><p>下面摘录一段更容易理解的文字（来自 http和socket之长连接和短连接区别）：</p><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><p>Socket是什么</p><p>Socket通信过程</p><p>主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。</p><p>而 WebSocket 则不同，它是一个完整的 应用层协议，包含一套标准的 API 。</p><p>所以，从使用上来说，WebSocket 更易用，而 Socket 更灵活。</p><ol><li>HTML5 与 WebSocket<br>WebSocket API 是 HTML5 标准的一部分， 但这并不代表 WebSocket 一定要用在 HTML 中，或者只能在基于浏览器的应用程序中使用。</li></ol><p>实际上，许多语言、框架和服务器都提供了 WebSocket 支持，例如：</p><p>基于 C 的 libwebsocket.org<br>基于 Node.js 的 Socket.io<br>基于 Python 的 ws4py<br>基于 C++ 的 WebSocket++<br>Apache 对 WebSocket 的支持： Apache Module mod_proxy_wstunnel<br>Nginx 对 WebSockets 的支持： NGINX as a WebSockets Proxy 、 NGINX Announces Support for WebSocket Protocol 、WebSocket proxying<br>lighttpd 对 WebSocket 的支持：mod_websocket</p><p><a href="http://blog.csdn.net/yuanyuanispeak/article/details/51729191" target="_blank" rel="external">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;对Web项目来讲，一般都用http请求来解决。&lt;/p&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="http" scheme="http://www.lilhui.com/categories/http/"/>
    
      <category term="WebSocket" scheme="http://www.lilhui.com/categories/http/WebSocket/"/>
    
    
      <category term="socket" scheme="http://www.lilhui.com/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>Twitter Snowflake 有序ID生成算法</title>
    <link href="http://www.lilhui.com/2018/01/31/java/java_2/"/>
    <id>http://www.lilhui.com/2018/01/31/java/java_2/</id>
    <published>2018-01-31T09:11:17.000Z</published>
    <updated>2018-01-31T09:22:07.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>分布式系统，各种系统平台建设中，需要用到全局唯一的ID场景，可以统一地进行一些简单的统计和排序。这时候我们需要一个统一的ID生成系统来做这个事情。<br>Twitter Snowflake 可以作为一个满足基础需求的原始样本算法。可以以此为蓝本开发自己的业务ID生成算法。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>snowflake的结构如下(每部分用-分开):<br>0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000<br>第一位为未使用，接下来的41位为毫秒级时间(41位的长度可以使用69年)，然后是5位datacenterId和5位workerId(10位的长度最多支持部署1024个节点） ，最后12位是毫秒内的计数（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号）<br>一共加起来刚好64位，为一个Long型。(转换成字符串后长度最多19)<br>snowflake生成的ID整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和workerId作区分），并且效率较高。经测试snowflake每秒能够产生26万个ID。</p><h3 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Twitter_Snowflake&lt;br&gt;</span></div><div class="line"><span class="comment"> * SnowFlake的结构如下(每部分用-分开):&lt;br&gt;</span></div><div class="line"><span class="comment"> * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;</span></div><div class="line"><span class="comment"> * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&lt;br&gt;</span></div><div class="line"><span class="comment"> * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截)</span></div><div class="line"><span class="comment"> * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&lt;br&gt;</span></div><div class="line"><span class="comment"> * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId&lt;br&gt;</span></div><div class="line"><span class="comment"> * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&lt;br&gt;</span></div><div class="line"><span class="comment"> * 加起来刚好64位，为一个Long型。&lt;br&gt;</span></div><div class="line"><span class="comment"> * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnowflakeIdWorker</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ==============================Fields===========================================</span></div><div class="line">    <span class="comment">/** 开始时间截 (2015-01-01) */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> twepoch = <span class="number">1420041600000L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/** 机器id所占的位数 */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/** 数据标识id所占的位数 */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterIdBits = <span class="number">5L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</div><div class="line"></div><div class="line">    <span class="comment">/** 支持的最大数据标识id，结果是31 */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxDatacenterId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</div><div class="line"></div><div class="line">    <span class="comment">/** 序列在id中占的位数 */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/** 机器ID向左移12位 */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdShift = sequenceBits;</div><div class="line"></div><div class="line">    <span class="comment">/** 数据标识id向左移17位(12+5) */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits;</div><div class="line"></div><div class="line">    <span class="comment">/** 时间截向左移22位(5+5+12) */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</div><div class="line"></div><div class="line">    <span class="comment">/** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);</div><div class="line"></div><div class="line">    <span class="comment">/** 工作机器ID(0~31) */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerId;</div><div class="line"></div><div class="line">    <span class="comment">/** 数据中心ID(0~31) */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> datacenterId;</div><div class="line"></div><div class="line">    <span class="comment">/** 毫秒内序列(0~4095) */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/** 上次生成ID的时间截 */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</div><div class="line"></div><div class="line">    <span class="comment">//==============================Constructors=====================================</span></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 构造函数</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> workerId 工作ID (0~31)</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> datacenterId 数据中心ID (0~31)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnowflakeIdWorker</span><span class="params">(<span class="keyword">long</span> workerId, <span class="keyword">long</span> datacenterId)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"worker Id can't be greater than %d or less than 0"</span>, maxWorkerId));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"datacenter Id can't be greater than %d or less than 0"</span>, maxDatacenterId));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.workerId = workerId;</div><div class="line">        <span class="keyword">this</span>.datacenterId = datacenterId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ==============================Methods==========================================</span></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获得下一个ID (该方法是线程安全的)</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> SnowflakeId</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> timestamp = timeGen();</div><div class="line"></div><div class="line">        <span class="comment">//如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span></div><div class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                    String.format(<span class="string">"Clock moved backwards.  Refusing to generate id for %d milliseconds"</span>, lastTimestamp - timestamp));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//如果是同一时间生成的，则进行毫秒内序列</span></div><div class="line">        <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</div><div class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</div><div class="line">            <span class="comment">//毫秒内序列溢出</span></div><div class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">//阻塞到下一个毫秒,获得新的时间戳</span></div><div class="line">                timestamp = tilNextMillis(lastTimestamp);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//时间戳改变，毫秒内序列重置</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            sequence = <span class="number">0L</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//上次生成ID的时间截</span></div><div class="line">        lastTimestamp = timestamp;</div><div class="line"></div><div class="line">        <span class="comment">//移位并通过或运算拼到一起组成64位的ID</span></div><div class="line">        <span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) <span class="comment">//</span></div><div class="line">                | (datacenterId &lt;&lt; datacenterIdShift) <span class="comment">//</span></div><div class="line">                | (workerId &lt;&lt; workerIdShift) <span class="comment">//</span></div><div class="line">                | sequence;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 阻塞到下一个毫秒，直到获得新的时间戳</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> lastTimestamp 上次生成ID的时间截</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间戳</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">tilNextMillis</span><span class="params">(<span class="keyword">long</span> lastTimestamp)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> timestamp = timeGen();</div><div class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</div><div class="line">            timestamp = timeGen();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> timestamp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 返回以毫秒为单位的当前时间</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间(毫秒)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">timeGen</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> System.currentTimeMillis();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//==============================Test=============================================</span></div><div class="line">    <span class="comment">/** 测试 */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SnowflakeIdWorker idWorker = <span class="keyword">new</span> SnowflakeIdWorker(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">            <span class="keyword">long</span> id = idWorker.nextId();</div><div class="line">            System.out.println(Long.toBinaryString(id));</div><div class="line">            System.out.println(id);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;分布式系统，各种系统平台建设中，需要用到全局唯一的ID场景，可以统一地进行一些简单的统计和排序。这时候我们需要一个统一的ID生成系统来做这个
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
    
      <category term="ID生成" scheme="http://www.lilhui.com/tags/ID%E7%94%9F%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="http://www.lilhui.com/2018/01/23/java/patterndesign/patterndesign_15/"/>
    <id>http://www.lilhui.com/2018/01/23/java/patterndesign/patterndesign_15/</id>
    <published>2018-01-23T07:25:00.000Z</published>
    <updated>2018-02-28T08:39:57.201Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>观察者模式提供了一种对象设计,让主题和观察者之间耦合度降得很低,为什么呢?关于观察者的一切,主题只知道观察者实现了Observer接口,并不需要观察者具体的类是谁,做了什么或者其他细节.<br>这样的话,由于松耦合,改变主题或者观察者其中一方,并不会影响另一方,只要他们之间的接口仍被遵守,就可以自由地改变它.<br>降低对象之间的耦合度,也是面设对象设计的一个很重要的原则.　　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;h3 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现&lt;/h3&gt;&lt;h3 id
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="设计模式" scheme="http://www.lilhui.com/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="观察者" scheme="http://www.lilhui.com/tags/%E8%A7%82%E5%AF%9F%E8%80%85/"/>
    
  </entry>
  
  <entry>
    <title>模板方法模式</title>
    <link href="http://www.lilhui.com/2018/01/23/java/patterndesign/patterndesign_14/"/>
    <id>http://www.lilhui.com/2018/01/23/java/patterndesign/patterndesign_14/</id>
    <published>2018-01-23T07:24:07.000Z</published>
    <updated>2018-03-01T06:43:45.914Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>模板方法模式 在意个方法中定义一个算法的骨架，而将这些具体步骤实现延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中<br>的某些步骤</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3></blockquote><p>AbstraceClass:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;模板方法模式 在意个方法中定义一个算法的骨架，而将这些具体步骤实现延迟到子类中。模板方法使得子类可以在不改变算法结
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="设计模式" scheme="http://www.lilhui.com/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="模板方法" scheme="http://www.lilhui.com/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="http://www.lilhui.com/2018/01/23/java/patterndesign/patterndesign_13/"/>
    <id>http://www.lilhui.com/2018/01/23/java/patterndesign/patterndesign_13/</id>
    <published>2018-01-23T07:22:01.000Z</published>
    <updated>2018-02-27T03:51:29.127Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>策略模式定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。</p></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>策略模式涉及到三个角色：</p><ul><li>环境(Context)角色：持有一个Strategy的引用。</li><li>抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li><li>具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。</li></ul><p>PriceStrategy:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.littlehui.design.strategy;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by littlehui on 2018/2/27.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PriceStrategy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">caculaPrice</span><span class="params">(Double price)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>MemberPriceStrategy:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.littlehui.design.strategy;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by littlehui on 2018/2/27.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberPriceStrategy</span> <span class="keyword">implements</span> <span class="title">PriceStrategy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">caculaPrice</span><span class="params">(Double price)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> price * <span class="number">0.9</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>VipPriceStrategy:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.littlehui.design.strategy;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by littlehui on 2018/2/27.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VipPriceStrategy</span> <span class="keyword">implements</span> <span class="title">PriceStrategy</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">caculaPrice</span><span class="params">(Double price)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> price * <span class="number">0.8</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Price:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.littlehui.design.strategy;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by littlehui on 2018/2/27.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Price</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Double price;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Price</span><span class="params">(Double price)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.price = price;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">cacularPrice</span><span class="params">(PriceStrategy priceStrategy)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> priceStrategy.caculaPrice(price);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Client:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.littlehui.design.strategy;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by littlehui on 2018/2/27.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Price price = <span class="keyword">new</span> Price(<span class="number">5</span>D);</div><div class="line">        System.out.println(price.cacularPrice(<span class="keyword">new</span> VipPriceStrategy()));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>策略模式的优点<br>　　（1）策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。</p><p>　　（2）使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。</p><p>策略模式的缺点<br>　　（1）客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。</p><p>　　（2）由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;策略模式定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。&lt;/p&gt;
&lt;/
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="设计模式" scheme="http://www.lilhui.com/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="策略模式" scheme="http://www.lilhui.com/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>linux免密码登录</title>
    <link href="http://www.lilhui.com/2018/01/17/linux/linux_3/"/>
    <id>http://www.lilhui.com/2018/01/17/linux/linux_3/</id>
    <published>2018-01-17T07:58:03.000Z</published>
    <updated>2018-01-17T08:38:16.676Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有两台机器 A,B。现在要实现A访问B免密码登录。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="生成秘钥"><a href="#生成秘钥" class="headerlink" title="生成秘钥"></a>生成秘钥</h4><p>在A主机上执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -f rsa_for_174</div><div class="line"></div><div class="line">回车</div><div class="line">回车</div><div class="line">回车</div></pre></td></tr></table></figure></p><ul><li>-t 类型</li><li>-f 指定生成秘钥文件名</li></ul><h4 id="追加认证"><a href="#追加认证" class="headerlink" title="追加认证"></a>追加认证</h4><ul><li>将生成的秘钥拷贝到B主机，可以手动ftp，也可以用命令。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp -i ~/.ssh/CY6034_rsa_4096 ./rsa_for_174.pub root@10.5.121.144:~/.ssh/</div></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -i CY6034_rsa_4096 root@10.5.121.144</div></pre></td></tr></table></figure><p>追加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat ~/.ssh/rsa_for_174 &gt;&gt; ~/.ssh/authorized_keys</div></pre></td></tr></table></figure></p><p>DONE</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;有两台机器 A,B。现在要实现A访问B免密码登录。&lt;/p&gt;
&lt;h3 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="linux" scheme="http://www.lilhui.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux服务器性能评估</title>
    <link href="http://www.lilhui.com/2017/11/21/linux/linux_2/"/>
    <id>http://www.lilhui.com/2017/11/21/linux/linux_2/</id>
    <published>2017-11-21T06:53:13.000Z</published>
    <updated>2017-12-08T10:07:44.458Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>Web服务在部署到Linux系统运行期间，可能会遇到各种问题。程序上的BUG，数据上的问题，这些排查起来较为简单。当排除这些问题后，往往需要深入到服务器<br>层面来寻找影响程序运行的稳定因素。</p></blockquote><h3 id="基本信息查看"><a href="#基本信息查看" class="headerlink" title="基本信息查看"></a>基本信息查看</h3><h4 id="CPU信息查看"><a href="#CPU信息查看" class="headerlink" title="CPU信息查看"></a>CPU信息查看</h4><ol><li><p>查看CPU个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq | wc -l</div></pre></td></tr></table></figure></li><li><p>查看CPU中core个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /proc/cpuinfo | grep &quot;cpu cores&quot; | wc -l</div></pre></td></tr></table></figure></li><li><p>查看CPU逻辑个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /proc/cpuinfo | grep &quot;processor&quot; | wc -l</div></pre></td></tr></table></figure></li></ol><p>逻辑CPU数 = 物理CPU个数*核心数</p><h4 id="内存信息查看"><a href="#内存信息查看" class="headerlink" title="内存信息查看"></a>内存信息查看</h4><ol><li>内存使用情况<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#free -m</div><div class="line">             total       used       free     shared    buffers     cached</div><div class="line">Mem:         64376      37881      26494          0        308      17273</div><div class="line">-/+ buffers/cache:      20299      44076</div><div class="line">Swap:        16383          0      16383</div></pre></td></tr></table></figure></li></ol><ul><li>total: 总内存数</li><li>used: 已用内存数</li><li>free: 空闲内存  </li><li>shared: 多进程共享的内存总数  </li><li>- buffers/cache: 已用缓存总数 used-buffer-cached  </li><li>+ buffers/cache: 可用缓存数 free+buffer+cached  </li><li>Buffer Cache 用于针对磁盘块的写  </li><li>Page Cache用于针对文件inode的读写，这些cache能够缩短I/O时间  </li><li>free / used是系统可用/暂用的内存   </li></ul><p>对于程序来说 -/+ buffers/cache是可用/占用内存，因为 buffers/cache很容易就会被使用到</p><h4 id="硬盘查看"><a href="#硬盘查看" class="headerlink" title="硬盘查看"></a>硬盘查看</h4><ol><li><p>查看硬盘分区信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fdisk -l</div></pre></td></tr></table></figure></li><li><p>查看文件系统磁盘暂用情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df -h</div></pre></td></tr></table></figure></li><li><p>查看硬盘的I/O性能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iostat -d -k 1</div><div class="line"></div><div class="line">Linux 2.6.32-358.el6.x86_64 (fzck-10-59-107-216.h.173ops.com) 2017年11月21日 _x86_64_(32 CPU)</div><div class="line"></div><div class="line">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</div><div class="line">sda              13.35        31.70       161.99 2867672698 14655271354</div><div class="line">sdb               0.86        17.77        29.61 1607620286 2679034433</div></pre></td></tr></table></figure></li></ol><p>参数解释：</p><ul><li>tps：该设备每秒的传输次数（Indicate the number of transfers per second that were issued to the device.）。”一次传输”意思是”一次I/O请求”。多个逻辑请求可能会被合并为”一次I/O请求”。”一次传输”请求的大小是未知的。</li><li>kB_read/s：每秒从设备（drive expressed）读取的数据量；</li><li>kB_wrtn/s：每秒向设备（drive expressed）写入的数据量；</li><li>kB_read：读取的总数据量；</li><li>kB_wrtn：写入的总数量数据量；这些单位都为Kilobytes。</li></ul><p>指定监控的设备名称为sda，该命令的输出结果和上面命令完全相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iostat -d sda 2</div></pre></td></tr></table></figure></p><p>默认监控所有的硬盘设备，现在指定只监控sda。 </p><h5 id="x-参数"><a href="#x-参数" class="headerlink" title="-x 参数"></a>-x 参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">iostat -d -x -k 1 10</div><div class="line"></div><div class="line">Linux 2.6.32-358.el6.x86_64 (fzck-10-59-107-216.h.173ops.com) 2017年11月21日 _x86_64_(32 CPU)</div><div class="line"></div><div class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</div><div class="line">sda               0.01    28.67    1.47   11.89    31.70   161.99    29.01     0.01    0.57    2.76    0.30   0.16   0.21</div><div class="line">sdb               0.00     0.00    0.47    0.39    17.77    29.61   109.69     0.00    1.61    0.55    2.87   0.38   0.03</div><div class="line"></div><div class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</div><div class="line">sda               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</div><div class="line">sdb               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</div><div class="line"></div><div class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</div><div class="line">sda               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</div><div class="line">sdb               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</div></pre></td></tr></table></figure><ul><li>rrqm/s：每秒这个设备相关的读取请求有多少被Merge了（当系统调用需要读取数据的时候，VFS将请求发到各个FS，如果FS发现不同的读取请求读取的是相同Block的数据，FS会将这个请求合并Merge）；</li><li>wrqm/s：每秒这个设备相关的写入请求有多少被Merge了.  </li><li>rsec/s：每秒读取的扇区数.  </li><li>wsec/：每秒写入的扇区数。 </li><li>rKB/s：The number of read requests that were issued to the device per second；  </li><li>wKB/s：The number of write requests that were issued to the device per second；  </li><li>avgrq-sz 平均请求扇区的大小  </li><li>avgqu-sz 是平均请求队列的长度。毫无疑问，队列长度越短越好。     </li><li>await：  每一个IO请求的处理的平均时间（单位是微秒毫秒）。这里可以理解为IO的响应时间，一般地系统IO响应时间应该低于5ms，如果大于10ms就比较大了。  <pre><code>这个时间包括了队列时间和服务时间，也就是说，一般情况下，await大于svctm，它们的差值越小，则说明队列时间越短，反之差值越大，队列时间越长，说明系统出了问题。  </code></pre></li><li>svctm    表示平均每次设备I/O操作的服务时间（以毫秒为单位）。如果svctm的值与await很接近，表示几乎没有I/O等待，磁盘性能很好，如果await的值远高于svctm的值，则表示I/O队列等待太长，         系统上运行的应用程序将变慢。<br>%util： 在统计时间内所有处理IO时间，除以总共统计时间。例如，如果统计间隔1秒，该设备有0.8秒在处理IO，而0.2秒闲置，那么该设备的%util = 0.8/1 = 80%，所以该参数暗示了设备的繁忙程度<br>。一般地，如果该参数是100%表示设备已经接近满负荷运行了（当然如果是多磁盘，即使%util是100%，因为磁盘的并发能力，所以磁盘使用未必就到了瓶颈）。</li></ul><h3 id="内存性能指标"><a href="#内存性能指标" class="headerlink" title="内存性能指标"></a>内存性能指标</h3><h3 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h3><h3 id="网络IO指标"><a href="#网络IO指标" class="headerlink" title="网络IO指标"></a>网络IO指标</h3><h4 id="系统评估指标"><a href="#系统评估指标" class="headerlink" title="系统评估指标"></a>系统评估指标</h4><table><thead><tr><th>性能因素</th><th>好</th><th>坏</th><th>糟糕  </th></tr></thead><tbody><tr><td>CPU</td><td>user% + sys% &lt; 70%</td><td>user% + sys% =85%</td><td>user% + sys% &gt;= 90%</td></tr><tr><td>内存</td><td>Swap In(si) = 0 Swap Out(so) = 0</td><td>Per CPU with 10 pages/s</td><td>More Swap In &amp; Swap Out</td></tr><tr><td>磁盘</td><td>iowait%&lt; 20%</td><td>iowat%=35%</td><td>iowat% &gt;= 50%</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Web服务在部署到Linux系统运行期间，可能会遇到各种问题。程序上的BUG，数据上的问题，这些排查起来较为简单。
      
    
    </summary>
    
      <category term="linux" scheme="http://www.lilhui.com/categories/linux/"/>
    
    
      <category term="性能优化" scheme="http://www.lilhui.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Linux自动删除N天日志</title>
    <link href="http://www.lilhui.com/2017/11/20/linux/linux_1/"/>
    <id>http://www.lilhui.com/2017/11/20/linux/linux_1/</id>
    <published>2017-11-20T02:38:07.000Z</published>
    <updated>2017-11-20T03:02:53.326Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>web在部署到linux环境后，一般都是把日志等级设置加高。只输出Error信息或者直接关闭Log。但是某些系统需要搜集容器的access日志来做数据分析。<br>如果本地存储的话，日子久了，日志就越来越大。占用大量磁盘资源，直接影响到系统的正常运行。所以，这种情况下，对日志做定期清理，是成本最低的方法了。</p></blockquote><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="删除文件脚本"><a href="#删除文件脚本" class="headerlink" title="删除文件脚本"></a>删除文件脚本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find 对应目录 -mtime +天数 -name &quot;文件名&quot; -exec rm -rf &#123;&#125; \;</div></pre></td></tr></table></figure><p>例如:删除3天前 /opt/logs下 search开头的日志。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find /opt/logs/ -mtime +3 -name &quot;search*.log&quot; exec rm -rf &#123;&#125; \;</div></pre></td></tr></table></figure></p><p>说明：<br>find：linux的查找命令，用户查找指定条件的文件<br>/opt/logs/：想要进行清理的任意目录；<br>-mtime：标准语句写法；<br>+3：查找30天前的文件，这里用数字代表天数；<br>“search*.log”：支持范式匹配<br>-exec：执行<br>rm -rf：强制删除命令<br>{} \; ：固定写法，一对大括号+空格++; </p><h4 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h4><p>将以上命令放置到可执行shell脚本中再通过cron调度执行。<br>创建shell:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">touch ~/bin/auto-del-30-days-ago-log.sh</div><div class="line">chmod +x auto-del-30-days-ago-log.sh</div></pre></td></tr></table></figure></p><p>编辑shell脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim auto-del-3-days-ago-log.sh</div></pre></td></tr></table></figure></p><p>内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line">find /opt/logs/ -mtime +3 -name &quot;search*.log&quot; exec rm -rf &#123;&#125; \;</div></pre></td></tr></table></figure></p><p>添加计划调度：<br>执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">10 0 * * * ~/auto-del-3-days-ago-log.sh &gt;/dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure></p><p>设置是每天凌晨0点10分执行auto-del-3-days-ago-log.sh文件进行数据清理任务了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>THE END.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;web在部署到linux环境后，一般都是把日志等级设置加高。只输出Error信息或者直接关闭Log。但是某些系统需
      
    
    </summary>
    
      <category term="linux" scheme="http://www.lilhui.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.lilhui.com/tags/linux/"/>
    
      <category term="系统维护" scheme="http://www.lilhui.com/tags/%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title>设计模式系列:桥接模式</title>
    <link href="http://www.lilhui.com/2017/11/09/java/patterndesign/patterndesign_10/"/>
    <id>http://www.lilhui.com/2017/11/09/java/patterndesign/patterndesign_10/</id>
    <published>2017-11-09T02:24:29.000Z</published>
    <updated>2018-01-17T10:22:41.632Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>类的继承是类本身的垂直维度变化。如果需要水平维度上的变化扩展。继承是不好实现的。这时候我们可以引入桥接方式。桥接模式的做法是把变化部分抽象<br>出来，使变化部分与主类分离开来，从而将多个维度的变化彻底分离。最后，提供一个管理类来组合不同维度上的变化，通过这种组合来满足业务的需要。</p></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1516184529562.png?imageView2/2/w/491/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p><p>Fruit:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.littlehui.design.bridge;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by littlehui on 2018/1/17.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>AbstractFruit:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.littlehui.design.bridge;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by littlehui on 2018/1/17.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFruit</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</div><div class="line"></div><div class="line">    EatHandler eatHandler;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractFruit</span><span class="params">(EatHandler eatHandler)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.eatHandler = eatHandler;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</div><div class="line">        eatHandler.handle();</div><div class="line">        System.out.println(<span class="string">"开始吃水果。"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Apple:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.littlehui.design.bridge;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by littlehui on 2018/1/17.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">AbstractFruit</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(EatHandler eatHandler)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(eatHandler);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enjoy</span><span class="params">()</span> </span>&#123;</div><div class="line">        eat();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>WaterMelon:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.littlehui.design.bridge;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by littlehui on 2018/1/17.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaterMelon</span> <span class="keyword">extends</span> <span class="title">AbstractFruit</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaterMelon</span><span class="params">(EatHandler eatHandler)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(eatHandler);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.eat();</div><div class="line">        System.out.println(<span class="string">"吃西瓜"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>EatHandler:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.littlehui.design.bridge;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by littlehui on 2018/1/17.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EatHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"吃水果前处理。"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>PeelHandler :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.littlehui.design.bridge;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by littlehui on 2018/1/17.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeelHandler</span> <span class="keyword">extends</span> <span class="title">EatHandler</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.handle();</div><div class="line">        System.out.println(<span class="string">"削皮"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>EatHandlerDivid:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.littlehui.design.bridge;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by littlehui on 2018/1/17.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EatHandlerDivid</span> <span class="keyword">extends</span> <span class="title">EatHandler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.handle();</div><div class="line">        System.out.println(<span class="string">"切块。"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.littlehui.design.bridge;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by littlehui on 2018/1/17.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        EatHandler eatHandler = <span class="keyword">new</span> PeelHandler();</div><div class="line">        EatHandler eatHandler1 = <span class="keyword">new</span> EatHandlerDivid();</div><div class="line">        Fruit apple = <span class="keyword">new</span> Apple(eatHandler);</div><div class="line">        Fruit waterMelon = <span class="keyword">new</span> WaterMelon(eatHandler1);</div><div class="line">        apple.eat();</div><div class="line">        waterMelon.eat();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如上代码解释：</p><ul><li>抽象部分 1：吃水果接口抽象，2.吃水果前处理抽象。</li><li>具体实现部分 : apple里的enjoy</li></ul><p>这里就分离了水果关于吃水果和水果处理的部分。Apple里的enjoy是具体的实现，可以eat，可以做其他操作。我们可以切换 水果处理 Handle来改变 Apple<br>enjoy具体时动作。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>略</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>桥接的重点是 将实现解耦，抽象和实现独立开，不影响对方。<br>桥接一般用于跨多个平台的图形和窗口系统上。当需要不同的方式改变借口和实现时，可以用桥接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;类的继承是类本身的垂直维度变化。如果需要水平维度上的变化扩展。继承是不好实现的。这时候我们可以引入桥接方式。桥接模
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="设计模式" scheme="http://www.lilhui.com/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.lilhui.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式系列：外观模式</title>
    <link href="http://www.lilhui.com/2017/11/09/java/patterndesign/patterndesign_9/"/>
    <id>http://www.lilhui.com/2017/11/09/java/patterndesign/patterndesign_9/</id>
    <published>2017-11-09T02:24:29.000Z</published>
    <updated>2018-01-17T10:26:51.859Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>外观模式用于简化系统中一个或者多个复杂的类。外观模式相当直接，容易理解。它提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个<br>高层接口，让子同更容易使用。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1516004360353.png?imageView2/2/w/322/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p></blockquote><ul><li>类图：</li></ul><p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1516184786908.png?imageView2/2/w/527/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p><p>MyOneDay:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.littlehui.design.facade;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by littlehui on 2018/1/16.</span></div><div class="line"><span class="comment"> * 我的一天</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyOneDay</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Morning morning;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Road road;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Back back;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Office office;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Rest rest;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyOneDay</span><span class="params">(Morning morning, Office office, Back back, Road road, Rest rest)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.morning = morning;</div><div class="line">        <span class="keyword">this</span>.office = office;</div><div class="line">        <span class="keyword">this</span>.back = back;</div><div class="line">        <span class="keyword">this</span>.road = road;</div><div class="line">        <span class="keyword">this</span>.rest = rest;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 在家起床</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morning</span><span class="params">()</span> </span>&#123;</div><div class="line">        morning.morningStepA();</div><div class="line">        morning.morningStepB();</div><div class="line">        morning.moringStepC();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 去公司</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goToOffice</span><span class="params">()</span> </span>&#123;</div><div class="line">        road.onLoadA();</div><div class="line">        road.onLoadB();</div><div class="line">        road.onLoadC();</div><div class="line">        road.onLoadE();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 工作，coding</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</div><div class="line">        office.officeA();</div><div class="line">        office.officeB();</div><div class="line">        office.officeC();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backToHome</span><span class="params">()</span> </span>&#123;</div><div class="line">        back.backStepA();</div><div class="line">        back.backStepB();</div><div class="line">        back.backStepC();</div><div class="line">        back.backStepD();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rest</span><span class="params">()</span> </span>&#123;</div><div class="line">        rest.restA();</div><div class="line">        rest.restB();</div><div class="line">        rest.restC();</div><div class="line">        rest.restD();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myWholeDay</span><span class="params">()</span> </span>&#123;</div><div class="line">        morning();</div><div class="line">        goToOffice();</div><div class="line">        work();</div><div class="line">        backToHome();</div><div class="line">        rest();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Morning:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.littlehui.design.facade;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by littlehui on 2018/1/16.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Morning</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morningStepA</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"起床刷牙洗脸"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morningStepB</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"吃早饭"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moringStepC</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"带上背包出门"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Office:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.littlehui.design.facade;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by littlehui on 2018/1/16.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Office</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">officeA</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"放下背包"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">officeB</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"去除电脑开机"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">officeC</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"打开IDEA 愉快地codeing"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Client:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.littlehui.design.facade;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by littlehui on 2018/1/16.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        MyOneDay myOneDay = <span class="keyword">new</span> MyOneDay(<span class="keyword">new</span> Morning(), <span class="keyword">new</span> Office(), <span class="keyword">new</span> Back(), <span class="keyword">new</span> Road(), <span class="keyword">new</span> Rest());</div><div class="line">        myOneDay.myWholeDay();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>以上其他类略：<br>详情github链接： <a href="https://github.com/littlehui/designpattern" target="_blank" rel="external">设计模式</a></p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>外观模式体现了设计模式中 最少知识原则。不让太多的类耦合在一起。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;外观模式用于简化系统中一个或者多个复杂的类。外观模式相当直接，容易理解。它提供了一个统一的接口，用来访问子系统中的
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="设计模式" scheme="http://www.lilhui.com/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.lilhui.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
