<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Littlehui&#39;s Notes</title>
  
  <subtitle>天地那么大，世界那么辽阔。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.lilhui.com/"/>
  <updated>2022-03-07T03:52:10.265Z</updated>
  <id>http://www.lilhui.com/</id>
  
  <author>
    <name>Littlehui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Dubbo源码系列6】Duboo 服务调用源码解析</title>
    <link href="http://www.lilhui.com/2022/03/03/java/dubbo/dubbo_6/"/>
    <id>http://www.lilhui.com/2022/03/03/java/dubbo/dubbo_6/</id>
    <published>2022-03-03T10:49:42.000Z</published>
    <updated>2022-03-07T03:52:10.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务消费端执行逻辑"><a href="#服务消费端执行逻辑" class="headerlink" title="服务消费端执行逻辑"></a>服务消费端执行逻辑</h2><ol><li>nvoker.invoke(new RpcInvocation(method, args))：Mock逻辑</li><li>AbstractClusterInvoker.invoke(invocation)：把RpcContext中设置的Attachments添加到invocation对象上，调用路由链从服务目录上筛选出适合的服务Invoker，获得服务均衡策略loadbalance</li><li>FailoverClusterInvoker.doInvoke(invocation, invokers, loadbalance)：根据负载均衡策略选出一个invoker，然后执行</li><li>InvokerWrapper.invoke(invocation)：没做什么事情</li><li>CallbackRegistrationInvoker.invoke(invocation)：开始执行Filter链，执行完得到结果后，会获取ListenableFilter中的listener，执行listener的onResponse方法</li><li>ConsumerContextFilter.invoke(invocation)：设置RpcContext中LocalAddress、RemoteAddress、RemoteApplicationName参数</li><li>FutureFilter.invoke(invocation)：</li><li>MonitorFilter.invoke(invocation)：方法的执行次数+1</li><li>ListenerInvokerWrapper.invoke(invocation)：没做什么事情</li><li>AsyncToSyncInvoker.invoke(invocation)：异步转同步，会先用下层Invoker去异步执行，然后阻塞Integer.MAX_VALUE时间，直到拿到了结果</li><li>AbstractInvoker.invoke(invocation)：主要调用DubboInvoker的doInvoke方法，如果doInvoker方法出现了异常，会进行包装，包装成AsyncRpcResult</li><li>DubboInvoker.doInvoke(invocation)：从clients轮询出一个client进行数据发送，如果配置了不关心结果，则调用ReferenceCountExchangeClient的send方法，否则调用ReferenceCountExchangeClient的request方法</li><li>ReferenceCountExchangeClient.request(Object request, int timeout)：没做什么事情</li><li>HeaderExchangeClient.request(Object request, int timeout)：没做什么事情</li><li>HeaderExchangeChannel.request(Object request, int timeout)：构造一个Request对象，并且会构造一个DefaultFuture对象来阻塞timeout的时间来等待结果，在构造DefaultFuture对象时，会把DefaultFuture对象和req的id存入FUTURES中，FUTURES是一个Map，当HeaderExchangeHandler接收到结果时，会从这个Map中根据id获取到DefaultFuture对象，然后返回Response。</li><li>AbstractPeer.send(Object message)：从url中获取send参数，默认为false</li><li>AbstractClient.send(Object message, boolean sent)：没做什么</li><li>NettyChannel.send(Object message, boolean sent)：调用NioSocketChannel的writeAndFlush发送数据，然后判断send如果是true，那么则阻塞url中指定的timeout时间，因为如果send是false，在HeaderExchangeChannel中会阻塞timeout时间</li><li>NioSocketChannel.writeAndFlush(Object msg)：最底层的Netty非阻塞式的发送数据</li></ol><h2 id="总结流程"><a href="#总结流程" class="headerlink" title="总结流程"></a>总结流程</h2><ol><li>最外层是Mock逻辑，调用前，调用后进行Mock</li><li>从服务目录中，根据当前调用的方法和路由链，筛选出部分服务Invoker（DubboInvoker）</li><li>对服务Invoker进行负载均衡，选出一个服务Invoker</li><li>执行Filter链</li><li>AsyncToSyncInvoker完成异步转同步，因为DubboInvoker的执行是异步非阻塞的，所以如果是同步调用，则会在此处阻塞，知道拿到响应结果</li><li>DubboInvoker开始异步非阻塞的调用</li><li>HeaderExchangeChannel中会阻塞timeout的时间来等待结果，该timeout就是用户在消费端所配置的timeout</li></ol><h2 id="服务提供端执行逻辑"><a href="#服务提供端执行逻辑" class="headerlink" title="服务提供端执行逻辑"></a>服务提供端执行逻辑</h2><ol><li>NettyServerHandler：接收数据</li><li>MultiMessageHandler：判断接收到的数据是否是MultiMessage，如果是则获取MultiMessage中的单个Message，传递给HeartbeatHandler进行处理</li><li>HeartbeatHandler：判断是不是心跳消息，如果是不是则把Message传递给AllChannelHandler</li><li>AllChannelHandler：把接收到的Message封装为一个ChannelEventRunnable对象，扔给线程池进行处理</li><li>ChannelEventRunnable：在ChannelEventRunnable的run方法中会调用DecodeHandler处理Message</li><li>DecodeHandler：按Dubbo协议的数据格式，解析当前请求的path，versio，方法，方法参数等等，然后把解析好了的请求交给HeaderExchangeHandler</li><li>HeaderExchangeHandler：处理Request数据，首先构造一个Response对象，然后调用ExchangeHandlerAdapter得到一个CompletionStage future，然后给future通过whenComplete绑定一个回调函数，当future执行完了之后，就可以从回调函数中得到ExchangeHandlerAdapter的执行结果，并把执行结果设置给Response对象，通过channel发送出去。</li><li>ExchangeHandlerAdapter：从本机已经导出的Exporter中根据当前Request所对应的服务key，去寻找Exporter对象，从Exporter中得到Invoker，然后执行invoke方法，此Invoker为ProtocolFilterWrapper$CallbackRegistrationInvoker</li><li>ProtocolFilterWrapper$CallbackRegistrationInvoker：负责执行过滤器链，并且在执行完了之后回调每个过滤器的onResponse或onError方法</li><li>EchoFilter：判断当前请求是不是一个回升测试，如果是，则不继续执行过滤器链了（服务实现者Invoker也不会调用了）</li><li>ClassLoaderFilter：设置当前线程的classloader为当前要执行的服务接口所对应的classloader</li><li>GenericFilter：把泛化调用发送过来的信息包装为RpcInvocation对象</li><li>ContextFilter：设置RpcContext.getContext()的参数</li><li>TraceFilter：先执行下一个invoker的invoke方法，调用成功后录调用信息</li><li>TimeoutFilter：调用时没有特别处理，只是记录了一下当前时间，当整个filter链都执行完了之后回调TimeoutFilter的onResponse方法时，会判断本次调用是否超过了timeout</li><li>MonitorFilter：记录当前服务的执行次数</li><li>ExceptionFilter：调用时没有特别处理，在回调onResponse方法时，对不同的异常进行处理，详解Dubbo的异常处理</li><li>DelegateProviderMetaDataInvoker：过滤器链结束，调用下一个Invoker</li><li>AbstractProxyInvoker：在服务导出时，根据服务接口，服务实现类对象生成的，它的invoke方法就会执行服务实现类对象的方法，得到结果</li></ol><h2 id="Dubbo的异常处理"><a href="#Dubbo的异常处理" class="headerlink" title="Dubbo的异常处理"></a>Dubbo的异常处理</h2><p>当服务消费者在调用一个服务时，服务提供者在执行服务逻辑时可能会出现异常，对于Dubbo来说，服务消费者需要在消费端抛出这个异常，那么这个功能是怎么做到的呢？<br>服务提供者在执行服务时，如果出现了异常，那么框架会把异常捕获，捕获异常的逻辑在AbstractProxyInvoker中，捕获到异常后，会把异常信息包装为正常的AppResponse对象，只是AppResponse的value属性没有值，exception属性有值。<br>此后，服务提供者会把这个AppResponse对象发送给服务消费端，服务消费端是在InvokerInvocationHandler中调用AppResponse的recreate方法重新得到一个结果，在recreate方法中会去失败AppResponse对象是否正常，也就是是否存在exception信息，如果存在，则直接throw这个exception，从而做到服务执行时出现的异常，在服务消费端抛出。<br>那么这里存在一个问题，如果服务提供者抛出的异常类，在服务消费者这边不存在，那么服务消费者也就抛不出这个异常了，那么dubbo是怎么处理的呢？<br>这里就涉及到了ExceptionFilter，它是服务提供者端的一个过滤器，它主要是在服务提供者执行完服务后会去识别异常：</p><ol><li>如果是需要开发人员捕获的异常，那么忽略，直接把这个异常返回给消费者</li><li>如果在当前所执行的方法签名上有声明，那么忽略，直接把这个异常返回给消费者</li><li>如果抛出的异常不需要开发人员捕获，或者方法上没有申明，那么服务端或记录一个error日志</li><li>异常类和接口类在同一jar包里，那么忽略，直接把这个异常返回给消费者</li><li>如果异常类是JDK自带的异常，那么忽略，直接把这个异常返回给消费者</li><li>如果异常类是Dubbo自带的异常，那么忽略，直接把这个异常返回给消费者</li><li>否则，把异常信息包装成RuntimeException，并覆盖AppResponse对象中的exception属性</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;服务消费端执行逻辑&quot;&gt;&lt;a href=&quot;#服务消费端执行逻辑&quot; class=&quot;headerlink&quot; title=&quot;服务消费端执行逻辑&quot;&gt;&lt;/a&gt;服务消费端执行逻辑&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;nvoker.invoke(new RpcInvocation(meth
      
    
    </summary>
    
      <category term="dubbo" scheme="http://www.lilhui.com/categories/dubbo/"/>
    
    
      <category term="服务调用" scheme="http://www.lilhui.com/tags/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Druid连接池 communications link failure问题</title>
    <link href="http://www.lilhui.com/2022/03/03/java/midware/druid_1/"/>
    <id>http://www.lilhui.com/2022/03/03/java/midware/druid_1/</id>
    <published>2022-03-03T01:46:31.000Z</published>
    <updated>2022-03-08T08:30:35.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>项目基于Spring boot 链接数据库用的Druid连接池1.1.16版。通过nginx代理连接数据库。数据库配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show VARIABLES like &apos;%timeout%&apos;</span><br><span class="line">        interactive_timeout 1000</span><br><span class="line">        wait_timeout 1000</span><br></pre></td></tr></table></figure></p><p>物理链接空闲1000秒后会进行回收。<br>druid连接池配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timeBetweenEvictionRunsMillis: 10000</span><br><span class="line">minEvictableIdleTimeMillis: 30000</span><br><span class="line">maxEvictableIdleTimeMillis: 84000</span><br></pre></td></tr></table></figure></p><p>每隔10秒回进行判断空闲时间大于30秒的，或者总存活时间大于84秒的，是否需要回收。按照道理不会有问题，但是执行后会发现druid后台的逻辑链接打开次数<br>大于逻辑链接关闭次数。两者之差，正好等于物理连接打开次数-物理链接关闭次数-1。（-1是因为配置的最小链接数量）。通过后台日志查看到会报</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Communications link failure\n\nThe last packet successfully received from the server was 3 milliseconds ago. The last packet sent successfully to the server was 4 milliseconds ago.; nested exception is com.mysql.cj.jdbc.exceptions.CommunicationsException: Communications link failure\n\nThe last packet successfully received from the server was 3 milliseconds ago. The last packet sent successfully to the server was 4 milliseconds ago.</span><br></pre></td></tr></table></figure><p>看着很难受，也影响使用。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>druid通过MySqlValidConnectionChecker类进行链接健康检查。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>   <span class="title">MySqlValidConnectionChecker</span></span>&#123;</span><br><span class="line">    <span class="comment">//其他方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configFromProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        String property = properties.getProperty(<span class="string">"druid.mysql.usePingMethod"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"true"</span>.equals(property)) &#123;</span><br><span class="line">            setUsePingMethod(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"false"</span>.equals(property)) &#123;</span><br><span class="line">            setUsePingMethod(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidConnection</span><span class="params">(Connection conn, String validateQuery, <span class="keyword">int</span> validationQueryTimeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (conn.isClosed()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (usePingMethod) &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn <span class="keyword">instanceof</span> DruidPooledConnection) &#123;</span><br><span class="line">                conn = ((DruidPooledConnection) conn).getConnection();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (conn <span class="keyword">instanceof</span> ConnectionProxy) &#123;</span><br><span class="line">                conn = ((ConnectionProxy) conn).getRawObject();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (clazz.isAssignableFrom(conn.getClass())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (validationQueryTimeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    validationQueryTimeout = DEFAULT_VALIDATION_QUERY_TIMEOUT;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ping.invoke(conn, <span class="keyword">true</span>, validationQueryTimeout * <span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                    Throwable cause = e.getCause();</span><br><span class="line">                    <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> SQLException) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> (SQLException) cause;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String query = validateQuery;</span><br><span class="line">        <span class="keyword">if</span> (validateQuery == <span class="keyword">null</span> || validateQuery.isEmpty()) &#123;</span><br><span class="line">            query = DEFAULT_VALIDATION_QUERY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="keyword">if</span> (validationQueryTimeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                stmt.setQueryTimeout(validationQueryTimeout);</span><br><span class="line">            &#125;</span><br><span class="line">            rs = stmt.executeQuery(query);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtils.close(rs);</span><br><span class="line">            JdbcUtils.close(stmt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查链接是否存活。默认是用的internalPing方法。这个方法会一直返回true 当达到mysql的wait_timeout后。数据库将物理链接关闭，druid端还认为可用。<br>这就有问题了。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>使用validationQuery进行检查。<br>配置方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 增加yml配置</span><br><span class="line">validationQuery: select &apos;x&apos;</span><br><span class="line">2.  启动时参数带上</span><br><span class="line">    -Ddruid.mysql.usePingMethod=false</span><br><span class="line">    或者在druid配置类上加入：</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void setProperties()&#123;</span><br><span class="line">        System.setProperty(&quot;druid.mysql.usePingMethod&quot;,&quot;false&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;项目基于Spring boot 链接数据库用的Druid连接池1.1.16版。通过nginx代理连接数据库。数据库配置&lt;br&gt;&lt;figure
      
    
    </summary>
    
      <category term="druid" scheme="http://www.lilhui.com/categories/druid/"/>
    
    
      <category term="druid" scheme="http://www.lilhui.com/tags/druid/"/>
    
  </entry>
  
  <entry>
    <title>【Dubbo源码系列5】Duboo 服务引入</title>
    <link href="http://www.lilhui.com/2022/02/18/java/dubbo/dubbo_5/"/>
    <id>http://www.lilhui.com/2022/02/18/java/dubbo/dubbo_5/</id>
    <published>2022-02-18T06:39:10.000Z</published>
    <updated>2022-03-07T03:57:02.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dubbo服务引入源码分析"><a href="#Dubbo服务引入源码分析" class="headerlink" title="Dubbo服务引入源码分析"></a>Dubbo服务引入源码分析</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li>服务引入原理解析</li><li>路由链源码解析</li><li>服务静态目录与动态目录源码解析</li><li>服务引入源码解析</li></ol><h3 id="服务引入原理"><a href="#服务引入原理" class="headerlink" title="服务引入原理"></a>服务引入原理</h3><p>当Spring启动过程中，会去给@Reference注解标注了的属性去进行赋值，赋值的对象为ReferenceBean中get()方法所返回的对象，这个对象是一个代理对象。<br>对于ReferenceBean，它表示应用想要引入的服务的信息，在执行get()时会做如下几步：</p><ol><li>调用checkAndUpdateSubConfigs()，检查和更新参数，和服务提供者类似，把ReferenceBean里的属性的值更新为优先级最高的参数值</li><li>调用init()去生成代理对象ref，get()方法会返回这个ref</li><li>在生成代理对象ref之前，先把消费者所引入服务设置的参数添加到一个map中，等会根据这个map中的参数去从注册中心查找服务</li><li>把消费者配置的所有注册中心获取出来<br>a. 如果只有一个注册中心，那么直接调用Protocol的refer(interfaceClass, urls.get(0));得到一个Invoker对象<br>b. 如果有多个注册中心，则遍历每个注册中心，分别调用Protocol的refer(interfaceClass, url);得到一个Invoker对象添加到invokers中，然后把invokers调用CLUSTER.join(new StaticDirectory(u, invokers));封装所有invokers得到一个invoker，</li><li>把最终得到的invoker对象调用PROXY_FACTORY.getProxy(invoker);得到一个代理对象，并返回，这个代理对象就是ref</li><li>总结：上文的Invoker对象，表示服务执行者，从注册中心refer下来的是一个服务执行者，合并invokers后得到的invoker也是一个服务执行者（抽象范围更大了）</li></ol><p>接下来，来看Protorol.refer(interfaceClass, url)方法是怎么生成一个Invoker的</p><ol><li>首先interfaceClass表示要引入的服务接口，url是注册中心的url（registry://），该url中有一个refer参数，参数值为当前所要引入服务的参数</li><li>调用doRefer(cluster, registry, type, url)</li><li>在doRefer方法中会生成一个RegistryDirectory</li><li>然后获取新版本中的路由器链，并添加到RegistryDirectory中去</li><li>RegistryDirectory监听几个目录（注意，完成监听器的订阅绑定后，会自动触发一次去获取这些目录上的当前数据）<br>a. 当前所引入的服务的动态配置目录：/dubbo/config/dubbo/org.apache.dubbo.demo.DemoService:1.1.1:g1.configurators<br>b. 当前所引入的服务的提供者目录：/dubbo/org.apache.dubbo.demo.DemoService/providers<br>c. 当前所引入的服务的老版本动态配置目录：/dubbo/org.apache.dubbo.demo.DemoService/configurators<br>d. 当前所引入的服务的老版本路由器目录：/dubbo/org.apache.dubbo.demo.DemoService/routers</li><li>调用cluster.join(directory)得到一个invoker</li><li>返回invoker（如果消费者引入了多个group中的服务，那么这里返回的是new MergeableClusterInvoker<t>(directory);，否则返回的是new FailoverClusterInvoker<t>(directory);）</t></t></li><li>但是，上面返回的两个Invoker都会被MockClusterInvoker包装，所以最终返回的是MockClusterInvoker。</li></ol><ol><li>获取服务提供者列表</li><li>Mock</li><li>路由 M–&gt;N</li><li>负载均衡 N—&gt;1</li><li>集群容错</li><li>构造NettyClient</li><li>发送数据</li></ol><h2 id="服务引入"><a href="#服务引入" class="headerlink" title="服务引入"></a>服务引入</h2><ol><li>构造Invoker</li><li>DemoService 服务目录。当前服务的提供者列表 List<invoker> 实际上是 List<dubboinvoker><ol><li>构造一个服务目录的时候要到注册中心查看</li><li>多少个提供者 List<invoker>就多少个 List<dubboinvoker></dubboinvoker></invoker></li><li>监听 当前服务对应的节点</li><li>路由 TagRouter–&gt;AppRouter–&gt;ServiceRouter<br>本质上是构造一个代理对象。代理对象最重要的是Invoker</li></ol></dubboinvoker></invoker></li></ol><p>代理对象逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">代理对象.a() &#123;</span><br><span class="line">    invoker.invoke(Invocation)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>代理对象<br>  Invoker invoker 有这个就行了。</li><li>Invoker<br>MockClusterInvoker.invoke()<br>  FailoverClusterInvoker.invoke()<pre><code>DubboInvoker.invoke()</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dubbo服务引入源码分析&quot;&gt;&lt;a href=&quot;#Dubbo服务引入源码分析&quot; class=&quot;headerlink&quot; title=&quot;Dubbo服务引入源码分析&quot;&gt;&lt;/a&gt;Dubbo服务引入源码分析&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; cla
      
    
    </summary>
    
      <category term="dubbo" scheme="http://www.lilhui.com/categories/dubbo/"/>
    
    
      <category term="服务引入" scheme="http://www.lilhui.com/tags/%E6%9C%8D%E5%8A%A1%E5%BC%95%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>【Dubbo源码系列4】Duboo 服务导出</title>
    <link href="http://www.lilhui.com/2022/02/18/java/dubbo/dubbo_4/"/>
    <id>http://www.lilhui.com/2022/02/18/java/dubbo/dubbo_4/</id>
    <published>2022-02-18T06:38:07.000Z</published>
    <updated>2022-03-03T08:54:59.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dubbo服务导出源码解析"><a href="#Dubbo服务导出源码解析" class="headerlink" title="Dubbo服务导出源码解析"></a>Dubbo服务导出源码解析</h2><p>服务导出流程 </p><ol><li>读取配置(端口，协议，loadbalance，注册中心)</li><li>启动netty,tomcat</li><li>服务注册 -&gt; 服务信息 -&gt; 注册中心</li><li>服务提供者，监听动态配置</li></ol><ol start="2"><li>服务注册<br>围绕URL + SPI</li></ol><p>export -&gt; doRegister<br>构造URL剔除冗余 信息，调用注册中心的接口保存到注册中心。</p><p>注册中心URL-&gt;服务URL-&gt;简化-&gt;注册</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dubbo服务导出源码解析&quot;&gt;&lt;a href=&quot;#Dubbo服务导出源码解析&quot; class=&quot;headerlink&quot; title=&quot;Dubbo服务导出源码解析&quot;&gt;&lt;/a&gt;Dubbo服务导出源码解析&lt;/h2&gt;&lt;p&gt;服务导出流程 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读取配置(
      
    
    </summary>
    
      <category term="dubbo" scheme="http://www.lilhui.com/categories/dubbo/"/>
    
    
      <category term="服务导出" scheme="http://www.lilhui.com/tags/%E6%9C%8D%E5%8A%A1%E5%AF%BC%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>【Dubbo源码系列3】Duboo 可扩展机制SPI源码解析</title>
    <link href="http://www.lilhui.com/2022/02/16/java/dubbo/dubbo_3/"/>
    <id>http://www.lilhui.com/2022/02/16/java/dubbo/dubbo_3/</id>
    <published>2022-02-16T06:12:39.000Z</published>
    <updated>2022-02-17T03:59:09.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dubbo-SPI架构图"><a href="#Dubbo-SPI架构图" class="headerlink" title="Dubbo SPI架构图"></a>Dubbo SPI架构图</h2><p><img src="http://images.lilhui.com/8920bd45bf8beedd17b1bab7339363cc" alt="图片"></p><ul><li>Demo获取Dubbo的protocol扩展点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExtensionLoader&lt;Protocol&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Protocol http = extensionLoader.getExtension(<span class="string">"dubbo"</span>);</span><br><span class="line">System.out.println(http);</span><br></pre></td></tr></table></figure><p>在ExtensionLoader类的内部有一个static的ConcurrentHashMap，用来缓存某个接口类型所对应的ExtensionLoader实例.</p><h2 id="ExtensionLoader"><a href="#ExtensionLoader" class="headerlink" title="ExtensionLoader"></a>ExtensionLoader</h2><p>ExtensionLoader表示某个接口的扩展点加载器，可以用来加载某个扩展点实例。<br>在ExtensionLoader中除开有上文的static的Map外，还有两个非常重要的属性：</p><ol><li>Class&lt;?&gt; type：表示当前ExtensionLoader实例是哪个接口的扩展点加载器</li><li>ExtensionFactory objectFactory：扩展点工厂（对象工厂），可以获得某个对象</li></ol><p>ExtensionLoader和ExtensionFactory的区别在于：</p><ol><li>ExtensionLoader最终所得到的对象是Dubbo SPI机制产生的</li><li>ExtensionFactory最终所得到的对象可能是Dubbo SPI机制所产生的，也可能是从Spring容器中所获得的对象</li></ol><p>在ExtensionLoader中有三个常用的方法：</p><ol><li>getExtension(“dubbo”)：表示获取名字为dubbo的扩展点实例</li><li>getAdaptiveExtension()：表示获取一个自适应的扩展点实例</li><li>getActivateExtension(URL url, String[] values, String group)：表示一个可以被url激活的扩展点实例，后文详细解释</li></ol><p>其中，什么是自适应扩展点实例？它其实就是当前这个接口的一个代理对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExtensionLoader&lt;Protocol&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Protocol protocol = extensionLoader.getExtension(<span class="string">"dubbo"</span>);</span><br></pre></td></tr></table></figure></p><p>当我们调用上述代码，我们会将得到一个DubboProtocol的实例对象，但在getExtension()方法中，Dubbo会对DubboProtocol对象进行依赖注入（也就是自动给属性赋值，属性的类型为一个接口，记为A接口），这个时候，对于Dubbo来说它并不知道该给这个属性赋什么值，换句话说，Dubbo并不知道在进行依赖注入时该找一个什么的的扩展点对象给这个属性，这时就会预先赋值一个A接口的自适应扩展点实例，也就是A接口的一个代理对象。</p><p>后续，在A接口的代理对象被真正用到时，才会结合URL信息找到真正的A接口对应的扩展点实例进行调用。</p><p><img src="http://images.lilhui.com/d917674e8a07d8f91ed5a9e4ebf49e04" alt="图片"></p><h3 id="getExtension-String-name-方法"><a href="#getExtension-String-name-方法" class="headerlink" title="getExtension(String name)方法"></a>getExtension(String name)方法</h3><p>在调用getExtension去获取一个扩展点实例后，会对实例进行缓存，下次再获取同样名字的扩展点实例时就会从缓存中拿了。</p><h3 id="createExtension-String-name-方法"><a href="#createExtension-String-name-方法" class="headerlink" title="createExtension(String name)方法"></a>createExtension(String name)方法</h3><p>在调用createExtension(String name)方法去创建一个扩展点实例时，要经过以下几个步骤：</p><ol><li>根据name找到对应的扩展点实现类</li><li>根据实现类生成一个实例，把实现类和对应生成的实例进行缓存</li><li>对生成出来的实例进行依赖注入（给实例的属性进行赋值）</li><li>对依赖注入后的实例进行AOP（Wrapper）,把当前接口类的所有的Wrapper全部一层一层包裹在实例对象上，没包裹个Wrapper后，也会对Wrapper对象进行依赖注入</li><li>返回最终的Wrapper对象</li></ol><p><img src="http://images.lilhui.com/265316c207746d158fcfe520beebd065" alt="图片"></p><h3 id="getExtensionClasses"><a href="#getExtensionClasses" class="headerlink" title="getExtensionClasses"></a>getExtensionClasses</h3><p>getExtensionClasses()是用来加载当前接口所有的扩展点实现类的，返回一个Map。之后可以从这个Map中按照指定的name获取对应的扩展点实现类。</p><p>当把当前接口的所有扩展点实现类都加载出来后也会进行缓存，下次需要加载时直接拿缓存中的。</p><p>Dubbo在加载一个接口的扩展点时，思路是这样的：</p><ol><li>根据接口的全限定名去META-INF/dubbo/internal/目录下寻找对应的文件，调用loadResource方法进行加载</li><li>根据接口的全限定名去META-INF/dubbo/目录下寻找对应的文件，调用loadResource方法进行加载</li><li>根据接口的全限定名去META-INF/services/目录下寻找对应的文件，调用loadResource方法进行加载</li></ol><p>这里其实会设计到老版本兼容的逻辑，不解释了。</p><h3 id="loadResource方法"><a href="#loadResource方法" class="headerlink" title="loadResource方法"></a>loadResource方法</h3><p>loadResource方法就是完成对文件内容的解析，按行进行解析，会解析出”=”两边的内容，”=”左边的内容就是扩展点的name，右边的内容就是扩展点实现类，并且会利用ExtensionLoader类的类加载器来加载扩展点实现类。</p><p>然后调用loadClass方法对name和扩展点实例进行详细的解析，并且最终把他们放到Map中去。</p><h3 id="loadClass方法"><a href="#loadClass方法" class="headerlink" title="loadClass方法"></a>loadClass方法</h3><p>loadClass方法会做如下几件事情：</p><ol><li>当前扩展点实现类上是否存在@Adaptive注解，如果存在则把该类认为是当前接口的默认自适应类（接口代理类），并把该类存到cachedAdaptiveClass属性上。</li><li>当前扩展点实现是否是一个当前接口的一个Wrapper类，如果判断的？就是看当前类中是否存在一个构造方法，该构造方法只有一个参数，参数类型为接口类型，如果存在这一的构造方法，那么这个类就是该接口的Wrapper类，如果是，则把该类添加到cachedWrapperClasses中去， cachedWrapperClasses是一个set。</li><li>如果不是自适应类，或者也不是Wrapper类，则判断是有存在name，如果没有name，则报错。</li><li>如果有多个name，则判断一下当前扩展点实现类上是否存在@Activate注解，如果存在，则把该类添加到cachedActivates中，cachedWrapperClasses是一个map。</li><li>最后，遍历多个name，把每个name和对应的实现类存到extensionClasses中去，extensionClasses就是上文所提到的map。</li></ol><p>至此，加载类就走完了。<br>回到createExtension(String name)方法中的逻辑，当前这个接口的所有扩展点实现类都扫描完了之后，就可以根据用户所指定的名字，找到对应的实现类了，然后进行实例化，然后进行IOC(依赖注入)和AOP。</p><h2 id="Dubbo中的IOC"><a href="#Dubbo中的IOC" class="headerlink" title="Dubbo中的IOC"></a>Dubbo中的IOC</h2><ol><li>根据当前实例的类，找到这个类中的setter方法，进行依赖注入</li><li>先分析出setter方法的参数类型pt</li><li>在截取出setter方法所对应的属性名property</li><li>调用objectFactory.getExtension(pt, property)得到一个对象，这里就会从Spring容器或通过DubboSpi机制得到一个对象，比较特殊的是，如果是通过DubboSpi机制得到的对象，是pt这个类型的一个自适应对象(代理对象)。</li><li>再反射调用setter方法进行注入</li></ol><h2 id="Dubbo中的AOP"><a href="#Dubbo中的AOP" class="headerlink" title="Dubbo中的AOP"></a>Dubbo中的AOP</h2><p>dubbo中也实现了一套非常简单的AOP，就是利用Wrapper，如果一个接口的扩展点中包含了多个Wrapper类，那么在实例化完某个扩展点后，就会利用这些Wrapper类对这个实例进行包裹，比如：现在有一个DubboProtocol的实例，同时对于Protocol这个接口还有很多的Wrapper，比如ProtocolFilterWrapper、ProtocolListenerWrapper，那么，当对DubboProtocol的实例完成了IOC之后，就会先调用new ProtocolFilterWrapper(DubboProtocol实例)生成一个新的Protocol的实例，再对此实例进行IOC，完了之后，会再调用new ProtocolListenerWrapper(ProtocolFilterWrapper实例)生成一个新的Protocol的实例，然后进行IOC，从而完成DubboProtocol实例的AOP。</p><h2 id="自适应扩展点补充"><a href="#自适应扩展点补充" class="headerlink" title="自适应扩展点补充"></a>自适应扩展点补充</h2><p>上面提到的自适应扩展点对象，也就是某个接口的代理对象是通过Dubbo内部生成代理类，然后生成代理对象的。</p><p>额外的，在Dubbo中还设计另外一种机制来生成自适应扩展点，这种机制就是可以通过@Adaptive注解来指定某个类为某个接口的代理类，如果指定了，Dubbo在生成自适应扩展点对象时实际上生成的就是@Adaptive注解所注解的类的实例对象。</p><p>如果是由Dubbo默认实现的，那么我们就看看Dubbo是如何生成代理类的。</p><h3 id="createAdaptiveExtensionClass方法"><a href="#createAdaptiveExtensionClass方法" class="headerlink" title="createAdaptiveExtensionClass方法"></a>createAdaptiveExtensionClass方法</h3><p>createAdaptiveExtensionClass方法就是Dubbo中默认生成Adaptive类实例的逻辑。说白了，这个实例就是当前这个接口的一个代理对象。比如下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExtensionLoader&lt;Protocol&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Protocol protocol = extensionLoader.getAdaptiveExtension();</span><br></pre></td></tr></table></figure><p>这个代码就是Protocol接口的一个代理对象，那么代理逻辑就是在new AdaptiveClassCodeGenerator(type, cachedDefaultName).generate()方法中。</p><ol><li>type就是接口</li><li>cacheDefaultName就是该接口默认的扩展点实现的名字</li></ol><p>看个例子，Protocol接口的Adaptive类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.rpc;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Protocol</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">rpc</span>.<span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span>  </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"The method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span>  </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"The method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Exporter <span class="title">export</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument == null"</span>);</span><br><span class="line"><span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument getUrl() == null"</span>);</span><br><span class="line"></span><br><span class="line">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line"></span><br><span class="line">        String extName = ( url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol() );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url ("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        </span><br><span class="line">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">extName</span>)</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> extension.export(arg0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Invoker <span class="title">refer</span><span class="params">(java.lang.Class arg0, org.apache.dubbo.common.URL arg1)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arg1 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line"></span><br><span class="line">        org.apache.dubbo.common.URL url = arg1;</span><br><span class="line"></span><br><span class="line">        String extName = ( url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol() );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url ("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line"></span><br><span class="line">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">extName</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> extension.refer(arg0, arg1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Protocol接口中有四个方法，但是只有export和refer两个方法进行代理。为什么？因为Protocol接口中在export方法和refer方法上加了@Adaptive注解。但是，不是只要在方法上加了@Adaptive注解就可以进行代理，还有其他条件，比如：</p><ol><li>该方法如果是无参的，那么则会报错</li><li>该方法有参数，可以有多个，并且其中某个参数类型是URL，那么则可以进行代理</li><li>该方法有参数，可以有多个，但是没有URL类型的参数，那么则不能进行代理</li><li>该方法有参数，可以有多个，没有URL类型的参数，但是如果这些参数类型，对应的类中存在getUrl方法（返回值类型为URL），那么也可以进行代理</li></ol><p>所以，可以发现，某个接口的Adaptive对象，在调用某个方法时，是通过该方法中的URL参数，通过调用ExtensionLoader.getExtensionLoader(com.luban.Car.class).getExtension(extName);得到一个扩展点实例，然后调用该实例对应的方法。</p><h3 id="Activate扩展点"><a href="#Activate扩展点" class="headerlink" title="Activate扩展点"></a>Activate扩展点</h3><p>上文说到，每个扩展点都有一个name，通过这个name可以获得该name对应的扩展点实例，但是有的场景下，希望一次性获得多个扩展点实例</p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight plain"><figcaption><span>extensionLoader </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">URL url = new URL(&quot;http://&quot;, &quot;localhost&quot;, 8080);</span><br><span class="line">url = url.addParameter(&quot;cache&quot;, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">List&lt;Filter&gt; activateExtensions = extensionLoader.getActivateExtension(url, </span><br><span class="line">                                                      new String[]&#123;&quot;validation&quot;&#125;,</span><br><span class="line">                                                      CommonConstants.CONSUMER);</span><br><span class="line">for (Filter activateExtension : activateExtensions) &#123;</span><br><span class="line">System.out.println(activateExtension);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会找到5个Filter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.apache.dubbo.rpc.filter.ConsumerContextFilter@<span class="number">4566e5</span>bd</span><br><span class="line">org.apache.dubbo.rpc.protocol.dubbo.filter.FutureFilter@<span class="number">1</span>ed4004b</span><br><span class="line">org.apache.dubbo.monitor.support.MonitorFilter<span class="meta">@ff</span>5b51f</span><br><span class="line">org.apache.dubbo.cache.filter.CacheFilter@<span class="number">25</span>bbe1b6</span><br><span class="line">org.apache.dubbo.validation.filter.ValidationFilter@<span class="number">5702</span>b3b1</span><br></pre></td></tr></table></figure><p>前三个是通过CommonConstants.CONSUMER找到的<br>CacheFilter是通过url中的参数找到的<br>ValidationFilter是通过指定的name找到的</p><p>在一个扩展点类上，可以添加@Activate注解，这个注解的属性有：</p><ol><li>String[] group()：表示这个扩展点是属于哪组的，这里组通常分为PROVIDER和CONSUMER，表示该扩展点能在服务提供者端，或者消费端使用</li><li>String[] value()：表示的是URL中的某个参数key，当利用getActivateExtension方法来寻找扩展点时，如果传入的url中包含的参数的所有key中，包括了当前扩展点中的value值，那么则表示当前url可以使用该扩展点</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dubbo-SPI架构图&quot;&gt;&lt;a href=&quot;#Dubbo-SPI架构图&quot; class=&quot;headerlink&quot; title=&quot;Dubbo SPI架构图&quot;&gt;&lt;/a&gt;Dubbo SPI架构图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://images.lilhui
      
    
    </summary>
    
      <category term="dubbo" scheme="http://www.lilhui.com/categories/dubbo/"/>
    
    
      <category term="SPI" scheme="http://www.lilhui.com/tags/SPI/"/>
    
  </entry>
  
  <entry>
    <title>shardingsphere简单源码解析</title>
    <link href="http://www.lilhui.com/2022/02/14/java/shardingsphere/shardingsphere_2/"/>
    <id>http://www.lilhui.com/2022/02/14/java/shardingsphere/shardingsphere_2/</id>
    <published>2022-02-14T07:41:01.000Z</published>
    <updated>2022-02-14T07:45:25.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>解析-&gt;路由-&gt;改写-&gt;执行-&gt;归并</p><ol><li>初始化过程</li></ol><p>ShardingDataSourceFactory.createDataSource</p><blockquote><p>ShardingRule 分片规则通过配置加载到内存中</p></blockquote><ol start="2"><li>SQL执行过程<br>(上下文)<br>ShardingStatement.executeQuery<blockquote><p>Statement   SqlRoute<br>statementEngine.route<br>StanndardRoutingEngine<br>SQLRewriteEngine<br>SQLRewriteEngine.generateSQL<br>SQLExecuteCallback.executeSQL //StatmentExecutor.executeQuery()多线程执行，同时执行多个sql</p></blockquote></li></ol><p>关键类<br>ShardingRouter.route</p><blockquote><p>ParsingSQLRouter.parse</p></blockquote><ul><li><p>SQL 语法解析<br>LexerEngine</p></li><li><p>SQL解析引擎<br>RoutingEngineFactory.</p></li><li><p>改写引擎<br>SQLRewritEngine</p></li></ul><p>比如 *** DESC limit 1,2<br>要改写成 limit 0,3<br>因为是倒序。直接用原来的limit可能会将需要到的结果截断。</p><ul><li><p>执行引擎<br>ShardingExecuteEngine</p></li><li><p>归并引擎<br>MergeEngine</p></li></ul><p>简单的 归并，获取limit x,y</p><p>优先队列。<br>每个分表获取的结果形成一个有序队列。然后用每个队列的第一个进行比较，每次需要就弹出一个。没有对其进行所有的合并。</p><p>clear 清空<br>sqlRoute(sql)<br>initStatementExecutor()</p><ul><li>读写分离<br>MasterSLave路由</li></ul><p>MasterSlaveRouter.route<br>-&gt; SQLJudgeEngine.judge</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;源码分析&quot;&gt;&lt;a href=&quot;#源码分析&quot; class=&quot;headerlink&quot; title=&quot;源码分析&quot;&gt;&lt;/a&gt;源码分析&lt;/h2&gt;&lt;p&gt;解析-&amp;gt;路由-&amp;gt;改写-&amp;gt;执行-&amp;gt;归并&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化过程&lt;/li&gt;
&lt;/ol&gt;
&lt;
      
    
    </summary>
    
      <category term="shardingsphere" scheme="http://www.lilhui.com/categories/shardingsphere/"/>
    
    
      <category term="分表" scheme="http://www.lilhui.com/tags/%E5%88%86%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>分库分表垂直详解与框架介绍</title>
    <link href="http://www.lilhui.com/2022/02/14/java/shardingsphere/shardingsphere_1/"/>
    <id>http://www.lilhui.com/2022/02/14/java/shardingsphere/shardingsphere_1/</id>
    <published>2022-02-14T07:40:12.000Z</published>
    <updated>2022-02-14T07:40:48.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是分库分表"><a href="#什么是分库分表" class="headerlink" title="什么是分库分表"></a>什么是分库分表</h1><p>性能瓶颈一般在数据库。</p><h1 id="为什么要分库分表"><a href="#为什么要分库分表" class="headerlink" title="为什么要分库分表"></a>为什么要分库分表</h1><p>增加性能。</p><h1 id="分库分表带来的问题"><a href="#分库分表带来的问题" class="headerlink" title="分库分表带来的问题"></a>分库分表带来的问题</h1><p>分库分表：<br>增加了维护成本<br>分布式事务问题<br>跨库join<br>分布式全局唯一ID</p><h1 id="分库分表算法"><a href="#分库分表算法" class="headerlink" title="分库分表算法"></a>分库分表算法</h1><p>取模  hash<br>解决数据热点问题，但是扩展麻烦<br>范围区分  range<br>解决扩展问题，仍然有数据热点问题。<br>预定义  固定编码<br>1 亿</p><h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><p>读多写少，分离主库的压力</p><h2 id="读写分离的问题"><a href="#读写分离的问题" class="headerlink" title="读写分离的问题"></a>读写分离的问题</h2><p>主从同步，数据一致性，网络延迟问题</p><p>强制路由：强制去访问master。下单的过程中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是分库分表&quot;&gt;&lt;a href=&quot;#什么是分库分表&quot; class=&quot;headerlink&quot; title=&quot;什么是分库分表&quot;&gt;&lt;/a&gt;什么是分库分表&lt;/h1&gt;&lt;p&gt;性能瓶颈一般在数据库。&lt;/p&gt;
&lt;h1 id=&quot;为什么要分库分表&quot;&gt;&lt;a href=&quot;#为什么要分库
      
    
    </summary>
    
      <category term="shardingsphere" scheme="http://www.lilhui.com/categories/shardingsphere/"/>
    
    
      <category term="分表" scheme="http://www.lilhui.com/tags/%E5%88%86%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>监控URL返回非200后执行重启脚本</title>
    <link href="http://www.lilhui.com/2022/02/11/tools/tools_1/"/>
    <id>http://www.lilhui.com/2022/02/11/tools/tools_1/</id>
    <published>2022-02-11T10:53:43.000Z</published>
    <updated>2022-02-11T10:56:21.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">TARGET_ADDR=$1</span><br><span class="line">TARGET_STATE=0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while true ;do</span><br><span class="line"></span><br><span class="line">    echo `date +"%Y-%m-%d %H:%M:%S"` start access $&#123;TARGET_ADDR&#125; &gt;&gt; statusMonitor.log</span><br><span class="line">    if [ $TARGET_STATE -gt 3 ];then</span><br><span class="line">        echo `date +"%Y-%m-%d %H:%M:%S"` can not  access $&#123;TARGET_ADDR&#125; ,service will reboot!</span><br><span class="line">        echo "&amp;&amp;&amp;&amp;&amp;&amp; reboot server!"</span><br><span class="line">        nohup ~/bin/restart.sh &gt;&gt; restart.log 2&gt;&amp;1 &amp;</span><br><span class="line">        sleep 360</span><br><span class="line">        let TARGET_STATE=0</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    HTTP_CODE=`curl -I -m 10 -o /dev/null -s -w %&#123;http_code&#125;"\n" $&#123;TARGET_ADDR&#125;`</span><br><span class="line">    if [ "$&#123;HTTP_CODE&#125;" != 200 ];then</span><br><span class="line">        echo `date +"%Y-%m-%d %H:%M:%S"` The $&#123;TARGET_STATE&#125; time  can not access</span><br><span class="line">        echo "****** Error:  Down!" &gt;&gt; statusMonitor.log</span><br><span class="line">        let TARGET_STATE=TARGET_STATE+1</span><br><span class="line">    else</span><br><span class="line">        echo "###### success" &gt;&gt; statusMonitor.log</span><br><span class="line">    fi</span><br><span class="line">    sleep 10</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./checkRunningStatus.sh www.lilhui.com &amp;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;脚本&quot;&gt;&lt;a href=&quot;#脚本&quot; class=&quot;headerlink&quot; title=&quot;脚本&quot;&gt;&lt;/a&gt;脚本&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="tools" scheme="http://www.lilhui.com/categories/tools/"/>
    
    
      <category term="shell" scheme="http://www.lilhui.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>【Java IO详解5】Netty实践2</title>
    <link href="http://www.lilhui.com/2022/02/10/java/io/netty_5/"/>
    <id>http://www.lilhui.com/2022/02/10/java/io/netty_5/</id>
    <published>2022-02-10T07:13:57.000Z</published>
    <updated>2022-02-14T07:37:47.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RPC实践"><a href="#RPC实践" class="headerlink" title="RPC实践"></a>RPC实践</h2><ul><li>http服务</li></ul><p>Netty实现了完整的http协议 HttpHandler只要在channelHandler初始化的时候设置就行。FullHttpServerHandler</p><ul><li>服务推送技术</li></ul><p>WebSocket</p><p><img src="http://images.lilhui.com/2e200872f8eac314980765e2adba30c0" alt="图片"></p><p>1：建立http请求<br>2：建立WebSocket握手</p><p>协议升级</p><p>子协议：STOMP<br>文本定向消息协议<br>生产者，消息代理，消费者。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RPC实践&quot;&gt;&lt;a href=&quot;#RPC实践&quot; class=&quot;headerlink&quot; title=&quot;RPC实践&quot;&gt;&lt;/a&gt;RPC实践&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;http服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Netty实现了完整的http协议 HttpHandler只要
      
    
    </summary>
    
      <category term="io" scheme="http://www.lilhui.com/categories/io/"/>
    
    
      <category term="netty" scheme="http://www.lilhui.com/tags/netty/"/>
    
      <category term="rpc" scheme="http://www.lilhui.com/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>【Java IO详解4】Netty实践</title>
    <link href="http://www.lilhui.com/2022/02/10/java/io/netty_4/"/>
    <id>http://www.lilhui.com/2022/02/10/java/io/netty_4/</id>
    <published>2022-02-10T07:10:32.000Z</published>
    <updated>2022-02-10T07:13:47.391Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ByteBuf回顾"><a href="#ByteBuf回顾" class="headerlink" title="ByteBuf回顾"></a>ByteBuf回顾</h2><p>ByteBuf</p><p>协议 nagle合并包<br>应用层  包大于套接字缓冲区<br>网络层 tcp分片 帧<br>路由器，硬件设备等等</p><ul><li><p>编码器</p></li><li><p>解码器</p></li></ul><p>netty基于ChannelInboudHandlerAdater和ChannelOutboudHanlderAdapter实现了一些编解码抽象类，我们在使用的过程中就只要关注编解码的业务实现。<br>MessageToMessageDecoder<i>：把某种对象解码成另外一种对象。泛型I对应的是第一个Message类型。<br>ByteToMessageDecoder：把ByteBuf解码成某一种对象。<br>MessageToMessageEncoder<i>：把某种对象编码成另一种对象。泛型I对应的是第一个Message类型。<br>MessageToByteEncoder<i>:把某对象编码成另一种对象。泛型I对应的是第一个Message类型。</i></i></i></p><h2 id="RPC框架实现"><a href="#RPC框架实现" class="headerlink" title="RPC框架实现"></a>RPC框架实现</h2><p><img src="http://images.lilhui.com/1c673683597bcd34f4636c8d569ca45b" alt="图片"></p><p>需要使用到的技术：<br>1、动态代理<br>通过java Proxy技术拿到代理对象，invocationHandler实现数据协议包装和通讯。<br>2、序列化、反序列化<br>3、网络通讯<br>基于netty的客户端和服务端进行通讯可以获得很好的IO性能<br>4、反射<br>根据客户端请求参数通过反射技术实现服务端对应实例的方法调用</p><p>使用netty实现客户端发送需要注意的点<br>通过Netty的channel调用写数据writeAndFlush 写的事件以及收到响应之后的channelRead事件都是会异步执行，所以需要注意线程协作的问题。可以使用countdowlacth来实现主线程等待channelread执行完之后才去获取收到的响应对象。</p><p><img src="http://images.lilhui.com/b6572ded990e4a9459d844d8d16bc69b" alt="图片"></p><p><img src="http://images.lilhui.com/4c692c1d48f22b4f25fe19af825c8702" alt="图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ByteBuf回顾&quot;&gt;&lt;a href=&quot;#ByteBuf回顾&quot; class=&quot;headerlink&quot; title=&quot;ByteBuf回顾&quot;&gt;&lt;/a&gt;ByteBuf回顾&lt;/h2&gt;&lt;p&gt;ByteBuf&lt;/p&gt;
&lt;p&gt;协议 nagle合并包&lt;br&gt;应用层  包大于套接字缓
      
    
    </summary>
    
      <category term="io" scheme="http://www.lilhui.com/categories/io/"/>
    
    
      <category term="netty" scheme="http://www.lilhui.com/tags/netty/"/>
    
      <category term="rpc" scheme="http://www.lilhui.com/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>【Java IO详解3】Netty进阶</title>
    <link href="http://www.lilhui.com/2022/02/10/java/io/netty_3/"/>
    <id>http://www.lilhui.com/2022/02/10/java/io/netty_3/</id>
    <published>2022-02-10T07:07:09.000Z</published>
    <updated>2022-02-10T07:12:20.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h2><ul><li>管件类和概念<br>Channel, ChannelHandler，ChannelHandlerContext<br>ChannelHandler的执行规则  INBound,OutBound<br>Pipline里的ChannelHandlerContext<br>OutBoundHandler也有read，是为了校验，因为OutBound是在前面。</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>outChannelHandler.write触发fireChannelRead的时候<br>inHandler会writeAndFlash,会触发outChannelHandler的 write形成死循环。<br>所以在OutHandler的write里不能fireChannelRead<br>会OverStackFlow</p><h2 id="Bytebuf"><a href="#Bytebuf" class="headerlink" title="Bytebuf"></a>Bytebuf</h2><p>Unpooled.xxx</p><ul><li>申请方式</li></ul><p>ByteBufAllocator heapBuffer() directBuffer()<br>compositeBuffer()</p><ul><li>两套索引</li></ul><p>readIndex和writeIndex</p><p>调用get<em> set</em>不会移动索引。调用read<em>, write</em>会移动相应的索引。<br>forEachByte 查找。</p><ul><li>派生缓冲区</li></ul><p>为Bytebuf提供了专门的方式来呈现其内容的试图。通过以下方法被创建：</p><p>dumplicate(), slice(), slice(int, int);</p><p>Unpooled.unmodifiableBuffer(…);<br>order(ByteOrder);<br>readSlice()</p><p>每个方法都返回一个新的ByteBuf实例，它具有自己的读索引、写索引和标记索引。<br>派生的缓冲区和原缓冲区的数据是共享的。</p><ul><li>引用计数</li></ul><p>release 计数减一。减到0后会进行回收。<br>减少GC。</p><p>池化的对象如果不释放，可能会引起内存溢出。</p><p>writeAndFlush会释放资源</p><p>SimpleChannelInboundHandler实现了 release。</p><ul><li>粘包，半包</li></ul><p><img src="http://images.lilhui.com/f6c05cc6032dad053d0a41f8811dc4c8" alt="图片"></p><p>假设客户端分别发送了两个数据包D1和D2给服务器，由于服务器一次读取的字节数是不确定的。所以可能会有以下4种情况。<br>从用户空间到内存空间。累计几个包后进行flash一起发送。</p><p>1：服务端分两次读取到两个独立的数据包，分别是D1和D2，没有粘包和拆包。<br>2：服务端一次接收到了两个数据包，D1和D2粘在一起，被称为TCP粘包。<br>3：服务端分两次读取到了两个数据包，第一次读取到了完整的D1和D2部分内容，第二次读取到了D2的剩余内容。这个叫做TCP拆包。<br>4：服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包剩余内容和D2包的完整包。<br>如果此时服务端TCP接收滑窗非常小，而数据D1和D2比较大，很有可能会发生第五种可能，既服务端分多次才能将D1和D2包接收完成。期间发生多次拆包。</p><ul><li>TCP粘包/半包发生的原因</li></ul><p><img src="http://images.lilhui.com/3487c1c6c200dbd7c746550f82911bbe" alt="图片"></p><p>TCP的Nagle算法，会合并小包，统一发送。如此，服务端无法区分哪些数据包是需要分开的，这就产生了粘包。</p><p>UDP：作为连接不可靠的传输协议。不会对数据包进行合并发送。没有Nogle算法。<br>UDP的包是 数据+UDP头+IP头一次封装，没有粘包。<br>分包产生的原因：</p><p>IP分片传输导致。传输过程丢失部分包。或者一个包被分成了多个，接收端顺序打乱了。<br>整理有几种情况：<br>1：数据大于套接字发送缓冲区。<br>2：进行MSS大小的TCP分段，MSS最大报文段长度的缩写。MSS是TCP报文段中数据段的最大长度。数据字段加上TCP首部才等于整个TCP报文段。所以MSS并不是TCP报文长度的最大长度。而是：MSS=TCP报文头长度-TCP首部长度。</p><p>1、两次请求，每个请求一个包<br>2、两次请求和成了一个包<br>3、第二个包被分成了两个包D2-2、D2-1 ，被分割的包D2-1的包有可能会跟D1合成一个包<br>4、第一个包分成了两个包，第二部分的包D1-2跟D2合成了一个包</p><ul><li>如何解决粘包半包问题</li></ul><p>1：包尾巴追加分隔符。 LineBasedFrameDecoder和DelimiterBasedFrameDecoder<br>2：消息定长。不够的补空格FixedLengthFrameDecoder<br>3：消息协议氛围消息头和消息体，消息头中包含标识消息总长度。通常设计思路为消息头的第一个字段使用int32来表示消息的总长度，LengthFieldBasedFrameDecoder。</p><ul><li>编解码<br>加密解密\序列化 反序列化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Reactor模型&quot;&gt;&lt;a href=&quot;#Reactor模型&quot; class=&quot;headerlink&quot; title=&quot;Reactor模型&quot;&gt;&lt;/a&gt;Reactor模型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;管件类和概念&lt;br&gt;Channel, ChannelHandler，Ch
      
    
    </summary>
    
      <category term="io" scheme="http://www.lilhui.com/categories/io/"/>
    
    
      <category term="netty" scheme="http://www.lilhui.com/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>【Java IO详解2】Netty初识</title>
    <link href="http://www.lilhui.com/2022/02/10/java/io/netty_2/"/>
    <id>http://www.lilhui.com/2022/02/10/java/io/netty_2/</id>
    <published>2022-02-10T07:05:19.000Z</published>
    <updated>2022-02-10T07:12:20.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>BIO, NIO, AIO<br>其中：  AIO中 linux在 内核绑定 CompleteChandle</p><h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><p>Reactor 模式，事件驱动实现方式</p><h3 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h3><ul><li>多线程<br>在selector加入了多线程支持。<br><img src="http://images.lilhui.com/5633cd5e1b23d8493684fe91229938dc" alt="图片"></li></ul><ul><li>主从</li></ul><p>selector加入到线程池</p><p><img src="http://images.lilhui.com/1a7d3c04ed76989cb06257a1e7424f8d" alt="图片"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ul><li>Bootstrap</li></ul><p>EventLoop   selector保持器<br>EventLoopGroup  Reactor主反应</p><p>结合实现多个selector</p><p><img src="http://images.lilhui.com/db1eea4b563ad1eab4a6df70ef9e9e58" alt="图片"></p><ul><li>Channel</li></ul><p>管道，充当用户空间与内核间的沟通</p><p><img src="http://images.lilhui.com/99f24ec74332fa18d9db568f50476f6a" alt="图片"></p><p>ChannelHandler</p><p><img src="http://images.lilhui.com/c21f2895d82cd0015a2eb35e4c129a37" alt="图片"></p><p>协作处理</p><p><img src="http://images.lilhui.com/f47ef15cbbeb00d3a7e12a79ca237363" alt="图片"></p><ul><li>ChannelHandlerContext</li></ul><p><img src="http://images.lilhui.com/3be250bdb608d37702227d534f4b0509" alt="图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IO模型&quot;&gt;&lt;a href=&quot;#IO模型&quot; class=&quot;headerlink&quot; title=&quot;IO模型&quot;&gt;&lt;/a&gt;IO模型&lt;/h2&gt;&lt;p&gt;BIO, NIO, AIO&lt;br&gt;其中：  AIO中 linux在 内核绑定 CompleteChandle&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="io" scheme="http://www.lilhui.com/categories/io/"/>
    
    
      <category term="netty" scheme="http://www.lilhui.com/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>【Java IO详解1】基础知识</title>
    <link href="http://www.lilhui.com/2022/02/10/java/io/netty_1/"/>
    <id>http://www.lilhui.com/2022/02/10/java/io/netty_1/</id>
    <published>2022-02-10T06:59:28.000Z</published>
    <updated>2022-02-11T03:54:19.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>TCP/IP</p><h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP UDP"></a>TCP UDP</h2><p>协议簇。</p><p>应用层，传输层，网络层，网络访问层。</p><p>TCP：面向连接的，需要两个端互相识别后才发送数据。</p><ul><li>TCP 在发送之前要先进行三次握手，建立链接。并把链接信息放在头部。<br>建立链接：<img src="http://images.lilhui.com/5d15d8dd5cf3f3fe6653910c30bf12ec" alt="图片"></li></ul><p>UDP：面向非链接的，单端发送。发送目的在UDP协议包里描述。</p><ul><li>UDP不理会接收端是否接收到，一股脑的发送。是不可靠的</li><li><p>报文头很小，比较高效</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3></li><li><p>建立链接的三次握手</p><p>A:你好  能通吗<br>B:收到  可以建立链接<br>A:建立连接成功</p></li><li><p>消除链接的四次握手</p><p>A:你好我要关闭了<br>B:确认可以关闭<br>B:我先关闭<br>A:我也关闭</p></li></ul><p>应用程序获取数据</p><ul><li><p>用户空间</p><p>socket</p></li><li><p>内核空间</p><p>网卡，驱动等</p></li></ul><p>文件描述<br>数据准备，数据拷贝</p><ul><li>阻塞IO</li></ul><p><img src="http://images.lilhui.com/3e005c673a86f5b7983a62a7562c90cc" alt="图片"></p><ul><li>非阻塞IO</li></ul><p><img src="http://images.lilhui.com/85667f9f740e4bdb67a050039ad1875b" alt="图片"></p><ul><li>IO多路复用</li></ul><p><img src="http://images.lilhui.com/d79874a36ba820681cf04084b6dc6c97" alt="图片"></p><p>· 零拷贝<br>epoll使用了 零拷贝<br>内核-用户epoll  共享部分空间。</p><ul><li>信号驱动</li></ul><p><img src="http://images.lilhui.com/b9bb1fee4aff4ff95e680bd598318c88" alt="图片"></p><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p><img src="http://images.lilhui.com/e9d187264391cc2d1c212e8955808376" alt="图片"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://images.lilhui.com/55b9ca8e0a7b629d86135ae0822a0e6f" alt="图片"></p><h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><p><img src="http://images.lilhui.com/dfbb129b19e3287b76360cb3174aaddd" alt="图片"></p><p>Buffer</p><p>flip</p><p>position</p><p>capacity</p><p>limit</p><p><img src="http://images.lilhui.com/59fd0c402c8bf0778ecdc89ab5e81bc1" alt="图片"></p><p>为什么要用读写翻转 flip<br>sc.read(buffer)<br>buffer.flip<br>socket从内核空间拷贝到用户空间，其实是对用户空间的写。</p><ul><li>AIO</li></ul><p>Linux 上多路复用实现的AIO。</p><p>所以netty 是基于NIO实现的</p><p>用户空间还是需要同步阻塞以获取内核的发送的消息。<br>在内核到用户控件的时候通过事件的方式进行通知，达到异步状态。</p><h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><ol><li>api复杂</li><li>多线程开发复杂</li><li>半包 粘包</li><li>心跳，网络中断，网络堵塞</li><li>nio bug空轮询<br>epoll 水平 触发  一次IO中没有读完，等到下次信号来时候才能读。信号驱动<br>边缘 触发  尽可能多的读取IO</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TCP-IP&quot;&gt;&lt;a href=&quot;#TCP-IP&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP&quot;&gt;&lt;/a&gt;TCP/IP&lt;/h2&gt;&lt;p&gt;TCP/IP&lt;/p&gt;
&lt;h2 id=&quot;TCP-UDP&quot;&gt;&lt;a href=&quot;#TCP-UDP&quot; class=&quot;
      
    
    </summary>
    
      <category term="io" scheme="http://www.lilhui.com/categories/io/"/>
    
    
      <category term="tcp" scheme="http://www.lilhui.com/tags/tcp/"/>
    
      <category term="udp" scheme="http://www.lilhui.com/tags/udp/"/>
    
  </entry>
  
  <entry>
    <title>【Dubbo源码系列2】基础应用和高级应用</title>
    <link href="http://www.lilhui.com/2022/02/10/java/dubbo/dubbo_2/"/>
    <id>http://www.lilhui.com/2022/02/10/java/dubbo/dubbo_2/</id>
    <published>2022-02-10T06:23:58.000Z</published>
    <updated>2022-02-14T07:37:04.423Z</updated>
    
    <content type="html"><![CDATA[<h3 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h3><p>提供诸如：<br><a href="http://ip:port/servicerName+group+version" target="_blank" rel="noopener">http://ip:port/servicerName+group+version</a><br>dubbo://ip:port/serviceName+group+version  </p><p>作为唯一识别码的不同服务。<br>Dubbo使用可以指定 协议，IP，端口</p><ul><li>负载均衡，集群容错，服务降级</li><li>本地存根，本地伪装，参数回调</li><li>异步调用，泛化调用，动态配置</li><li>管理台，动态配置，服务路由</li></ul><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><ul><li>Random LoadBalance<br>随机</li><li>RoundRobin LoadBalance<br>轮询</li><li>LastActiveLoadBalance<br>最少活跃</li><li>ConsistentHash LoadBalance<br>一致性hash</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;服务提供者&quot;&gt;&lt;a href=&quot;#服务提供者&quot; class=&quot;headerlink&quot; title=&quot;服务提供者&quot;&gt;&lt;/a&gt;服务提供者&lt;/h3&gt;&lt;p&gt;提供诸如：&lt;br&gt;&lt;a href=&quot;http://ip:port/servicerName+group+versio
      
    
    </summary>
    
      <category term="dubbo" scheme="http://www.lilhui.com/categories/dubbo/"/>
    
    
      <category term="泛化调用" scheme="http://www.lilhui.com/tags/%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>【分库分表1】分布式主键1</title>
    <link href="http://www.lilhui.com/2022/01/15/java/distributed/distributed_3/"/>
    <id>http://www.lilhui.com/2022/01/15/java/distributed/distributed_3/</id>
    <published>2022-01-15T03:00:57.000Z</published>
    <updated>2022-02-14T07:45:56.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>ShardingSphere</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分库分表&quot;&gt;&lt;a href=&quot;#分库分表&quot; class=&quot;headerlink&quot; title=&quot;分库分表&quot;&gt;&lt;/a&gt;分库分表&lt;/h2&gt;&lt;p&gt;ShardingSphere&lt;/p&gt;

      
    
    </summary>
    
      <category term="电商" scheme="http://www.lilhui.com/categories/%E7%94%B5%E5%95%86/"/>
    
      <category term="微服务" scheme="http://www.lilhui.com/categories/%E7%94%B5%E5%95%86/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="亿级流量" scheme="http://www.lilhui.com/tags/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F/"/>
    
      <category term="分库分表" scheme="http://www.lilhui.com/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【Dubbo源码系列1】框架介绍</title>
    <link href="http://www.lilhui.com/2022/01/14/java/dubbo/dubbo_1/"/>
    <id>http://www.lilhui.com/2022/01/14/java/dubbo/dubbo_1/</id>
    <published>2022-01-14T06:05:57.000Z</published>
    <updated>2022-02-10T06:23:00.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dubbo框架介绍"><a href="#Dubbo框架介绍" class="headerlink" title="Dubbo框架介绍"></a>Dubbo框架介绍</h2><ol><li>方法名</li><li>参数类型列表</li><li>入参</li><li>类</li><li>version</li></ol><p>RPC：通信协议，数据传输上层的一种协议。用于完成远程方法调用。</p><p>RPC over http协议传输<br>RPC over tcp传输</p><ul><li>消费端：</li></ul><ol><li>组织协议</li><li>序列化</li><li>调用netty传输</li></ol><ul><li>服务端：</li></ul><ol><li>接收并反序列化</li><li>invoke调用实现方法</li><li>获取结果，组织协议，序列化</li><li>调用netty传输</li></ol><p><img src="http://images.lilhui.com/b1834ce26273be087e101a81b7d5ec4d" alt="图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dubbo框架介绍&quot;&gt;&lt;a href=&quot;#Dubbo框架介绍&quot; class=&quot;headerlink&quot; title=&quot;Dubbo框架介绍&quot;&gt;&lt;/a&gt;Dubbo框架介绍&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;方法名&lt;/li&gt;
&lt;li&gt;参数类型列表&lt;/li&gt;
&lt;li&gt;入参&lt;/li&gt;
      
    
    </summary>
    
      <category term="dubbo" scheme="http://www.lilhui.com/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="http://www.lilhui.com/tags/dubbo/"/>
    
      <category term="SPI" scheme="http://www.lilhui.com/tags/SPI/"/>
    
  </entry>
  
  <entry>
    <title>【分布式事务问题】TCC模式常见问题以及解决</title>
    <link href="http://www.lilhui.com/2021/12/03/java/distributed/distributed_2/"/>
    <id>http://www.lilhui.com/2021/12/03/java/distributed/distributed_2/</id>
    <published>2021-12-03T03:13:20.000Z</published>
    <updated>2022-02-10T06:16:25.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCC的异常场景"><a href="#TCC的异常场景" class="headerlink" title="TCC的异常场景"></a>TCC的异常场景</h2><p>在分布式系统中，随时随地都需要面对网络超时，网络重发和服务器宕机等问题。所以分布式事务框架作为搭载在分布式系统之上的一个框架型应用也绕不开这些问题。具体而言，有以下常见问题：</p><ol><li>幂等处理</li><li>空回滚</li><li>资源悬挂</li></ol><p>这些异常的应对需要TCC框架的支持和解决方案。</p><h2 id="幂等处理"><a href="#幂等处理" class="headerlink" title="幂等处理"></a>幂等处理</h2><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>因为网络抖动等原因，分布式事务框架可能会<strong>重复调用同一个分布式事务中的一个分支事务的二阶段接口</strong>。所以分支事务的二阶段接口Confirm/Cancel需要能够保证幂等性。如果二阶段接口不能保证幂等性，则会产生严重的问题，造成资源的重复使用或者重复释放，进而导致业务故障。（多次执行cancel confirm   重试操作）</p><p><img src="http://images.lilhui.com/010edd2e9bfc776ea7ff279c73ad3720" alt="图片"></p><p>从上图中红色部分可以看到：如果当TC调用参与者的二阶段方法时，发生了异常(TC本身异常或者网络异常丢失结果)。此时TC无法感知到调用的结果。为了保证分布式事务能够走到终态，此时TC会按照一定的规则重复调用参与者的二阶段方法。</p><h3 id="应对策略"><a href="#应对策略" class="headerlink" title="应对策略"></a>应对策略</h3><p>对于幂等类型的问题，通常的手段是引入幂等字段进行防重放攻击。对于分布式事务框架中的幂等问题，同样可以祭出这一利器。我们可以通过增加一张<strong>事务状态控制表</strong>来实现，这个表的关键字段有以下几个：</p><ol><li>主事务ID</li><li>分支事务ID</li><li>分支事务状态</li></ol><p>其中1和2构成表的联合主键来唯一标识一笔分布式事务中的一条分支事务。3用来标识该分支事务的状态，一共有3种状态：<br>INIT(I) - 初始化<br>CONFIRMED© - 已提交<br>ROLLBACKED® - 已回滚  </p><p>幂等记录的插入时机是参与者的Try方法，此时的分支事务状态会被初始化为INIT。然后当二阶段的Confirm/Cancel执行时会将其状态置为CONFIRMED/ROLLBACKED。</p><p>当TC重复调用二阶段接口时，参与者会先获取事务状态控制表的对应记录查看其事务状态。如果状态已经为CONFIRMED/ROLLBACKED，那么表示参与者已经处理完其分内之事，不需要再次执行，可以直接返回幂等成功的结果给TC，帮助其推进分布式事务。增加了幂等记录的写入和读取判断后，时序图如下(蓝色部分)：</p><p><img src="http://images.lilhui.com/c77b3d00cd350f897ccac0d16dc47974" alt="图片"></p><h2 id="空回滚"><a href="#空回滚" class="headerlink" title="空回滚"></a>空回滚</h2><h3 id="产生原因-1"><a href="#产生原因-1" class="headerlink" title="产生原因"></a>产生原因</h3><p>先来说定义，当没有调用参与方Try方法的情况下，就调用了二阶段的Cancel方法，Cancel方法需要有办法识别出此时Try有没有执行。如果Try还没执行，表示这个Cancel操作是无效的，即本次Cancel属于空回滚；如果Try已经执行，那么执行的是正常的回滚逻辑。</p><p><img src="http://images.lilhui.com/df780906ab4661d139ee0b75dab41057" alt="图片"></p><p>如上图所示，红色部分的一阶段Try可能失败。</p><p>首先发起方在调用参与者之前，会向TC申请开始一笔分布式事务。然后发起方调用参与者的一阶段方法，在调用实际发生之前，一般会有切面拦截器感知到此次Try调用，然后写入一条分支事务记录。紧接着，在实际调用参与者的Try方法时发生了异常。异常原因可以是发起方宕机，网络抖动等。</p><p>总而言之，就是Try方法没有执行成功，然而此时这笔分布式事务和分支事务已经落库。有两种情况会触发分布式事务的回滚：</p><ol><li>发起方认为当前分布式事务无法成功，主动通知TC回滚</li><li>TC发现分布式事务超时，被动触发回滚</li></ol><p>触发回滚操作后，TC会对该分布式事务关联的分支事务调用其二阶段Cancel。在执行Cancel时，Try还未执行成功，触发空回滚。如果不对空回滚加以防范的话，可能会造成资源的无效释放。即在没有预留资源的情况下就释放资源，造成故障。</p><h3 id="应对策略-1"><a href="#应对策略-1" class="headerlink" title="应对策略"></a>应对策略</h3><p>可以发现，要应对空回滚的问题，就需要让参与者在二阶段的Cancel方法中有办法识别到一阶段的Try是否已经执行。<br>很显然，可以继续利用<strong>事务状态控制</strong>表来实现这个功能。</p><p>前面提到过为了保证幂等性，当Try方法被成功执行后，会插入一条记录，标识该分支事务处于INIT状态。所以后续当二阶段的Cancel方法被调用时，可以通过查询控制表的对应记录进行判断。如果记录存在且状态为INIT，就表示一阶段已成功执行，可以正常执行回滚操作，释放预留的资源；如果记录不存在则表示一阶段未执行，本次为空回滚，不释放任何资源。</p><p>时序图如下所示：</p><p><img src="http://images.lilhui.com/5cdd703d498a93fb68ad70771ab9d439" alt="图片"></p><h2 id="资源悬挂（try-cancel-–try-循环执行，cancel在try之前）"><a href="#资源悬挂（try-cancel-–try-循环执行，cancel在try之前）" class="headerlink" title="资源悬挂（try - cancel –try  循环执行，cancel在try之前）"></a>资源悬挂（try - cancel –try  循环执行，cancel在try之前）</h2><h3 id="产生原因-2"><a href="#产生原因-2" class="headerlink" title="产生原因"></a>产生原因</h3><p>悬挂，顾名思义，是有一些资源被悬挂起来后续无法处理了。那么什么场景下才会出现这种现象呢？</p><p>上一节中提到过空回滚，指的是当一阶段Try未执行成功，而二阶段Cancel就因TC回滚整个分布式事务而被调用。</p><p>但是考虑一种极端情况，当分布式事务到终态后，参与者的一阶段Try才被执行，此时参与者会根据业务需求预留相关资源。预留资源只有当前事务才能使用，然而此时分布式事务已经走到终态，后续再没有任何手段能够处理这些预留资源。至此，就形成了资源悬挂。</p><p>这种一阶段比二阶段执行的还晚的情况看似不可能，但是仔细考虑RPC调用的时序，其实这种情况在复杂多变的网络中是完全可能的，下面的时序展示了这种可能性：</p><ol><li>发起方通过RPC调用参与者一阶段Try，但是发生网络阻塞导致RPC超时</li><li>RPC超时后，TC会回滚分布式事务(可能是发起方主动通知TC回滚或者是TC发现事务超时后回滚)，调用已注册的各个参与方的二阶段Cancel</li><li>参与方空回滚后，发起方对参与者的一阶段Try才开始执行，进行资源预留从而形成悬挂</li></ol><p>使用时序图来描述，红色部分为产生资源悬挂的关键步骤：</p><p><img src="http://images.lilhui.com/2c269f2d9a233c752b935b3ce59f6d5e" alt="图片"></p><h3 id="应对策略-2"><a href="#应对策略-2" class="headerlink" title="应对策略"></a>应对策略</h3><p>资源悬挂的本质原因在于，一阶段和二阶段的执行顺序没有被严格地保证。所以相应的解决方案还是通过读取事务状态控制表的事务状态。</p><p>前面在幂等方案的讨论中说过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">幂等记录的插入时机是参与者的Try方法，此时的分支事务状态会被初始化为INIT。然后当二阶段的Confirm/Cancel执行时会将其状态置为CONFIRMED/ROLLBACKED。</span><br></pre></td></tr></table></figure><p>由于悬挂的产生背景是一阶段方法根本就未执行，所以此时事务控制记录是不存在的，需要在二阶段中处理ROLLBACK的情况(因为超时后触发回滚不可能存在二阶段为CONFIRM)。</p><p>处理方案为在判断为空回滚的场景下(体现在对应一阶段事务控制记录不存在)，插入一条状态为ROLLBACKED的控制记录。</p><p>那么下次当一阶段Try抵达执行的时候，首先会尝试插入状态为INIT的事务控制记录。如果插入失败，表示当前分支事务的记录已经存在，Try无需继续执行。有几种可能性会导致此情形：</p><ol><li>一阶段Try重复请求，网络抖动情况可能发生，可以理解为命中幂等</li><li>二阶段插入了防悬挂记录，一阶段不可继续执行</li></ol><p>时序图描述如下，蓝色部分为防止资源悬挂增加的检查项：</p><p><img src="http://images.lilhui.com/200bc9ff36e970c062980826f14a6550" alt="图片"></p><h2 id="三种异常总结"><a href="#三种异常总结" class="headerlink" title="三种异常总结"></a>三种异常总结</h2><p>前面讨论了分布式事务三种典型的异常类型，它们的解决方案都依赖于一张<strong>事务状态控制表</strong>。我们来尝试总结一下它们各自的特点。</p><h3 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h3><p><strong>问题</strong>:TC重复调用二阶段<br><strong>解决</strong>:事务状态控制记录作为控制手段，只有存在INIT记录时蔡执行，存在CONFIRMED/ROLLBACKED记录时不再执行</p><h3 id="空回滚-1"><a href="#空回滚-1" class="headerlink" title="空回滚"></a>空回滚</h3><p><strong>问题</strong>：TC回滚事务调用二阶段，但一阶段尚未执行<br><strong>解决</strong>：事务状态控制记录作为控制手段，无记录时即为空回滚</p><h3 id="资源悬挂"><a href="#资源悬挂" class="headerlink" title="资源悬挂"></a>资源悬挂</h3><p><strong>问题</strong>：TC回滚事务调用二阶段完成空回滚后，一阶段执行成功<br><strong>解决</strong>：事务状态控制记录作为控制手段，二阶段发现无记录时插入记录，一阶段执行时检查记录是否存在</p><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><ol><li>核心的解决方案就是事务状态控制表  </li><li>幂等控制作为最基础的异常处理手段；资源悬挂的前置条件是空回滚，所以发生空回滚时会插入一条状态为ROLLBACKED的控制记录</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TCC的异常场景&quot;&gt;&lt;a href=&quot;#TCC的异常场景&quot; class=&quot;headerlink&quot; title=&quot;TCC的异常场景&quot;&gt;&lt;/a&gt;TCC的异常场景&lt;/h2&gt;&lt;p&gt;在分布式系统中，随时随地都需要面对网络超时，网络重发和服务器宕机等问题。所以分布式事务框架作
      
    
    </summary>
    
      <category term="电商" scheme="http://www.lilhui.com/categories/%E7%94%B5%E5%95%86/"/>
    
      <category term="微服务" scheme="http://www.lilhui.com/categories/%E7%94%B5%E5%95%86/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="分布式事务" scheme="http://www.lilhui.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="亿级流量" scheme="http://www.lilhui.com/tags/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F/"/>
    
      <category term="TCC" scheme="http://www.lilhui.com/tags/TCC/"/>
    
  </entry>
  
  <entry>
    <title>【微服务电商平台关键技术1】分布式事务</title>
    <link href="http://www.lilhui.com/2021/12/02/java/distributed/distributed_1/"/>
    <id>http://www.lilhui.com/2021/12/02/java/distributed/distributed_1/</id>
    <published>2021-12-02T03:43:08.000Z</published>
    <updated>2022-02-10T06:12:44.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见的分布式事务方案"><a href="#常见的分布式事务方案" class="headerlink" title="常见的分布式事务方案"></a>常见的分布式事务方案</h2><p><img src="http://images.lilhui.com/aff38186038103177cb12abc59492773" alt="图片"></p><h3 id="2PC-两阶段提交"><a href="#2PC-两阶段提交" class="headerlink" title="2PC 两阶段提交"></a>2PC 两阶段提交</h3><p><strong>角色定义：</strong></p><p>TM：TransactionManager协调者<br>RM：RresourceManager参与者</p><p>从字面上理解两阶段提交分两个阶段提交的事务。</p><p><strong>阶段一：</strong><br>TM通知RM准备提交他们的事务分支，如果RM判断自己进行的工作可以被提交，就对工作内容进行持久化<br>再回复TM,否则异常。<br>Mysql是这样做的：事务管理器向所有涉及到的数据库发出prepare 准备提交请求，数据库收到请求后<br>执行修改和日志记录处理，处理完后把事务的状态标记成 可以提交，然后返回结果。</p><p><strong>阶段二：</strong><br>TM根据阶段一各个RM prepare的结果，决定提交还是回滚操作。所有的prepare都成功，就提交。如果有prepare失败的<br>则TM通知所有RM回滚自己的事务。<br>Mysql是这样做的：第一阶段提交的prepare成功，那么事务管理器向数据库服务器发出 确认提交 请求，数据库服务器把事务<br>的状态改成 提交完成 状态，然后返回。如果第一阶段内有任何一个数据库操作发生了错误，或者事务管理器收不到某个数据库的<br>响应，则认为事务失败，回滚所有的事务，数据库服务器收不到第二阶段的确认提交，也会把  可以提交的事务 回滚。</p><p><img src="http://images.lilhui.com/926fc561b6ea8c0c8e5304b7281c5596" alt="图片"></p><p><strong>二阶段提交存在的问题：</strong></p><ul><li>同步阻塞</li></ul><p>各个事务的ACID保证了全局的ACID所以需要用到串行化,<br>SERIALZABLE隔离级别。效率低。可重复度隔离级别无法保障分布式事务一致性。</p><ul><li>单点故障</li></ul><p>协调者TM有单点故障问题。</p><ul><li>数据不一致</li></ul><p>发送commit的时候有的参与者没接收到！</p><h3 id="JTA-XA-规范实现"><a href="#JTA-XA-规范实现" class="headerlink" title="JTA/XA 规范实现"></a>JTA/XA 规范实现</h3><p>java对于事务的规范实现。管理多个connection事务的封装。有阻塞。</p><h2 id="补偿机制"><a href="#补偿机制" class="headerlink" title="补偿机制"></a>补偿机制</h2><p>为了解决阻塞的问题，引入了补偿机制。</p><h3 id="Seata-AT模式实现"><a href="#Seata-AT模式实现" class="headerlink" title="Seata AT模式实现"></a>Seata AT模式实现</h3><p>补偿机制实现的 应用层面的分布式事务框架。</p><p><img src="http://images.lilhui.com/9b81d334f266e632772648638da6e6c6" alt="图片"></p><p>TC，事务协调，独立出来。存储全局事务和分支事务信息。</p><p>开启事务的时候通过RPC向TC发送一个请求生成XID 全局事务ID。</p><p>RM:资源管理器</p><ul><li>第一阶段  </li></ul><ol start="0"><li>解析SQL</li><li>现场记录（查原始数据，并记录。）行锁，级别。</li><li>执行sql语句。</li><li>查下执行完成的日志存到 UndoLog</li><li>Befor commit</li><li>commit</li><li>After local TX</li></ol><p><img src="http://images.lilhui.com/bd850c07c83c6ec78265a4bc15af9786" alt="图片"></p><ul><li>第二阶段<br>如果成功：  </li></ul><ol><li>Find undo Log</li><li>Delete Undo log</li><li>commit</li></ol><p><img src="http://images.lilhui.com/33ae92e7385a402bd7be89fd1b5d0022" alt="图片"></p><p>如果失败：  </p><ol><li>Find Undo log</li><li>确认后置镜像是否可以回滚。</li><li>执行Undo SQL</li><li>删除 Undo SQL</li><li>Commit</li><li>After Local TX</li></ol><p><img src="http://images.lilhui.com/ba2d7021ccb83903ed03b390b2524301" alt="图片"></p><ul><li>设计优点  </li></ul><ol><li>应用成实现，给予SQL解析和补偿。</li><li>TC可以独立部署，避免单点故障。</li><li>通过全局（TC管理）锁实现了隔离与读隔离</li></ol><ul><li>存在的问题  </li></ul><ol><li>数据局交互太多，效率低。性能损耗严重。</li><li>全局锁，力度也高</li><li>性价比不高</li></ol><h4 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h4><ol><li><p>注册，授权   </p></li><li><p>订单服务，扣减库存，扣除余额。订单状态。</p></li></ol><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>微服务为例：</p><ol><li>引入Seata包，nacos注册中心  </li><li>添加Undo_log表</li><li>配置seata DataSourceProxy代理数据源  </li><li>启动类排除DataSourceAutoCinfiguration，以免造成循环依赖。</li><li>添加seata配置 在nacos配置中心。存TC的配置。</li><li>使用 @GlobalTransactionnal</li></ol><h3 id="柔性事务-TCC-Try-Confirm-Cancel"><a href="#柔性事务-TCC-Try-Confirm-Cancel" class="headerlink" title="柔性事务 TCC (Try-Confirm-Cancel)"></a>柔性事务 TCC (Try-Confirm-Cancel)</h3><p>TCC和XA都是2阶段提交</p><p>实现有：</p><ul><li>TCC-Transaction</li><li>Hmily</li><li>ByteTCC</li><li>EasyTransaction</li><li>SeataTCC</li></ul><p><img src="http://images.lilhui.com/df9e0ab532d5b31a27ee48a608359442" alt="图片"></p><p>XA是资源层面的分布式事务，强一致性，在两阶段提交的过程中，一直会持有资源的锁。<br>TCC是业务层的分布式事务，最终一致性，不会一直持有资源的锁。  </p><p><strong>优点:</strong> XA两阶段提交是资源层面的，而TCC是提升到了应用层面，避免了XA两阶段提交占用<br>资源锁时间过长导致的性能低下问题。<br><strong>缺点:</strong> 主业务和从业务服务都需要改造，从业务改造成本更高，原来只需要提供一个接口，现在需要改造try,confirm,cancel三<br>个接口。开发成本高。</p><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>TCC需要把事务在应用层面切成两个阶段。</p><p><img src="http://images.lilhui.com/b151157caa0e6674a218c4a78d825dbd" alt="图片"></p><p>三种方法设计不好有很大bug，一般用以下方式：</p><p><img src="http://images.lilhui.com/611c9e22f3a2a606410887f5d30cf71f" alt="图片"></p><h4 id="TCC设计"><a href="#TCC设计" class="headerlink" title="TCC设计"></a>TCC设计</h4><ul><li>TCC异常控制<br>网络问题，重发，机器宕机等一系列问题。出现空回滚，幂等，悬挂问题。</li></ul><p>TCC允许空回滚。</p><ul><li>TCC 防悬挂控制<br>要运行空回滚，必须拒绝空回滚之后的try操作。<br>案例：<br>try方法超时，这时候触发了cancel后try才到达。try是减少数据操作。这时候数据就出错了。</li></ul><p>此时try方法不能被执行。</p><p><img src="http://images.lilhui.com/257ca2a2ead452ea870ef8a3324dc6d0" alt="图片"></p><ul><li>TCC 幂等</li></ul><p>网络故障情况下，分支事务可能多次被执行，需要支持幂等性。</p><h4 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h4><ol><li>引入依赖</li><li>添加配置 Hmily配置</li><li>建Hmily的表</li><li>实现接口，添加 @Hmily注解，制定confirm方法，cancel方法</li></ol><h3 id="柔性事务，可靠消息最终一致性方案"><a href="#柔性事务，可靠消息最终一致性方案" class="headerlink" title="柔性事务，可靠消息最终一致性方案"></a>柔性事务，可靠消息最终一致性方案</h3><p>可靠性消息最终一致性的方案是指当事务发起执行完成本地食物后并发出一条消息，事务参与方（消息消费者）一定能接受消息并处理事务成功，<br>此方案强调的是只要消息发给事务参与方最终事务要达成一致。</p><p>TCC比较难，业务侵入比较大。控制力比较强，适合金融类产品。<br>可靠新消息方案是从架构上避免分布式事务！</p><h4 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h4><p>本地消息表，这个方案是ebay提出。核心是通过保证本地事务操作和消息的一致性。</p><p><img src="http://images.lilhui.com/197864dc504ab51310d5111de069170f" alt="图片"></p><ul><li>RockMq事务消息的方案<br><img src="http://images.lilhui.com/42887bcf2282a910d82a046444b1f94d" alt="图片"></li></ul><p>事务消息也有2PC,存在MqProducer RocketMq 4.3开始支持。</p><p>关键点，事务回查。</p><h3 id="柔性事务，最大努力通知"><a href="#柔性事务，最大努力通知" class="headerlink" title="柔性事务，最大努力通知"></a>柔性事务，最大努力通知</h3><ol><li>消息重复通知机制</li><li>消息校对机制<br> 可查消息最终状态</li></ol><p>场景：比如公司内部实现了短信平台，所有的业务都接入这个短信平台，来实现发送短信的功能。<br><img src="http://images.lilhui.com/bb6a1ee6f9abcfe697ebcb3a57604af0" alt="图片"></p><p>场景2：充值</p><p><img src="http://images.lilhui.com/c72ea521f4efbadc03c2c31bc6a03888" alt="图片"></p><p>最大通知与可靠新消息最终一致性的区别？</p><ul><li>思想不同<br>  可靠消息最终一致性，发起通知方需要保证消息发出去，并且将消息发送到接收方，消息的<br>可靠性关键由发起通知放来保证。</li><li>业务场景不同<br>  可靠消息最终一致性关注的是交易过程的事务一致性，以异步的方式完成交易。<br>  最大努力通知关注的是交易后的通知事务，即将交易结果可靠的通知出去。</li><li>技术解决方向不同<br>  可靠消息最终一致性要解决消息从发出到接收的一致性，既消息发出并且被接收到。<br>  最大努力通知无法保证消息从发出到接收的一致性，只提供消息接收的可靠性机制。可靠性机制是，最大努力的将消息通知给<br>接收方，当消息无法被接收方接收时，由接收方主动查询消息。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常见的分布式事务方案&quot;&gt;&lt;a href=&quot;#常见的分布式事务方案&quot; class=&quot;headerlink&quot; title=&quot;常见的分布式事务方案&quot;&gt;&lt;/a&gt;常见的分布式事务方案&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://images.lilhui.com/aff
      
    
    </summary>
    
      <category term="电商" scheme="http://www.lilhui.com/categories/%E7%94%B5%E5%95%86/"/>
    
      <category term="微服务" scheme="http://www.lilhui.com/categories/%E7%94%B5%E5%95%86/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="分布式事务" scheme="http://www.lilhui.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="亿级流量" scheme="http://www.lilhui.com/tags/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>【深入理解Spring系列2】自动装配Bean初始化</title>
    <link href="http://www.lilhui.com/2021/12/02/java/spring/spring_deep_2/"/>
    <id>http://www.lilhui.com/2021/12/02/java/spring/spring_deep_2/</id>
    <published>2021-12-02T03:38:39.000Z</published>
    <updated>2022-02-10T06:19:31.275Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 四中bean装配模型</p><p>NO<br>byType<br>byName<br>byConstructor</p><p>官网说是针对 xml配置的。其实不完全正确。<br>应该是：xml提供了配置入口。</p><p>@Autowire 这个可以通过后置处理器，在beandefinitioan里设置autowireMode(int)</p><p>@Autowired与上面四种的区别是，他可以通过field.set 反射来装配。其他的需要 setXXX方法。</p><p>populaBan</p><p>spring 生命周期中，先拿到后置处理器处理，处理<br>@PostConstruct<br>注解，再处理<br>initMethod。initMethod会依次处理（afterPropertiesSet） 接口方法，和xml配置 的方法。</p><ul><li>smartlifeCycle</li></ul><p>isAutoStartUp 一旦容器开始就调用start()方法<br>容器停止会调用stop(runnalble callback )</p><p>包：<br>spring-context-indxer<br>容器索引<br>在大型项目的时候用于加载预处理。</p><p>javax.inject<br>@Inject @Name</p><ul><li>FactoryBean 与Bean的区别</li></ul><p>初始化时机不同。</p><p>什么是 factoryBean？</p><ol><li>本身是一个Bean，getObject()也是一个bean<br>2</li></ol><p>问题： 如何将一个对象放到spring容器中？</p><ol><li>factoryBean (一般跟第三方jar包结合 ： nacosDataSourceFactoryBean)</li><li>@Bean (手动业务类操作放到spring里。)</li><li>applicationContext.getBeanFactory().registerSingleTon(“”, Object); –（有依赖的时候作用比较大。）</li></ol><p>applicationContext.getBean(“factoryBean”); 获取的 是这个bean中getObject()的对象。</p><p>applicationContext.getBean(“&amp;factoryBean”); 获取的是factoryBean </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring 四中bean装配模型&lt;/p&gt;
&lt;p&gt;NO&lt;br&gt;byType&lt;br&gt;byName&lt;br&gt;byConstructor&lt;/p&gt;
&lt;p&gt;官网说是针对 xml配置的。其实不完全正确。&lt;br&gt;应该是：xml提供了配置入口。&lt;/p&gt;
&lt;p&gt;@Autowire 这个可以通过
      
    
    </summary>
    
      <category term="spring" scheme="http://www.lilhui.com/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>【深入理解Spring系列1】自动装配Bean初始化</title>
    <link href="http://www.lilhui.com/2021/11/17/java/spring/spring_deep_1/"/>
    <id>http://www.lilhui.com/2021/11/17/java/spring/spring_deep_1/</id>
    <published>2021-11-17T02:32:40.000Z</published>
    <updated>2022-02-10T06:19:08.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4种自动装配-注入）模型"><a href="#4种自动装配-注入）模型" class="headerlink" title="4种自动装配(注入）模型"></a>4种自动装配(注入）模型</h2><ul><li>@Autowired </li><li>@Resource</li></ul><ol><li>no: AUTOWIRE_NO(NO,不使用自动转配)</li><li>byName：AUTOWIRE_BY_NAME </li><li>byType: AUTOWIRE_BY_TYPE</li><li>byConstructor: AUTOWIRE_CONSTRUCTOR</li></ol><h2 id="2种注入方式"><a href="#2种注入方式" class="headerlink" title="2种注入方式"></a>2种注入方式</h2><p>注入方式可以理解成寻找Bean方式</p><ol><li>byType</li><li>byName</li></ol><h2 id="7个后置处理器"><a href="#7个后置处理器" class="headerlink" title="7个后置处理器"></a>7个后置处理器</h2><ol><li>AutowiredAnnotationBeanPostProcessor</li><li>CommonAnnotationBeanPostProcessor</li></ol><h2 id="Bean生命周期里的回调"><a href="#Bean生命周期里的回调" class="headerlink" title="Bean生命周期里的回调"></a>Bean生命周期里的回调</h2><p>Bean生命周期里的回调<br>lifeCycle Callback</p><h3 id="实现接口InitializingBean"><a href="#实现接口InitializingBean" class="headerlink" title="实现接口InitializingBean"></a>实现接口InitializingBean</h3><ol><li>xml配置 initial-method A </li><li>实现initializingBean接口 B </li><li>注解@PostConstruct C</li></ol><p>三种方法先后顺序<br>C-&gt;B-&gt;A</p><h3 id="Spring初始化方法"><a href="#Spring初始化方法" class="headerlink" title="Spring初始化方法"></a>Spring初始化方法</h3><p>一个后置处理器，2个初始化方法。<br>执行构造方法后，</p><ul><li>callback</li></ul><ol><li>Spring一个对象被Spring实例化后就执行某些逻辑。</li><li>当Spring容器初始化完成后立马执行，使用SmartLifeCycle </li></ol><p><strong>问题</strong>：Spring中属性注入和和初始化方法 @PostConstruct 谁先执行？<br>回答：属性注入先执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;4种自动装配-注入）模型&quot;&gt;&lt;a href=&quot;#4种自动装配-注入）模型&quot; class=&quot;headerlink&quot; title=&quot;4种自动装配(注入）模型&quot;&gt;&lt;/a&gt;4种自动装配(注入）模型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;@Autowired &lt;/li&gt;
&lt;li&gt;@Re
      
    
    </summary>
    
      <category term="spring" scheme="http://www.lilhui.com/categories/spring/"/>
    
    
      <category term="自动装配" scheme="http://www.lilhui.com/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"/>
    
  </entry>
  
</feed>
