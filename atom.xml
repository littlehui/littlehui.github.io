<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Littlehui&#39;s Notes</title>
  
  <subtitle>天地那么大，世界那么辽阔。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.lilhui.com/"/>
  <updated>2017-10-11T09:27:45.000Z</updated>
  <id>http://www.lilhui.com/</id>
  
  <author>
    <name>Littlehui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM系列：JVM内存优化实例</title>
    <link href="http://www.lilhui.com/2017/10/11/java/jvm/jvm_3/"/>
    <id>http://www.lilhui.com/2017/10/11/java/jvm/jvm_3/</id>
    <published>2017-10-11T08:22:09.000Z</published>
    <updated>2017-10-11T09:27:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="优化实例"><a href="#优化实例" class="headerlink" title="优化实例"></a>优化实例</h3><p>java application项目（非web项目）</p><p>改进前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">-Xms128m</div><div class="line">-Xmx128m</div><div class="line">-XX:NewSize=64m</div><div class="line">-XX:PermSize=64m</div><div class="line">-XX:+UseConcMarkSweepGC</div><div class="line">-XX:CMSInitiatingOccupancyFraction=78</div><div class="line">-XX:ThreadStackSize=128</div><div class="line">-Xloggc:logs/gc.log</div><div class="line">-Dsun.rmi.dgc.server.gcInterval=3600000</div><div class="line">-Dsun.rmi.dgc.client.gcInterval=3600000</div><div class="line">-Dsun.rmi.server.exceptionTrace=true</div></pre></td></tr></table></figure></p><p>问题:<br>permsize 设置较小,很容易达到报警范围(0.8)<br>没有设置MaxPermSize，堆增长会带来额外压力。<br>NewSize较大，old gen 剩余空间64m，一方面可能会带来old区容易增长到报警范围（监控数据显示oldgenused长期在50m左右，接近78%，容易出现full gc）,另一方面也存在promontion fail风险<br>改进后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">-Xms128m</div><div class="line">-Xmx128m</div><div class="line">-Xmn24m</div><div class="line">-XX:PermSize=80m</div><div class="line">-XX:MaxPermSize=80m</div><div class="line">-Xss256k</div><div class="line">-XX:SurvivorRatio=1</div><div class="line">-XX:MaxTenuringThreshold=20</div><div class="line">-XX:+UseParNewGC</div><div class="line">-XX:+UseConcMarkSweepGC</div><div class="line">-XX:CMSInitiatingOccupancyFraction=75</div><div class="line">-XX:+UseCMSCompactAtFullCollection</div><div class="line">-XX:+CMSParallelRemarkEnabled</div><div class="line">-XX:CMSFullGCsBeforeCompaction=2</div><div class="line">-XX:SoftRefLRUPolicyMSPerMB=0</div><div class="line">-XX:+PrintClassHistogram</div><div class="line">-XX:+PrintGCDetails</div><div class="line">-XX:+PrintGCTimeStamps</div><div class="line">-XX:+PrintHeapAtGC</div><div class="line">-Xloggc:logs/gc.log</div><div class="line">-Dsun.rmi.dgc.server.gcInterval=3600000</div><div class="line">-Dsun.rmi.dgc.client.gcInterval=3600000</div><div class="line">-Dsun.rmi.server.exceptionTrace=true</div></pre></td></tr></table></figure></p><p>修改点：<br>PermSize与MaxPermSize都设置为80，一方面避免non heap warn(报警阀值0.8 非对内存一般占用到60M以内），一方面避免堆伸缩带来的压力<br>通过设置Xmn=24M及SurvivorRatio=1 使得Eden区=from space=to  space=8M,降低了Eden区大小，降低YGC的时间(降低到3-4ms左右),同时通过设MaxTenuringThreshold=20，使得old gen的增长很缓慢。带来的问题是YGC的次数明显提高了很多。<br>其他参数优化 修改后带来的好处见JVM参数设置<br>再次改进后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">-Xms128m</div><div class="line">-Xmx128m</div><div class="line">-Xmn36m</div><div class="line">-XX:PermSize=80m</div><div class="line">-XX:MaxPermSize=80m</div><div class="line">-Xss256k</div><div class="line">-XX:SurvivorRatio=1</div><div class="line">-XX:MaxTenuringThreshold=20</div><div class="line">-XX:+UseParNewGC</div><div class="line">-XX:+UseConcMarkSweepGC</div><div class="line">-XX:CMSInitiatingOccupancyFraction=73</div><div class="line">-XX:+UseCMSCompactAtFullCollection</div><div class="line">-XX:+CMSParallelRemarkEnabled</div><div class="line">-XX:CMSFullGCsBeforeCompaction=2</div><div class="line">-XX:SoftRefLRUPolicyMSPerMB=0</div><div class="line">-XX:+PrintClassHistogram</div><div class="line">-XX:+PrintGCDetails</div><div class="line">-XX:+PrintGCTimeStamps</div><div class="line">-XX:+PrintHeapAtGC</div><div class="line">-Xloggc:logs/gc.log</div><div class="line">-Dsun.rmi.dgc.server.gcInterval=3600000</div><div class="line">-Dsun.rmi.dgc.client.gcInterval=3600000</div><div class="line">-Dsun.rmi.server.exceptionTrace=true</div></pre></td></tr></table></figure></p><p>修改点：<br>      在上面的基础上调整Xmn大小到36M，设置CMSInitiatingOccupancyFraction=73。</p><pre><code>Dden区与Survivor区大小都增加到12M，通过CMSInitiatingOccupancyFraction计算公式,计算得出value为73是，可以避免promotion faild问题，同时满足堆内存监控报警值在80%：内存大小128M*80%=102.4M 102.4M-36M=66.4M(老生代达到此值报警） 老生代达到67.15M（92M*0.73）将发生Full GC，所以在老生代大小达到66.4M时也就是WARN报警时将很有可能出现Full GC。 增大了Eden和Survivor区的值，会减小YGC的次数，但由于空间变大理论上也会相应的增加YGC的时间，不过由于新生代本身就很小（才36M）这点儿变化可以忽略掉。实际的监控值显示YGC的时间在4-5ms之间。是可以接受范围。SurvivorRatio 这个值还得在仔细考虑下,有待优化中</code></pre><p>网上某个牛人的配置 :每天几百万pv一点问题都没有，网站没有停顿<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">$JAVA_ARGS</div><div class="line">.=</div><div class="line">&quot;</div><div class="line">-Dresin.home=$SERVER_ROOT</div><div class="line">-server</div><div class="line">-Xms6000M</div><div class="line">-Xmx6000M</div><div class="line">-Xmn500M</div><div class="line">-XX:PermSize=500M</div><div class="line">-XX:MaxPermSize=500M</div><div class="line">-XX:SurvivorRatio=65536</div><div class="line">-XX:MaxTenuringThreshold=0</div><div class="line">-Xnoclassgc</div><div class="line">-XX:+DisableExplicitGC</div><div class="line">-XX:+UseParNewGC</div><div class="line">-XX:+UseConcMarkSweepGC</div><div class="line">-XX:+UseCMSCompactAtFullCollection</div><div class="line">-XX:CMSFullGCsBeforeCompaction=0</div><div class="line">-XX:+CMSClassUnloadingEnabled</div><div class="line">-XX:-CMSParallelRemarkEnabled</div><div class="line">-XX:CMSInitiatingOccupancyFraction=90</div><div class="line">-XX:SoftRefLRUPolicyMSPerMB=0</div><div class="line">-XX:+PrintClassHistogram</div><div class="line">-XX:+PrintGCDetails</div><div class="line">-XX:+PrintGCTimeStamps</div><div class="line">-XX:+PrintHeapAtGC</div><div class="line">-Xloggc:log/gc.log</div><div class="line">&quot;;</div></pre></td></tr></table></figure></p><p>说明一下， -XX:SurvivorRatio=65536 -XX:MaxTenuringThreshold=0就是去掉了救助空间；<br>-Xnoclassgc禁用类垃圾回收，性能会高一点；<br>-XX:+DisableExplicitGC禁止System.gc()，免得程序员误调用gc方法影响性能；<br>-XX:+UseParNewGC，对年轻代采用多线程并行回收，这样收得快；<br>带CMS参数的都是和并发回收相关的，不明白的可以上网搜索；<br>CMSInitiatingOccupancyFraction，这个参数设置有很大技巧，基本上满足(Xmx-Xmn)<em>(100-CMSInitiatingOccupancyFraction)/100&gt;=Xmn就不会出现promotion failed。在我的应用中Xmx是6000，Xmn是500，那么Xmx-Xmn是5500兆，也就是年老代有5500兆，CMSInitiatingOccupancyFraction=90说明年老代到90%满的时候开始执行对年老代的并发垃圾回收（CMS），这时还剩10%的空间是5500</em>10%=550兆，所以即使Xmn（也就是年轻代共500兆）里所有对象都搬到年老代里，550兆的空间也足够了，所以只要满足上面的公式，就不会出现垃圾回收时的promotion failed；<br>SoftRefLRUPolicyMSPerMB这个参数我认为可能有点用，官方解释是softly reachable objects will remain alive for some amount of time after the last time they were referenced. The default value is one second of lifetime per free megabyte in the heap，我觉得没必要等1秒；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">-Xmx4000M</div><div class="line">-Xms4000M</div><div class="line">-Xmn600M</div><div class="line">-XX:PermSize=500M</div><div class="line">-XX:MaxPermSize=500M</div><div class="line">-Xss256K</div><div class="line">-XX:+DisableExplicitGC</div><div class="line">-XX:SurvivorRatio=1</div><div class="line">-XX:+UseConcMarkSweepGC</div><div class="line">-XX:+UseParNewGC</div><div class="line">-XX:+CMSParallelRemarkEnabled</div><div class="line">-XX:+UseCMSCompactAtFullCollection</div><div class="line">-XX:CMSFullGCsBeforeCompaction=0</div><div class="line">-XX:+CMSClassUnloadingEnabled</div><div class="line">-XX:LargePageSizeInBytes=128M</div><div class="line">-XX:+UseFastAccessorMethods</div><div class="line">-XX:+UseCMSInitiatingOccupancyOnly</div><div class="line">-XX:CMSInitiatingOccupancyFraction=80</div><div class="line">-XX:SoftRefLRUPolicyMSPerMB=0</div><div class="line">-XX:+PrintClassHistogram</div><div class="line">-XX:+PrintGCDetails</div><div class="line">-XX:+PrintGCTimeStamps</div><div class="line">-XX:+PrintHeapAtGC</div><div class="line">-Xloggc:log/gc.log</div></pre></td></tr></table></figure></p><p>改进方案：<br>上面方法不太好，因为没有用到救助空间，所以年老代容易满，CMS执行会比较频繁。我改善了一下，还是用救助空间，但是把救助空间加大，这样也不会有promotion failed。<br>具体操作上，32位Linux和64位Linux好像不一样，64位系统似乎只要配置MaxTenuringThreshold参数，CMS还是有暂停。为了解决暂停问题和promotion failed问题，最后我设置-XX:SurvivorRatio=1 ，并把MaxTenuringThreshold去掉，这样即没有暂停又不会有promotoin failed，而且更重要的是，年老代和永久代上升非常慢（因为好多对象到不了年老代就被回收了），所以CMS执行频率非常低，好几个小时才执行一次，这样，服务器都不用重启了。<br>某网友:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">$JAVA_ARGS</div><div class="line">.=</div><div class="line">&quot;</div><div class="line">-Dresin.home=$SERVER_ROOT</div><div class="line">-server</div><div class="line">-Xmx3000M</div><div class="line">-Xms3000M</div><div class="line">-Xmn600M</div><div class="line">-XX:PermSize=500M</div><div class="line">-XX:MaxPermSize=500M</div><div class="line">-Xss256K</div><div class="line">-XX:+DisableExplicitGC</div><div class="line">-XX:SurvivorRatio=1</div><div class="line">-XX:+UseConcMarkSweepGC</div><div class="line">-XX:+UseParNewGC</div><div class="line">-XX:+CMSParallelRemarkEnabled</div><div class="line">-XX:+UseCMSCompactAtFullCollection</div><div class="line">-XX:CMSFullGCsBeforeCompaction=0</div><div class="line">-XX:+CMSClassUnloadingEnabled</div><div class="line">-XX:LargePageSizeInBytes=128M</div><div class="line">-XX:+UseFastAccessorMethods</div><div class="line">-XX:+UseCMSInitiatingOccupancyOnly</div><div class="line">-XX:CMSInitiatingOccupancyFraction=70</div><div class="line">-XX:SoftRefLRUPolicyMSPerMB=0</div><div class="line">-XX:+PrintClassHistogram</div><div class="line">-XX:+PrintGCDetails</div><div class="line">-XX:+PrintGCTimeStamps</div><div class="line">-XX:+PrintHeapAtGC</div><div class="line">-Xloggc:log/gc.log</div><div class="line">&quot;;</div></pre></td></tr></table></figure></p><pre><code>64位jdk参考设置，年老代涨得很慢，CMS执行频率变小，CMS没有停滞，也不会有promotion failed问题，内存回收得很干净</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>打印并分析进行垃圾回收的时间，内容，具体数值。如果有OOM导出OOM时内存使用情况。</li><li>分析垃圾回收时候的数据信息，（年轻区，年老区，方法区）查看OOM时内存使用情况。 </li><li>优化的权重顺序可以按照，FullGc&gt;频繁YGC</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;优化实例&quot;&gt;&lt;a href=&quot;#优化实例&quot; class=&quot;headerlink&quot; title=&quot;优化实例&quot;&gt;&lt;/a&gt;优化实例&lt;/h3&gt;&lt;p&gt;java application项目（非web项目）&lt;/p&gt;
&lt;p&gt;改进前：&lt;br&gt;&lt;figure class=&quot;highl
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="jvm" scheme="http://www.lilhui.com/categories/java/jvm/"/>
    
    
      <category term="java" scheme="http://www.lilhui.com/tags/java/"/>
    
      <category term="jvm调优" scheme="http://www.lilhui.com/tags/jvm%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM系列：JVM内存优化建议</title>
    <link href="http://www.lilhui.com/2017/10/09/java/jvm/jvm_2/"/>
    <id>http://www.lilhui.com/2017/10/09/java/jvm/jvm_2/</id>
    <published>2017-10-09T09:21:09.000Z</published>
    <updated>2017-10-11T08:22:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h3><p>JAVA程序在运行时  </p><ol><li>加快GC速度</li><li>减少FullGC</li><li>减少停顿</li><li>杜绝GC出错<blockquote><p>GC优化的策略本质上JVM运行中通过参数的变换调和达到运行平衡的过程。it is an art.</p><h3 id="经验配置"><a href="#经验配置" class="headerlink" title="经验配置"></a>经验配置</h3></blockquote></li></ol><h4 id="垃圾搜集器"><a href="#垃圾搜集器" class="headerlink" title="垃圾搜集器"></a>垃圾搜集器</h4><p>新生代收集器：有Serial收集器、ParNew收集器、Parallel Scavenge收集器<br>老生代收集器：Serial Old收集器、Parallel Old收集器、CMS收集器、G1收集器<br>以上所有的垃圾收集器都会发生STW，只不过FGC的STW时间更长。</p><h5 id="常用搜集器："><a href="#常用搜集器：" class="headerlink" title="常用搜集器："></a>常用搜集器：</h5><ul><li>CMSGC<br>  CMS(Concurrent Mark-Sweep)是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合，因此我们又叫它低延迟垃圾收集器。在启动JVM参数加上-XX:+UseConcMarkSweepGC ，这个参数表示对于老年代的回收采用CMS，注意此时新生代默认使用的是ParNew。CMS采用的基础算法是：标记—清除。</li><li>MSCGC vs CMSGC<br>  和普通序列化整理（MSC）区别在于有三个mark阶段（实际上还有个预清理过程，但对于解释清楚CMSGC没有帮助就忽略了）。CMSGC的精髓在于因为做到了不STW的情况下进行mark，我们得到了更短的总STW时间，代价是因为并行mark产生了『脏数据』即在mark的同时又生成了需要mark的对象，我们必须再进行一次STW，并收尾（remark）。<br>同时，我们要注意到得到更短的STW的同时，我们牺牲了系统吞吐量，CMSGC总吞吐量比ParOld要更低。</li><li>G1GC<br>  作为最新的垃圾收集器，有可能在jdk9中成为默认的垃圾收集器。<br>主要思路是将新生代老生代进一步分为多个region，每次gc可以针对部分region而不是整个堆内存。由此可以降低stw的单次最长时间，代价是可能在总时间上会更高。<br>G1GC让系统在整体吞吐量略降的情况下变得更加平滑稳定。</li></ul><h4 id="响应时间优先的应用"><a href="#响应时间优先的应用" class="headerlink" title="响应时间优先的应用"></a>响应时间优先的应用</h4><ul><li>年轻代选择<br>尽可能设大,直到接近系统的最低响应时间限制(根据实际情况选择).在此种情况下,年轻代收集发生的频率也是最小的.同时,减少到达年老代的对象.</li><li>年老代选择<br>年老代使用并发收集器,所以其大小需要小心设置,一般要考虑并发会话率和会话持续时间等一些参数.如果堆设置小了,可以会造成内存碎片,高回收频率以及应用暂停而使用传统的标记清除方式;如果堆大了,则需要较长的收集时间.最优化的方案,一般需要参考以下数据获得:<ol><li>并发垃圾收集信息.</li><li>持久代并发收集次数.</li><li>传统GC信息.</li><li>花在年轻代和年老代回收上的时间比例。<h4 id="吞吐量优先的应用"><a href="#吞吐量优先的应用" class="headerlink" title="吞吐量优先的应用"></a>吞吐量优先的应用</h4></li></ol></li><li>年轻代选择<br>尽可能的设置大,可能到达Gbit的程度.因为对响应时间没有要求,垃圾收集可以并行进行,一般适合8CPU以上的应用.<br>避免设置过小.当新生代设置过小时会导致:<ol><li>YGC次数更加频繁 </li><li>可能导致YGC对象直接进入旧生代,如果此时旧生代满了,会触发FGC.</li></ol></li><li>年老代选择<br>一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代.这样可以尽可能回收掉大部分短期对象,减少中期的对象,而年老代尽存放长期存活对象.</li></ul><h4 id="碎片问题"><a href="#碎片问题" class="headerlink" title="碎片问题"></a>碎片问题</h4><p>因为年老代的并发收集器使用标记,清除算法,所以不会对堆进行压缩.当收集器回收时,他会把相邻的空间进行合并,这样可以分配给较大的对象.但是,当堆空间较小时,运行一段时间以后,就会出现”碎片”,如果并发收集器找不到足够的空间,那么并发收集器将会停止,然后使用传统的标记,清除方式进行回收.如果出现”碎片”,可能需要进行如下配置:</p><blockquote><p>-XX:+UseCMSCompactAtFullCollection:使用并发收集器时,开启对年老代的压缩.<br>-XX:CMSFullGCsBeforeCompaction=0:上面配置开启的情况下,这里设置多少次Full GC后,对年老代进行压缩</p></blockquote><h4 id="promotion-failed问题"><a href="#promotion-failed问题" class="headerlink" title="promotion failed问题"></a>promotion failed问题</h4><p>可能是两种原因产生：</p><pre><code>1. 第一个原因是救助空间不够，救助空间里的对象还不应该被移动到年老代，但年轻代又有很多对象需要放入救助空间。2. 第二个原因是年老代没有足够的空间接纳来自年轻代的对象；这两种情况都会转向Full GC，网站停顿时间较长。</code></pre><p>用64位操作系统，Linux下64位的jdk比32位jdk要慢一些，但是吃得内存更多，吞吐量更大<br>XMX和XMS设置一样大，MaxPermSize和MinPermSize设置一样大，这样可以减轻伸缩堆大小带来的压力</p><ul><li>使用CMS的好处是用尽量少的新生代，经验值是128M－256M， 老生代利用CMS并行收集，这样能保证系统低延迟的吞吐效率。 </li><li>cms的收集停顿时间非常的短，2G的内存， 大约20－80ms的应用程序停顿时间<br>系统停顿的时候可能是GC的问题也可能是程序的问题，多用jmap和jstack查看，或者killall -3 java，然后查看java控制台日志，能看出很多问题。</li><li>如果用了缓存，那么年老代应该大一些，缓存的HashMap不应该无限制长，建议采用LRU算法的Map做缓存，LRUMap的最大长度也要根据实际情况设定。</li><li>采用并发回收时，年轻代小一点，年老代要大，因为年老大用的是并发回收，即使时间长点也不会影响其他程序继续运行，网站不会停顿<br>JVM参数的设置(特别是 –Xmx –Xms –Xmn -XX:SurvivorRatio  -XX:MaxTenuringThreshold等参数的设置没有一个固定的公式，需要根据PV old区实际数据 YGC次数等多方面来衡量。为了避免promotion faild可能会导致xmn设置偏小，也意味着YGC的次数会增多，处理并发访问的能力下降等问题。每个参数的调整都需要经过详细的性能测试，才能找到特定应用的最佳配置。</li></ul><p>解决方方案一：<br>    第一个原因最终解决办法是去掉救助空间，设置-XX:SurvivorRatio=65536 -XX:MaxTenuringThreshold=0即可，<br>    第二个原因我的解决办法是设置CMSInitiatingOccupancyFraction为某个值（假设70），这样年老代空间到70%时就开始执行CMS，年老代有足够的空间接纳来自年轻代的对象。<br>解决方案一的改进方案：</p><p>又有改进了，上面方法不太好，因为没有用到救助空间，所以年老代容易满，CMS执行会比较频繁。我改善了一下，还是用救助空间，但是把救助空间加大，这样也不会有promotion failed。具体操作上，32位Linux和64位Linux好像不一样，64位系统似乎只要配置MaxTenuringThreshold参数，CMS还是有暂停。为了解决暂停问题和promotion failed问题，最后我设置-XX:SurvivorRatio=1 ，并把MaxTenuringThreshold去掉，这样即没有暂停又不会有promotoin failed，而且更重要的是，年老代和永久代上升非常慢（因为好多对象到不了年老代就被回收了），所以CMS执行频率非常低，好几个小时才执行一次，这样，服务器都不用重启了。</p><p>-Xmx4000M -Xms4000M -Xmn600M -XX:PermSize=500M -XX:MaxPermSize=500M -Xss256K -XX:+DisableExplicitGC -XX:SurvivorRatio=1 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSClassUnloadingEnabled -XX:LargePageSizeInBytes=128M -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=80 -XX:SoftRefLRUPolicyMSPerMB=0 -XX:+PrintClassHistogram -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -Xloggc:log/gc.log</p><p>CMSInitiatingOccupancyFraction值与Xmn的关系公式</p><p>上面介绍了promontion faild产生的原因是EDEN空间不足的情况下将EDEN与From survivor中的存活对象存入To survivor区时,To survivor区的空间不足，再次晋升到old gen区，而old gen区内存也不够的情况下产生了promontion faild从而导致full gc.那可以推断出：eden+from survivor &lt; old gen区剩余内存时，不会出现promontion faild的情况，即：<br>(Xmx-Xmn)*(1-CMSInitiatingOccupancyFraction/100)&gt;=(Xmn-Xmn/(SurvivorRatior+2))  进而推断出：</p><p>CMSInitiatingOccupancyFraction &lt;=((Xmx-Xmn)-(Xmn-Xmn/(SurvivorRatior+2)))/(Xmx-Xmn)*100</p><p>例如：</p><p>当xmx=128 xmn=36 SurvivorRatior=1时 CMSInitiatingOccupancyFraction&lt;=((128.0-36)-(36-36/(1+2)))/(128-36)*100 =73.913</p><p>当xmx=128 xmn=24 SurvivorRatior=1时 CMSInitiatingOccupancyFraction&lt;=((128.0-24)-(24-24/(1+2)))/(128-24)*100=84.615…</p><p>当xmx=3000 xmn=600 SurvivorRatior=1时  CMSInitiatingOccupancyFraction&lt;=((3000.0-600)-(600-600/(1+2)))/(3000-600)*100=83.33</p><p>CMSInitiatingOccupancyFraction低于70% 需要调整xmn或SurvivorRatior值。</p><p>令：</p><p>网上一童鞋推断出的公式是：:(Xmx-Xmn)*(100-CMSInitiatingOccupancyFraction)/100&gt;=Xmn 这个公式个人认为不是很严谨，在内存小的时候会影响xmn的计算。</p><p>参考：<br><a href="http://www.cnblogs.com/redcreen/archive/2011/05/05/2038331.html" target="_blank" rel="external">http://www.cnblogs.com/redcreen/archive/2011/05/05/2038331.html</a><br><a href="http://www.jianshu.com/p/c9ac99b87d56" target="_blank" rel="external">http://www.jianshu.com/p/c9ac99b87d56</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;优化原则&quot;&gt;&lt;a href=&quot;#优化原则&quot; class=&quot;headerlink&quot; title=&quot;优化原则&quot;&gt;&lt;/a&gt;优化原则&lt;/h3&gt;&lt;p&gt;JAVA程序在运行时  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加快GC速度&lt;/li&gt;
&lt;li&gt;减少FullGC&lt;/li&gt;
&lt;li&gt;减少
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="jvm" scheme="http://www.lilhui.com/categories/java/jvm/"/>
    
    
      <category term="java" scheme="http://www.lilhui.com/tags/java/"/>
    
      <category term="jvm调优" scheme="http://www.lilhui.com/tags/jvm%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM系列：基础概念</title>
    <link href="http://www.lilhui.com/2017/09/28/java/jvm/jvm_1/"/>
    <id>http://www.lilhui.com/2017/09/28/java/jvm/jvm_1/</id>
    <published>2017-09-28T08:15:39.000Z</published>
    <updated>2017-10-11T10:26:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>jvm内存区域分三种：栈，堆，方法区。设计上Java还可以使用到直接内存，在Java NIO包里使用DirectBuffer可以显示地调用申请堆外内存。</p></blockquote><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>   栈是基于线程执行而言的，它描述的是一个线程执行的流程路线。并且在整个业务执行流程中需要用到的各种局部变量（简单类型保存值，对象保存地址），以及基本类型。<br>    这个路线可以认为是通过方法区的程序执行流程，按照帧（Stack Frame)的方式一压入内存，在JVM内存<br>    看起来就是Stack的存储。</p><h4 id="栈的配置"><a href="#栈的配置" class="headerlink" title="栈的配置"></a>栈的配置</h4><p>   JVM通过 -XSS指定配置每个线程所拥有栈大小。默认值随着虚拟机版本以及操作系统影响，官网上指定：</p><blockquote><p>In Java SE 6, the default on Sparc is 512k in the 32-bit VM, and 1024k in the 64-bit VM. On x86 Solaris/Linux it is 320k in the 32-bit VM and 1024k in the 64-bit VM.<br>     。  </p></blockquote><p>   栈的大小直接影响可以创建的线程数量。</p><pre><code>线程数 = （系统空闲内存-堆内存（-Xms, -Xmx）- perm方法区内存(-XX:MaxPermSize)) / 线程栈大小(-Xss)</code></pre><p>   如上我们可知栈设置越小，可以创建的线程数就越多，但是也是有限制的。限制有两个方便：</p><p>   操作系统配置也可以限制数量。例如ubuntu里/proc/sys/kernel/threads-max设置最大线程数。</p><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>   调用链太长，栈不够时会抛出StackOverFlow。一般是发生了递归而产生。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>   堆是JVM最大的内存部分，它负责存放对象实例，JVM所有对象实例都在这里。（变量，对象属性但是不包括方法里的简单类型变量）。它保存了执行所需要的<br>   各种东西。</p><h3 id="堆的配置"><a href="#堆的配置" class="headerlink" title="堆的配置"></a>堆的配置</h3><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>其他</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td><td>物理内存的1/64(&lt;1GB)</td><td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td></tr><tr><td>-Xmx</td><td>最大堆大小</td><td>物理内存的1/4(&lt;1GB)</td><td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td></tr><tr><td>-Xmn</td><td>年轻代大小</td><td>(1.4or lator)</td><td>注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td></tr><tr><td>-XX:NewSize</td><td>设置年轻代大小(for 1.3/1.4)</td><td></td></tr><tr><td>-XX:MaxNewSize</td><td>年轻代最大值(for 1.3/1.4)</td><td></td></tr><tr><td>-XX:PermSize</td><td>设置持久代(perm gen)初始值</td><td>物理内存的1/64     </td></tr><tr><td>-XX:MaxPermSize</td><td>设置持久代最大值</td><td>物理内存的1/4     </td></tr><tr><td>-Xss</td><td>每个线程的堆栈大小</td><td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右</td><td>一般小的应用，如果栈不很深， 应该是128k够用的大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:”-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了</td></tr><tr><td>-XX:ThreadStackSize</td><td>Thread Stack Size</td><td>(0 means use default stack size) [Sparc: 512; Solaris x86: 320 (was 256 prior in 5.0 and earlier); Sparc 64 bit: 1024; Linux amd64: 1024 (was 0 in 5.0 and earlier); all others 0.]</td></tr><tr><td>-XX:NewRatio</td><td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td><td>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5</td><td>Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td></tr><tr><td>-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td><td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td></tr><tr><td>-XX:LargePageSizeInBytes</td><td>内存页的大小</td><td>不可设置过大， 会影响Perm的大小         =128m</td></tr><tr><td>-XX:+UseFastAccessorMethods</td><td>原始类型的快速优化</td><td></td></tr><tr><td>-XX:+DisableExplicitGC</td><td>关闭System.gc()</td><td>这个参数需要严格的测试</td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>垃圾最大年龄</td><td>如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率该参数只有在串行GC时才有效.</td></tr><tr><td>-XX:+AggressiveOpts</td><td>加快编译          </td></tr><tr><td>-XX:+UseBiasedLocking</td><td>锁机制的性能改善          </td></tr><tr><td>-Xnoclassgc</td><td>禁用垃圾回收          </td></tr><tr><td>-XX:SoftRefLRUPolicyMSPerMB</td><td>每兆堆空闲空间中SoftReference的存活时间</td><td>1s    softly reachable objects will remain alive for some amount of time after the last time they were referenced. The default value is one second of lifetime per free megabyte in the heap</td></tr><tr><td>-XX:PretenureSizeThreshold</td><td>对象超过多大是直接在旧生代分配</td><td>0</td><td>单位字节 新生代采用Parallel Scavenge GC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td></tr><tr><td>-XX:TLABWasteTargetPercent</td><td>TLAB占eden区的百分比</td><td>1%     </td></tr><tr><td>-XX:+CollectGen0First</td><td>FullGC时是否先YGC</td><td>false     </td></tr></tbody></table><h4 id="并行收集器相关参数"><a href="#并行收集器相关参数" class="headerlink" title="并行收集器相关参数"></a>并行收集器相关参数</h4><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>其他</th></tr></thead><tbody><tr><td>-XX:+UseParallelGC</td><td>Full GC采用parallel MSC</td><td></td><td>选择垃圾收集器为并行收集器.此配置仅对年轻代有效.即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集.(此项待验证)</td></tr><tr><td>-XX:+UseParNewGC</td><td>设置年轻代为并行收集</td><td>可与CMS收集同时使用</td><td>JDK5.0以上,JVM会根据系统配置自行设置,所以无需再设置此值</td></tr><tr><td>-XX:ParallelGCThreads</td><td>并行收集器的线程数</td><td>此值最好配置与处理器数目相等</td><td>同样适用于CMS</td></tr><tr><td>-XX:+UseParallelOldGC</td><td>年老代垃圾收集方式为并行收集(Parallel Compacting)</td><td></td><td>这个是JAVA 6出现的参数选项</td></tr><tr><td>-XX:MaxGCPauseMillis</td><td>每次年轻代垃圾回收的最长时间(最大暂停时间)</td><td></td><td>如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.</td></tr><tr><td>-XX:+UseAdaptiveSizePolicy</td><td>自动选择年轻代区大小和相应的Survivor区比例</td><td></td><td>设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例,以达到目标系统规定的最低相应时间或者收集频率等,此值建议使用并行收集器时,一直打开.</td></tr><tr><td>-XX:GCTimeRatio</td><td>设置垃圾回收时间占程序运行时间的百分比</td><td>公式为1/(1+n)</td></tr><tr><td>-XX:+ScavengeBeforeFullGC</td><td>Full GC前调用YGC</td><td>true</td><td>Do young generation GC prior to a full GC. (Introduced in 1.4.1.)</td></tr></tbody></table><h4 id="CMS相关参数"><a href="#CMS相关参数" class="headerlink" title="CMS相关参数"></a>CMS相关参数</h4><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>其他</th></tr></thead><tbody><tr><td>-XX:+UseConcMarkSweepGC</td><td>使用CMS内存收集</td><td></td><td>测试中配置这个以后,-XX:NewRatio=4的配置失效了,原因不明.所以,此时年轻代大小最好用-Xmn设置.???</td></tr><tr><td>-XX:+AggressiveHeap</td><td>试图是使用大量的物理内存</td><td></td><td>长时间大内存使用的优化，能检查计算资源（内存， 处理器数量）至少需要256MB内存大量的CPU／内存， （在1.4.1在4CPU的机器上已经显示有提升）</td></tr><tr><td>-XX:CMSFullGCsBeforeCompaction</td><td>多少次后进行内存压缩</td><td></td><td>由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生”碎片”,使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理.</td></tr><tr><td>-XX:+CMSParallelRemarkEnabled</td><td>降低标记停顿</td><td></td></tr><tr><td>-XX+UseCMSCompactAtFullCollection</td><td>在FULL GC的时候， 对年老代的压缩         CMS是不会移动内存的， 因此， 这个非常容易产生碎片， 导致内存不够用， 因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。</td><td></td><td>可能会影响性能,但是可以消除碎片</td></tr><tr><td>-XX:+UseCMSInitiatingOccupancyOnly</td><td>使用手动定义初始化定义开始CMS收集         禁止hostspot自行触发CMS GC</td><td></td><td></td></tr><tr><td>-XX:CMSInitiatingOccupancyFraction=70</td><td>使用cms作为垃圾回收</td></tr><tr><td>使用70％后开始CMS收集</td><td>92</td><td>为了保证不出现promotion failed(见下面介绍)错误,该值的设置需要满足以下公式CMSInitiatingOccupancyFraction计算公式</td></tr><tr><td>-XX:CMSInitiatingPermOccupancyFraction</td><td>设置Perm Gen使用到达多少比率时触发</td><td>92     </td></tr><tr><td>-XX:+CMSIncrementalMode</td><td>设置为增量模式</td><td>用于单CPU情况</td></tr><tr><td>-XX:+CMSClassUnloadingEnabled</td><td></td></tr></tbody></table><h4 id="辅助信息"><a href="#辅助信息" class="headerlink" title="辅助信息"></a>辅助信息</h4><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>其他</th></tr></thead><tbody><tr><td>-XX:+PrintGC</td><td></td><td></td><td>输出形式:[GC 118250K-&gt;113543K(130112K), 0.0094143secs][Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</td></tr><tr><td>-XX:+PrintGCDetails</td><td></td><td></td><td>输出形式:[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs][GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs]</td></tr><tr><td>-XX:+PrintGCTimeStamps</td><td></td><td></td><td></td></tr><tr><td>-XX:+PrintGC:PrintGCTimeStamps</td><td>可与-XX:+PrintGC -XX:+PrintGCDetails混合使用</td><td></td><td>输出形式:11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs]</td></tr><tr><td>-XX:+PrintGCApplicationStoppedTime</td><td>打印垃圾回收期间程序暂停的时间.可与上面混合使用</td><td></td><td>输出形式:Total time for which application threads were stopped: 0.0468229 seconds</td></tr><tr><td>-XX:+PrintGCApplicationConcurrentTime</td><td>打印每次垃圾回收前,程序未中断的执行时间.可与上面混合使用</td><td></td><td>输出形式:Application time: 0.5291524 seconds</td></tr><tr><td>-XX:+PrintHeapAtGC</td><td>打印GC前后的详细堆栈信息          </td></tr><tr><td>-Xloggc:filename</td><td>把相关日志信息记录到文件以便分析.与上面几个配合使用          </td></tr><tr><td>-XX:+PrintClassHistogram</td><td>garbage collects before printing the histogram.         </td></tr><tr><td>-XX:+PrintTLAB</td><td>查看TLAB空间的使用情况          </td></tr><tr><td>XX:+PrintTenuringDistribution</td><td>查看每次minor GC后新的存活周期的阈值</td><td>Desired survivor size 1048576 bytes, new threshold 7 (max 15)</td><td>new threshold 7即标识新的存活周期的阈值为7。</td></tr></tbody></table><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>   又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量；方法区中包含的都是在程序中永远的唯一的元素。特别说明的是枚举<br>   是存放在方法区，而单例是某个类在内存中唯一的对象实例，是存放在堆中的。</p><h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><p> -XX:PermSize=10M -XX:MaxPermSize=10M</p><ul><li>值得一提的是 JAVA8 将方法区 改成了 MateSpace (元数据区。) 同时 PerSize MaxPermSize参数也移除了。<br>带来了几个新的参数：<ol><li>-XX:MetaspaceSize，class metadata的初始空间配额，以bytes为单位，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当的降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize（如果设置了的话），适当的提高该值。</li><li>-XX:MaxMetaspaceSize，可以为class metadata分配的最大空间。默认是没有限制的。</li><li>-XX:MinMetaspaceFreeRatio,在GC之后，最小的Metaspace剩余空间容量的百分比，减少为class metadata分配空间导致的垃圾收集</li><li>-XX:MaxMetaspaceFreeRatio,在GC之后，最大的Metaspace剩余空间容量的百分比，减少为class metadata释放空间导致的垃圾收集XX:MaxMetaspaceSize<h3 id="总结图"><a href="#总结图" class="headerlink" title="总结图"></a>总结图</h3></li></ol></li></ul><p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1507544256116.png?imageView2/2/w/730/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;jvm内存区域分三种：栈，堆，方法区。设计上Java还可以使用到直接内存，在Java NIO包里使用DirectBuffer可以显示地调用申请堆外内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
      <category term="jvm" scheme="http://www.lilhui.com/categories/java/jvm/"/>
    
    
      <category term="java" scheme="http://www.lilhui.com/tags/java/"/>
    
      <category term="jvm调优" scheme="http://www.lilhui.com/tags/jvm%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>redis简介</title>
    <link href="http://www.lilhui.com/2017/09/26/redis/redis_2/"/>
    <id>http://www.lilhui.com/2017/09/26/redis/redis_2/</id>
    <published>2017-09-26T10:12:59.000Z</published>
    <updated>2017-09-26T10:13:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><blockquote><p>Redis 是一个非常快速的非关系内存型数据库。Redis非常有区分度的是它提供的5种不同类型的数据结构，其数据结构是有针对地为解决问题而生的数据结构，区分于其他数据库的一个显著特点。可以说，Redis核心问题和功能都围绕着五种数据结构展开的，另外，它方便的扩展功能，可以支持到数百GB级数据。</p></blockquote><h3 id="与其他数据库和软件的对比"><a href="#与其他数据库和软件的对比" class="headerlink" title="与其他数据库和软件的对比"></a>与其他数据库和软件的对比</h3><p> Redis的特点决定了它在存储工具里的定位，它经常被用来与其他数据库进行对比。这里，我们介于内存键值存储 Memcached 与MongoDB对Redis进行一次比较。</p><table><thead><tr><th>名称</th><th>类型</th><th>存储</th><th>查询</th><th>附加功能</th></tr></thead><tbody><tr><td>Redis</td><td>内存存储（in-memmory)的非关系数据库</td><td>字符串,列表，集合，散列表，有序集合</td><td>每种数据类型都有自己的专属命令，还有批操作和不完整的事务支持</td><td>发布与订阅，主从复制，持久化，脚本</td></tr><tr><td>Memcached</td><td>使用内存存储的键值缓存</td><td>键值之间的映射</td><td>创建，读取，更新删除等命令</td><td>多线程服务支持</td></tr><tr><td>MongoDB</td><td>硬盘存储的非关系文档存储</td><td>每个数据库可以包含多个个表，每个表包含多个schema 的BSON文档</td><td>更新，读取，删除，条件查询等命令</td><td>支持map-reduce操作，主从复制，分片，空间索引（spatial index）</td><td></td></tr></tbody></table><h3 id="使用Redis的理由"><a href="#使用Redis的理由" class="headerlink" title="使用Redis的理由"></a>使用Redis的理由</h3><p>Redis之于缓存界：使用memcached 时，没有原生的列表结构，只能用Append命令将数据添加到已有字符串末尾。可以认为那个字符串就是一个列表。但是删除这些就比较困难了。memcached采用的办法是通过黑名单来隐藏列表里的元素，从而避免对元素进行读取，更新，写入。相反地，Redis的LIST和SET允许用户直接添加或者删除元素。</p><hr><p>Redis之于数据库：当数据库用于存储长期数据报告，报表。并将这些数据作为固定时间范围内聚合。数据库的做法是：将各个行插入一个报表中，通过扫描这些行进行聚合数据。这样就要频繁地对表里数据进行</p><hr><p>读，写。Redis可以使用原子的INCR命令来进行聚合计算。并且Redis存储在内存里。并且查询不通过数据库的分析器，查询优化器等，所以对Redis存储的数据行随机写的速度是非常迅速的。<br>Redis之于NoSql数据库：避免写入不必要的临时数据。免去了临时数据进行扫描删除的麻烦。可以改上程序的性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis简介&quot;&gt;&lt;a href=&quot;#Redis简介&quot; class=&quot;headerlink&quot; title=&quot;Redis简介&quot;&gt;&lt;/a&gt;Redis简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Redis 是一个非常快速的非关系内存型数据库。Redis非常有区分度的是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HttpURLConnection Post请求自动重传机制</title>
    <link href="http://www.lilhui.com/2017/09/26/java/java_1/"/>
    <id>http://www.lilhui.com/2017/09/26/java/java_1/</id>
    <published>2017-09-26T10:01:22.000Z</published>
    <updated>2017-09-27T10:21:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景故事"><a href="#背景故事" class="headerlink" title="背景故事"></a>背景故事</h2><blockquote><p>之前负责的一个商城项目，需要从供应商库进行订单下单同步，服务器间通讯通过http请求。 加密方式采用DES加密方式。在运行初期一切正常，几个月后<br>供应商发现有重复订单存在，而客户端这边接收到异常生成订单异常信息，订单生成不同步。供应商的处理逻辑我们无从得知，只能从自身角度思考为什么会有这<br>种问题，在排除了一系列原因后，定位到一个问题。那就是 HttpURLConnection的post请求重发机制。</p></blockquote><h2 id="场景再现"><a href="#场景再现" class="headerlink" title="场景再现"></a>场景再现</h2><p>Http请求是通过HttpUrlConnection封装的一套Java请求客户端 部分源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> <span class="comment">//请求的header如下</span></div><div class="line"> <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">getDefaultHeaders</span><span class="params">()</span> </span>&#123;</div><div class="line">     Map&lt;String, Object&gt; defaultHeaders = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">     defaultHeaders.put(<span class="string">"Accept"</span>, <span class="string">"*/*"</span>);</div><div class="line">     defaultHeaders.put(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</div><div class="line">     defaultHeaders.put(<span class="string">"User-Agent"</span>, <span class="string">"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1)"</span>);</div><div class="line">     defaultHeaders.put(<span class="string">"Accept-Charset"</span>, <span class="string">"utf-8"</span>);</div><div class="line">     defaultHeaders.put(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded;charset=utf-8"</span>);</div><div class="line">     headers = defaultHeaders;</div><div class="line">     <span class="keyword">return</span> headers;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="comment">//初始化 httpConnection</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">     <span class="keyword">if</span> (<span class="string">"POST"</span>.equals(method)) &#123;</div><div class="line">         <span class="keyword">this</span>.url = <span class="keyword">new</span> URL(getUrl);</div><div class="line">         <span class="keyword">this</span>.postJson = JsonUtil.toJson(param);</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         <span class="keyword">this</span>.url = <span class="keyword">new</span> URL(getUrl + urlParams);</div><div class="line">     &#125;</div><div class="line">     httpConnection = (HttpURLConnection) url.openConnection();</div><div class="line">     <span class="keyword">for</span> (String keyset : headers.keySet()) &#123;</div><div class="line">         httpConnection.setRequestProperty(keyset, headers.get(keyset).toString());</div><div class="line">     &#125;</div><div class="line">     <span class="comment">/**</span></div><div class="line"><span class="comment">      * 然后把连接设为输出模式。URLConnection通常作为输入来使用，比如下载一个Web页。</span></div><div class="line"><span class="comment">      * 通过把URLConnection设为输出，你可以把数据向你个Web页传送。：</span></div><div class="line"><span class="comment">      */</span></div><div class="line">     httpConnection.setRequestMethod(method);</div><div class="line">     httpConnection.setUseCaches(<span class="keyword">false</span>);</div><div class="line">     <span class="keyword">if</span> (<span class="string">"POST"</span>.equals(method)) &#123;</div><div class="line">         httpConnection.setDoOutput(<span class="keyword">true</span>);</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         httpConnection.setDoOutput(<span class="keyword">true</span>);</div><div class="line">     &#125;</div><div class="line">     httpConnection.setDoInput(<span class="keyword">true</span>);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="comment">//执行Http请求</span></div><div class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">doRequest</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">this</span>.toUrlParams();</div><div class="line">     OutputStreamWriter out = <span class="keyword">null</span>;</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">         <span class="keyword">this</span>.initConnection();</div><div class="line">         <span class="comment">// 一旦发送成功，用以下方法就可以得到服务器的回应：</span></div><div class="line">         String sTotalString;</div><div class="line">         InputStream urlStream;</div><div class="line">         out = <span class="keyword">new</span> OutputStreamWriter(httpConnection.getOutputStream(), charSet);</div><div class="line">         <span class="keyword">if</span> (method.equals(<span class="string">"POST"</span>)) &#123;</div><div class="line">             out.write(<span class="keyword">this</span>.postJson); <span class="comment">//向页面传递数据。post的关键所在！</span></div><div class="line">         &#125;</div><div class="line">         <span class="comment">// remember to clean up</span></div><div class="line">         out.flush();</div><div class="line">         urlStream = httpConnection.getInputStream();</div><div class="line">         logger.debug(<span class="string">"连接状态:"</span> + urlStream.available());</div><div class="line">         <span class="comment">//new InputStreamReader(l_urlStream,)</span></div><div class="line">         sTotalString = IOUtil.in2Str(urlStream, charSet);</div><div class="line">         <span class="keyword">return</span> sTotalString;</div><div class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(e);</div><div class="line">     &#125; <span class="keyword">finally</span> &#123;</div><div class="line">         <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</div><div class="line">             <span class="keyword">try</span> &#123;</div><div class="line">                 out.close();</div><div class="line">             &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                 e.printStackTrace();</div><div class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(e);</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">         httpConnection.disconnect();</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>Java代码调用doRequest通过HttpUrlConnection模拟一个Post请求。结果服务端会收到两次请求。</p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>HttpURLConnection 采用 Sun 私有的一个 HTTP 协议实现类： HttpClient.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">parseHTTP</span><span class="params">(MessageHeader var1, ProgressSource var2, HttpURLConnection var3)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">this</span>.serverInput = <span class="keyword">this</span>.serverSocket.getInputStream();</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.capture != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">this</span>.serverInput = <span class="keyword">new</span> HttpCaptureInputStream(<span class="keyword">this</span>.serverInput, <span class="keyword">this</span>.capture);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">this</span>.serverInput = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">this</span>.serverInput);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.parseHTTPHeader(var1, var2, var3);</div><div class="line">        &#125; <span class="keyword">catch</span> (SocketTimeoutException var6) &#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.ignoreContinue) &#123;</div><div class="line">                <span class="keyword">this</span>.closeServer();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">throw</span> var6;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException var7) &#123;</div><div class="line">            <span class="keyword">this</span>.closeServer();</div><div class="line">            <span class="keyword">this</span>.cachedHttpClient = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">if</span>(!<span class="keyword">this</span>.failedOnce &amp;&amp; <span class="keyword">this</span>.requests != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">this</span>.failedOnce = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">if</span>(!<span class="keyword">this</span>.getRequestMethod().equals(<span class="string">"CONNECT"</span>) &amp;&amp; !<span class="keyword">this</span>.streaming &amp;&amp; (!var3.getRequestMethod().equals(<span class="string">"POST"</span>) || retryPostProp)) &#123;</div><div class="line">                    <span class="keyword">this</span>.openServer();</div><div class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>.needsTunneling()) &#123;</div><div class="line">                        MessageHeader var5 = <span class="keyword">this</span>.requests;</div><div class="line">                        var3.doTunneling();</div><div class="line">                        <span class="keyword">this</span>.requests = var5;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">this</span>.afterConnect();</div><div class="line">                    <span class="keyword">this</span>.writeRequests(<span class="keyword">this</span>.requests, <span class="keyword">this</span>.poster);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.parseHTTP(var1, var2, var3);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">throw</span> var7;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>当发生IOException就会执行判断是否进行重试。<br>failedOnce 默认是 false，表示是否已经失败过一次了。这也就限制了最多发送 2 次请求。<br>var3 是请求信息<br>retryPostProp 默认是 true ，可以通过命令行参数( -Dsun.net.http.retryPost=false )来指定值。<br>streaming：默认 false 。 true if we are in streaming mode (fixed length or chunked) 。</p><p>bug链接：<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6427251" target="_blank" rel="external">http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6427251</a><br>这个Bug很早就有了，归根结底原因就是sun提供的实现与Http对于Post请求的规范有不同。Http协议里Post不是幂等的，不能进行重试。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>使用Apache Client请求</li><li>修改JVM启动参数 添加：-Dsun.net.http.retryPost=false</li></ol><p><a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6427251" target="_blank" rel="external">http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6427251</a></p><h2 id="总结心得"><a href="#总结心得" class="headerlink" title="总结心得"></a>总结心得</h2><ul><li>http协议方面：http规定的部分是规范，实现有千种方法。有的符合协议，有的又有所区别，在对接过程中，指定接入方式，形成书面文档规范。有利于后续<br>问题职责归属。</li><li>在寻找问题方面，无法完整获取所有信息时，从已掌握的信息出发，避免任何一点得出结论的依据。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景故事&quot;&gt;&lt;a href=&quot;#背景故事&quot; class=&quot;headerlink&quot; title=&quot;背景故事&quot;&gt;&lt;/a&gt;背景故事&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;之前负责的一个商城项目，需要从供应商库进行订单下单同步，服务器间通讯通过http请求。 加密方式采
      
    
    </summary>
    
      <category term="java" scheme="http://www.lilhui.com/categories/java/"/>
    
    
      <category term="java" scheme="http://www.lilhui.com/tags/java/"/>
    
      <category term="http" scheme="http://www.lilhui.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>solr 的ecismax插件扩展方式</title>
    <link href="http://www.lilhui.com/2017/09/19/search/solr_2/"/>
    <id>http://www.lilhui.com/2017/09/19/search/solr_2/</id>
    <published>2017-09-19T09:54:07.000Z</published>
    <updated>2017-09-26T09:38:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>solr 通过插件的方式实现对edismax的支持。在熟悉了solr插件的执行流程后我，我们也可以对solr插件功能进行定制。实现更加强大的功能。</p></blockquote><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><ul><li>ExtendedDismaxQParserPlugin</li></ul><p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1505899037285.png?imageView2/2/w/531/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p><ol><li>NamedListInitializedPlugin 作用<br>NameList作为solr存储map的方式，可以看成是一个key value容器。<br>NameListInitializedPlugin是可以通过NameList初始化的插件。只有一个init方法。接收NameList参数。</li><li>SolrInfoMBean 作用<br>提供Solr后台基础信息的Bean接口。<br>3：QparserPlugin<br>所有插件的父类，定义了默认方法，保存声明了所有solr已经实现的plugin。</li></ol><ul><li>ExtendedDismaxQparser</li></ul><p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1505899337351.png?imageView2/2/w/266/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片">  </p><p>ExtendDismaxQparser<br>描述edismax支持的配置和方法，集合了edismax所需功能的各种操作。并创建 ExtendedSolrDismaxQueryParser,为其提供职责更为简明的操作环境。是edismax语法支持类。</p><ul><li>ExtendSolrQueryParser</li></ul><p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1505900285118.png?imageView2/2/w/393/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p><ol><li><p>QueryBuilder<br>lucene 提供用于创建查询器的工厂类</p><p>可以被当做自定义解析器的子类，使得查询解析器更容易地集成到分析链中。生成查询可以定制化。<br>所有默认lucene提供的query在这里创建</p></li></ol><ol><li><p>SolrQueryParserBase<br>Solr继承自QueryBuilder的类。作为Solr标准查询解析器的父类。Solr对lucene的扩展，加入了 MagicFieldName RawQuery等支持。初始化时读入 schema配置。可以修改这个类来扩展schema标签功能。</p></li><li><p>QueryParser<br>默认的query解析器</p></li><li>SolrQueryParser<br>Solr’s 的默认查询解析器schema驱动的经典lucene查询解析方式。</li><li>ExtendedSolrQueryParser<br>作为ExtendedSolrQParser的内部类存在。实施最终的查询解析。</li></ol><h2 id="请求过程"><a href="#请求过程" class="headerlink" title="请求过程"></a>请求过程</h2><p>SolrDispatchFilter（doFilter,execute）</p><p>-&gt;SolrCore.execute</p><p>-&gt;RequestHandlerBase.handleRequest</p><p>-&gt;SearchHandler.handleRequestBody<br>//有可能执行多个Component<br>//query,facet,group等等，这里每个查询特性对应每个SearchComponent<br>-&gt;QueryComponent.process</p><p>-&gt;SolrIndexSearcher(search,getDocListC)  </p><blockquote><p>描述<br>edismax请求到 SearchHandler 分析调用的SearchComponent链，其中QueryComponent 通过defType选择 插件ExtendedDismaxQParserPlugin 创建queryParser初始化插件paraer</p></blockquote><p>QueryComponent prepare调用<br>QParser rqparser = QParser.getParser(rankQueryString, defType, req);<br>先解析出参数语法包含的解析器信息</p><p> QueryComponent 源码部分 关键方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> QParser <span class="title">getParser</span><span class="params">(String qstr, String defaultParser, SolrQueryRequest req)</span> <span class="keyword">throws</span> SyntaxError </span>&#123;</div><div class="line">  ...</div><div class="line"> <span class="comment">//存在字符 &#123;！需要分析参数需要什么样的查询解析器选定信息</span></div><div class="line"> <span class="keyword">if</span> (qstr != <span class="keyword">null</span> &amp;&amp; qstr.startsWith(QueryParsing.LOCALPARAM_START)) &#123;</div><div class="line">   localParams = <span class="keyword">new</span> ModifiableSolrParams();</div><div class="line">   localParamsEnd = QueryParsing.parseLocalParams(qstr, <span class="number">0</span>, localParams, globalParams);</div><div class="line"></div><div class="line">   String val = localParams.get(QueryParsing.V);</div><div class="line">   <span class="keyword">if</span> (val != <span class="keyword">null</span>) &#123;</div><div class="line">     <span class="comment">// val was directly specified in localParams via v=&lt;something&gt; or v=$arg</span></div><div class="line">     valFollowedParams = <span class="keyword">false</span>;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">     <span class="comment">// use the remainder of the string as the value</span></div><div class="line">     valFollowedParams = <span class="keyword">true</span>;</div><div class="line">     val = qstr.substring(localParamsEnd);</div><div class="line">     localParams.set(QueryParsing.V, val);</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line"> ...</div><div class="line"> </div><div class="line"> <span class="comment">//localParams 语法解析出来的localParams是否需要特殊的解析器来解析查询。</span></div><div class="line">  <span class="keyword">if</span> (localParams == <span class="keyword">null</span>) &#123;</div><div class="line">   parserName = defaultParser;</div><div class="line"> &#125; <span class="keyword">else</span> &#123;</div><div class="line">   <span class="comment">//显示的defType与解析出来的信息一起判断优先级来选定解析器名称</span></div><div class="line">   parserName = localParams.get(QueryParsing.TYPE,defaultParser);</div><div class="line">   qstr = localParams.get(<span class="string">"v"</span>);</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> parserName = parserName==<span class="keyword">null</span> ? QParserPlugin.DEFAULT_QTYPE : parserName;</div><div class="line"> <span class="comment">//确定后通过名称获取解析插件</span></div><div class="line"> QParserPlugin qplug = req.getCore().getQueryPlugin(parserName);</div><div class="line"> QParser parser =  qplug.createParser(qstr, localParams, req.getParams(), req);</div><div class="line"> ...</div><div class="line"> <span class="keyword">return</span> parser;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>对edisMax查询操作，QueryComponet返回了 ExtendDismaxQparser 作为查询解析器作为后续的查询支持 。<br>默认解析器 lucene  </p><h2 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h2><p>扩展步骤：<br>1:新建 XXPlugin 继承 QParserPlugin<br> 实现方法：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义插件名称，用于配置指定</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> String NAME = <span class="string">"XXXqueryPlus"</span>;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> QParser <span class="title">createParser</span><span class="params">(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XXXQParser(qstr, localParams, params, req);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>2:创建XXXQParser继承QParser, XXXSolrQueryParser继承SolrQueryParser<br>可以采用组合方式，也可以采用内部类的方式。在XXXQParser里重写 parser()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Query <span class="title">parse</span><span class="params">()</span> <span class="keyword">throws</span> SyntaxError </span>&#123;</div><div class="line">    <span class="comment">//返回具体的 查询Query</span></div><div class="line">    <span class="comment">//可以结合XXXSolrQueryParser方法返回.</span></div><div class="line">    <span class="comment">//this.parser() --&gt; XXSolrQueryParser.parser()。</span></div><div class="line">    <span class="comment">//提交给 SolrQuerybase执行，只要根据需要重写 SolrQueryBase里的</span></div><div class="line">    <span class="comment">//    protected Query getFieldQuery(String field, String queryText, //boolean quoted, boolean raw)方法即可。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>3:solrConfig里配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">requestHandler</span> <span class="attr">name</span>=<span class="string">"standard"</span> <span class="attr">class</span>=<span class="string">"solr.SearchHandler"</span> <span class="attr">default</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">lst</span> <span class="attr">name</span>=<span class="string">"defaults"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">str</span> <span class="attr">name</span>=<span class="string">"defType"</span>&gt;</span>XXXqueryPlus<span class="tag">&lt;/<span class="name">str</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">lst</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">requestHandler</span>&gt;</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;solr 通过插件的方式实现对edismax的支持。在熟悉了solr插件的执行流程后我，我们也可以对solr插件功
      
    
    </summary>
    
      <category term="搜索" scheme="http://www.lilhui.com/categories/%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="solr" scheme="http://www.lilhui.com/tags/solr/"/>
    
      <category term="edismax" scheme="http://www.lilhui.com/tags/edismax/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构介绍</title>
    <link href="http://www.lilhui.com/2017/09/18/redis/Redisshujujiegou/"/>
    <id>http://www.lilhui.com/2017/09/18/redis/Redisshujujiegou/</id>
    <published>2017-09-18T09:20:47.000Z</published>
    <updated>2017-10-09T02:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis数据结构介绍"><a href="#Redis数据结构介绍" class="headerlink" title="Redis数据结构介绍"></a>Redis数据结构介绍</h2><blockquote><p>Redis数据结构分为 STRING,LIST,SET,HASH,ZSET五种。与其他数据库或者缓存有相互对应关系。又有他自己的特点。</p></blockquote><table><thead><tr><th>结构类型</th><th>值类型</th><th>读写能力</th></tr></thead><tbody><tr><td>STRING</td><td>字符串，整数，浮点数，基本类型</td><td>对整个字符串或者字符串其中的一部分进行操作，对整数和浮点数进行自增或者自减</td></tr><tr><td>LIST</td><td>一个链表，链表上的每个节点都包含了一个字符串</td><td>从链表的两端推入或者弹出元素，根据偏移量对链表进行修剪，读取单个或者多个元素；根据值查找或者移除元素</td></tr><tr><td>SET</td><td>包含字符串的无序搜集器（unordered collection)，并且被包含的每个字符串都是独一无二，各不相同的</td><td>添加，获取，移除单个元素；检查一个元素是否存在于集合中；计算交集，并集，差集；从集合里随机获取元素</td></tr><tr><td>HASH</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对；获取所有键值对</td></tr><tr><td>ZSET(有序集合)</td><td>字符串成员（member）与浮点数值（score）之间的有序映射，元素的排列顺序由分值的大小决定</td><td>添加、获取、删除、单个元素；根据分值范围（染个）或者成员来获取元素</td></tr></tbody></table><h3 id="字符串（STRING"><a href="#字符串（STRING" class="headerlink" title="字符串（STRING)"></a>字符串（STRING)</h3><p>基本操作：</p><table><thead><tr><th>命令</th><th>行为</th></tr></thead><tbody><tr><td>GET</td><td>获取存储在给定键值中的值</td></tr><tr><td>SET</td><td>设置存储在给定键中的值</td></tr><tr><td>DEL</td><td>删除存储在给定键中的值（所有类型适用）</td></tr></tbody></table><h3 id="列表（List"><a href="#列表（List" class="headerlink" title="列表（List)"></a>列表（List)</h3><p>基本操作：</p><table><thead><tr><th>命令</th><th>行为</th></tr></thead><tbody><tr><td>RPUSH</td><td>给定的值推入列表的右端</td></tr><tr><td>LRANGE</td><td>获取列表在给定范围上的所有值</td></tr><tr><td>LINDEX</td><td>获取在列表给定位置上的单个元素</td></tr><tr><td>LPOP</td><td>从列表的左端弹出一个值，并返回被弹出的值</td></tr></tbody></table><h3 id="集合（SET）"><a href="#集合（SET）" class="headerlink" title="集合（SET）"></a>集合（SET）</h3><blockquote><p>和集合一样可以存储多个字符串，不同的是 列表中可以村粗多个相同的字符串。而集合则通过使用散列来保证自己存储的每个字符串都是各自不同的（这些散列只有键没有键值）</p></blockquote><p>基本操作：</p><table><thead><tr><th>命令</th><th>行为</th></tr></thead><tbody><tr><td>SADD</td><td>将给定元素添加到集合</td></tr><tr><td>SMEMBERS</td><td>返回集合包含的所有元素</td></tr><tr><td>SISMEMBER</td><td>检查给定元素是存在于集合中</td></tr><tr><td>SREM</td><td>如果给定的元素存在于集合中，那么移除这个元素</td></tr></tbody></table><p>另外的操作<br>SINTER,SUNION, SDIFF 分别执行交集计算、并集计算和差集计算。</p><h3 id="散列（HASH）"><a href="#散列（HASH）" class="headerlink" title="散列（HASH）"></a>散列（HASH）</h3><blockquote><p>Redis的散列可以存储多个键值间的映射。其值，可以是字符串有可以是数字值。也可以对散列存储的值进行自增或自减。</p><p>散列在很多方面就是一个缩小版的Redis，不少字符串都有相应的散列版本。</p></blockquote><p>基本操作：</p><table><thead><tr><th>命令</th><th>行为</th></tr></thead><tbody><tr><td>HSET</td><td>在散列里面关联起给定的键值对</td></tr><tr><td>HGET</td><td>获取指定散列键的值</td></tr><tr><td>HGETALL</td><td>获取散列包含所有键值对</td></tr><tr><td>HDEL</td><td>如果给定键存在于散列里，那么移除这个键</td></tr></tbody></table><p>Redis的散列可以看做文档数据库里的文档，在开发过程中可以很好的对应。在关系书库里可以看做关系数据库里的行。散列、文档、数据行这三者都允许用户同时访问或者修改一个火多个域。</p><h3 id="有序集（ZSET）"><a href="#有序集（ZSET）" class="headerlink" title="有序集（ZSET）"></a>有序集（ZSET）</h3><blockquote><p>和散列一样，有序集都用于存储键值对：有序集合的键称为 成员（member）每个成员都各不相同；有序集的值被称为分值（score）必须为浮点数。是唯一一个可以根据成员访问元素，又可以根据分值以及分值的排序来访问元素的结构。</p></blockquote><p>基本操作：</p><table><thead><tr><th>命令</th><th>行为</th></tr></thead><tbody><tr><td>ZADD</td><td>将一个带有给定成分值的成员添加到有序集合里</td></tr><tr><td>ZRANGE</td><td>根据元素在有序排列中所处处的位置，从有序集合中获取多个元素</td></tr><tr><td>ZRANGEBYSCORE</td><td>获取有序集合给定分值范围内的所有属性</td></tr><tr><td>ZREM</td><td>如果给定成员存在，移除这个成员</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis数据结构介绍&quot;&gt;&lt;a href=&quot;#Redis数据结构介绍&quot; class=&quot;headerlink&quot; title=&quot;Redis数据结构介绍&quot;&gt;&lt;/a&gt;Redis数据结构介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Redis数据结构分为 STRING,LI
      
    
    </summary>
    
      <category term="缓存" scheme="http://www.lilhui.com/categories/%E7%BC%93%E5%AD%98/"/>
    
      <category term="Redis" scheme="http://www.lilhui.com/categories/%E7%BC%93%E5%AD%98/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.lilhui.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Mysql缓存与Memcached,Redis区别</title>
    <link href="http://www.lilhui.com/2017/09/18/mysql/Mysql_1/"/>
    <id>http://www.lilhui.com/2017/09/18/mysql/Mysql_1/</id>
    <published>2017-09-18T08:09:31.000Z</published>
    <updated>2017-09-19T01:23:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>我们在做Web开发的时候从至上而下的技术分层里，缓存始终贯穿其中。浏览器层–》业务层–》数据库层。每个层面上的缓存都有各自的功能与场景。我们今天探讨下业务层到数据库层上缓存的功能和区别。</p></blockquote><h2 id="业务层缓存"><a href="#业务层缓存" class="headerlink" title="业务层缓存"></a>业务层缓存</h2><h3 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h3><p>Memcached 严格上讲还不能说是完整的分布式缓存系统。它有很多第三方工具支撑其分布式功能。<br>Memcached 通过内部固定的大小的chunk预申请内存数据。使得分配和回收内存的效率很高。读写性能也很高。64k对象的情况下，单机QPS可以达到15W以上。<br>Memcached 的集群架构中，单个节点对其他节点是相互独立的，没有数据方面的通信。不具备failover能力。<br>Memcached 支持多语言，有相当的稳定性。</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>Redis 显著的特点是不仅支持普通的K，V 类型存储，还支持其独特的 五种数据结构 详见<a href="http://www.lilhui.com/2017/0918/redis/Redis数据结构">Redis数据结构</a><br>Redis 也支持集群，Redis支持的集群是Master-Slave模式。其有点是可以在宕机时切换到备份机。可用性方面有一定的提升。<br>Redis 单纯当做缓存存储在内存时速度和Memcached不相上下。存储到硬盘时，性能和速度会下降很多，介于 Memcahced 和mysql之间。<br>Redis 有特殊的订阅功能，使得它经常被用于当做内存队列使用。<br>Redis 扩展方面不如Memcached，无法做到持续的线性扩容。目前支持通过复制的方式，产生一主多备架构并升级容量。</p><h2 id="数据库层缓存"><a href="#数据库层缓存" class="headerlink" title="数据库层缓存"></a>数据库层缓存</h2><h3 id="mysql缓存"><a href="#mysql缓存" class="headerlink" title="mysql缓存"></a>mysql缓存</h3><p>MySQL将缓存分为Buffer缓存和Cache缓存。<br>Buffer缓存:<br>由于硬盘的写入速度过慢，或者频繁的I/O，对于硬盘来说是极大的效率浪费。那么可以等到缓存中储存一定量的数据之后，一次性的写入到硬盘中。Buffer 缓存主要用于写数据，提升I/O性能。<br>Cache 缓存:<br>Cache 是在开启缓存功能前提下，在通过的每次sql进行hash计算，生成此条sql的唯一hash作为存储的Key值。SO select是区分大小写的。<br>生成缓存之后，如果涉及的table有任何数据的变动（整个talbe),所有的cache就会被删除。如果Cache缓存已经存储满，则启用LRU算法，进行数据淘汰。淘汰掉最远未使用的数据，从而开辟新的存储空间。<br>不过对于特大型的网站，依靠这种策略很难缓解高频率的读请求，一般会把访问非常频繁的数据静态化，直接由nginx返还给用户。<br>程序和数据库I/O设备交互的越少，则效率越高。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="既然有Memcached-Redis-为什么还要用Mysql缓存呢？"><a href="#既然有Memcached-Redis-为什么还要用Mysql缓存呢？" class="headerlink" title="既然有Memcached,Redis 为什么还要用Mysql缓存呢？"></a>既然有Memcached,Redis 为什么还要用Mysql缓存呢？</h3><ul><li>解答</li></ul><p>从整体架构上看，Memcached和Redis支持扩展分布式缓存。适用于大型Web项目。<br>单从单节点功能上看，Mysql由于自身的cache 删除方式。使得其缓存有相对的局限性。并且无法简单的管控。需要更好的使用的话，需要对业务上进行更详尽细致的分析。<br>在数据库的逻辑设计层面细分出能够说回合mysql缓存的场景。<br>单节点，数据简单，无太多修改的数据面前，但根据场景来，mysql缓存还是有一定价值的。比Memcached Redis简单易用，效率更好。</p><p>参考：<br><a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/5.7/en/query-cache.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我们在做Web开发的时候从至上而下的技术分层里，缓存始终贯穿其中。浏览器层–》业务层–》数据库层。每个层面上的缓存
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.lilhui.com/categories/mysql/"/>
    
    
      <category term="数据库" scheme="http://www.lilhui.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="缓存" scheme="http://www.lilhui.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>linux expect ssh自动登录详解</title>
    <link href="http://www.lilhui.com/2017/09/14/linux/linux%20expect%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.lilhui.com/2017/09/14/linux/linux expect详解/</id>
    <published>2017-09-14T01:40:11.000Z</published>
    <updated>2017-09-14T08:22:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>Expect是用于自动化交互式应用程序的工具，如telnet，ftp，passwd，fsck，rlogin，tip等。使用起来很简单。</p></blockquote><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li>首行加上/usr/bin/expect</li><li>spawn: 后面加上需要执行的shell 命令，比如说spawn sudo touch testfile</li><li>expect: 只有spawn 执行的命令结果才会被expect 捕捉到，因为spawn 会启<br>动一个进程，只有这个进程的相关信息才会被捕捉到，主要包括：标准输入的提<br>示信息，eof 和timeout。</li><li>send 和send_user：send 会将expect 脚本中需要的信息发送给spawn 启动<br>的那个进程，而send_user 只是回显用户发出的信息，类似于shell 中的echo 而<br>已。</li></ol><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>1:远程拷贝文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">set timeout 10</div><div class="line">set host [lindex $argv 0]</div><div class="line">set username [lindex $argv 1]</div><div class="line">set password [lindex $argv 2]</div><div class="line">set src_file [lindex $argv 3]</div><div class="line">set dest_file [lindex $argv 4]</div><div class="line">spawn scp  $src_file $username@$host:$dest_file</div><div class="line">   expect &#123;</div><div class="line">           &quot;(yes/no)?&quot;</div><div class="line">            &#123;</div><div class="line">                send &quot;yes\n&quot;</div><div class="line">                expect &quot;*assword:&quot; &#123; send &quot;$password\n&quot;&#125;</div><div class="line">             &#125;</div><div class="line">           &quot;*assword:&quot;</div><div class="line">             &#123;</div><div class="line">                 send &quot;$password\n&quot;</div><div class="line">             &#125;</div><div class="line">        &#125;</div><div class="line">   expect &quot;100%&quot;</div><div class="line">   expect eof</div></pre></td></tr></table></figure></p><p>2:执行远程命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">set timeout 10</div><div class="line">set host [lindex $argv 0]</div><div class="line">set username [lindex $argv 1]</div><div class="line">set password [lindex $argv 2]</div><div class="line">set cmd [lindex $argv 3]</div><div class="line"></div><div class="line">spawn ssh -t -p $port $username@$host &apos;cmd&apos;  </div><div class="line">   expect &#123;</div><div class="line">       &quot;(yes/no)?&quot;</div><div class="line">            &#123;</div><div class="line">                send &quot;yes\n&quot;</div><div class="line">                expect &quot;*assword:&quot; &#123; send &quot;$password\n&quot;&#125;</div><div class="line">             &#125;</div><div class="line">           &quot;*assword:&quot;</div><div class="line">             &#123;</div><div class="line">                 send &quot;$password\n&quot;</div><div class="line">             &#125;</div><div class="line">        &#125;</div><div class="line">   expect &quot;100%&quot;</div><div class="line">   expect eof</div></pre></td></tr></table></figure></p><p>3：与SSH合用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/usr/bin/expect &lt;&lt;-EOF</div><div class="line">//TODO这里写expect脚本 </div><div class="line">EOF</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Expect是用于自动化交互式应用程序的工具，如telnet，ftp，passwd，fsck，rlogin，tip
      
    
    </summary>
    
      <category term="linux" scheme="http://www.lilhui.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.lilhui.com/tags/linux/"/>
    
      <category term="bash" scheme="http://www.lilhui.com/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>alfred结合七牛实现快速插入markdown格式图片</title>
    <link href="http://www.lilhui.com/2017/09/13/blog/alfred%E7%BB%93%E5%90%88%E4%B8%83%E7%89%9B%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8F%92%E5%85%A5markdown%E6%A0%BC%E5%BC%8F%E5%9B%BE%E7%89%87/"/>
    <id>http://www.lilhui.com/2017/09/13/blog/alfred结合七牛实现快速插入markdown格式图片/</id>
    <published>2017-09-13T03:17:03.000Z</published>
    <updated>2017-09-28T04:00:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/tiann/markdown-img-upload" target="_blank" rel="external">详细过程可以访问：https://github.com/tiann/markdown-img-upload</a></p><h2 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h2><blockquote><p>由于retina截屏的图片会放大，所以在markdown脚本里做了处理：有遇到缩放的会进行指定宽度大小。所以会插入&lt;img 标签。但是这不符合markdown的图片方式，这里做了一下改进。将 计算后的size插入七牛的样式图片里就可以解决。</p></blockquote><p>打开workflow的脚本修改保存<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"><span class="keyword">from</span> clipboard <span class="keyword">import</span> get_paste_img_file</div><div class="line"><span class="keyword">from</span> upload <span class="keyword">import</span> upload_qiniu</div><div class="line"><span class="keyword">import</span> util</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> subprocess</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(util.CONFIG_FILE):</div><div class="line">    util.generate_config_file()</div><div class="line"></div><div class="line">config = util.read_config()</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> config:</div><div class="line">    util.notice(<span class="string">'请先设置你的七牛图床信息'</span>)</div><div class="line">    util.open_with_editor(util.CONFIG_FILE)</div><div class="line">    sys.exit(<span class="number">0</span>)</div><div class="line"></div><div class="line">url = <span class="string">'%s/%s'</span> % (config[<span class="string">'url'</span>], config[<span class="string">'prefix'</span>])</div><div class="line">styleprefix = <span class="string">'imageView2/2/w/'</span></div><div class="line">stylesubfix = <span class="string">'/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim'</span></div><div class="line">mkdprefix=<span class="string">'![图片]('</span></div><div class="line">mkdsubfix=<span class="string">')'</span></div><div class="line">img_file, need_format, format = get_paste_img_file()</div><div class="line"><span class="keyword">if</span> img_file:</div><div class="line">    <span class="comment"># has image</span></div><div class="line"></div><div class="line">    <span class="comment"># use time to generate a unique upload_file name, we can not use the tmp file name</span></div><div class="line"></div><div class="line">    upload_name = <span class="string">"%s.%s"</span> % (int(time.time() * <span class="number">1000</span>), format) </div><div class="line">    <span class="keyword">if</span> need_format:</div><div class="line">        size_str = subprocess.check_output(<span class="string">'sips -g pixelWidth %s | tail -n1 | cut -d" " -f4'</span> % img_file.name, shell=<span class="keyword">True</span>)</div><div class="line">        size = int(size_str.strip()) / <span class="number">2</span></div><div class="line">        <span class="comment">#markdown_url = '&lt;img src="%s/%s-1960" width="%d"/&gt;' % (url, upload_name, size)</span></div><div class="line">    </div><div class="line">        markdown_url = <span class="string">'%s%s/%s?%s%d%s%s'</span> % (mkdprefix, url, upload_name, styleprefix, size, stylesubfix, mkdsubfix)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        markdown_url = <span class="string">'%s%s/%s-960%s'</span> % (mkdprefix, url, upload_name, mkdsubfix)</div><div class="line"></div><div class="line">    <span class="comment"># make it to clipboard</span></div><div class="line">    os.system(<span class="string">"echo '%s' | pbcopy"</span> % markdown_url)</div><div class="line">    os.system(<span class="string">'osascript -e \'tell application "System Events" to keystroke "v" using command down\''</span>)</div><div class="line">    upload_file = util.try_compress_png(img_file, format!=<span class="string">'gif'</span>)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> upload_qiniu(upload_file.name, upload_name): util.notice(<span class="string">"上传图片到图床失败，请检查网络后重试"</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    util.notice(<span class="string">"剪切版里没有图片！"</span>)</div></pre></td></tr></table></figure></p><p>上面是我修改后的脚本信息，修改的地方是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">markdown_url = &apos;%s%s/%s?%s%d%s%s&apos; % (mkdprefix, url, upload_name, styleprefix, size, stylesubfix, mkdsubfix)</div></pre></td></tr></table></figure></p><p>注意这两个变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">styleprefix = &apos;imageView2/2/w/&apos;  </div><div class="line">stylesubfix =&apos;/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim&apos;</div></pre></td></tr></table></figure></p><p>根据自己的七牛图片拼装 markdown_url即可。我这里用的是通过改变七牛提供的链接图片 size 进行替换。<br>中间拼装计算好的原始图片size即变成正常大小。<br>既： styleprefix + size + stylesubfix</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/tiann/markdown-img-upload&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;详细过程可以访问：https://github.com/tiann/markdown-img-uplo
      
    
    </summary>
    
      <category term="blog" scheme="http://www.lilhui.com/categories/blog/"/>
    
    
      <category term="alfred" scheme="http://www.lilhui.com/tags/alfred/"/>
    
      <category term="markdown" scheme="http://www.lilhui.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>solr高级查询edismax函数详解</title>
    <link href="http://www.lilhui.com/2017/09/11/search/solr%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2edismax%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.lilhui.com/2017/09/11/search/solr高级查询edismax函数详解/</id>
    <published>2017-09-11T09:29:43.000Z</published>
    <updated>2017-09-27T06:07:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>最近遇到solr查询中加入字段权重的需求，自然而然地想到了edismax这个功能。通过系统的学习和文档阅读，大概了解solr 对于函数式查询的支持方式。为了便于记忆，这里对常用公式进行整理说明。  </p></blockquote><p>使用方式详细见<a href="https://cwiki.apache.org/confluence/display/solr/The+DisMax+Query+Parser" target="_blank" rel="external">官方文档介绍</a><br>，这里不做说明，我们重点讲solr edismax所涉及到的函数。   </p><h2 id="bf函数列表"><a href="#bf函数列表" class="headerlink" title="bf函数列表"></a>bf函数列表</h2><ol><li><p>constant<br> 支持小数点的常量<br>例如，1.5，查询表达式就是：_val_:1.5</p></li><li><p>fieldvalue<br> 返回numberic field的名字.<br>域必须是index的，非multivalue。格式为该域的名字。如果这个域没值，就返回0</p></li><li><p>ord<br> ord，返回你要查询的那个特定的值在这个顺序中的排名。<br> 非multiValued的，当没有值存在的时候，将返回0<br> 例如：某个特定的域只能去三个值，“apple”、“banana”、“pear”，那么ord（“apple”）=1，ord（“banana”）=2，ord（“pear”）=3<br> 需要注意的是，ord（）这个函数，依赖于值在索引中的位置，所以当有文档被删除、或者添加的时候，ord（）的值就会发生变化。当你使用MultiSearcher的时候，这个值也就是不定的了。</p></li><li>rord<br> 函数将会返回与ord相对应的倒排序的排名。<br> 格式: rord(myIndexedField).</li><li>sum<br> 就是表示多个数值的“和”。  <pre><code>格式：  sum(x,1)  sum(x,y)  sum(sqrt(x),log(y),z,0.5)</code></pre></li><li><p>product<br> 多个参数的乘积，参数可以是数值，也可以是函数，当为函数时，表示为此函数的计算值乘积。<br> 格式：<br> product(x,2)<br> product(x,y)</p></li><li><p>div<br> 两个参数做除法。支持函数参数<br> 格式：<br> div(x,y)<br> div(sum(x,100),max(y,1))</p></li><li>pow<br> 幂值计算，pow(x,y)=x^y 。支持函数参数。<br> 格式：<br> pow(x,0.5) 标识开方<br> pow(x, log(y))</li><li>abs<br> 返回表达式的绝对值，支持函数参数。<br> 格式：<br> abx(-5)<br> abc(x)  </li><li><p>log<br>返回对数操作，支持函数参数。<br>格式：<br>log(x)<br>log(sum(x,100))  </p></li><li><p>sqrt<br>返回平方根。与pow(x，0.5)一样。<br>格式：<br>sqrt(2)<br>sqrt(sum(x,100))</p></li><li><p>map<br>区间检测<br>如果 min&lt;=x&lt;=max，那么map(x,min,max,target)=target，如果x不在[min,max]这个区间内，那么map(x,min,max,target)=x.</p></li><li>scala<br>限制参数区间<br>例如：<br>scale(x,minTarget,maxTarget) 这个函数将会把x的值限制在[minTarget,maxTarget]范围内。</li><li>query<br>计算subquery查询分数<br>例如：<br>query(subquery,default)表示返回给定的subquery的分数，如果subquery与文档不匹配，那么将会返回默认值。任何的查询类型都是受支持的。可以通过引用的方式，也可以直接指定查询串。<br>q=product(popularity, query({!dismax v=’solr rocks’})) 将会返回popularity和通过dismax 查询得到的分数的乘积<br>q=product(popularity, query($qq)&amp;qq={!dismax}solr rocks) 跟上一个例子的效果是一样的。不过这里使用的是引用的方式<br>q=product(popularity, query($qq,0.1)&amp;qq={!dismax}solr rocks) 在前一个例子的基础上又加了一个默认值。</li><li>linear<br>线性函数计算<br>例如：<br>liner(x,m,c)其中 x为变量或者函数，m,c为常量。整个函数取值为： x<em>m+c的值。<br>liner(x,2,4)=2</em>x+4</li><li>recip<br>recip(x,m,a,b) 函数表达式 a/(m*x+b)<br>其中，m、a、b是常量，x是变量或者一个函数。当a=b，并且x&gt;=0的时候，这个函数的最大值是1，值的大小随着x的增大而减小。</li><li>max<br>比较大小<br>例如：max(x,c) x可以为变量或者函数，c为常数，返回两个之间最大值。</li></ol><h2 id="场景应用"><a href="#场景应用" class="headerlink" title="场景应用"></a>场景应用</h2><ol><li><p>某地的新闻网页库中原本的逻辑是对仓库里的数据字段 subject，message进行搜索。默认是通过score检索字段匹配得分进行排序输出。随着时间的推移，大量的搜索可能会展示两年前，三年前匹配度更高的数据，这些搜索结果明显不合适的。那么我们需要对其进行改造，加入发布时间权重排序。</p><p> 原本的参数：  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject:武则天 OR message:武则天</div></pre></td></tr></table></figure><p> 搜索得出结果：  </p><p> <img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1505143414801.png?imageView2/2/w/1225/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"><br> 文档得分：<br> <img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1505143508131.png?imageView2/2/w/913/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p><p> 上面我们可以看到，tid为666811的文档排在第一位，得分27.811375 它的dateline时间是：1239781944明显早于第二位 tid：10364925的 1503334472，得分：26.519054。第三位是 tid:9759987 得分：26.511488。这样的搜索结果显然不是很令人满意的。<br> 开启edismax 加入</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bf=sqrt(log(dateline))^100</div></pre></td></tr></table></figure><p> 搜索得出结果：  </p><p> <img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1505143118475.png?imageView2/2/w/1222/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p><p> 文档得分： </p><p> <img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1505143152722.png?imageView2/2/w/922/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"><br> 经过调整，我们得出的结果中排在第一位的是 tid:9759987 其时间dateline是1473820016 得分：330.85 是原本的第三位。原来的排第一的 tid:666811排在了第三位，得分 329.40 原来的第二tid:10364925 得分：329.50</p><p> 调整后的排序大致满足我们的需求。那么为什么调整后会变成这样的排序呢？</p><p> 首先我们要清楚solr的打分机制默认是通过匹配度计算文档相似度得来的。也就是第一次搜索的默认得分，引入edismax的bf函数后我们来分析下最终的结果是怎样，以第一次搜索排名前三的数据为例子：  </p><p> tid  | dateline | 初始得分 | 引入bf重新计算<br> —|—|—|—<br> 666811 | 1239781944 | 27.811382 | 329.40198<br> 10364925 | 1503334472  | 26.519054 |329.50174<br> 9759987 | 1473820016 | 26.511488 | 330.85834 </p></li></ol><blockquote><p>根据bf=sqrt(log(dateline))^100 分别计算上面三个的新得分  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">sqrt(log(1239781944)) = 3.0155174194591075  </div><div class="line">权重乘100 得:  </div><div class="line">301.55174194591075</div><div class="line">再加 27.811382  </div><div class="line">=329.36312394591073</div><div class="line"></div><div class="line">sqrt(log(1503334472)) = 3.029365546794402</div><div class="line">权重乘100 得:</div><div class="line">302.9365546794402</div><div class="line">再加 26.519054</div><div class="line">=329.45560867944016</div><div class="line"></div><div class="line">sqrt(log(1473820016)) = 3.0279439311841663</div><div class="line">权重乘100 得:</div><div class="line">302.79439311841663</div><div class="line">再加 26.511488</div><div class="line">=329.3058811184166</div></pre></td></tr></table></figure><pre><code>纳尼。很奇怪为什么 9759987 计算最小 不对劲</code></pre><p>于是翻看原来前面查询的debug列表分析仔细看原来是<br>原图：</p><p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1505186205866.png?imageView2/2/w/898/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p><p>添加edismax后：<br><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1505186154351.png?imageView2/2/w/916/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p><p>对比以上靓图，原来是我们的Qparser不一样。在普通查询的时候我么使用的是定制化的 SWMCLuceneQparser 查询解析器。而 用edimax后，解析器变成了 ExtendDismaxQparser 这两个差别在于 定制化的 SWMCLuceneQparser会将查询字段通过IK分词转换后进行查询。其parsedquery_tostring 变成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;parsedquery&quot;:&quot;PhraseQuery(subject:\&quot;武 则 天\&quot;) PhraseQuery(message:\&quot;武 则 天\&quot;)&quot;,</div></pre></td></tr></table></figure></p><p>ExtendDismaxQparser的 parsedquery_tostringshi :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;parsedquery_toString&quot;:&quot;+((subject:武 subject:则 subject:天) (message:武 message:则 message:天)) (sqrt(log(long(dateline))))^10.0&quot;,</div></pre></td></tr></table></figure></p><p>两者稍有不同，所以在计算最终权重的时候有些差异。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;最近遇到solr查询中加入字段权重的需求，自然而然地想到了edismax这个功能。通过系统的学习和文档阅读，大概了
      
    
    </summary>
    
      <category term="搜索" scheme="http://www.lilhui.com/categories/%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="solr" scheme="http://www.lilhui.com/tags/solr/"/>
    
      <category term="edismax" scheme="http://www.lilhui.com/tags/edismax/"/>
    
  </entry>
  
  <entry>
    <title>Hexo技术博客搭建日记</title>
    <link href="http://www.lilhui.com/2017/09/02/blog/hexo%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%97%A5%E8%AE%B0/"/>
    <id>http://www.lilhui.com/2017/09/02/blog/hexo技术博客搭建日记/</id>
    <published>2017-09-02T09:58:27.000Z</published>
    <updated>2017-09-13T06:54:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>9月2号听说Hexo  </p><ul><li><a href="http://blog.didispace.com/books/" target="_blank" rel="external">案例1</a>  </li><li><a href="http://www.itmuch.com" target="_blank" rel="external">案例2</a>  </li></ul><p>9月3号了解Hexo搭建博客方式  </p><ul><li><a href="http://www.youmeek.com/hexo/" target="_blank" rel="external">hexo搭建参考1</a>  </li><li><a href="http://www.jianshu.com/p/a417262815a6" target="_blank" rel="external">hexo搭建参考2</a>  </li><li><a href="https://www.zhihu.com/question/24422335" target="_blank" rel="external">hexo主题</a>  </li></ul><p>9月5号搭建完成</p><p>9月6号添加域名解析</p><p>9月7号添加Gitment评论功能</p><ul><li><a href="https://github.com/littlehui/gitment" target="_blank" rel="external">Gitment的github地址</a>  </li></ul><p>9月9号配置结合alfred + 七牛 快捷插入markdown图片工具</p><ul><li><a href="https://github.com/tiann/markdown-img-upload" target="_blank" rel="external">Github地址</a>  </li></ul><p>9月11号第一篇文章登陆</p><p>9月12号完善主题配置</p><p>9月13日添加站点收录</p><blockquote><p>npm install hexo-generator-sitemap –save<br>  npm install hexo-generator-baidu-sitemap –save</p></blockquote><ul><li><a href="http://www.cnblogs.com/tengj/p/5357879.html" target="_blank" rel="external">搜索引擎站点收录</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;9月2号听说Hexo  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.didispace.com/books/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;案例1&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://ww
      
    
    </summary>
    
      <category term="blog" scheme="http://www.lilhui.com/categories/blog/"/>
    
    
      <category term="Hexo" scheme="http://www.lilhui.com/tags/Hexo/"/>
    
      <category term="IntelliJ IDEA" scheme="http://www.lilhui.com/tags/IntelliJ-IDEA/"/>
    
      <category term="Git" scheme="http://www.lilhui.com/tags/Git/"/>
    
      <category term="Github" scheme="http://www.lilhui.com/tags/Github/"/>
    
  </entry>
  
</feed>
