<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Littlehui&#39;s Notes</title>
  
  <subtitle>天地那么大，世界那么辽阔。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.lilhui.com/"/>
  <updated>2022-06-30T16:31:02.594Z</updated>
  <id>http://www.lilhui.com/</id>
  
  <author>
    <name>Littlehui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Redis学习2】redis持久化，主从，哨兵架构</title>
    <link href="http://www.lilhui.com/2022/06/29/redis/redis_core_2/"/>
    <id>http://www.lilhui.com/2022/06/29/redis/redis_core_2/</id>
    <published>2022-06-29T07:35:00.000Z</published>
    <updated>2022-06-30T16:31:02.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="RDB快照（snapshot"><a href="#RDB快照（snapshot" class="headerlink" title="RDB快照（snapshot)"></a>RDB快照（snapshot)</h3><p>在默认情况下， Redis 将内存数据库快照保存在名字为 dump.rdb 的二进制文件中。 你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”<br>这一条件被满足时， 自动保存一次 数据集。 比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次 数据<br>集： # save 60 1000 //关闭RDB只需要将所有的save保存策略注释掉即可</p><p>还可以手动执行命令生成RDB快照，进入redis客户端执行命令save或bgsave可以生成dump.rdb文件， 每次命令执行都会将所有redis内存快照到一个新的rdb<br>文件里，并覆盖原有rdb快照文件。</p><p><strong>bgsave的写时复制(COW)机制</strong><br>Redis 借助操作系统提供的写时复制技术（Copy-On-Write, COW），在生成快照的同时，依然可以正常 处理写命令。简单来说，bgsave 子进程是由主线程<br>fork 生成的，可以共享主线程的所有内存数据。 bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些 数<br>据也都是读操作，那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据，那 么，这块数据就会被复制一份，生成该数据的副本。然后，<br>bgsave 子进程会把这个副本数据写入 RDB 文 件，而在这个过程中，主线程仍然可以直接修改原来的数据。</p><p><strong>save与bgsave对比</strong></p><table><thead><tr><th>命令</th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>是否阻塞redis其他命令</td><td>是</td><td>否（在生成子进程执行调用fork函数时会有短期阻塞）</td></tr><tr><td>复杂度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>有点</td><td>不会消耗额外内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>需要fork子进程，消耗内存</td></tr></tbody></table><p>配置自动生成rdb文件后台使用的是bgsave方式。</p><ul><li>AOF (append-only file)</li></ul><p>快照功能并不是非常耐久(durable)：如果redis因为某些原因造成故障停机，那么服务器将丢失最近写入、且未保存到快照的那些数据。从1.1版开始<br>Redis增加了一种完全耐久的持久化方式：AOF持久化，将修改的每一条指令记录进文件appendonly.aof中（先写入os cache,每隔一段时间fsync到<br>磁盘）<br>比如执行命令 “set littlehui 666” ，aof记录如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3</span><br><span class="line"><span class="meta">$</span><span class="bash">3 </span></span><br><span class="line">set </span><br><span class="line"><span class="meta">$</span><span class="bash">5 </span></span><br><span class="line">littlehui</span><br><span class="line"><span class="meta">$</span><span class="bash">3 </span></span><br><span class="line">666</span><br></pre></td></tr></table></figure><p>这种是resp协议格式数据，星号后面的数字代表命令有多少个参数。$号后面的数字代表这个参数有几个字符。<br>PS:如果执行带过期的set命令，aof文件记录的并不是原始命令。而是记录这个key的过期时间戳。</p><p>比如执行 “set littlehui 888 ex 1000” aof记录如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*3 </span><br><span class="line"><span class="meta">$</span><span class="bash">3</span></span><br><span class="line">set</span><br><span class="line"><span class="meta">$</span><span class="bash">6</span></span><br><span class="line">littlehui</span><br><span class="line"><span class="meta">$</span><span class="bash">3</span></span><br><span class="line">888</span><br><span class="line">*3</span><br><span class="line"><span class="meta">$</span><span class="bash">9</span></span><br><span class="line">PEXPIREAT </span><br><span class="line"><span class="meta">$</span><span class="bash">6</span></span><br><span class="line">tuling</span><br><span class="line"><span class="meta">$</span><span class="bash">13</span></span><br><span class="line">1604249786301</span><br></pre></td></tr></table></figure></p><p>AOF功能开启：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure></p><p>redis重启时，程序通过执行AOF的命令来进行重加数据集。<br>通过配置修改fsync到磁盘的频次。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always：每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全。</span><br><span class="line">appendfsync everysec：每秒 fsync 一次，足够快，并且在故障时只会丢失 1 秒钟的数据。</span><br><span class="line">appendfsync no：从不 fsync ，将数据交给操作系统来处理。更快，也更不安全的选择。</span><br></pre></td></tr></table></figure></p><p>以上配置为推荐值，可以兼顾速度和安全性。</p><ul><li>AOF重写<br>AOF文件里可能有太多没用指令，所以AOF会定期根据内存的新数据生成aof文件。<br>例如：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;incr readcount</span><br><span class="line">（Integer）1</span><br><span class="line">127.0.0.1:6379&gt;incr readcount</span><br><span class="line">（Integer）2</span><br></pre></td></tr></table></figure></li></ul><p>重写后AOF变成<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3</span><br><span class="line"><span class="meta">$</span><span class="bash">3</span></span><br><span class="line">set</span><br><span class="line"><span class="meta">$</span><span class="bash">2</span></span><br><span class="line">readcount</span><br><span class="line"><span class="meta">$</span><span class="bash">1</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure></p><p><strong>自动重写频率</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> auto‐aof‐rewrite‐min‐size 64mb //aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就 很快，重写的意义不大 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> auto‐aof‐rewrite‐percentage 100 //aof文件自上一次重写后文件大小增长了100%则再次触发重写</span></span><br></pre></td></tr></table></figure></p><table><thead><tr><th>命令</th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>容易丢数据</td><td>根据策略决定</td></tr></tbody></table><p>生产环境可以都启用，redis启动时如果既有rdb文件又有aof文件则优先选择aof文件恢复数据，因为aof 一般来说数据更全一点。</p><h3 id="Redis-4-0混合持久化"><a href="#Redis-4-0混合持久化" class="headerlink" title="Redis 4.0混合持久化"></a>Redis 4.0混合持久化</h3><p>重启 Redis 时，我们很少使用 RDB来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重 放，但是重放 AOF 日志性能相对 RDB来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很 长的时间。 Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。 通过如下配置可以开启混合持久化(必须先开启aof)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure><p>如果开启了混合持久化，AOF在重写时，不再是单纯将内存数据转换为RESP命令写入AOF文件，而是将 重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容和增量的AOF修改内存数据的命令存在一 起，都写入新的AOF文件，新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改 名，覆盖原有的AOF文件，完成新旧两个AOF文件的替换。 于是在 Redis 重启的时候，可以先加载 RDB 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，因此重启效率大幅得到提升。</p><p>混合持久化AOF文件结构</p><p><img src="https://images.lilhui.com/0042927170653d7df11736fd7cbdad67" alt="图片"></p><ul><li>Redis数据备份策略</li></ul><ol><li>写crontab定时调度脚本，每小时都copy一份rdb或aof备份到一个目录中去，仅仅保留最近48小时的备份。</li><li>每天都保留一份当日的数据备份到一个目录中去，可以保留最近1个月的备份。</li><li>每次copy留备份的时候，都把太旧的备份给删了。</li><li>每天晚上将当前机器上的备份复制一份到其他机器上，以防机器损坏。</li></ol><h3 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h3><p><img src="https://images.lilhui.com/bbc61a741bf58968a1eb3d42ae25f2d1" alt="图片"></p><p><strong> redis主从架构搭建，配置从节点步骤 </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、复制一份redis.conf文件</span><br><span class="line">2、将相关配置修改为：</span><br><span class="line">port 6380</span><br><span class="line">pidfile /var/run/redis_6380.pid #把pid进程号写入pidfile配置的文件</span><br><span class="line">logfile "6380.log"</span><br><span class="line">dif /usr/local/redis-5.0.3/data/6380 #指定数据存放目录</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要注释掉<span class="built_in">bind</span> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">bind</span> 127.0.0.1（<span class="built_in">bind</span>绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip，代表允许客户端通 过机器的哪些网卡ip去访问，内网一般可以不配置<span class="built_in">bind</span>，注释掉即可） </span></span><br><span class="line">3、配置主从复制</span><br><span class="line">replicaof 192.168.0.60 6379 # 从本机6379的redis实例复制数据，Redis 5.0之前使用slaveof</span><br><span class="line">replica‐read‐only yes # 配置从节点只读 </span><br><span class="line">4、启动从节点 16 redis‐server redis.conf 1718 5、连接从节点  </span><br><span class="line">redis‐cli ‐p 6380 2021 6、测试在6379实例上写数据，6380实例是否能及时同步新修改数据 </span><br><span class="line">7、可以自己再配置一个6381的从节点</span><br></pre></td></tr></table></figure><h2 id="Redis主从工作原理"><a href="#Redis主从工作原理" class="headerlink" title="Redis主从工作原理"></a>Redis主从工作原理</h2><p>如果你为master配置了一个slave,不管这个slave是否是第一次连上Master，都会发送一个PSYNC命令给master请求复制数据。<br>master收到PSYNC命令后，会再后台进行数据持久化通过bgsave生成最新的rdb快照文件，持久化期间，master会继续接收客户端<br>的请求，它会把这些可能修改数据集的请求缓存在内存中。当持久化进行完毕后，master会把这份rdb文件数据集发送给slave,slave<br>会把接收到的数据进行持久化生成rdb,然后加载到内存中。最后master再将之前缓存在内存中的命令发送给slave.</p><p>当master与slave之间的链接由于某些原因而断开时，slave能够自动重连Master,如果master收到了多个slave并发链接请求，它<br>只会进行一次持久化，而不是一个连接一次，然后再把这一份持久化的数据发送给多个并发连接的slave.</p><ul><li>主从复制（全量复制）流程图</li></ul><p><img src="https://images.lilhui.com/ff66d9de5d9dc974140a149f433647f4" alt="图片"></p><ul><li>数据部分复制</li></ul><p>当master和slave断开重连后，一般会对整个数据进行复制。但从redis2.8版开始，redis改用可以支持部分数据复制的命令PSYNC<br>去master同步数据，slave和master能够在网络连接断开重连后进行部分数据复制（断点续传）</p><p>master会再其内存中创建一个复制数据用的缓存队列，缓存最近一段时间的数据，master和它所有的slave都维护了复制数据下表offset<br>和master的进程ID,因此，当网络连接断开后，slave会请求master offset太久，已经补在master的缓存队列里了。那么将会进行一次<br>全量数据的复制。</p><ul><li>主从断点续传流程图</li></ul><p><img src="https://images.lilhui.com/af577bd4dd5d5aaffcc48b4ad76d3dd7" alt="图片"></p><p>如果有很多从节点，为了环节主从复制风暴（多个节点同时复制主节点导致主节点压力过大可以做一下架构，让部分从节点与从节点同步数据。</p><p><img src="https://images.lilhui.com/84e0a901a219fdb01f0d6172d46f80d4" alt="图片"></p><h2 id="Redis管道与Lua脚本"><a href="#Redis管道与Lua脚本" class="headerlink" title="Redis管道与Lua脚本"></a>Redis管道与Lua脚本</h2><h3 id="管道（pipeline"><a href="#管道（pipeline" class="headerlink" title="管道（pipeline)"></a>管道（pipeline)</h3><p>客户端可以一次性发送多个请求而不用等待服务器的响应，待所有命令都发送完后再一次性读取服务的响应，这样可以极大的降低多条命令执行的网络传输开销，管道执行多条命令的网络开销实际上只相当于一次命令执行的网络开销。需要注意到是用pipeline方式打包命令发送，redis必须在处理完所有命令前先缓存起所有命令的处理结果。打包的命令越多，缓存消耗内存也越多。所以并不是打包的命令越多越好。<br>pipeline中发送的每个command都会被server立即执行，如果执行失败，将会在此后的响应中得到信<br>息；也就是pipeline并不是表达“所有command都一起成功”的语义，管道中前面命令失败，后面命令不会有影响，继续执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pipeline pl = jedis.pipelined();</span><br><span class="line">for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line">  pl.incr("pipelineKey");</span><br><span class="line">  pl.set("littlehui" + i, "666")</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Object&gt; results = pl.syncAndReturnAll();</span><br><span class="line">System.out.println(results)</span><br></pre></td></tr></table></figure><h3 id="Redis-Lua脚本"><a href="#Redis-Lua脚本" class="headerlink" title="Redis Lua脚本"></a>Redis Lua脚本</h3><hr><p>Redis在2.6推出了脚本功能，允许开发者使用Lua语言编写脚本传到Redis中执行。使用脚本的好处如下:<br>1、<strong>减少网络开销</strong>：本来5次网络请求的操作，可以用一个请求完成，原先5次请求的逻辑放在redis服务器上完成。使用脚本，减少了网络往返时延。这点跟管道类似。<br>2、<strong>原子操作</strong>：Redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。管道不是原子的，不过redis的批量操作命令(类似mset)是原子的。<br>3、<strong>替代redis的事务功能</strong>：redis自带的事务功能很鸡肋，而redis的lua脚本几乎实现了常规的事务功能，官方推荐如果要使用redis的事务功能可以用redis lua替代。</p><p>官网文档上有这样一段话：</p><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A Redis script is transactional by definition, so everything you can do with a Redis t ransaction, you can also do with a script,</span><br><span class="line">and usually the script will be both simpler and faster.</span><br></pre></td></tr></table></figure><p>从Redis2.6.0版本开始，通过内置的Lua解释器，可以使用EVAL命令对Lua脚本进行求值。EVAL命令的格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL script numkeys key [key ...] arg [arg ...]</span><br></pre></td></tr></table></figure><p>script参数是一段Lua脚本程序，它会被运行在Redis服务器上下文中，这段脚本不必(也不应该)定义为一个Lua函数。numkeys参数用于指定键名参数的个数。键名参数 key [key …] 从EVAL的第三个参数开始算起，表示在脚本中所用到的那些Redis键(key)，这些键名参数可以在 Lua中通过全局变量KEYS数组，用1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。<br>在命令的最后，那些不是键名参数的附加参数 arg [arg …] ，可以在Lua中通过全局变量ARGV数组访问，访问的形式和KEYS变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; eval "return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;" 2 key1 key2 first seco nd</span><br><span class="line">1) "key1"</span><br><span class="line">2) "key2"</span><br><span class="line">3) "key3"</span><br><span class="line">4) "key4"</span><br></pre></td></tr></table></figure><p>其中 “return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}” 是被求值的Lua脚本，数字2指定了键名参数的数量， key1和key2是键名参数，分别使用 KEYS[1] 和 KEYS[2] 访问，而最后的 first 和 second 则是附加参数，可以通过 ARGV[1] 和 ARGV[2] 访问它们。<br>在 Lua 脚本中，可以使用redis.call()函数来执行Redis命令<br>Jedis调用示例详见上面jedis连接示例：</p><p><img src="https://images.lilhui.com/559aa96f28fdd3cb8e1371f9974d69f6" alt="图片"></p><p><strong>注意，不要在Lua脚本中出现死循环和耗时的运算，否则redis会阻塞，将不接受其他的命令， 所以使用时要注意不能出现死循环、耗时的运算。redis是单进程、单线程执行脚本。管道不会阻塞redis。</strong></p><h2 id="Redis哨兵高可用架构"><a href="#Redis哨兵高可用架构" class="headerlink" title="Redis哨兵高可用架构"></a>Redis哨兵高可用架构</h2><p><img src="https://images.lilhui.com/8d7487de106d52e9bdb8f25e9bb9862b" alt="图片"></p><p>sentinel哨兵是特殊的redis服务，不提供读写服务，主要用来监控redis实例节点。<br>哨兵架构下client端第一次从哨兵找出redis的主节点，后续就直接访问redis的主节点，不会每次都通过<br>sentinel代理访问redis的主节点，当redis的主节点发生变化，哨兵会第一时间感知到，并且将新的redis 主节点通知给client端(这里面redis的client端一般都实现了订阅功能，订阅sentinel发布的节点变动消息)</p><h3 id="Redis-哨兵搭建步骤"><a href="#Redis-哨兵搭建步骤" class="headerlink" title="Redis 哨兵搭建步骤"></a>Redis 哨兵搭建步骤</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1、复制一份sentinel.conf文件</span><br><span class="line">cp sentinel.conf sentinel‐26379.conf  </span><br><span class="line">2、将相关配置修改为如下值： </span><br><span class="line">port 26379 </span><br><span class="line">daemonize yes </span><br><span class="line">pidfile "/var/run/redis‐sentinel‐26379.pid" </span><br><span class="line">logfile "26379.log" </span><br><span class="line">dir "/usr/local/redis‐5.0.3/data" </span><br><span class="line"><span class="meta">#</span><span class="bash"> sentinel monitor &lt;master‐redis‐name&gt; &lt;master‐redis‐ip&gt; &lt;master‐redis‐port&gt; &lt;quorum&gt; </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> quorum是一个数字，指明当有多少个sentinel认为一个master失效时(值一般为：sentinel总数/2 + 1)，master才算真正失效</span></span><br><span class="line"></span><br><span class="line">sentinel monitor mymaster 192.168.0.60 6379 2 # mymaster这个名字随便取，客户端访问时会用 到</span><br><span class="line">3、启动sentinel哨兵实例 </span><br><span class="line">src/redis‐sentinel sentinel‐26379.conf </span><br><span class="line">4、查看sentinel的info信息 </span><br><span class="line">src/redis‐cli ‐p 26379 19 127.0.0.1:26379&gt;info </span><br><span class="line">可以看到Sentinel的info里已经识别出了redis的主从 </span><br><span class="line">5、可以自己再配置两个sentinel，端口26380和26381，注意上述配置文件里的对应数字都要修改</span><br></pre></td></tr></table></figure><p>sentinel集群都启动完毕后，会将哨兵集群的元数据信息写入所有sentinel的配置文件里去(追加在文件的 最下面)，我们查看下如下配置文件sentinel-26379.conf，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sentinel known‐replica mymaster 192.168.0.60 6380 #代表redis主节点的从节点信息 </span><br><span class="line">sentinel known‐replica mymaster 192.168.0.60 6381 #代表redis主节点的从节点信息 </span><br><span class="line">sentinel known‐sentinel mymaster 192.168.0.60 26380 52d0a5d70c1f90475b4fc03b6ce7c3c569 35760f #代表感知到的其它哨兵节点 </span><br><span class="line">sentinel known‐sentinel mymaster 192.168.0.60 26381 e9f530d3882f8043f76ebb8e1686438ba8 bd5ca6 #代表感知到的其它哨兵节点</span><br></pre></td></tr></table></figure><p>当redis主节点如果挂了，哨兵集群会重新选举出新的redis主节点，同时会修改所有sentinel节点配置文件 的集群元数据信息，比如6379的redis如果挂了，假设选举出的新主节点是6380，则sentinel文件里的集 群元数据信息会变成如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sentinel known‐replica mymaster 192.168.0.60 6379 #代表主节点的从节点信息 </span><br><span class="line">sentinel known‐replica mymaster 192.168.0.60 6381 #代表主节点的从节点信息 </span><br><span class="line">sentinel known‐sentinel mymaster 192.168.0.60 26380 52d0a5d70c1f90475b4fc03b6ce7c3c569 35760f #代表感知到的其它哨兵节点 </span><br><span class="line">sentinel known‐sentinel mymaster 192.168.0.60 26381 e9f530d3882f8043f76ebb8e1686438ba8 bd5ca6 #代表感知到的其它哨兵节点</span><br></pre></td></tr></table></figure><p>同时还会修改sentinel文件里之前配置的mymaster对应的6379端口，改为6380<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 192.168.0.60 6380 2</span><br></pre></td></tr></table></figure></p><p>当6379的redis实例再次启动时，哨兵集群根据集群元数据信息就可以将6379端口的redis节点作为从节点 加入集群。</p><p>哨兵的Jedis连接代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisSentinelTest</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig(); </span><br><span class="line">        config.setMaxTotal(<span class="number">20</span>); </span><br><span class="line">        config.setMaxIdle(<span class="number">10</span>); </span><br><span class="line">        config.setMinIdle(<span class="number">5</span>); </span><br><span class="line">        String masterName = <span class="string">"mymaster"</span>; </span><br><span class="line">        Set&lt;String&gt; sentinels = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        sentinels.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.0.60"</span>,<span class="number">26379</span>).toString()); </span><br><span class="line">        sentinels.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.0.60"</span>,<span class="number">26380</span>).toString()); </span><br><span class="line">        sentinels.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.0.60"</span>,<span class="number">26381</span>).toString());</span><br><span class="line">        <span class="comment">//JedisSentinelPool其实本质跟JedisPool类似，都是与redis主节点建立的连接池 </span></span><br><span class="line">        <span class="comment">// JedisSentinelPool并不是说与sentinel建立的连接池，而是通过sentinel发现redis主节点并与其 建立连接</span></span><br><span class="line">        JedisSentinelPool jedisSentinelPool = <span class="keyword">new</span> JedisSentinelPool(masterName, sentinels, co nfig, <span class="number">3000</span>, <span class="keyword">null</span>); </span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            jedis = jedisSentinelPool.getResource(); </span><br><span class="line">            System.out.println(jedis.set(<span class="string">"sentinel"</span>, <span class="string">"littlehui"</span>)); </span><br><span class="line">            System.out.println(jedis.get(<span class="string">"sentinel"</span>)); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">            <span class="comment">//注意这里不是关闭连接，在JedisPool模式下，Jedis会被归还给资源池。 </span></span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) </span><br><span class="line">                jedis.close(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>哨兵的Spring Boot整合Redis连接代码见示例项目：redis-sentinel-cluster</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;spring‐boot‐starter‐data‐redis&lt;/artifactId&gt; </span><br><span class="line">&lt;/dependency&gt; </span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.apache.commons&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;commons‐pool2&lt;/artifactId&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>springboot项目核心配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server: </span><br><span class="line">        port: 8080 </span><br><span class="line">        spring: </span><br><span class="line">            redis: </span><br><span class="line">                database: 0</span><br><span class="line">                timeout: 3000 </span><br><span class="line">                sentinel: #哨兵模式 </span><br><span class="line">                    master: mymaster #主服务器所在集群名称 </span><br><span class="line">                    nodes: 192.168.0.60:26379,192.168.0.60:26380,192.168.0.60:26381 </span><br><span class="line">            lettuce:</span><br><span class="line">                pool: </span><br><span class="line">                  max‐idle: 50 </span><br><span class="line">                  min‐idle: 10 </span><br><span class="line">                  max‐active: 100 </span><br><span class="line">                  max‐wait: 1000</span><br></pre></td></tr></table></figure><h3 id="StringRedisTemplate与RedisTemplate详解"><a href="#StringRedisTemplate与RedisTemplate详解" class="headerlink" title="StringRedisTemplate与RedisTemplate详解"></a>StringRedisTemplate与RedisTemplate详解</h3><p>spring 封装了 RedisTemplate 对象来进行对redis的各种操作，它支持所有的 redis 原生的 api。在 RedisTemplate中提供了几个常用的接口方法的使用，分别是:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private ValueOperations&lt;K, V&gt; valueOps; </span><br><span class="line">private HashOperations&lt;K, V&gt; hashOps; </span><br><span class="line">private ListOperations&lt;K, V&gt; listOps; </span><br><span class="line">private SetOperations&lt;K, V&gt; setOps;</span><br><span class="line">private ZSetOperations&lt;K, V&gt; zSetOps;</span><br></pre></td></tr></table></figure><p>RedisTemplate中定义了对5种数据结构操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForValue();//操作字符串 </span><br><span class="line">redisTemplate.opsForHash();//操作hash </span><br><span class="line">redisTemplate.opsForList();//操作list </span><br><span class="line">redisTemplate.opsForSet();//操作set </span><br><span class="line">redisTemplate.opsForZSet();//操作有序set</span><br></pre></td></tr></table></figure><p>StringRedisTemplate继承自RedisTemplate，也一样拥有上面这些操作。 StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存 的。RedisTemplate默认采用的是JDK的序列化策略，保存的key和value都是采用此策略序列化保存的。</p><p>Redis客户端命令对应的RedisTemplate中的方法列表：</p><p><img src="https://images.lilhui.com/701b9d3fc1a6eacf37468e93d36f10e0" alt="图片"></p><p><img src="https://images.lilhui.com/74100f8edf5b02b2f9bc229dd567da87" alt="图片"></p><p><img src="https://images.lilhui.com/1ec7a56abb3e06364c49830ce29a8988" alt="图片"></p><p><img src="https://images.lilhui.com/d14be88c07fe271ca86af964e71ca178" alt="图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis持久化&quot;&gt;&lt;a href=&quot;#Redis持久化&quot; class=&quot;headerlink&quot; title=&quot;Redis持久化&quot;&gt;&lt;/a&gt;Redis持久化&lt;/h2&gt;&lt;h3 id=&quot;RDB快照（snapshot&quot;&gt;&lt;a href=&quot;#RDB快照（snapshot&quot;
      
    
    </summary>
    
      <category term="redis" scheme="http://www.lilhui.com/categories/redis/"/>
    
    
      <category term="redis，哨兵" scheme="http://www.lilhui.com/tags/redis%EF%BC%8C%E5%93%A8%E5%85%B5/"/>
    
  </entry>
  
  <entry>
    <title>【Redis学习1】核心数据结构与高性能原理</title>
    <link href="http://www.lilhui.com/2022/06/29/redis/redis_core_1/"/>
    <id>http://www.lilhui.com/2022/06/29/redis/redis_core_1/</id>
    <published>2022-06-29T07:14:58.000Z</published>
    <updated>2022-06-29T08:11:36.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-单线程为什么还能这么快？"><a href="#Redis-单线程为什么还能这么快？" class="headerlink" title="Redis 单线程为什么还能这么快？"></a>Redis 单线程为什么还能这么快？</h2><p>因为它所有的数据都在内存中，所有的运算都是内存级别的运算，而且单线程避免了多线程的切换性 能损耗问题。正因为 Redis 是单线程，所以要小心使用<br>Redis 指令，对于那些耗时的指令(比如 keys)，一定要谨慎使用，一不小心就可能会导致 Redis 卡顿。</p><h2 id="Redis单线程如何处理那么多的并发客户端链接？"><a href="#Redis单线程如何处理那么多的并发客户端链接？" class="headerlink" title="Redis单线程如何处理那么多的并发客户端链接？"></a>Redis单线程如何处理那么多的并发客户端链接？</h2><p>Redis的<strong>IO多路复用</strong>：redis利用epoll来实现IO多路复用，将连接信息和事件放到队列中，依次放到 文件事件分派器，事件分派器将事件分发给事件处理器。</p><p><img src="https://images.lilhui.com/3d76aa01f1678c619f175331f40e982d" alt="图片"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看redis支持的最大连接数，在redis.conf文件中可修改<span class="comment"># maxclients 10000 </span></span></span><br><span class="line">        127.0.0.1:6379&gt; CONFIG GET maxclients </span><br><span class="line">        ##1) "maxclients" 4 </span><br><span class="line">        ##2) "10000"</span><br></pre></td></tr></table></figure><h2 id="一些高级命令"><a href="#一些高级命令" class="headerlink" title="一些高级命令"></a>一些高级命令</h2><p>keys: 全量遍历，用来列出所有满足特定正则字符串规则的key.性能比较差。避免使用。<br>scan: 渐进式遍历。SCAN cursor [MATCH pattern] [COUNT count]</p><p>scan 参数提供了三个参数，第一个是 cursor 整数值(hash桶的索引值)，第二个是 key 的正则模式， 第三个是一次遍历的key的数量(参考值，底层遍历的数量不一定)，并不是符合条件的结果数量。第 一次遍历时，cursor 值为 0，然后将返回结果中第一个整数值作为下一次遍历的 cursor。一直遍历 到返回的 cursor 值为 0 时结束。<br>注意：但是scan并非完美无瑕， 如果在scan的过程中如果有键的变化（增加、 删除、 修改） ，那 么遍历效果可能会碰到如下问题： 新增的键可能没有遍历到， 遍历出了重复的键等情况， 也就是说 scan并不能保证完整的遍历出来所有的键， 这些是我们在开发时需要考虑的。</p><p>Info：查看redis服务运行信息，分为 9 大块，每个块都有非常多的参数，这 9 个块分别是:</p><p>Server 服务器运行的环境参数<br>Clients 客户端相关信息<br>Memory 服务器运行内存统计数据<br>Persistence 持久化信息<br>Stats 通用统计数据<br>Replication 主从复制相关信息<br>CPU CPU 使用情况<br>Cluster 集群信息<br>KeySpace 键值对统计数量信息</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><img src="https://images.lilhui.com/5a5b50442717feb7d0a23dd21b64d570" alt="图片"></p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">字符串常用操作</span><br><span class="line">SET  key  value //存入字符串键值对</span><br><span class="line">MSET  key  value [key value ...] //批量存储字符串键值对</span><br><span class="line">SETNX  key  value //存入一个不存在的字符串键值对</span><br><span class="line">GET  key //获取一个字符串键值</span><br><span class="line">MGET  key  [key ...] //批量获取字符串键值</span><br><span class="line">DEL  key  [key ...] //删除一个键</span><br><span class="line">EXPIRE  key  seconds //设置一个键的过期时间(秒)</span><br><span class="line"></span><br><span class="line">原子加减</span><br><span class="line">INCR  key //将key中储存的数字值加1</span><br><span class="line">DECR  key //将key中储存的数字值减1</span><br><span class="line">INCRBY  key  increment //将key所储存的值加上increment</span><br><span class="line">DECRBY  key  decrement //将key所储存的值减去decrement</span><br><span class="line"></span><br><span class="line">计数器</span><br><span class="line">INCR article:readcount:&#123;文章id&#125;</span><br><span class="line">GET article:readcount:&#123;文章id&#125; </span><br><span class="line"></span><br><span class="line">Web集群session共享</span><br><span class="line">spring session + redis实现session共享</span><br><span class="line"></span><br><span class="line">分布式系统全局序列号</span><br><span class="line">INCRBY  orderId  1000</span><br></pre></td></tr></table></figure><h3 id="Hash结构"><a href="#Hash结构" class="headerlink" title="Hash结构"></a>Hash结构</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Hash常用操作</span><br><span class="line">HSET  key  field  value //存储一个哈希表key的键值</span><br><span class="line">HSETNX  key  field  value //存储一个不存在的哈希表key的键值</span><br><span class="line">HMSET  key  field  value [field value ...] //在一个哈希表key中存储多个键值对</span><br><span class="line">HGET  key  field //获取哈希表key对应的field键值</span><br><span class="line">HMGET  key  field  [field ...] //批量获取哈希表key中多个field键值</span><br><span class="line">HDEL  key  field  [field ...] //删除哈希表key中的field键值</span><br><span class="line">HLEN  key//返回哈希表key中field的数量</span><br><span class="line">HGETALL key//返回哈希表key中所有的键值</span><br><span class="line"></span><br><span class="line">HINCRBY  key  field  increment //为哈希表key中field键的值加上增量increment</span><br><span class="line"></span><br><span class="line">对象缓存</span><br><span class="line">HMSET  user  &#123;userId&#125;:name  zhuge  &#123;userId&#125;:balance  1888</span><br><span class="line">HMSET  user  1:name  zhuge  1:balance  1888</span><br><span class="line">HMGET  user  1:name  1:balance</span><br></pre></td></tr></table></figure><p><img src="https://images.lilhui.com/8ea1cfd959c1da3d3febafbff977c492" alt="图片"><br>表内容<br><img src="https://images.lilhui.com/50e1a804785e735f677e9844230bb37d" alt="图片"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">电商购物车</span><br><span class="line">1）以用户id为key</span><br><span class="line">2）商品id为field</span><br><span class="line">3）商品数量为value</span><br><span class="line"></span><br><span class="line">购物车操作</span><br><span class="line">添加商品hset cart:1001 10088 1</span><br><span class="line">增加数量hincrby cart:1001 10088 1</span><br><span class="line">商品总数hlen cart:1001</span><br><span class="line">删除商品hdel cart:1001 10088</span><br><span class="line">获取购物车所有商品hgetall cart:1001</span><br></pre></td></tr></table></figure><ul><li>hash结构的优点<br>优点<br>1）同类数据归类整合储存，方便数据管理<br>2）相比string操作消耗内存与cpu更小<br>3）相比string储存更节省空间</li><li>hash结构的缺点<br>缺点<br>过期功能不能使用在field上，只能用在key上<br>Redis集群架构下不适合大规模使用</li></ul><h3 id="List结构"><a href="#List结构" class="headerlink" title="List结构"></a>List结构</h3><p><img src="https://images.lilhui.com/ff9c0592b6fc90f5b541809cbd3cb90c" alt="图片"></p><ul><li><p>常用操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List常用操作</span><br><span class="line">LPUSH  key  value [value ...] //将一个或多个值value插入到key列表的表头(最左边)</span><br><span class="line">RPUSH  key  value [value ...] //将一个或多个值value插入到key列表的表尾(最右边)</span><br><span class="line">LPOP  key//移除并返回key列表的头元素</span><br><span class="line">RPOP  key//移除并返回key列表的尾元素</span><br><span class="line">LRANGE  key  start  stop//返回列表key中指定区间内的元素，区间以偏移量start和stop指定</span><br><span class="line"></span><br><span class="line">BLPOP  key  [key ...]  timeout//从key列表表头弹出一个元素，若列表中没有元素，阻塞等待timeout秒,如果timeout=0,一直阻塞等待</span><br><span class="line">BRPOP  key  [key ...]  timeout //从key列表表尾弹出一个元素，若列表中没有元素，阻塞等待timeout秒,如果timeout=0,一直阻塞等待</span><br></pre></td></tr></table></figure></li><li><p>应用场景</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常用数据结构</span><br><span class="line">Stack(栈) = LPUSH + LPOP</span><br><span class="line">Queue(队列）= LPUSH + RPOP</span><br><span class="line">Blocking MQ(阻塞队列）= LPUSH + BRPOP</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://images.lilhui.com/ff9c0592b6fc90f5b541809cbd3cb90c" alt="图片"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">微博消息和微信公号消息</span><br><span class="line">诸葛老师关注了MacTalk，备胎说车等大V</span><br><span class="line">1）MacTalk发微博，消息ID为10018</span><br><span class="line">LPUSH  msg:&#123;诸葛老师-ID&#125;  10018</span><br><span class="line">2）备胎说车发微博，消息ID为10086</span><br><span class="line">LPUSH  msg:&#123;诸葛老师-ID&#125; 10086</span><br><span class="line">3）查看最新微博消息</span><br><span class="line">LRANGE  msg:&#123;诸葛老师-ID&#125;  0  4</span><br></pre></td></tr></table></figure><p><img src="https://images.lilhui.com/62e6f348f1bde713939375c504320454" alt="图片"></p><h3 id="Set结构"><a href="#Set结构" class="headerlink" title="Set结构"></a>Set结构</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Set常用操作</span><br><span class="line">SADD  key  member  [member ...]//往集合key中存入元素，元素存在则忽略，</span><br><span class="line">若key不存在则新建</span><br><span class="line">SREM  key  member  [member ...]//从集合key中删除元素</span><br><span class="line">SMEMBERS  key//获取集合key中所有元素</span><br><span class="line">SCARD  key//获取集合key的元素个数</span><br><span class="line">SISMEMBER  key  member//判断member元素是否存在于集合key中</span><br><span class="line">SRANDMEMBER  key  [count]//从集合key中选出count个元素，元素不从key中删除</span><br><span class="line">SPOP  key  [count]//从集合key中选出count个元素，元素从key中删除</span><br><span class="line"></span><br><span class="line">Set运算操作</span><br><span class="line">SINTER  key  [key ...] //交集运算</span><br><span class="line">SINTERSTORE  destination  key  [key ..]//将交集结果存入新集合destination中</span><br><span class="line">SUNION  key  [key ..] //并集运算</span><br><span class="line">SUNIONSTORE  destination  key  [key ...]//将并集结果存入新集合destination中</span><br><span class="line">SDIFF  key  [key ...] //差集运算</span><br><span class="line">SDIFFSTORE  destination  key  [key ...]//将差集结果存入新集合destination中</span><br><span class="line"></span><br><span class="line">微信抽奖小程序</span><br><span class="line">1）点击参与抽奖加入集合</span><br><span class="line">SADD key &#123;userlD&#125;</span><br><span class="line">2）查看参与抽奖所有用户</span><br><span class="line">SMEMBERS key  </span><br><span class="line">3）抽取count名中奖者</span><br><span class="line">SRANDMEMBER key [count] / SPOP key [count]</span><br></pre></td></tr></table></figure><p><img src="https://images.lilhui.com/a73277f489af351a18afef12a4a309ad" alt="图片"></p><ul><li>应用场景</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">微信微博点赞，收藏，标签</span><br><span class="line">1) 点赞</span><br><span class="line">SADD  like:&#123;消息ID&#125;  &#123;用户ID&#125;</span><br><span class="line">2) 取消点赞</span><br><span class="line">SREM like:&#123;消息ID&#125;  &#123;用户ID&#125;</span><br><span class="line">3) 检查用户是否点过赞</span><br><span class="line">SISMEMBER  like:&#123;消息ID&#125;  &#123;用户ID&#125;</span><br><span class="line">4) 获取点赞的用户列表</span><br><span class="line">SMEMBERS like:&#123;消息ID&#125;</span><br><span class="line">5) 获取点赞用户数 </span><br><span class="line">SCARD like:&#123;消息ID&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images.lilhui.com/a9e7bcdfdb7f96bf0f13595f44c40792" alt="图片"></p><ul><li>集合操作<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SINTER set1 set2 set3  &#123; c &#125;</span><br><span class="line">SUNION set1 set2 set3  &#123; a,b,c,d,e &#125;</span><br><span class="line">SDIFF set1 set2 set3  &#123; a &#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://images.lilhui.com/a32160b24d2b4685bad068eb3afd1ca2" alt="图片"></p><ul><li>集合操作实现微博关注模型</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">集合操作实现微博微信关注模型</span><br><span class="line">1) 诸葛老师关注的人: </span><br><span class="line"><span class="meta">zhugeSet-&gt;</span><span class="bash"> &#123;guojia, xushu&#125;</span></span><br><span class="line">2) 杨过老师关注的人:</span><br><span class="line"><span class="meta"> yangguoSet--&gt;</span><span class="bash"> &#123;zhuge, baiqi, guojia, xushu&#125;</span></span><br><span class="line">3) 郭嘉老师关注的人: </span><br><span class="line"><span class="meta">guojiaSet-&gt;</span><span class="bash"> &#123;zhuge, yangguo, baiqi, xushu, xunyu)</span></span><br><span class="line">4) 我和杨过老师共同关注: </span><br><span class="line">SINTER zhugeSet yangguoSet--&gt; &#123;guojia, xushu&#125;</span><br><span class="line">5) 我关注的人也关注他(杨过老师): </span><br><span class="line">SISMEMBER guojiaSet yangguo </span><br><span class="line">SISMEMBER xushuSet yangguo</span><br><span class="line">6) 我可能认识的人: </span><br><span class="line">SDIFF yangguoSet zhugeSet-&gt;(zhuge, baiqi&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images.lilhui.com/a389d879e58447147e4ce1ddcab47473" alt="图片"></p><p><img src="https://images.lilhui.com/31491901442e1895639eab5095e5eee6" alt="图片"></p><ul><li>集合操作实现电商商品筛选</li></ul><p><img src="https://images.lilhui.com/3783a4643c2467640defa05085821cd7" alt="图片"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SADD  brand:huawei  P40</span><br><span class="line">SADD  brand:xiaomi  mi-10</span><br><span class="line">SADD  brand:iPhone iphone12</span><br><span class="line">SADD os:android  P40  mi-10</span><br><span class="line">SADD cpu:brand:intel  P40  mi-10</span><br><span class="line">SADD ram:8G  P40  mi-10  iphone12</span><br><span class="line"></span><br><span class="line">SINTER  os:android  cpu:brand:intel  ram:8G   &#123;P40，mi-10&#125;</span><br></pre></td></tr></table></figure><h3 id="Zset有序集合结构"><a href="#Zset有序集合结构" class="headerlink" title="Zset有序集合结构"></a>Zset有序集合结构</h3><p><img src="https://images.lilhui.com/f693785556dbdb72de891f82df20830d" alt="图片"></p><ul><li><p>ZSet常用操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ZSet常用操作</span><br><span class="line">ZADD key score member [[score member]…]//往有序集合key中加入带分值元素</span><br><span class="line">ZREM key member [member …]//从有序集合key中删除元素</span><br><span class="line">ZSCORE key member //返回有序集合key中元素member的分值</span><br><span class="line">ZINCRBY key increment member//为有序集合key中元素member的分值加上increment </span><br><span class="line">ZCARD key//返回有序集合key中元素个数</span><br><span class="line">ZRANGE key start stop [WITHSCORES]//正序获取有序集合key从start下标到stop下标的元素</span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]//倒序获取有序集合key从start下标到stop下标的元素</span><br></pre></td></tr></table></figure></li><li><p>ZSet集合操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZUNIONSTORE destkey numkeys key [key ...] //并集计算</span><br><span class="line">ZINTERSTORE destkey numkeys key [key …]//交集计算</span><br></pre></td></tr></table></figure></li><li><p>应用场景</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Zset集合操作实现排行榜</span><br><span class="line">1）点击新闻</span><br><span class="line">ZINCRBY  hotNews:20190819  1  守护香港</span><br><span class="line">2）展示当日排行前十</span><br><span class="line">ZREVRANGE  hotNews:20190819  0  9  WITHSCORES </span><br><span class="line">3）七日搜索榜单计算</span><br><span class="line">ZUNIONSTORE  hotNews:20190813-20190819  7 </span><br><span class="line">hotNews:20190813  hotNews:20190814... hotNews:20190819</span><br><span class="line">4）展示七日排行前十</span><br><span class="line">ZREVRANGE hotNews:20190813-20190819  0  9  WITHSCORES</span><br></pre></td></tr></table></figure><p><img src="https://images.lilhui.com/5c41f408bd96434d668b17cb147b8603" alt="图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-单线程为什么还能这么快？&quot;&gt;&lt;a href=&quot;#Redis-单线程为什么还能这么快？&quot; class=&quot;headerlink&quot; title=&quot;Redis 单线程为什么还能这么快？&quot;&gt;&lt;/a&gt;Redis 单线程为什么还能这么快？&lt;/h2&gt;&lt;p&gt;因为它所有的
      
    
    </summary>
    
      <category term="redis" scheme="http://www.lilhui.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://www.lilhui.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>【深入理解Spring系列2】动态代理</title>
    <link href="http://www.lilhui.com/2022/04/28/java/spring/spring_deep_3/"/>
    <id>http://www.lilhui.com/2022/04/28/java/spring/spring_deep_3/</id>
    <published>2022-04-28T06:11:53.000Z</published>
    <updated>2022-04-28T06:19:58.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-动态代理"><a href="#Spring-动态代理" class="headerlink" title="Spring 动态代理"></a>Spring 动态代理</h2><p>以mybatis-spring为例子讲下Spring的动态代理过程。<br>mybatis官网：<a href="https://mybatis.org/mybatis-3/zh" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh</a></p><ul><li>动态代理的关键</li></ul><ol><li>新建</li></ol><p>JDK的动态代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br></pre></td></tr></table></figure><p>mapperProxy实现了InvocationHanlder<br>mapperInterface是这个new出来的类接口。接口与实现是分开的。<br>mybatis的关键点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br></pre></td></tr></table></figure><p>sqlSession在这里传入 MapperProxy<br>MapperProxy又调用MapperMethod<br>Mybatis Mapper具体的代理方法的实现在这里<br>MybatisMapperRegistry.addMapper(Class)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MybatisMapperAnnotationBuilder parser = new MybatisMapperAnnotationBuilder(config, type);</span><br></pre></td></tr></table></figure><p>MybatisMapperAnnotationBuilder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public void parse() &#123;</span><br><span class="line">    String resource = type.toString();</span><br><span class="line">    if (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">        loadXmlResource();</span><br><span class="line">        configuration.addLoadedResource(resource);</span><br><span class="line">        assistant.setCurrentNamespace(type.getName());</span><br><span class="line">        parseCache();</span><br><span class="line">        parseCacheRef();</span><br><span class="line">        Method[] methods = type.getMethods();</span><br><span class="line">        // TODO 注入 CURD 动态 SQL (应该在注解之前注入)</span><br><span class="line">        if (GlobalConfigUtils.getSuperMapperClass(configuration).isAssignableFrom(type)) &#123;</span><br><span class="line">            GlobalConfigUtils.getSqlInjector(configuration).inspectInject(assistant, type);</span><br><span class="line">        &#125;</span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // issue #237</span><br><span class="line">                if (!method.isBridge()) &#123;</span><br><span class="line">                    parseStatement(method);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * 使用 MybatisMethodResolver 而不是 MethodResolver</span><br><span class="line">                 */</span><br><span class="line">                configuration.addIncompleteMethod(new MybatisMethodResolver(this, method));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parsePendingMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mybatis两种：</p><ul><li><p>初始化</p></li><li><p>执行过程</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-动态代理&quot;&gt;&lt;a href=&quot;#Spring-动态代理&quot; class=&quot;headerlink&quot; title=&quot;Spring 动态代理&quot;&gt;&lt;/a&gt;Spring 动态代理&lt;/h2&gt;&lt;p&gt;以mybatis-spring为例子讲下Spring的动态代理过程。
      
    
    </summary>
    
      <category term="spring" scheme="http://www.lilhui.com/categories/spring/"/>
    
    
      <category term="动态代理" scheme="http://www.lilhui.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【Redis核心原理1】</title>
    <link href="http://www.lilhui.com/2022/03/08/redis/redis_deep_1/"/>
    <id>http://www.lilhui.com/2022/03/08/redis/redis_deep_1/</id>
    <published>2022-03-08T10:51:11.000Z</published>
    <updated>2022-03-11T06:16:50.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><p>simple dynamic string<br>redis 3.2以前<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> len; <span class="comment">//32 bit 0-2 32次方-1</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds</span><br></pre></td></tr></table></figure></p><p>redis3.2以后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line">sdshdr5</span><br><span class="line">sdshdr8</span><br><span class="line">sdshdr16</span><br><span class="line">sdshdr32</span><br><span class="line">sdshdr64</span><br></pre></td></tr></table></figure><p>对sdshdr做了优化和细分;<br>内存对齐：<br><img src="http://images.lilhui.com/054ba99b9267ed34e17460afff4d24bf" alt="图片"></p><h3 id="key类型"><a href="#key类型" class="headerlink" title="key类型"></a>key类型</h3><p>string</p><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>string,hash,set, sorted set,list</p><ul><li>K-V: 是一个dict数据类型。<br>海量数据的存储：</li></ul><ol><li>数组: O(1)</li><li>链表: O(N)</li><li>树： long(N)</li></ol><p>arr[4]<br>hash(key) -&gt; 自然数%4 。变成索引。</p><p>hash(k1) % 4 = 0<br>hash(k2) % 4 = 1<br>hash(k3) % 4 = 1</p><p>arr[0] -&gt; (k1, v1,next -&gt; null)<br>arr[1,2] -&gt; (k3, v3, next -&gt; k2) (k2, v2, next -&gt; null)</p><p>当数组容量很大时，hash碰撞加剧。数据结构由数组变成了链表，时间复杂度从O(1)退化成<br>O(N) 此时需要进行扩容。</p><p>k2,k3碰撞了怎么办？</p><ol><li>开放地址法。</li><li>链表法</li><li>头插法（redis使用的方式）</li></ol><p>redisDB的设计<br>redis总共16个Db 索引从0-15<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    dict *expires;</span><br><span class="line">    dict *blocking_keys;</span><br><span class="line">    dict *watched_keys;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> expires_cursor;</span><br><span class="line">    <span class="built_in">list</span> *defrag_later;</span><br><span class="line">&#125; redisDb;</span><br><span class="line"></span><br><span class="line">_typedef <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span>_</span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];<span class="comment">//ht : hashTable的缩小</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators;</span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdate, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size; <span class="comment">// hashtable 容量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask; <span class="comment">//size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used; <span class="comment">//hashtable元素个数 used/size = 1</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"><span class="comment">//redis值类型对象封装 string,list,set,hash, zset</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">//约束能够对redis key进行的操作 lpush，get什么的</span></span><br><span class="line">    unsiged type:<span class="number">4</span>;  <span class="comment">// 4bit,string hash</span></span><br><span class="line">    <span class="comment">//object encoding key 支持。对应的值在redis底层用的编码形式</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// 4bit</span></span><br><span class="line">    unsigined lru:LRU_BITS;</span><br><span class="line">    <span class="comment">//管理内存，引用计数法！这里表示引用的数量。0的时候可以进行回收。</span></span><br><span class="line">    <span class="keyword">int</span> refcount;  <span class="comment">//4 byte</span></span><br><span class="line">    <span class="comment">//指向数据的地址</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;      <span class="comment">//8byte</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p><p>扩容方法 。原有容量 *2.<br>rehash迁移方式：1. 渐进式迁移。2. 定时迁移。</p><p>set xxx // set是对 string操作。所以 type xxx也是string<br>lpush xxx // lpush 操作 type xxx 是list</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SDS&quot;&gt;&lt;a href=&quot;#SDS&quot; class=&quot;headerlink&quot; title=&quot;SDS&quot;&gt;&lt;/a&gt;SDS&lt;/h2&gt;&lt;p&gt;simple dynamic string&lt;br&gt;redis 3.2以前&lt;br&gt;&lt;figure class=&quot;highlight c
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.lilhui.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.lilhui.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【Dubbo源码系列6】Duboo 服务调用源码解析</title>
    <link href="http://www.lilhui.com/2022/03/03/java/dubbo/dubbo_6/"/>
    <id>http://www.lilhui.com/2022/03/03/java/dubbo/dubbo_6/</id>
    <published>2022-03-03T10:49:42.000Z</published>
    <updated>2022-03-07T03:52:10.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务消费端执行逻辑"><a href="#服务消费端执行逻辑" class="headerlink" title="服务消费端执行逻辑"></a>服务消费端执行逻辑</h2><ol><li>nvoker.invoke(new RpcInvocation(method, args))：Mock逻辑</li><li>AbstractClusterInvoker.invoke(invocation)：把RpcContext中设置的Attachments添加到invocation对象上，调用路由链从服务目录上筛选出适合的服务Invoker，获得服务均衡策略loadbalance</li><li>FailoverClusterInvoker.doInvoke(invocation, invokers, loadbalance)：根据负载均衡策略选出一个invoker，然后执行</li><li>InvokerWrapper.invoke(invocation)：没做什么事情</li><li>CallbackRegistrationInvoker.invoke(invocation)：开始执行Filter链，执行完得到结果后，会获取ListenableFilter中的listener，执行listener的onResponse方法</li><li>ConsumerContextFilter.invoke(invocation)：设置RpcContext中LocalAddress、RemoteAddress、RemoteApplicationName参数</li><li>FutureFilter.invoke(invocation)：</li><li>MonitorFilter.invoke(invocation)：方法的执行次数+1</li><li>ListenerInvokerWrapper.invoke(invocation)：没做什么事情</li><li>AsyncToSyncInvoker.invoke(invocation)：异步转同步，会先用下层Invoker去异步执行，然后阻塞Integer.MAX_VALUE时间，直到拿到了结果</li><li>AbstractInvoker.invoke(invocation)：主要调用DubboInvoker的doInvoke方法，如果doInvoker方法出现了异常，会进行包装，包装成AsyncRpcResult</li><li>DubboInvoker.doInvoke(invocation)：从clients轮询出一个client进行数据发送，如果配置了不关心结果，则调用ReferenceCountExchangeClient的send方法，否则调用ReferenceCountExchangeClient的request方法</li><li>ReferenceCountExchangeClient.request(Object request, int timeout)：没做什么事情</li><li>HeaderExchangeClient.request(Object request, int timeout)：没做什么事情</li><li>HeaderExchangeChannel.request(Object request, int timeout)：构造一个Request对象，并且会构造一个DefaultFuture对象来阻塞timeout的时间来等待结果，在构造DefaultFuture对象时，会把DefaultFuture对象和req的id存入FUTURES中，FUTURES是一个Map，当HeaderExchangeHandler接收到结果时，会从这个Map中根据id获取到DefaultFuture对象，然后返回Response。</li><li>AbstractPeer.send(Object message)：从url中获取send参数，默认为false</li><li>AbstractClient.send(Object message, boolean sent)：没做什么</li><li>NettyChannel.send(Object message, boolean sent)：调用NioSocketChannel的writeAndFlush发送数据，然后判断send如果是true，那么则阻塞url中指定的timeout时间，因为如果send是false，在HeaderExchangeChannel中会阻塞timeout时间</li><li>NioSocketChannel.writeAndFlush(Object msg)：最底层的Netty非阻塞式的发送数据</li></ol><h2 id="总结流程"><a href="#总结流程" class="headerlink" title="总结流程"></a>总结流程</h2><ol><li>最外层是Mock逻辑，调用前，调用后进行Mock</li><li>从服务目录中，根据当前调用的方法和路由链，筛选出部分服务Invoker（DubboInvoker）</li><li>对服务Invoker进行负载均衡，选出一个服务Invoker</li><li>执行Filter链</li><li>AsyncToSyncInvoker完成异步转同步，因为DubboInvoker的执行是异步非阻塞的，所以如果是同步调用，则会在此处阻塞，知道拿到响应结果</li><li>DubboInvoker开始异步非阻塞的调用</li><li>HeaderExchangeChannel中会阻塞timeout的时间来等待结果，该timeout就是用户在消费端所配置的timeout</li></ol><h2 id="服务提供端执行逻辑"><a href="#服务提供端执行逻辑" class="headerlink" title="服务提供端执行逻辑"></a>服务提供端执行逻辑</h2><ol><li>NettyServerHandler：接收数据</li><li>MultiMessageHandler：判断接收到的数据是否是MultiMessage，如果是则获取MultiMessage中的单个Message，传递给HeartbeatHandler进行处理</li><li>HeartbeatHandler：判断是不是心跳消息，如果是不是则把Message传递给AllChannelHandler</li><li>AllChannelHandler：把接收到的Message封装为一个ChannelEventRunnable对象，扔给线程池进行处理</li><li>ChannelEventRunnable：在ChannelEventRunnable的run方法中会调用DecodeHandler处理Message</li><li>DecodeHandler：按Dubbo协议的数据格式，解析当前请求的path，versio，方法，方法参数等等，然后把解析好了的请求交给HeaderExchangeHandler</li><li>HeaderExchangeHandler：处理Request数据，首先构造一个Response对象，然后调用ExchangeHandlerAdapter得到一个CompletionStage future，然后给future通过whenComplete绑定一个回调函数，当future执行完了之后，就可以从回调函数中得到ExchangeHandlerAdapter的执行结果，并把执行结果设置给Response对象，通过channel发送出去。</li><li>ExchangeHandlerAdapter：从本机已经导出的Exporter中根据当前Request所对应的服务key，去寻找Exporter对象，从Exporter中得到Invoker，然后执行invoke方法，此Invoker为ProtocolFilterWrapper$CallbackRegistrationInvoker</li><li>ProtocolFilterWrapper$CallbackRegistrationInvoker：负责执行过滤器链，并且在执行完了之后回调每个过滤器的onResponse或onError方法</li><li>EchoFilter：判断当前请求是不是一个回升测试，如果是，则不继续执行过滤器链了（服务实现者Invoker也不会调用了）</li><li>ClassLoaderFilter：设置当前线程的classloader为当前要执行的服务接口所对应的classloader</li><li>GenericFilter：把泛化调用发送过来的信息包装为RpcInvocation对象</li><li>ContextFilter：设置RpcContext.getContext()的参数</li><li>TraceFilter：先执行下一个invoker的invoke方法，调用成功后录调用信息</li><li>TimeoutFilter：调用时没有特别处理，只是记录了一下当前时间，当整个filter链都执行完了之后回调TimeoutFilter的onResponse方法时，会判断本次调用是否超过了timeout</li><li>MonitorFilter：记录当前服务的执行次数</li><li>ExceptionFilter：调用时没有特别处理，在回调onResponse方法时，对不同的异常进行处理，详解Dubbo的异常处理</li><li>DelegateProviderMetaDataInvoker：过滤器链结束，调用下一个Invoker</li><li>AbstractProxyInvoker：在服务导出时，根据服务接口，服务实现类对象生成的，它的invoke方法就会执行服务实现类对象的方法，得到结果</li></ol><h2 id="Dubbo的异常处理"><a href="#Dubbo的异常处理" class="headerlink" title="Dubbo的异常处理"></a>Dubbo的异常处理</h2><p>当服务消费者在调用一个服务时，服务提供者在执行服务逻辑时可能会出现异常，对于Dubbo来说，服务消费者需要在消费端抛出这个异常，那么这个功能是怎么做到的呢？<br>服务提供者在执行服务时，如果出现了异常，那么框架会把异常捕获，捕获异常的逻辑在AbstractProxyInvoker中，捕获到异常后，会把异常信息包装为正常的AppResponse对象，只是AppResponse的value属性没有值，exception属性有值。<br>此后，服务提供者会把这个AppResponse对象发送给服务消费端，服务消费端是在InvokerInvocationHandler中调用AppResponse的recreate方法重新得到一个结果，在recreate方法中会去失败AppResponse对象是否正常，也就是是否存在exception信息，如果存在，则直接throw这个exception，从而做到服务执行时出现的异常，在服务消费端抛出。<br>那么这里存在一个问题，如果服务提供者抛出的异常类，在服务消费者这边不存在，那么服务消费者也就抛不出这个异常了，那么dubbo是怎么处理的呢？<br>这里就涉及到了ExceptionFilter，它是服务提供者端的一个过滤器，它主要是在服务提供者执行完服务后会去识别异常：</p><ol><li>如果是需要开发人员捕获的异常，那么忽略，直接把这个异常返回给消费者</li><li>如果在当前所执行的方法签名上有声明，那么忽略，直接把这个异常返回给消费者</li><li>如果抛出的异常不需要开发人员捕获，或者方法上没有申明，那么服务端或记录一个error日志</li><li>异常类和接口类在同一jar包里，那么忽略，直接把这个异常返回给消费者</li><li>如果异常类是JDK自带的异常，那么忽略，直接把这个异常返回给消费者</li><li>如果异常类是Dubbo自带的异常，那么忽略，直接把这个异常返回给消费者</li><li>否则，把异常信息包装成RuntimeException，并覆盖AppResponse对象中的exception属性</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;服务消费端执行逻辑&quot;&gt;&lt;a href=&quot;#服务消费端执行逻辑&quot; class=&quot;headerlink&quot; title=&quot;服务消费端执行逻辑&quot;&gt;&lt;/a&gt;服务消费端执行逻辑&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;nvoker.invoke(new RpcInvocation(meth
      
    
    </summary>
    
      <category term="dubbo" scheme="http://www.lilhui.com/categories/dubbo/"/>
    
    
      <category term="服务调用" scheme="http://www.lilhui.com/tags/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Druid连接池 communications link failure问题</title>
    <link href="http://www.lilhui.com/2022/03/03/java/midware/druid_1/"/>
    <id>http://www.lilhui.com/2022/03/03/java/midware/druid_1/</id>
    <published>2022-03-03T01:46:31.000Z</published>
    <updated>2022-03-08T08:30:35.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>项目基于Spring boot 链接数据库用的Druid连接池1.1.16版。通过nginx代理连接数据库。数据库配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show VARIABLES like &apos;%timeout%&apos;</span><br><span class="line">        interactive_timeout 1000</span><br><span class="line">        wait_timeout 1000</span><br></pre></td></tr></table></figure></p><p>物理链接空闲1000秒后会进行回收。<br>druid连接池配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timeBetweenEvictionRunsMillis: 10000</span><br><span class="line">minEvictableIdleTimeMillis: 30000</span><br><span class="line">maxEvictableIdleTimeMillis: 84000</span><br></pre></td></tr></table></figure></p><p>每隔10秒回进行判断空闲时间大于30秒的，或者总存活时间大于84秒的，是否需要回收。按照道理不会有问题，但是执行后会发现druid后台的逻辑链接打开次数<br>大于逻辑链接关闭次数。两者之差，正好等于物理连接打开次数-物理链接关闭次数-1。（-1是因为配置的最小链接数量）。通过后台日志查看到会报</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Communications link failure\n\nThe last packet successfully received from the server was 3 milliseconds ago. The last packet sent successfully to the server was 4 milliseconds ago.; nested exception is com.mysql.cj.jdbc.exceptions.CommunicationsException: Communications link failure\n\nThe last packet successfully received from the server was 3 milliseconds ago. The last packet sent successfully to the server was 4 milliseconds ago.</span><br></pre></td></tr></table></figure><p>看着很难受，也影响使用。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>druid通过MySqlValidConnectionChecker类进行链接健康检查。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>   <span class="title">MySqlValidConnectionChecker</span></span>&#123;</span><br><span class="line">    <span class="comment">//其他方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configFromProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        String property = properties.getProperty(<span class="string">"druid.mysql.usePingMethod"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"true"</span>.equals(property)) &#123;</span><br><span class="line">            setUsePingMethod(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"false"</span>.equals(property)) &#123;</span><br><span class="line">            setUsePingMethod(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidConnection</span><span class="params">(Connection conn, String validateQuery, <span class="keyword">int</span> validationQueryTimeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (conn.isClosed()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (usePingMethod) &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn <span class="keyword">instanceof</span> DruidPooledConnection) &#123;</span><br><span class="line">                conn = ((DruidPooledConnection) conn).getConnection();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (conn <span class="keyword">instanceof</span> ConnectionProxy) &#123;</span><br><span class="line">                conn = ((ConnectionProxy) conn).getRawObject();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (clazz.isAssignableFrom(conn.getClass())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (validationQueryTimeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    validationQueryTimeout = DEFAULT_VALIDATION_QUERY_TIMEOUT;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ping.invoke(conn, <span class="keyword">true</span>, validationQueryTimeout * <span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                    Throwable cause = e.getCause();</span><br><span class="line">                    <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> SQLException) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> (SQLException) cause;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String query = validateQuery;</span><br><span class="line">        <span class="keyword">if</span> (validateQuery == <span class="keyword">null</span> || validateQuery.isEmpty()) &#123;</span><br><span class="line">            query = DEFAULT_VALIDATION_QUERY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="keyword">if</span> (validationQueryTimeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                stmt.setQueryTimeout(validationQueryTimeout);</span><br><span class="line">            &#125;</span><br><span class="line">            rs = stmt.executeQuery(query);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtils.close(rs);</span><br><span class="line">            JdbcUtils.close(stmt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查链接是否存活。默认是用的internalPing方法。这个方法会一直返回true 当达到mysql的wait_timeout后。数据库将物理链接关闭，druid端还认为可用。<br>这就有问题了。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>使用validationQuery进行检查。<br>配置方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 增加yml配置</span><br><span class="line">validationQuery: select &apos;x&apos;</span><br><span class="line">2.  启动时参数带上</span><br><span class="line">    -Ddruid.mysql.usePingMethod=false</span><br><span class="line">    或者在druid配置类上加入：</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void setProperties()&#123;</span><br><span class="line">        System.setProperty(&quot;druid.mysql.usePingMethod&quot;,&quot;false&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;项目基于Spring boot 链接数据库用的Druid连接池1.1.16版。通过nginx代理连接数据库。数据库配置&lt;br&gt;&lt;figure
      
    
    </summary>
    
      <category term="druid" scheme="http://www.lilhui.com/categories/druid/"/>
    
    
      <category term="druid" scheme="http://www.lilhui.com/tags/druid/"/>
    
  </entry>
  
  <entry>
    <title>【Dubbo源码系列5】Duboo 服务引入</title>
    <link href="http://www.lilhui.com/2022/02/18/java/dubbo/dubbo_5/"/>
    <id>http://www.lilhui.com/2022/02/18/java/dubbo/dubbo_5/</id>
    <published>2022-02-18T06:39:10.000Z</published>
    <updated>2022-03-07T03:57:02.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dubbo服务引入源码分析"><a href="#Dubbo服务引入源码分析" class="headerlink" title="Dubbo服务引入源码分析"></a>Dubbo服务引入源码分析</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li>服务引入原理解析</li><li>路由链源码解析</li><li>服务静态目录与动态目录源码解析</li><li>服务引入源码解析</li></ol><h3 id="服务引入原理"><a href="#服务引入原理" class="headerlink" title="服务引入原理"></a>服务引入原理</h3><p>当Spring启动过程中，会去给@Reference注解标注了的属性去进行赋值，赋值的对象为ReferenceBean中get()方法所返回的对象，这个对象是一个代理对象。<br>对于ReferenceBean，它表示应用想要引入的服务的信息，在执行get()时会做如下几步：</p><ol><li>调用checkAndUpdateSubConfigs()，检查和更新参数，和服务提供者类似，把ReferenceBean里的属性的值更新为优先级最高的参数值</li><li>调用init()去生成代理对象ref，get()方法会返回这个ref</li><li>在生成代理对象ref之前，先把消费者所引入服务设置的参数添加到一个map中，等会根据这个map中的参数去从注册中心查找服务</li><li>把消费者配置的所有注册中心获取出来<br>a. 如果只有一个注册中心，那么直接调用Protocol的refer(interfaceClass, urls.get(0));得到一个Invoker对象<br>b. 如果有多个注册中心，则遍历每个注册中心，分别调用Protocol的refer(interfaceClass, url);得到一个Invoker对象添加到invokers中，然后把invokers调用CLUSTER.join(new StaticDirectory(u, invokers));封装所有invokers得到一个invoker，</li><li>把最终得到的invoker对象调用PROXY_FACTORY.getProxy(invoker);得到一个代理对象，并返回，这个代理对象就是ref</li><li>总结：上文的Invoker对象，表示服务执行者，从注册中心refer下来的是一个服务执行者，合并invokers后得到的invoker也是一个服务执行者（抽象范围更大了）</li></ol><p>接下来，来看Protorol.refer(interfaceClass, url)方法是怎么生成一个Invoker的</p><ol><li>首先interfaceClass表示要引入的服务接口，url是注册中心的url（registry://），该url中有一个refer参数，参数值为当前所要引入服务的参数</li><li>调用doRefer(cluster, registry, type, url)</li><li>在doRefer方法中会生成一个RegistryDirectory</li><li>然后获取新版本中的路由器链，并添加到RegistryDirectory中去</li><li>RegistryDirectory监听几个目录（注意，完成监听器的订阅绑定后，会自动触发一次去获取这些目录上的当前数据）<br>a. 当前所引入的服务的动态配置目录：/dubbo/config/dubbo/org.apache.dubbo.demo.DemoService:1.1.1:g1.configurators<br>b. 当前所引入的服务的提供者目录：/dubbo/org.apache.dubbo.demo.DemoService/providers<br>c. 当前所引入的服务的老版本动态配置目录：/dubbo/org.apache.dubbo.demo.DemoService/configurators<br>d. 当前所引入的服务的老版本路由器目录：/dubbo/org.apache.dubbo.demo.DemoService/routers</li><li>调用cluster.join(directory)得到一个invoker</li><li>返回invoker（如果消费者引入了多个group中的服务，那么这里返回的是new MergeableClusterInvoker<t>(directory);，否则返回的是new FailoverClusterInvoker<t>(directory);）</t></t></li><li>但是，上面返回的两个Invoker都会被MockClusterInvoker包装，所以最终返回的是MockClusterInvoker。</li></ol><ol><li>获取服务提供者列表</li><li>Mock</li><li>路由 M–&gt;N</li><li>负载均衡 N—&gt;1</li><li>集群容错</li><li>构造NettyClient</li><li>发送数据</li></ol><h2 id="服务引入"><a href="#服务引入" class="headerlink" title="服务引入"></a>服务引入</h2><ol><li>构造Invoker</li><li>DemoService 服务目录。当前服务的提供者列表 List<invoker> 实际上是 List<dubboinvoker><ol><li>构造一个服务目录的时候要到注册中心查看</li><li>多少个提供者 List<invoker>就多少个 List<dubboinvoker></dubboinvoker></invoker></li><li>监听 当前服务对应的节点</li><li>路由 TagRouter–&gt;AppRouter–&gt;ServiceRouter<br>本质上是构造一个代理对象。代理对象最重要的是Invoker</li></ol></dubboinvoker></invoker></li></ol><p>代理对象逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">代理对象.a() &#123;</span><br><span class="line">    invoker.invoke(Invocation)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>代理对象<br>  Invoker invoker 有这个就行了。</li><li>Invoker<br>MockClusterInvoker.invoke()<br>  FailoverClusterInvoker.invoke()<pre><code>DubboInvoker.invoke()</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dubbo服务引入源码分析&quot;&gt;&lt;a href=&quot;#Dubbo服务引入源码分析&quot; class=&quot;headerlink&quot; title=&quot;Dubbo服务引入源码分析&quot;&gt;&lt;/a&gt;Dubbo服务引入源码分析&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; cla
      
    
    </summary>
    
      <category term="dubbo" scheme="http://www.lilhui.com/categories/dubbo/"/>
    
    
      <category term="服务引入" scheme="http://www.lilhui.com/tags/%E6%9C%8D%E5%8A%A1%E5%BC%95%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>【Dubbo源码系列4】Duboo 服务导出</title>
    <link href="http://www.lilhui.com/2022/02/18/java/dubbo/dubbo_4/"/>
    <id>http://www.lilhui.com/2022/02/18/java/dubbo/dubbo_4/</id>
    <published>2022-02-18T06:38:07.000Z</published>
    <updated>2022-03-03T08:54:59.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dubbo服务导出源码解析"><a href="#Dubbo服务导出源码解析" class="headerlink" title="Dubbo服务导出源码解析"></a>Dubbo服务导出源码解析</h2><p>服务导出流程 </p><ol><li>读取配置(端口，协议，loadbalance，注册中心)</li><li>启动netty,tomcat</li><li>服务注册 -&gt; 服务信息 -&gt; 注册中心</li><li>服务提供者，监听动态配置</li></ol><ol start="2"><li>服务注册<br>围绕URL + SPI</li></ol><p>export -&gt; doRegister<br>构造URL剔除冗余 信息，调用注册中心的接口保存到注册中心。</p><p>注册中心URL-&gt;服务URL-&gt;简化-&gt;注册</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dubbo服务导出源码解析&quot;&gt;&lt;a href=&quot;#Dubbo服务导出源码解析&quot; class=&quot;headerlink&quot; title=&quot;Dubbo服务导出源码解析&quot;&gt;&lt;/a&gt;Dubbo服务导出源码解析&lt;/h2&gt;&lt;p&gt;服务导出流程 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读取配置(
      
    
    </summary>
    
      <category term="dubbo" scheme="http://www.lilhui.com/categories/dubbo/"/>
    
    
      <category term="服务导出" scheme="http://www.lilhui.com/tags/%E6%9C%8D%E5%8A%A1%E5%AF%BC%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>【Dubbo源码系列3】Duboo 可扩展机制SPI源码解析</title>
    <link href="http://www.lilhui.com/2022/02/16/java/dubbo/dubbo_3/"/>
    <id>http://www.lilhui.com/2022/02/16/java/dubbo/dubbo_3/</id>
    <published>2022-02-16T06:12:39.000Z</published>
    <updated>2022-02-17T03:59:09.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dubbo-SPI架构图"><a href="#Dubbo-SPI架构图" class="headerlink" title="Dubbo SPI架构图"></a>Dubbo SPI架构图</h2><p><img src="http://images.lilhui.com/8920bd45bf8beedd17b1bab7339363cc" alt="图片"></p><ul><li>Demo获取Dubbo的protocol扩展点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExtensionLoader&lt;Protocol&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Protocol http = extensionLoader.getExtension(<span class="string">"dubbo"</span>);</span><br><span class="line">System.out.println(http);</span><br></pre></td></tr></table></figure><p>在ExtensionLoader类的内部有一个static的ConcurrentHashMap，用来缓存某个接口类型所对应的ExtensionLoader实例.</p><h2 id="ExtensionLoader"><a href="#ExtensionLoader" class="headerlink" title="ExtensionLoader"></a>ExtensionLoader</h2><p>ExtensionLoader表示某个接口的扩展点加载器，可以用来加载某个扩展点实例。<br>在ExtensionLoader中除开有上文的static的Map外，还有两个非常重要的属性：</p><ol><li>Class&lt;?&gt; type：表示当前ExtensionLoader实例是哪个接口的扩展点加载器</li><li>ExtensionFactory objectFactory：扩展点工厂（对象工厂），可以获得某个对象</li></ol><p>ExtensionLoader和ExtensionFactory的区别在于：</p><ol><li>ExtensionLoader最终所得到的对象是Dubbo SPI机制产生的</li><li>ExtensionFactory最终所得到的对象可能是Dubbo SPI机制所产生的，也可能是从Spring容器中所获得的对象</li></ol><p>在ExtensionLoader中有三个常用的方法：</p><ol><li>getExtension(“dubbo”)：表示获取名字为dubbo的扩展点实例</li><li>getAdaptiveExtension()：表示获取一个自适应的扩展点实例</li><li>getActivateExtension(URL url, String[] values, String group)：表示一个可以被url激活的扩展点实例，后文详细解释</li></ol><p>其中，什么是自适应扩展点实例？它其实就是当前这个接口的一个代理对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExtensionLoader&lt;Protocol&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Protocol protocol = extensionLoader.getExtension(<span class="string">"dubbo"</span>);</span><br></pre></td></tr></table></figure></p><p>当我们调用上述代码，我们会将得到一个DubboProtocol的实例对象，但在getExtension()方法中，Dubbo会对DubboProtocol对象进行依赖注入（也就是自动给属性赋值，属性的类型为一个接口，记为A接口），这个时候，对于Dubbo来说它并不知道该给这个属性赋什么值，换句话说，Dubbo并不知道在进行依赖注入时该找一个什么的的扩展点对象给这个属性，这时就会预先赋值一个A接口的自适应扩展点实例，也就是A接口的一个代理对象。</p><p>后续，在A接口的代理对象被真正用到时，才会结合URL信息找到真正的A接口对应的扩展点实例进行调用。</p><p><img src="http://images.lilhui.com/d917674e8a07d8f91ed5a9e4ebf49e04" alt="图片"></p><h3 id="getExtension-String-name-方法"><a href="#getExtension-String-name-方法" class="headerlink" title="getExtension(String name)方法"></a>getExtension(String name)方法</h3><p>在调用getExtension去获取一个扩展点实例后，会对实例进行缓存，下次再获取同样名字的扩展点实例时就会从缓存中拿了。</p><h3 id="createExtension-String-name-方法"><a href="#createExtension-String-name-方法" class="headerlink" title="createExtension(String name)方法"></a>createExtension(String name)方法</h3><p>在调用createExtension(String name)方法去创建一个扩展点实例时，要经过以下几个步骤：</p><ol><li>根据name找到对应的扩展点实现类</li><li>根据实现类生成一个实例，把实现类和对应生成的实例进行缓存</li><li>对生成出来的实例进行依赖注入（给实例的属性进行赋值）</li><li>对依赖注入后的实例进行AOP（Wrapper）,把当前接口类的所有的Wrapper全部一层一层包裹在实例对象上，没包裹个Wrapper后，也会对Wrapper对象进行依赖注入</li><li>返回最终的Wrapper对象</li></ol><p><img src="http://images.lilhui.com/265316c207746d158fcfe520beebd065" alt="图片"></p><h3 id="getExtensionClasses"><a href="#getExtensionClasses" class="headerlink" title="getExtensionClasses"></a>getExtensionClasses</h3><p>getExtensionClasses()是用来加载当前接口所有的扩展点实现类的，返回一个Map。之后可以从这个Map中按照指定的name获取对应的扩展点实现类。</p><p>当把当前接口的所有扩展点实现类都加载出来后也会进行缓存，下次需要加载时直接拿缓存中的。</p><p>Dubbo在加载一个接口的扩展点时，思路是这样的：</p><ol><li>根据接口的全限定名去META-INF/dubbo/internal/目录下寻找对应的文件，调用loadResource方法进行加载</li><li>根据接口的全限定名去META-INF/dubbo/目录下寻找对应的文件，调用loadResource方法进行加载</li><li>根据接口的全限定名去META-INF/services/目录下寻找对应的文件，调用loadResource方法进行加载</li></ol><p>这里其实会设计到老版本兼容的逻辑，不解释了。</p><h3 id="loadResource方法"><a href="#loadResource方法" class="headerlink" title="loadResource方法"></a>loadResource方法</h3><p>loadResource方法就是完成对文件内容的解析，按行进行解析，会解析出”=”两边的内容，”=”左边的内容就是扩展点的name，右边的内容就是扩展点实现类，并且会利用ExtensionLoader类的类加载器来加载扩展点实现类。</p><p>然后调用loadClass方法对name和扩展点实例进行详细的解析，并且最终把他们放到Map中去。</p><h3 id="loadClass方法"><a href="#loadClass方法" class="headerlink" title="loadClass方法"></a>loadClass方法</h3><p>loadClass方法会做如下几件事情：</p><ol><li>当前扩展点实现类上是否存在@Adaptive注解，如果存在则把该类认为是当前接口的默认自适应类（接口代理类），并把该类存到cachedAdaptiveClass属性上。</li><li>当前扩展点实现是否是一个当前接口的一个Wrapper类，如果判断的？就是看当前类中是否存在一个构造方法，该构造方法只有一个参数，参数类型为接口类型，如果存在这一的构造方法，那么这个类就是该接口的Wrapper类，如果是，则把该类添加到cachedWrapperClasses中去， cachedWrapperClasses是一个set。</li><li>如果不是自适应类，或者也不是Wrapper类，则判断是有存在name，如果没有name，则报错。</li><li>如果有多个name，则判断一下当前扩展点实现类上是否存在@Activate注解，如果存在，则把该类添加到cachedActivates中，cachedWrapperClasses是一个map。</li><li>最后，遍历多个name，把每个name和对应的实现类存到extensionClasses中去，extensionClasses就是上文所提到的map。</li></ol><p>至此，加载类就走完了。<br>回到createExtension(String name)方法中的逻辑，当前这个接口的所有扩展点实现类都扫描完了之后，就可以根据用户所指定的名字，找到对应的实现类了，然后进行实例化，然后进行IOC(依赖注入)和AOP。</p><h2 id="Dubbo中的IOC"><a href="#Dubbo中的IOC" class="headerlink" title="Dubbo中的IOC"></a>Dubbo中的IOC</h2><ol><li>根据当前实例的类，找到这个类中的setter方法，进行依赖注入</li><li>先分析出setter方法的参数类型pt</li><li>在截取出setter方法所对应的属性名property</li><li>调用objectFactory.getExtension(pt, property)得到一个对象，这里就会从Spring容器或通过DubboSpi机制得到一个对象，比较特殊的是，如果是通过DubboSpi机制得到的对象，是pt这个类型的一个自适应对象(代理对象)。</li><li>再反射调用setter方法进行注入</li></ol><h2 id="Dubbo中的AOP"><a href="#Dubbo中的AOP" class="headerlink" title="Dubbo中的AOP"></a>Dubbo中的AOP</h2><p>dubbo中也实现了一套非常简单的AOP，就是利用Wrapper，如果一个接口的扩展点中包含了多个Wrapper类，那么在实例化完某个扩展点后，就会利用这些Wrapper类对这个实例进行包裹，比如：现在有一个DubboProtocol的实例，同时对于Protocol这个接口还有很多的Wrapper，比如ProtocolFilterWrapper、ProtocolListenerWrapper，那么，当对DubboProtocol的实例完成了IOC之后，就会先调用new ProtocolFilterWrapper(DubboProtocol实例)生成一个新的Protocol的实例，再对此实例进行IOC，完了之后，会再调用new ProtocolListenerWrapper(ProtocolFilterWrapper实例)生成一个新的Protocol的实例，然后进行IOC，从而完成DubboProtocol实例的AOP。</p><h2 id="自适应扩展点补充"><a href="#自适应扩展点补充" class="headerlink" title="自适应扩展点补充"></a>自适应扩展点补充</h2><p>上面提到的自适应扩展点对象，也就是某个接口的代理对象是通过Dubbo内部生成代理类，然后生成代理对象的。</p><p>额外的，在Dubbo中还设计另外一种机制来生成自适应扩展点，这种机制就是可以通过@Adaptive注解来指定某个类为某个接口的代理类，如果指定了，Dubbo在生成自适应扩展点对象时实际上生成的就是@Adaptive注解所注解的类的实例对象。</p><p>如果是由Dubbo默认实现的，那么我们就看看Dubbo是如何生成代理类的。</p><h3 id="createAdaptiveExtensionClass方法"><a href="#createAdaptiveExtensionClass方法" class="headerlink" title="createAdaptiveExtensionClass方法"></a>createAdaptiveExtensionClass方法</h3><p>createAdaptiveExtensionClass方法就是Dubbo中默认生成Adaptive类实例的逻辑。说白了，这个实例就是当前这个接口的一个代理对象。比如下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExtensionLoader&lt;Protocol&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Protocol protocol = extensionLoader.getAdaptiveExtension();</span><br></pre></td></tr></table></figure><p>这个代码就是Protocol接口的一个代理对象，那么代理逻辑就是在new AdaptiveClassCodeGenerator(type, cachedDefaultName).generate()方法中。</p><ol><li>type就是接口</li><li>cacheDefaultName就是该接口默认的扩展点实现的名字</li></ol><p>看个例子，Protocol接口的Adaptive类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.rpc;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Protocol</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">rpc</span>.<span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span>  </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"The method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span>  </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"The method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Exporter <span class="title">export</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument == null"</span>);</span><br><span class="line"><span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument getUrl() == null"</span>);</span><br><span class="line"></span><br><span class="line">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line"></span><br><span class="line">        String extName = ( url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol() );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url ("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        </span><br><span class="line">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">extName</span>)</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> extension.export(arg0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Invoker <span class="title">refer</span><span class="params">(java.lang.Class arg0, org.apache.dubbo.common.URL arg1)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arg1 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line"></span><br><span class="line">        org.apache.dubbo.common.URL url = arg1;</span><br><span class="line"></span><br><span class="line">        String extName = ( url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol() );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url ("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line"></span><br><span class="line">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">extName</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> extension.refer(arg0, arg1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Protocol接口中有四个方法，但是只有export和refer两个方法进行代理。为什么？因为Protocol接口中在export方法和refer方法上加了@Adaptive注解。但是，不是只要在方法上加了@Adaptive注解就可以进行代理，还有其他条件，比如：</p><ol><li>该方法如果是无参的，那么则会报错</li><li>该方法有参数，可以有多个，并且其中某个参数类型是URL，那么则可以进行代理</li><li>该方法有参数，可以有多个，但是没有URL类型的参数，那么则不能进行代理</li><li>该方法有参数，可以有多个，没有URL类型的参数，但是如果这些参数类型，对应的类中存在getUrl方法（返回值类型为URL），那么也可以进行代理</li></ol><p>所以，可以发现，某个接口的Adaptive对象，在调用某个方法时，是通过该方法中的URL参数，通过调用ExtensionLoader.getExtensionLoader(com.luban.Car.class).getExtension(extName);得到一个扩展点实例，然后调用该实例对应的方法。</p><h3 id="Activate扩展点"><a href="#Activate扩展点" class="headerlink" title="Activate扩展点"></a>Activate扩展点</h3><p>上文说到，每个扩展点都有一个name，通过这个name可以获得该name对应的扩展点实例，但是有的场景下，希望一次性获得多个扩展点实例</p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight plain"><figcaption><span>extensionLoader </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">URL url = new URL(&quot;http://&quot;, &quot;localhost&quot;, 8080);</span><br><span class="line">url = url.addParameter(&quot;cache&quot;, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">List&lt;Filter&gt; activateExtensions = extensionLoader.getActivateExtension(url, </span><br><span class="line">                                                      new String[]&#123;&quot;validation&quot;&#125;,</span><br><span class="line">                                                      CommonConstants.CONSUMER);</span><br><span class="line">for (Filter activateExtension : activateExtensions) &#123;</span><br><span class="line">System.out.println(activateExtension);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会找到5个Filter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.apache.dubbo.rpc.filter.ConsumerContextFilter@<span class="number">4566e5</span>bd</span><br><span class="line">org.apache.dubbo.rpc.protocol.dubbo.filter.FutureFilter@<span class="number">1</span>ed4004b</span><br><span class="line">org.apache.dubbo.monitor.support.MonitorFilter<span class="meta">@ff</span>5b51f</span><br><span class="line">org.apache.dubbo.cache.filter.CacheFilter@<span class="number">25</span>bbe1b6</span><br><span class="line">org.apache.dubbo.validation.filter.ValidationFilter@<span class="number">5702</span>b3b1</span><br></pre></td></tr></table></figure><p>前三个是通过CommonConstants.CONSUMER找到的<br>CacheFilter是通过url中的参数找到的<br>ValidationFilter是通过指定的name找到的</p><p>在一个扩展点类上，可以添加@Activate注解，这个注解的属性有：</p><ol><li>String[] group()：表示这个扩展点是属于哪组的，这里组通常分为PROVIDER和CONSUMER，表示该扩展点能在服务提供者端，或者消费端使用</li><li>String[] value()：表示的是URL中的某个参数key，当利用getActivateExtension方法来寻找扩展点时，如果传入的url中包含的参数的所有key中，包括了当前扩展点中的value值，那么则表示当前url可以使用该扩展点</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dubbo-SPI架构图&quot;&gt;&lt;a href=&quot;#Dubbo-SPI架构图&quot; class=&quot;headerlink&quot; title=&quot;Dubbo SPI架构图&quot;&gt;&lt;/a&gt;Dubbo SPI架构图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://images.lilhui
      
    
    </summary>
    
      <category term="dubbo" scheme="http://www.lilhui.com/categories/dubbo/"/>
    
    
      <category term="SPI" scheme="http://www.lilhui.com/tags/SPI/"/>
    
  </entry>
  
  <entry>
    <title>shardingsphere简单源码解析</title>
    <link href="http://www.lilhui.com/2022/02/14/java/shardingsphere/shardingsphere_2/"/>
    <id>http://www.lilhui.com/2022/02/14/java/shardingsphere/shardingsphere_2/</id>
    <published>2022-02-14T07:41:01.000Z</published>
    <updated>2022-02-14T07:45:25.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>解析-&gt;路由-&gt;改写-&gt;执行-&gt;归并</p><ol><li>初始化过程</li></ol><p>ShardingDataSourceFactory.createDataSource</p><blockquote><p>ShardingRule 分片规则通过配置加载到内存中</p></blockquote><ol start="2"><li>SQL执行过程<br>(上下文)<br>ShardingStatement.executeQuery<blockquote><p>Statement   SqlRoute<br>statementEngine.route<br>StanndardRoutingEngine<br>SQLRewriteEngine<br>SQLRewriteEngine.generateSQL<br>SQLExecuteCallback.executeSQL //StatmentExecutor.executeQuery()多线程执行，同时执行多个sql</p></blockquote></li></ol><p>关键类<br>ShardingRouter.route</p><blockquote><p>ParsingSQLRouter.parse</p></blockquote><ul><li><p>SQL 语法解析<br>LexerEngine</p></li><li><p>SQL解析引擎<br>RoutingEngineFactory.</p></li><li><p>改写引擎<br>SQLRewritEngine</p></li></ul><p>比如 *** DESC limit 1,2<br>要改写成 limit 0,3<br>因为是倒序。直接用原来的limit可能会将需要到的结果截断。</p><ul><li><p>执行引擎<br>ShardingExecuteEngine</p></li><li><p>归并引擎<br>MergeEngine</p></li></ul><p>简单的 归并，获取limit x,y</p><p>优先队列。<br>每个分表获取的结果形成一个有序队列。然后用每个队列的第一个进行比较，每次需要就弹出一个。没有对其进行所有的合并。</p><p>clear 清空<br>sqlRoute(sql)<br>initStatementExecutor()</p><ul><li>读写分离<br>MasterSLave路由</li></ul><p>MasterSlaveRouter.route<br>-&gt; SQLJudgeEngine.judge</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;源码分析&quot;&gt;&lt;a href=&quot;#源码分析&quot; class=&quot;headerlink&quot; title=&quot;源码分析&quot;&gt;&lt;/a&gt;源码分析&lt;/h2&gt;&lt;p&gt;解析-&amp;gt;路由-&amp;gt;改写-&amp;gt;执行-&amp;gt;归并&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化过程&lt;/li&gt;
&lt;/ol&gt;
&lt;
      
    
    </summary>
    
      <category term="shardingsphere" scheme="http://www.lilhui.com/categories/shardingsphere/"/>
    
    
      <category term="分表" scheme="http://www.lilhui.com/tags/%E5%88%86%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>分库分表垂直详解与框架介绍</title>
    <link href="http://www.lilhui.com/2022/02/14/java/shardingsphere/shardingsphere_1/"/>
    <id>http://www.lilhui.com/2022/02/14/java/shardingsphere/shardingsphere_1/</id>
    <published>2022-02-14T07:40:12.000Z</published>
    <updated>2022-02-14T07:40:48.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是分库分表"><a href="#什么是分库分表" class="headerlink" title="什么是分库分表"></a>什么是分库分表</h1><p>性能瓶颈一般在数据库。</p><h1 id="为什么要分库分表"><a href="#为什么要分库分表" class="headerlink" title="为什么要分库分表"></a>为什么要分库分表</h1><p>增加性能。</p><h1 id="分库分表带来的问题"><a href="#分库分表带来的问题" class="headerlink" title="分库分表带来的问题"></a>分库分表带来的问题</h1><p>分库分表：<br>增加了维护成本<br>分布式事务问题<br>跨库join<br>分布式全局唯一ID</p><h1 id="分库分表算法"><a href="#分库分表算法" class="headerlink" title="分库分表算法"></a>分库分表算法</h1><p>取模  hash<br>解决数据热点问题，但是扩展麻烦<br>范围区分  range<br>解决扩展问题，仍然有数据热点问题。<br>预定义  固定编码<br>1 亿</p><h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><p>读多写少，分离主库的压力</p><h2 id="读写分离的问题"><a href="#读写分离的问题" class="headerlink" title="读写分离的问题"></a>读写分离的问题</h2><p>主从同步，数据一致性，网络延迟问题</p><p>强制路由：强制去访问master。下单的过程中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是分库分表&quot;&gt;&lt;a href=&quot;#什么是分库分表&quot; class=&quot;headerlink&quot; title=&quot;什么是分库分表&quot;&gt;&lt;/a&gt;什么是分库分表&lt;/h1&gt;&lt;p&gt;性能瓶颈一般在数据库。&lt;/p&gt;
&lt;h1 id=&quot;为什么要分库分表&quot;&gt;&lt;a href=&quot;#为什么要分库
      
    
    </summary>
    
      <category term="shardingsphere" scheme="http://www.lilhui.com/categories/shardingsphere/"/>
    
    
      <category term="分表" scheme="http://www.lilhui.com/tags/%E5%88%86%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>监控URL返回非200后执行重启脚本</title>
    <link href="http://www.lilhui.com/2022/02/11/tools/tools_1/"/>
    <id>http://www.lilhui.com/2022/02/11/tools/tools_1/</id>
    <published>2022-02-11T10:53:43.000Z</published>
    <updated>2022-02-11T10:56:21.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">TARGET_ADDR=$1</span><br><span class="line">TARGET_STATE=0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while true ;do</span><br><span class="line"></span><br><span class="line">    echo `date +"%Y-%m-%d %H:%M:%S"` start access $&#123;TARGET_ADDR&#125; &gt;&gt; statusMonitor.log</span><br><span class="line">    if [ $TARGET_STATE -gt 3 ];then</span><br><span class="line">        echo `date +"%Y-%m-%d %H:%M:%S"` can not  access $&#123;TARGET_ADDR&#125; ,service will reboot!</span><br><span class="line">        echo "&amp;&amp;&amp;&amp;&amp;&amp; reboot server!"</span><br><span class="line">        nohup ~/bin/restart.sh &gt;&gt; restart.log 2&gt;&amp;1 &amp;</span><br><span class="line">        sleep 360</span><br><span class="line">        let TARGET_STATE=0</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    HTTP_CODE=`curl -I -m 10 -o /dev/null -s -w %&#123;http_code&#125;"\n" $&#123;TARGET_ADDR&#125;`</span><br><span class="line">    if [ "$&#123;HTTP_CODE&#125;" != 200 ];then</span><br><span class="line">        echo `date +"%Y-%m-%d %H:%M:%S"` The $&#123;TARGET_STATE&#125; time  can not access</span><br><span class="line">        echo "****** Error:  Down!" &gt;&gt; statusMonitor.log</span><br><span class="line">        let TARGET_STATE=TARGET_STATE+1</span><br><span class="line">    else</span><br><span class="line">        echo "###### success" &gt;&gt; statusMonitor.log</span><br><span class="line">    fi</span><br><span class="line">    sleep 10</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./checkRunningStatus.sh www.lilhui.com &amp;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;脚本&quot;&gt;&lt;a href=&quot;#脚本&quot; class=&quot;headerlink&quot; title=&quot;脚本&quot;&gt;&lt;/a&gt;脚本&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="tools" scheme="http://www.lilhui.com/categories/tools/"/>
    
    
      <category term="shell" scheme="http://www.lilhui.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>【Java IO详解5】Netty实践2</title>
    <link href="http://www.lilhui.com/2022/02/10/java/io/netty_5/"/>
    <id>http://www.lilhui.com/2022/02/10/java/io/netty_5/</id>
    <published>2022-02-10T07:13:57.000Z</published>
    <updated>2022-02-14T07:37:47.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RPC实践"><a href="#RPC实践" class="headerlink" title="RPC实践"></a>RPC实践</h2><ul><li>http服务</li></ul><p>Netty实现了完整的http协议 HttpHandler只要在channelHandler初始化的时候设置就行。FullHttpServerHandler</p><ul><li>服务推送技术</li></ul><p>WebSocket</p><p><img src="http://images.lilhui.com/2e200872f8eac314980765e2adba30c0" alt="图片"></p><p>1：建立http请求<br>2：建立WebSocket握手</p><p>协议升级</p><p>子协议：STOMP<br>文本定向消息协议<br>生产者，消息代理，消费者。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RPC实践&quot;&gt;&lt;a href=&quot;#RPC实践&quot; class=&quot;headerlink&quot; title=&quot;RPC实践&quot;&gt;&lt;/a&gt;RPC实践&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;http服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Netty实现了完整的http协议 HttpHandler只要
      
    
    </summary>
    
      <category term="io" scheme="http://www.lilhui.com/categories/io/"/>
    
    
      <category term="netty" scheme="http://www.lilhui.com/tags/netty/"/>
    
      <category term="rpc" scheme="http://www.lilhui.com/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>【Java IO详解4】Netty实践</title>
    <link href="http://www.lilhui.com/2022/02/10/java/io/netty_4/"/>
    <id>http://www.lilhui.com/2022/02/10/java/io/netty_4/</id>
    <published>2022-02-10T07:10:32.000Z</published>
    <updated>2022-02-10T07:13:47.391Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ByteBuf回顾"><a href="#ByteBuf回顾" class="headerlink" title="ByteBuf回顾"></a>ByteBuf回顾</h2><p>ByteBuf</p><p>协议 nagle合并包<br>应用层  包大于套接字缓冲区<br>网络层 tcp分片 帧<br>路由器，硬件设备等等</p><ul><li><p>编码器</p></li><li><p>解码器</p></li></ul><p>netty基于ChannelInboudHandlerAdater和ChannelOutboudHanlderAdapter实现了一些编解码抽象类，我们在使用的过程中就只要关注编解码的业务实现。<br>MessageToMessageDecoder<i>：把某种对象解码成另外一种对象。泛型I对应的是第一个Message类型。<br>ByteToMessageDecoder：把ByteBuf解码成某一种对象。<br>MessageToMessageEncoder<i>：把某种对象编码成另一种对象。泛型I对应的是第一个Message类型。<br>MessageToByteEncoder<i>:把某对象编码成另一种对象。泛型I对应的是第一个Message类型。</i></i></i></p><h2 id="RPC框架实现"><a href="#RPC框架实现" class="headerlink" title="RPC框架实现"></a>RPC框架实现</h2><p><img src="http://images.lilhui.com/1c673683597bcd34f4636c8d569ca45b" alt="图片"></p><p>需要使用到的技术：<br>1、动态代理<br>通过java Proxy技术拿到代理对象，invocationHandler实现数据协议包装和通讯。<br>2、序列化、反序列化<br>3、网络通讯<br>基于netty的客户端和服务端进行通讯可以获得很好的IO性能<br>4、反射<br>根据客户端请求参数通过反射技术实现服务端对应实例的方法调用</p><p>使用netty实现客户端发送需要注意的点<br>通过Netty的channel调用写数据writeAndFlush 写的事件以及收到响应之后的channelRead事件都是会异步执行，所以需要注意线程协作的问题。可以使用countdowlacth来实现主线程等待channelread执行完之后才去获取收到的响应对象。</p><p><img src="http://images.lilhui.com/b6572ded990e4a9459d844d8d16bc69b" alt="图片"></p><p><img src="http://images.lilhui.com/4c692c1d48f22b4f25fe19af825c8702" alt="图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ByteBuf回顾&quot;&gt;&lt;a href=&quot;#ByteBuf回顾&quot; class=&quot;headerlink&quot; title=&quot;ByteBuf回顾&quot;&gt;&lt;/a&gt;ByteBuf回顾&lt;/h2&gt;&lt;p&gt;ByteBuf&lt;/p&gt;
&lt;p&gt;协议 nagle合并包&lt;br&gt;应用层  包大于套接字缓
      
    
    </summary>
    
      <category term="io" scheme="http://www.lilhui.com/categories/io/"/>
    
    
      <category term="netty" scheme="http://www.lilhui.com/tags/netty/"/>
    
      <category term="rpc" scheme="http://www.lilhui.com/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>【Java IO详解3】Netty进阶</title>
    <link href="http://www.lilhui.com/2022/02/10/java/io/netty_3/"/>
    <id>http://www.lilhui.com/2022/02/10/java/io/netty_3/</id>
    <published>2022-02-10T07:07:09.000Z</published>
    <updated>2022-02-10T07:12:20.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h2><ul><li>管件类和概念<br>Channel, ChannelHandler，ChannelHandlerContext<br>ChannelHandler的执行规则  INBound,OutBound<br>Pipline里的ChannelHandlerContext<br>OutBoundHandler也有read，是为了校验，因为OutBound是在前面。</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>outChannelHandler.write触发fireChannelRead的时候<br>inHandler会writeAndFlash,会触发outChannelHandler的 write形成死循环。<br>所以在OutHandler的write里不能fireChannelRead<br>会OverStackFlow</p><h2 id="Bytebuf"><a href="#Bytebuf" class="headerlink" title="Bytebuf"></a>Bytebuf</h2><p>Unpooled.xxx</p><ul><li>申请方式</li></ul><p>ByteBufAllocator heapBuffer() directBuffer()<br>compositeBuffer()</p><ul><li>两套索引</li></ul><p>readIndex和writeIndex</p><p>调用get<em> set</em>不会移动索引。调用read<em>, write</em>会移动相应的索引。<br>forEachByte 查找。</p><ul><li>派生缓冲区</li></ul><p>为Bytebuf提供了专门的方式来呈现其内容的试图。通过以下方法被创建：</p><p>dumplicate(), slice(), slice(int, int);</p><p>Unpooled.unmodifiableBuffer(…);<br>order(ByteOrder);<br>readSlice()</p><p>每个方法都返回一个新的ByteBuf实例，它具有自己的读索引、写索引和标记索引。<br>派生的缓冲区和原缓冲区的数据是共享的。</p><ul><li>引用计数</li></ul><p>release 计数减一。减到0后会进行回收。<br>减少GC。</p><p>池化的对象如果不释放，可能会引起内存溢出。</p><p>writeAndFlush会释放资源</p><p>SimpleChannelInboundHandler实现了 release。</p><ul><li>粘包，半包</li></ul><p><img src="http://images.lilhui.com/f6c05cc6032dad053d0a41f8811dc4c8" alt="图片"></p><p>假设客户端分别发送了两个数据包D1和D2给服务器，由于服务器一次读取的字节数是不确定的。所以可能会有以下4种情况。<br>从用户空间到内存空间。累计几个包后进行flash一起发送。</p><p>1：服务端分两次读取到两个独立的数据包，分别是D1和D2，没有粘包和拆包。<br>2：服务端一次接收到了两个数据包，D1和D2粘在一起，被称为TCP粘包。<br>3：服务端分两次读取到了两个数据包，第一次读取到了完整的D1和D2部分内容，第二次读取到了D2的剩余内容。这个叫做TCP拆包。<br>4：服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包剩余内容和D2包的完整包。<br>如果此时服务端TCP接收滑窗非常小，而数据D1和D2比较大，很有可能会发生第五种可能，既服务端分多次才能将D1和D2包接收完成。期间发生多次拆包。</p><ul><li>TCP粘包/半包发生的原因</li></ul><p><img src="http://images.lilhui.com/3487c1c6c200dbd7c746550f82911bbe" alt="图片"></p><p>TCP的Nagle算法，会合并小包，统一发送。如此，服务端无法区分哪些数据包是需要分开的，这就产生了粘包。</p><p>UDP：作为连接不可靠的传输协议。不会对数据包进行合并发送。没有Nogle算法。<br>UDP的包是 数据+UDP头+IP头一次封装，没有粘包。<br>分包产生的原因：</p><p>IP分片传输导致。传输过程丢失部分包。或者一个包被分成了多个，接收端顺序打乱了。<br>整理有几种情况：<br>1：数据大于套接字发送缓冲区。<br>2：进行MSS大小的TCP分段，MSS最大报文段长度的缩写。MSS是TCP报文段中数据段的最大长度。数据字段加上TCP首部才等于整个TCP报文段。所以MSS并不是TCP报文长度的最大长度。而是：MSS=TCP报文头长度-TCP首部长度。</p><p>1、两次请求，每个请求一个包<br>2、两次请求和成了一个包<br>3、第二个包被分成了两个包D2-2、D2-1 ，被分割的包D2-1的包有可能会跟D1合成一个包<br>4、第一个包分成了两个包，第二部分的包D1-2跟D2合成了一个包</p><ul><li>如何解决粘包半包问题</li></ul><p>1：包尾巴追加分隔符。 LineBasedFrameDecoder和DelimiterBasedFrameDecoder<br>2：消息定长。不够的补空格FixedLengthFrameDecoder<br>3：消息协议氛围消息头和消息体，消息头中包含标识消息总长度。通常设计思路为消息头的第一个字段使用int32来表示消息的总长度，LengthFieldBasedFrameDecoder。</p><ul><li>编解码<br>加密解密\序列化 反序列化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Reactor模型&quot;&gt;&lt;a href=&quot;#Reactor模型&quot; class=&quot;headerlink&quot; title=&quot;Reactor模型&quot;&gt;&lt;/a&gt;Reactor模型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;管件类和概念&lt;br&gt;Channel, ChannelHandler，Ch
      
    
    </summary>
    
      <category term="io" scheme="http://www.lilhui.com/categories/io/"/>
    
    
      <category term="netty" scheme="http://www.lilhui.com/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>【Java IO详解2】Netty初识</title>
    <link href="http://www.lilhui.com/2022/02/10/java/io/netty_2/"/>
    <id>http://www.lilhui.com/2022/02/10/java/io/netty_2/</id>
    <published>2022-02-10T07:05:19.000Z</published>
    <updated>2022-02-10T07:12:20.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>BIO, NIO, AIO<br>其中：  AIO中 linux在 内核绑定 CompleteChandle</p><h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><p>Reactor 模式，事件驱动实现方式</p><h3 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h3><ul><li>多线程<br>在selector加入了多线程支持。<br><img src="http://images.lilhui.com/5633cd5e1b23d8493684fe91229938dc" alt="图片"></li></ul><ul><li>主从</li></ul><p>selector加入到线程池</p><p><img src="http://images.lilhui.com/1a7d3c04ed76989cb06257a1e7424f8d" alt="图片"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ul><li>Bootstrap</li></ul><p>EventLoop   selector保持器<br>EventLoopGroup  Reactor主反应</p><p>结合实现多个selector</p><p><img src="http://images.lilhui.com/db1eea4b563ad1eab4a6df70ef9e9e58" alt="图片"></p><ul><li>Channel</li></ul><p>管道，充当用户空间与内核间的沟通</p><p><img src="http://images.lilhui.com/99f24ec74332fa18d9db568f50476f6a" alt="图片"></p><p>ChannelHandler</p><p><img src="http://images.lilhui.com/c21f2895d82cd0015a2eb35e4c129a37" alt="图片"></p><p>协作处理</p><p><img src="http://images.lilhui.com/f47ef15cbbeb00d3a7e12a79ca237363" alt="图片"></p><ul><li>ChannelHandlerContext</li></ul><p><img src="http://images.lilhui.com/3be250bdb608d37702227d534f4b0509" alt="图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IO模型&quot;&gt;&lt;a href=&quot;#IO模型&quot; class=&quot;headerlink&quot; title=&quot;IO模型&quot;&gt;&lt;/a&gt;IO模型&lt;/h2&gt;&lt;p&gt;BIO, NIO, AIO&lt;br&gt;其中：  AIO中 linux在 内核绑定 CompleteChandle&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="io" scheme="http://www.lilhui.com/categories/io/"/>
    
    
      <category term="netty" scheme="http://www.lilhui.com/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>【Java IO详解1】基础知识</title>
    <link href="http://www.lilhui.com/2022/02/10/java/io/netty_1/"/>
    <id>http://www.lilhui.com/2022/02/10/java/io/netty_1/</id>
    <published>2022-02-10T06:59:28.000Z</published>
    <updated>2022-02-11T03:54:19.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>TCP/IP</p><h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP UDP"></a>TCP UDP</h2><p>协议簇。</p><p>应用层，传输层，网络层，网络访问层。</p><p>TCP：面向连接的，需要两个端互相识别后才发送数据。</p><ul><li>TCP 在发送之前要先进行三次握手，建立链接。并把链接信息放在头部。<br>建立链接：<img src="http://images.lilhui.com/5d15d8dd5cf3f3fe6653910c30bf12ec" alt="图片"></li></ul><p>UDP：面向非链接的，单端发送。发送目的在UDP协议包里描述。</p><ul><li>UDP不理会接收端是否接收到，一股脑的发送。是不可靠的</li><li><p>报文头很小，比较高效</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3></li><li><p>建立链接的三次握手</p><p>A:你好  能通吗<br>B:收到  可以建立链接<br>A:建立连接成功</p></li><li><p>消除链接的四次握手</p><p>A:你好我要关闭了<br>B:确认可以关闭<br>B:我先关闭<br>A:我也关闭</p></li></ul><p>应用程序获取数据</p><ul><li><p>用户空间</p><p>socket</p></li><li><p>内核空间</p><p>网卡，驱动等</p></li></ul><p>文件描述<br>数据准备，数据拷贝</p><ul><li>阻塞IO</li></ul><p><img src="http://images.lilhui.com/3e005c673a86f5b7983a62a7562c90cc" alt="图片"></p><ul><li>非阻塞IO</li></ul><p><img src="http://images.lilhui.com/85667f9f740e4bdb67a050039ad1875b" alt="图片"></p><ul><li>IO多路复用</li></ul><p><img src="http://images.lilhui.com/d79874a36ba820681cf04084b6dc6c97" alt="图片"></p><p>· 零拷贝<br>epoll使用了 零拷贝<br>内核-用户epoll  共享部分空间。</p><ul><li>信号驱动</li></ul><p><img src="http://images.lilhui.com/b9bb1fee4aff4ff95e680bd598318c88" alt="图片"></p><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p><img src="http://images.lilhui.com/e9d187264391cc2d1c212e8955808376" alt="图片"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://images.lilhui.com/55b9ca8e0a7b629d86135ae0822a0e6f" alt="图片"></p><h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><p><img src="http://images.lilhui.com/dfbb129b19e3287b76360cb3174aaddd" alt="图片"></p><p>Buffer</p><p>flip</p><p>position</p><p>capacity</p><p>limit</p><p><img src="http://images.lilhui.com/59fd0c402c8bf0778ecdc89ab5e81bc1" alt="图片"></p><p>为什么要用读写翻转 flip<br>sc.read(buffer)<br>buffer.flip<br>socket从内核空间拷贝到用户空间，其实是对用户空间的写。</p><ul><li>AIO</li></ul><p>Linux 上多路复用实现的AIO。</p><p>所以netty 是基于NIO实现的</p><p>用户空间还是需要同步阻塞以获取内核的发送的消息。<br>在内核到用户控件的时候通过事件的方式进行通知，达到异步状态。</p><h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><ol><li>api复杂</li><li>多线程开发复杂</li><li>半包 粘包</li><li>心跳，网络中断，网络堵塞</li><li>nio bug空轮询<br>epoll 水平 触发  一次IO中没有读完，等到下次信号来时候才能读。信号驱动<br>边缘 触发  尽可能多的读取IO</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TCP-IP&quot;&gt;&lt;a href=&quot;#TCP-IP&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP&quot;&gt;&lt;/a&gt;TCP/IP&lt;/h2&gt;&lt;p&gt;TCP/IP&lt;/p&gt;
&lt;h2 id=&quot;TCP-UDP&quot;&gt;&lt;a href=&quot;#TCP-UDP&quot; class=&quot;
      
    
    </summary>
    
      <category term="io" scheme="http://www.lilhui.com/categories/io/"/>
    
    
      <category term="tcp" scheme="http://www.lilhui.com/tags/tcp/"/>
    
      <category term="udp" scheme="http://www.lilhui.com/tags/udp/"/>
    
  </entry>
  
  <entry>
    <title>【Dubbo源码系列2】基础应用和高级应用</title>
    <link href="http://www.lilhui.com/2022/02/10/java/dubbo/dubbo_2/"/>
    <id>http://www.lilhui.com/2022/02/10/java/dubbo/dubbo_2/</id>
    <published>2022-02-10T06:23:58.000Z</published>
    <updated>2022-02-14T07:37:04.423Z</updated>
    
    <content type="html"><![CDATA[<h3 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h3><p>提供诸如：<br><a href="http://ip:port/servicerName+group+version" target="_blank" rel="noopener">http://ip:port/servicerName+group+version</a><br>dubbo://ip:port/serviceName+group+version  </p><p>作为唯一识别码的不同服务。<br>Dubbo使用可以指定 协议，IP，端口</p><ul><li>负载均衡，集群容错，服务降级</li><li>本地存根，本地伪装，参数回调</li><li>异步调用，泛化调用，动态配置</li><li>管理台，动态配置，服务路由</li></ul><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><ul><li>Random LoadBalance<br>随机</li><li>RoundRobin LoadBalance<br>轮询</li><li>LastActiveLoadBalance<br>最少活跃</li><li>ConsistentHash LoadBalance<br>一致性hash</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;服务提供者&quot;&gt;&lt;a href=&quot;#服务提供者&quot; class=&quot;headerlink&quot; title=&quot;服务提供者&quot;&gt;&lt;/a&gt;服务提供者&lt;/h3&gt;&lt;p&gt;提供诸如：&lt;br&gt;&lt;a href=&quot;http://ip:port/servicerName+group+versio
      
    
    </summary>
    
      <category term="dubbo" scheme="http://www.lilhui.com/categories/dubbo/"/>
    
    
      <category term="泛化调用" scheme="http://www.lilhui.com/tags/%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>【分库分表1】分布式主键1</title>
    <link href="http://www.lilhui.com/2022/01/15/java/distributed/distributed_3/"/>
    <id>http://www.lilhui.com/2022/01/15/java/distributed/distributed_3/</id>
    <published>2022-01-15T03:00:57.000Z</published>
    <updated>2022-02-14T07:45:56.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>ShardingSphere</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分库分表&quot;&gt;&lt;a href=&quot;#分库分表&quot; class=&quot;headerlink&quot; title=&quot;分库分表&quot;&gt;&lt;/a&gt;分库分表&lt;/h2&gt;&lt;p&gt;ShardingSphere&lt;/p&gt;

      
    
    </summary>
    
      <category term="电商" scheme="http://www.lilhui.com/categories/%E7%94%B5%E5%95%86/"/>
    
      <category term="微服务" scheme="http://www.lilhui.com/categories/%E7%94%B5%E5%95%86/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="亿级流量" scheme="http://www.lilhui.com/tags/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F/"/>
    
      <category term="分库分表" scheme="http://www.lilhui.com/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【Dubbo源码系列1】框架介绍</title>
    <link href="http://www.lilhui.com/2022/01/14/java/dubbo/dubbo_1/"/>
    <id>http://www.lilhui.com/2022/01/14/java/dubbo/dubbo_1/</id>
    <published>2022-01-14T06:05:57.000Z</published>
    <updated>2022-02-10T06:23:00.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dubbo框架介绍"><a href="#Dubbo框架介绍" class="headerlink" title="Dubbo框架介绍"></a>Dubbo框架介绍</h2><ol><li>方法名</li><li>参数类型列表</li><li>入参</li><li>类</li><li>version</li></ol><p>RPC：通信协议，数据传输上层的一种协议。用于完成远程方法调用。</p><p>RPC over http协议传输<br>RPC over tcp传输</p><ul><li>消费端：</li></ul><ol><li>组织协议</li><li>序列化</li><li>调用netty传输</li></ol><ul><li>服务端：</li></ul><ol><li>接收并反序列化</li><li>invoke调用实现方法</li><li>获取结果，组织协议，序列化</li><li>调用netty传输</li></ol><p><img src="http://images.lilhui.com/b1834ce26273be087e101a81b7d5ec4d" alt="图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dubbo框架介绍&quot;&gt;&lt;a href=&quot;#Dubbo框架介绍&quot; class=&quot;headerlink&quot; title=&quot;Dubbo框架介绍&quot;&gt;&lt;/a&gt;Dubbo框架介绍&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;方法名&lt;/li&gt;
&lt;li&gt;参数类型列表&lt;/li&gt;
&lt;li&gt;入参&lt;/li&gt;
      
    
    </summary>
    
      <category term="dubbo" scheme="http://www.lilhui.com/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="http://www.lilhui.com/tags/dubbo/"/>
    
      <category term="SPI" scheme="http://www.lilhui.com/tags/SPI/"/>
    
  </entry>
  
</feed>
