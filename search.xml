<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Twitter Snowflake 有序ID生成算法]]></title>
    <url>%2F2018%2F01%2F31%2Fjava%2Fjava_2%2F</url>
    <content type="text"><![CDATA[概述分布式系统，各种系统平台建设中，需要用到全局唯一的ID场景，可以统一地进行一些简单的统计和排序。这时候我们需要一个统一的ID生成系统来做这个事情。Twitter Snowflake 可以作为一个满足基础需求的原始样本算法。可以以此为蓝本开发自己的业务ID生成算法。 结构snowflake的结构如下(每部分用-分开):0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000第一位为未使用，接下来的41位为毫秒级时间(41位的长度可以使用69年)，然后是5位datacenterId和5位workerId(10位的长度最多支持部署1024个节点） ，最后12位是毫秒内的计数（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号）一共加起来刚好64位，为一个Long型。(转换成字符串后长度最多19)snowflake生成的ID整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和workerId作区分），并且效率较高。经测试snowflake每秒能够产生26万个ID。 Java实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144/** * Twitter_Snowflake&lt;br&gt; * SnowFlake的结构如下(每部分用-分开):&lt;br&gt; * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt; * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&lt;br&gt; * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截) * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&lt;br&gt; * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId&lt;br&gt; * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&lt;br&gt; * 加起来刚好64位，为一个Long型。&lt;br&gt; * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。 */public class SnowflakeIdWorker &#123; // ==============================Fields=========================================== /** 开始时间截 (2015-01-01) */ private final long twepoch = 1420041600000L; /** 机器id所占的位数 */ private final long workerIdBits = 5L; /** 数据标识id所占的位数 */ private final long datacenterIdBits = 5L; /** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */ private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); /** 支持的最大数据标识id，结果是31 */ private final long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits); /** 序列在id中占的位数 */ private final long sequenceBits = 12L; /** 机器ID向左移12位 */ private final long workerIdShift = sequenceBits; /** 数据标识id向左移17位(12+5) */ private final long datacenterIdShift = sequenceBits + workerIdBits; /** 时间截向左移22位(5+5+12) */ private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; /** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */ private final long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); /** 工作机器ID(0~31) */ private long workerId; /** 数据中心ID(0~31) */ private long datacenterId; /** 毫秒内序列(0~4095) */ private long sequence = 0L; /** 上次生成ID的时间截 */ private long lastTimestamp = -1L; //==============================Constructors===================================== /** * 构造函数 * @param workerId 工作ID (0~31) * @param datacenterId 数据中心ID (0~31) */ public SnowflakeIdWorker(long workerId, long datacenterId) &#123; if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123; throw new IllegalArgumentException(String.format("worker Id can't be greater than %d or less than 0", maxWorkerId)); &#125; if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) &#123; throw new IllegalArgumentException(String.format("datacenter Id can't be greater than %d or less than 0", maxDatacenterId)); &#125; this.workerId = workerId; this.datacenterId = datacenterId; &#125; // ==============================Methods========================================== /** * 获得下一个ID (该方法是线程安全的) * @return SnowflakeId */ public synchronized long nextId() &#123; long timestamp = timeGen(); //如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常 if (timestamp &lt; lastTimestamp) &#123; throw new RuntimeException( String.format("Clock moved backwards. Refusing to generate id for %d milliseconds", lastTimestamp - timestamp)); &#125; //如果是同一时间生成的，则进行毫秒内序列 if (lastTimestamp == timestamp) &#123; sequence = (sequence + 1) &amp; sequenceMask; //毫秒内序列溢出 if (sequence == 0) &#123; //阻塞到下一个毫秒,获得新的时间戳 timestamp = tilNextMillis(lastTimestamp); &#125; &#125; //时间戳改变，毫秒内序列重置 else &#123; sequence = 0L; &#125; //上次生成ID的时间截 lastTimestamp = timestamp; //移位并通过或运算拼到一起组成64位的ID return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) // | (datacenterId &lt;&lt; datacenterIdShift) // | (workerId &lt;&lt; workerIdShift) // | sequence; &#125; /** * 阻塞到下一个毫秒，直到获得新的时间戳 * @param lastTimestamp 上次生成ID的时间截 * @return 当前时间戳 */ protected long tilNextMillis(long lastTimestamp) &#123; long timestamp = timeGen(); while (timestamp &lt;= lastTimestamp) &#123; timestamp = timeGen(); &#125; return timestamp; &#125; /** * 返回以毫秒为单位的当前时间 * @return 当前时间(毫秒) */ protected long timeGen() &#123; return System.currentTimeMillis(); &#125; //==============================Test============================================= /** 测试 */ public static void main(String[] args) &#123; SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0); for (int i = 0; i &lt; 1000; i++) &#123; long id = idWorker.nextId(); System.out.println(Long.toBinaryString(id)); System.out.println(id); &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2018%2F01%2F23%2Fjava%2Fpatterndesign%2Fpatterndesign_15%2F</url>
    <content type="text"><![CDATA[概念实现场景总结]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板方法模式]]></title>
    <url>%2F2018%2F01%2F23%2Fjava%2Fpatterndesign%2Fpatterndesign_14%2F</url>
    <content type="text"><![CDATA[概念实现场景总结]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>模板方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2F2018%2F01%2F23%2Fjava%2Fpatterndesign%2Fpatterndesign_13%2F</url>
    <content type="text"><![CDATA[概念实现场景总结]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux免密码登录]]></title>
    <url>%2F2018%2F01%2F17%2Flinux%2Flinux_3%2F</url>
    <content type="text"><![CDATA[前言有两台机器 A,B。现在要实现A访问B免密码登录。 步骤生成秘钥在A主机上执行12345ssh-keygen -t rsa -f rsa_for_174回车回车回车 -t 类型 -f 指定生成秘钥文件名 追加认证 将生成的秘钥拷贝到B主机，可以手动ftp，也可以用命令。1scp -i ~/.ssh/CY6034_rsa_4096 ./rsa_for_174.pub root@10.5.121.144:~/.ssh/ 1ssh -i CY6034_rsa_4096 root@10.5.121.144 追加1cat ~/.ssh/rsa_for_174 &gt;&gt; ~/.ssh/authorized_keys DONE]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux服务器性能评估]]></title>
    <url>%2F2017%2F11%2F21%2Flinux%2Flinux_2%2F</url>
    <content type="text"><![CDATA[前言 Web服务在部署到Linux系统运行期间，可能会遇到各种问题。程序上的BUG，数据上的问题，这些排查起来较为简单。当排除这些问题后，往往需要深入到服务器层面来寻找影响程序运行的稳定因素。 基本信息查看CPU信息查看 查看CPU个数 1cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq | wc -l 查看CPU中core个数 1cat /proc/cpuinfo | grep &quot;cpu cores&quot; | wc -l 查看CPU逻辑个数 1cat /proc/cpuinfo | grep &quot;processor&quot; | wc -l 逻辑CPU数 = 物理CPU个数*核心数 内存信息查看 内存使用情况12345#free -m total used free shared buffers cachedMem: 64376 37881 26494 0 308 17273-/+ buffers/cache: 20299 44076Swap: 16383 0 16383 total: 总内存数 used: 已用内存数 free: 空闲内存 shared: 多进程共享的内存总数 - buffers/cache: 已用缓存总数 used-buffer-cached + buffers/cache: 可用缓存数 free+buffer+cached Buffer Cache 用于针对磁盘块的写 Page Cache用于针对文件inode的读写，这些cache能够缩短I/O时间 free / used是系统可用/暂用的内存 对于程序来说 -/+ buffers/cache是可用/占用内存，因为 buffers/cache很容易就会被使用到 硬盘查看 查看硬盘分区信息 1fdisk -l 查看文件系统磁盘暂用情况 1df -h 查看硬盘的I/O性能 1234567iostat -d -k 1Linux 2.6.32-358.el6.x86_64 (fzck-10-59-107-216.h.173ops.com) 2017年11月21日 _x86_64_ (32 CPU)Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtnsda 13.35 31.70 161.99 2867672698 14655271354sdb 0.86 17.77 29.61 1607620286 2679034433 参数解释： tps：该设备每秒的传输次数（Indicate the number of transfers per second that were issued to the device.）。”一次传输”意思是”一次I/O请求”。多个逻辑请求可能会被合并为”一次I/O请求”。”一次传输”请求的大小是未知的。 kB_read/s：每秒从设备（drive expressed）读取的数据量； kB_wrtn/s：每秒向设备（drive expressed）写入的数据量； kB_read：读取的总数据量； kB_wrtn：写入的总数量数据量；这些单位都为Kilobytes。 指定监控的设备名称为sda，该命令的输出结果和上面命令完全相同。1iostat -d sda 2 默认监控所有的硬盘设备，现在指定只监控sda。 -x 参数123456789101112131415iostat -d -x -k 1 10Linux 2.6.32-358.el6.x86_64 (fzck-10-59-107-216.h.173ops.com) 2017年11月21日 _x86_64_ (32 CPU)Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilsda 0.01 28.67 1.47 11.89 31.70 161.99 29.01 0.01 0.57 2.76 0.30 0.16 0.21sdb 0.00 0.00 0.47 0.39 17.77 29.61 109.69 0.00 1.61 0.55 2.87 0.38 0.03Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilsda 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00sdb 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilsda 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00sdb 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 rrqm/s：每秒这个设备相关的读取请求有多少被Merge了（当系统调用需要读取数据的时候，VFS将请求发到各个FS，如果FS发现不同的读取请求读取的是相同Block的数据，FS会将这个请求合并Merge）； wrqm/s：每秒这个设备相关的写入请求有多少被Merge了. rsec/s：每秒读取的扇区数. wsec/：每秒写入的扇区数。 rKB/s：The number of read requests that were issued to the device per second； wKB/s：The number of write requests that were issued to the device per second； avgrq-sz 平均请求扇区的大小 avgqu-sz 是平均请求队列的长度。毫无疑问，队列长度越短越好。 await： 每一个IO请求的处理的平均时间（单位是微秒毫秒）。这里可以理解为IO的响应时间，一般地系统IO响应时间应该低于5ms，如果大于10ms就比较大了。 这个时间包括了队列时间和服务时间，也就是说，一般情况下，await大于svctm，它们的差值越小，则说明队列时间越短，反之差值越大，队列时间越长，说明系统出了问题。 svctm 表示平均每次设备I/O操作的服务时间（以毫秒为单位）。如果svctm的值与await很接近，表示几乎没有I/O等待，磁盘性能很好，如果await的值远高于svctm的值，则表示I/O队列等待太长， 系统上运行的应用程序将变慢。%util： 在统计时间内所有处理IO时间，除以总共统计时间。例如，如果统计间隔1秒，该设备有0.8秒在处理IO，而0.2秒闲置，那么该设备的%util = 0.8/1 = 80%，所以该参数暗示了设备的繁忙程度。一般地，如果该参数是100%表示设备已经接近满负荷运行了（当然如果是多磁盘，即使%util是100%，因为磁盘的并发能力，所以磁盘使用未必就到了瓶颈）。 内存性能指标磁盘性能指标网络IO指标系统评估指标 性能因素 好 坏 糟糕 CPU user% + sys% &lt; 70% user% + sys% =85% user% + sys% &gt;= 90% 内存 Swap In(si) = 0 Swap Out(so) = 0 Per CPU with 10 pages/s More Swap In &amp; Swap Out 磁盘 iowait%&lt; 20% iowat%=35% iowat% &gt;= 50%]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux自动删除N天日志]]></title>
    <url>%2F2017%2F11%2F20%2Flinux%2Flinux_1%2F</url>
    <content type="text"><![CDATA[前言 web在部署到linux环境后，一般都是把日志等级设置加高。只输出Error信息或者直接关闭Log。但是某些系统需要搜集容器的access日志来做数据分析。如果本地存储的话，日子久了，日志就越来越大。占用大量磁盘资源，直接影响到系统的正常运行。所以，这种情况下，对日志做定期清理，是成本最低的方法了。 过程删除文件脚本1find 对应目录 -mtime +天数 -name &quot;文件名&quot; -exec rm -rf &#123;&#125; \; 例如:删除3天前 /opt/logs下 search开头的日志。1find /opt/logs/ -mtime +3 -name &quot;search*.log&quot; exec rm -rf &#123;&#125; \; 说明：find：linux的查找命令，用户查找指定条件的文件/opt/logs/：想要进行清理的任意目录；-mtime：标准语句写法；+3：查找30天前的文件，这里用数字代表天数；“search*.log”：支持范式匹配-exec：执行rm -rf：强制删除命令{} \; ：固定写法，一对大括号+空格++; 计划任务将以上命令放置到可执行shell脚本中再通过cron调度执行。创建shell:12touch ~/bin/auto-del-30-days-ago-log.shchmod +x auto-del-30-days-ago-log.sh 编辑shell脚本1vim auto-del-3-days-ago-log.sh 内容如下：12#!/bin/shfind /opt/logs/ -mtime +3 -name &quot;search*.log&quot; exec rm -rf &#123;&#125; \; 添加计划调度：执行：110 0 * * * ~/auto-del-3-days-ago-log.sh &gt;/dev/null 2&gt;&amp;1 设置是每天凌晨0点10分执行auto-del-3-days-ago-log.sh文件进行数据清理任务了。 总结THE END.]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>系统维护</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列：代理模式]]></title>
    <url>%2F2017%2F11%2F09%2Fjava%2Fpatterndesign%2Fpatterndesign_8%2F</url>
    <content type="text"><![CDATA[概念 为另外一个对象提供一个替身或者占位符以控制对这个对象的访问。 实现静态代理 类图： Car：123456789package com.littlehui.design.proxy.statics;/** * Created by littlehui on 2018/1/16. */public interface Car &#123; public void run();&#125; Bus:1234567891011package com.littlehui.design.proxy.statics;/** * Created by littlehui on 2018/1/16. */public class Bus implements Car &#123; public void run() &#123; System.out.println("bus run"); &#125;&#125; BusProxy:12345678910111213package com.littlehui.design.proxy.statics;/** * Created by littlehui on 2018/1/16. */public class BusProxy implements Car &#123; public void run() &#123; System.out.println("car proxy"); Car bus = new Bus(); bus.run(); &#125;&#125; Client:123456789101112package com.littlehui.design.proxy.statics;/** * Created by littlehui on 2018/1/16. */public class Client &#123; public static void main(String[] args) &#123; Car bus = new BusProxy(); bus.run(); &#125;&#125; car为接口 Bus实现car的run方法 BusProxy负责控制Bus访问方法。 动态代理 类图： 动态代理是JDK支持的一种方式 实现例子如下： Car12345678package com.littlehui.design.proxy.dymatic;/** * Created by littlehui on 2018/1/16. */public interface Car &#123; public void run();&#125; Bus:12345678910package com.littlehui.design.proxy.dymatic;/** * Created by littlehui on 2018/1/16. */public class Bus implements Car &#123; public void run() &#123; System.out.println("car run"); &#125;&#125; BusProxyFactory:123456789101112131415161718192021222324252627282930313233package com.littlehui.design.proxy.dymatic;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * Created by littlehui on 2018/1/16. */public class BusProxyFactory &#123; private Object target; public BusProxyFactory(Object car) &#123; this.target = car; &#125; public Object getNewInstance() &#123; return Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("开始事务"); //执行目标对象方法 Object returnValue = method.invoke(target, args); System.out.println("提交事务"); return returnValue; &#125; &#125; ); &#125;&#125; Client:123456789101112131415package com.littlehui.design.proxy.dymatic;/** * Created by littlehui on 2018/1/16. */public class Client &#123; public static void main(String[] args) &#123; Car bus = new Bus(); Car newBus = (Car) new BusProxyFactory(bus).getNewInstance(); System.out.println(newBus.getClass()); newBus.run(); &#125;&#125; CGLIB动态代理，引入包spring-core-XX.jarBusProxyFactoryCglib1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.littlehui.design.proxy.dymatic;import org.springframework.cglib.proxy.Enhancer;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/** * Created by littlehui on 2018/1/16. */public class BusProxyFactoryCglib implements MethodInterceptor &#123; private Object target;//业务类对象，供代理方法中进行真正的业务方法调用 //相当于JDK动态代理中的绑定 public Object getInstance(Object target) &#123; this.target = target; //创建加强器，用来创建动态代理类 Enhancer enhancer = new Enhancer(); //为加强器指定要代理的业务类（即：为下面生成的代理类指定父类） enhancer.setSuperclass(this.target.getClass()); //设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦 enhancer.setCallback(this); // 创建动态代理类对象并返回 return enhancer.create(); &#125; //CGLIB的特有方式，不指定 具体对象，只指定类 public Object getInstanceByClass(Class targetClass) &#123; //创建加强器，用来创建动态代理类 Enhancer enhancer = new Enhancer(); //为加强器指定要代理的业务类（即：为下面生成的代理类指定父类） enhancer.setSuperclass(targetClass); //设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦 enhancer.setCallback(this); // 创建动态代理类对象并返回 return enhancer.create(); &#125; public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println("预处理"); methodProxy.invokeSuper(o, objects); //调用业务类（父类中）的方法 System.out.println("调用后操作"); return null; &#125;&#125; Client:12345678910111213141516171819package com.littlehui.design.proxy.dymatic;/** * Created by littlehui on 2018/1/16. */public class Client &#123; public static void main(String[] args) &#123; Car bus = new Bus(); Car newBus = (Car) new BusProxyFactory(bus).getNewInstance(); System.out.println(newBus.getClass()); newBus.run(); System.out.println("-----------cglib------------"); Car cglibBus = (Car)new BusProxyFactoryCglib().getInstanceByClass(Bus.class); cglibBus.run(); System.out.println(cglibBus.getClass()); &#125;&#125; result:1234567891011121314/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/bin/java -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:62751,suspend=y,server=n -Dfile.encoding=UTF-8 -classpath &quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/lib/tools.jar:/Users/littlehui/WorkSpaces/Home/pattern/proxy/target/classes:/Users/littlehui/software/repository/org/springframework/spring-core/5.0.0.RC3/spring-core-5.0.0.RC3.jar:/Users/littlehui/software/repository/org/springframework/spring-jcl/5.0.0.RC3/spring-jcl-5.0.0.RC3.jar:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar&quot; com.littlehui.design.proxy.dymatic.ClientConnected to the target VM, address: &apos;127.0.0.1:62751&apos;, transport: &apos;socket&apos;class com.sun.proxy.$Proxy0开始事务car run提交事务-----------cglib------------预处理Disconnected from the target VM, address: &apos;127.0.0.1:62751&apos;, transport: &apos;socket&apos;car run调用后操作class com.littlehui.design.proxy.dymatic.Bus$$EnhancerByCGLIB$$1e8a65c7Process finished with exit code 0 Cglib生成的动态代理类是业务类的子类，重写业务方法进行代理。可以看到CGLIB调用的 class是 class com.littlehui.design.proxy.dymatic.Bus 这个在Spring类的装配和其他涉及获取Class的地方相当有用。 car为接口 Bus实现Car的run方法 Bus对象的访问交给了BusProxyFactory控制。 BusProxyFactory执行中动态地加入了run方法执行前后的标识。场景 Spring AOP 如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP 如果目标对象实现了接口，可以强制使用CGLIB实现AOP 如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换 总结 代理和装饰模式看起来很相似，但是深入理解，本质上是有区别的 主要的区别是：使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。也就是那句话：代理模式可以控制被代理的对象可以控制被代理对象的访问，而装饰模式是被装饰对象的增强。不体现在控制上。]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列：外观模式]]></title>
    <url>%2F2017%2F11%2F09%2Fjava%2Fpatterndesign%2Fpatterndesign_9%2F</url>
    <content type="text"><![CDATA[概念 外观模式用于简化系统中一个或者多个复杂的类。外观模式相当直接，容易理解。它提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子同更容易使用。 实现 类图： MyOneDay:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.littlehui.design.facade;/** * Created by littlehui on 2018/1/16. * 我的一天 */public class MyOneDay &#123; private Morning morning; private Road road; private Back back; private Office office; private Rest rest; public MyOneDay(Morning morning, Office office, Back back, Road road, Rest rest) &#123; this.morning = morning; this.office = office; this.back = back; this.road = road; this.rest = rest; &#125; /** * 在家起床 */ public void morning() &#123; morning.morningStepA(); morning.morningStepB(); morning.moringStepC(); &#125; /** * 去公司 */ public void goToOffice() &#123; road.onLoadA(); road.onLoadB(); road.onLoadC(); road.onLoadE(); &#125; /** * 工作，coding */ public void work() &#123; office.officeA(); office.officeB(); office.officeC(); &#125; public void backToHome() &#123; back.backStepA(); back.backStepB(); back.backStepC(); back.backStepD(); &#125; public void rest() &#123; rest.restA(); rest.restB(); rest.restC(); rest.restD(); &#125; public void myWholeDay() &#123; morning(); goToOffice(); work(); backToHome(); rest(); &#125;&#125; Morning:12345678910111213141516171819package com.littlehui.design.facade;/** * Created by littlehui on 2018/1/16. */public class Morning &#123; public void morningStepA() &#123; System.out.println("起床刷牙洗脸"); &#125; public void morningStepB() &#123; System.out.println("吃早饭"); &#125; public void moringStepC() &#123; System.out.println("带上背包出门"); &#125;&#125; Office:12345678910111213141516171819package com.littlehui.design.facade;/** * Created by littlehui on 2018/1/16. */public class Office &#123; public void officeA() &#123; System.out.println("放下背包"); &#125; public void officeB() &#123; System.out.println("去除电脑开机"); &#125; public void officeC() &#123; System.out.println("打开IDEA 愉快地codeing"); &#125;&#125; Client:1234567891011package com.littlehui.design.facade;/** * Created by littlehui on 2018/1/16. */public class Client &#123; public static void main(String[] args) &#123; MyOneDay myOneDay = new MyOneDay(new Morning(), new Office(), new Back(), new Road(), new Rest()); myOneDay.myWholeDay(); &#125;&#125; 以上其他类略：详情github链接： 设计模式 场景总结 外观模式体现了设计模式中 最少知识原则。不让太多的类耦合在一起。]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列:享元模式]]></title>
    <url>%2F2017%2F11%2F09%2Fjava%2Fpatterndesign%2Fpatterndesign_12%2F</url>
    <content type="text"><![CDATA[概念 一个类的实例有多种 “虚拟实例”。 虚拟实例通过共享数据的方式存在。 实现 类图： Tree:1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.littlehui.design.flyweight;/** * Created by littlehui on 2018/1/23. */public class Tree &#123; private int x; private int y; private int age; public Tree(int x, int y, int age) &#123; this.x = x; this.y = y; this.age = age; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void display() &#123; System.out.println("坐标x:" + x + "坐标y:" + y + "年龄age:" + age); &#125;&#125; 123456789101112131415161718192021222324252627282930package com.littlehui.design.flyweight;import java.util.HashMap;import java.util.Map;/** * Created by littlehui on 2018/1/23. */public class TreeManager &#123; Map&lt;String, Tree&gt; allTrees = new HashMap&lt;String, Tree&gt;(); public Tree createTree(int x, int y, int age) &#123; String treeHash = new StringBuffer().append(x).append(y).append(age).toString(); if (allTrees.get(treeHash) != null) &#123; return allTrees.get(treeHash); &#125; else &#123; Tree tree = new Tree(x, y, age); allTrees.put(treeHash, tree); return allTrees.get(treeHash); &#125; &#125; public void displayAllTrees() &#123; for (String key : allTrees.keySet()) &#123; Tree tree = allTrees.get(key); tree.display(); &#125; &#125;&#125; 123456789101112131415161718package com.littlehui.design.flyweight;/** * Created by littlehui on 2018/1/23. */public class Client &#123; public static void main(String[] args) &#123; TreeManager treeManager = new TreeManager(); Tree tree1 = treeManager.createTree(1,2,3); Tree tree2 = treeManager.createTree(1,2,3); Tree tree3 = treeManager.createTree(1,2,4); System.out.println("实例个数：" + "tree1, tree2, tree3"); System.out.println("真实实例个数："); treeManager.displayAllTrees(); &#125;&#125; 场景在java应用中,会出现许多String a=”123”,String b=”123”之类的String类型的变量,如果只是小应用,到还好,假设是一个庞大的系统,有好多处都需要用定义String a=”223”,那开销可想而知,而JDK的开发者自然想到了这点,采用了享元模式解决创建大量相同String变量带来的开销问题 总结 享元模式，其功能是在运行时减少实例的个数，节省内存。当一个类有许多的实例，而这些实例能被统一个方法控制到时候，可以用享元模式。]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列：装饰器模式]]></title>
    <url>%2F2017%2F11%2F09%2Fjava%2Fpatterndesign%2Fpatterndesign_7%2F</url>
    <content type="text"><![CDATA[概念 动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 实现 类图： Money:1234567891011package com.littlehui.design.decorator;/** * Created by littlehui on 2018/1/15. */public interface Money &#123; public Double totalMoney(); public String getDescription();&#125; Wages:123456789101112131415package com.littlehui.design.decorator;/** * Created by littlehui on 2018/1/15. */public class Wages implements Money &#123; public Double totalMoney() &#123; return 10D; &#125; public String getDescription() &#123; return "基础工资，"; &#125;&#125; Reward:123456789101112131415161718192021package com.littlehui.design.decorator;/** * Created by littlehui on 2018/1/15. */public class Reward implements Money &#123; Money money; public Reward(Money money) &#123; this.money = money; &#125; public Double totalMoney() &#123; return 4d + money.totalMoney(); &#125; public String getDescription() &#123; return "加上额外奖励" + money.getDescription(); &#125;&#125; Bonuses:123456789101112131415161718192021package com.littlehui.design.decorator;/** * Created by littlehui on 2018/1/15. */public class Bonuses implements Money &#123; Money money; public Bonuses(Money money) &#123; this.money = money; &#125; public Double totalMoney() &#123; return 5d + money.totalMoney(); &#125; public String getDescription() &#123; return "加上奖金" + money.getDescription(); &#125;&#125; Client:12345678910111213141516package com.littlehui.design.decorator;/** * Created by littlehui on 2017/11/9. */public class Client &#123; public static void main(String[] args) &#123; Money wages = new Wages(); //奖金装饰它 wages = new Bonuses(wages); //额外奖励装饰它 wages = new Reward(wages); System.out.println("工资：" + wages.getDescription() + wages.totalMoney()); &#125;&#125; 场景Java.io包里就使用了装饰器。BufferedInputStream及LineNumberInputStream都扩展自FilterInputStream，而FilterInputStream是一个抽象的装饰类。 总结 装饰器模式体现了设计模式里的 开放-关闭原则。 装饰者和被装饰者对象有相同的父类 可以使用一个或者多个装饰者包装一个对象。 在任何需要原始对象他们可以相互替换。 装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的。 对象可以在任何时候被装饰，所以可以在运行时动态，不限量地使用。]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列:桥接模式]]></title>
    <url>%2F2017%2F11%2F09%2Fjava%2Fpatterndesign%2Fpatterndesign_10%2F</url>
    <content type="text"><![CDATA[概念 类的继承是类本身的垂直维度变化。如果需要水平维度上的变化扩展。继承是不好实现的。这时候我们可以引入桥接方式。桥接模式的做法是把变化部分抽象出来，使变化部分与主类分离开来，从而将多个维度的变化彻底分离。最后，提供一个管理类来组合不同维度上的变化，通过这种组合来满足业务的需要。 实现 Fruit:12345678package com.littlehui.design.bridge;/** * Created by littlehui on 2018/1/17. */public interface Fruit &#123; public void eat();&#125; AbstractFruit:12345678910111213141516171819package com.littlehui.design.bridge;/** * Created by littlehui on 2018/1/17. */public class AbstractFruit implements Fruit &#123; EatHandler eatHandler; public AbstractFruit(EatHandler eatHandler) &#123; this.eatHandler = eatHandler; &#125; @Override public void eat() &#123; eatHandler.handle(); System.out.println("开始吃水果。"); &#125;&#125; Apple:123456789101112131415package com.littlehui.design.bridge;/** * Created by littlehui on 2018/1/17. */public class Apple extends AbstractFruit &#123; public Apple(EatHandler eatHandler) &#123; super(eatHandler); &#125; public void enjoy() &#123; eat(); &#125;&#125; WaterMelon:1234567891011121314151617package com.littlehui.design.bridge;/** * Created by littlehui on 2018/1/17. */public class WaterMelon extends AbstractFruit &#123; public WaterMelon(EatHandler eatHandler) &#123; super(eatHandler); &#125; public void eat() &#123; super.eat(); System.out.println("吃西瓜"); &#125;&#125; EatHandler:1234567891011package com.littlehui.design.bridge;/** * Created by littlehui on 2018/1/17. */public abstract class EatHandler &#123; public void handle() &#123; System.out.println("吃水果前处理。"); &#125;&#125; PeelHandler :123456789101112package com.littlehui.design.bridge;/** * Created by littlehui on 2018/1/17. */public class PeelHandler extends EatHandler &#123; @Override public void handle() &#123; super.handle(); System.out.println("削皮"); &#125;&#125; EatHandlerDivid:1234567891011package com.littlehui.design.bridge;/** * Created by littlehui on 2018/1/17. */public class EatHandlerDivid extends EatHandler &#123; public void handle() &#123; super.handle(); System.out.println("切块。"); &#125;&#125; 123456789101112131415package com.littlehui.design.bridge;/** * Created by littlehui on 2018/1/17. */public class Client &#123; public static void main(String[] args) &#123; EatHandler eatHandler = new PeelHandler(); EatHandler eatHandler1 = new EatHandlerDivid(); Fruit apple = new Apple(eatHandler); Fruit waterMelon = new WaterMelon(eatHandler1); apple.eat(); waterMelon.eat(); &#125;&#125; 如上代码解释： 抽象部分 1：吃水果接口抽象，2.吃水果前处理抽象。 具体实现部分 : apple里的enjoy 这里就分离了水果关于吃水果和水果处理的部分。Apple里的enjoy是具体的实现，可以eat，可以做其他操作。我们可以切换 水果处理 Handle来改变 Appleenjoy具体时动作。 场景略 总结桥接的重点是 将实现解耦，抽象和实现独立开，不影响对方。桥接一般用于跨多个平台的图形和窗口系统上。当需要不同的方式改变借口和实现时，可以用桥接。]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列:组合模式]]></title>
    <url>%2F2017%2F11%2F09%2Fjava%2Fpatterndesign%2Fpatterndesign_11%2F</url>
    <content type="text"><![CDATA[概念 组合模式是把对象堆起来形成集合的一种方式。它组织对象形成集合，结合迭代器模式，可以对客户隐藏具体对象实现。不至于暴露集合内部信息。形式上经常将组合你模式用于对象的树形结构表示。 实现 背景 村子里面养了 鸡，鸭，本地鸭，外地鸭，猪。这些家畜都会跑。现在要将他们集合起来，进行统一管理。每天数数，防止丢失。 抽象我们可以用组合模式来进行管理这些家畜。首先家畜的集合进行抽象树形结构。第一层：普通家畜第二层：普通家禽下有 猪，禽类第三层：禽类 下面有 鸡，鸭第四层：鸭子下面有 本地鸭，外地鸭。 类图 对象关联图： 部分代码： AnimalType: 1234567891011package com.littlehui.design.composite;import com.littlehui.design.iterate.AnimalIterator;/** * Created by littlehui on 2018/1/18. */public interface AnimalType &#123; public AnimalIterator createIterator();&#125; 123456789101112131415package com.littlehui.design.composite;import com.littlehui.design.iterate.AnimalIterator;/** * Created by littlehui on 2018/1/18. */public interface Animal &#123; public void run(); public void each(); public AnimalIterator iterator();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940package com.littlehui.design.composite;import com.littlehui.design.iterate.AnimalIterator;import com.littlehui.design.iterate.HomeAnimalIterator;import com.littlehui.design.iterate.IteratorComposite;import java.util.ArrayList;import java.util.List;/** * Created by littlehui on 2018/1/18. */public class Bird extends IteratorAnimal implements AnimalType &#123; List&lt;Animal&gt; birds; public Bird() &#123; this.birds = new ArrayList&lt;Animal&gt;(); birds.add(new Chicken()); birds.add(new Duck()); &#125; public void run() &#123; System.out.println("鸟类跑"); &#125; public void each() &#123; for (Animal animal : birds) &#123; animal.each(); &#125; &#125; public AnimalIterator iterator() &#123; return new HomeAnimalIterator(birds); &#125; public AnimalIterator createIterator() &#123; return new IteratorComposite(this.iterator()); &#125;&#125; 12345678910111213141516package com.littlehui.design.composite;/** * Created by littlehui on 2018/1/18. */public class Chicken extends IteratorAnimal &#123; public void run() &#123; System.out.println("小鸡跑"); &#125; public void each() &#123; System.out.println("鸡"); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738package com.littlehui.design.composite;import com.littlehui.design.iterate.AnimalIterator;import com.littlehui.design.iterate.HomeAnimalIterator;import com.littlehui.design.iterate.IteratorComposite;import java.util.ArrayList;import java.util.List;/** * Created by littlehui on 2018/1/18. */public class Duck extends IteratorAnimal implements AnimalType &#123; List&lt;Animal&gt; ducks; public Duck() &#123; ducks = new ArrayList&lt;Animal&gt;(); ducks.add(new LocalDuck()); ducks.add(new ForignDuck()); &#125; public void run() &#123; System.out.println("鸭类跑"); &#125; public void each() &#123; System.out.println("鸭"); &#125; public AnimalIterator iterator() &#123; return new HomeAnimalIterator(ducks); &#125; public AnimalIterator createIterator() &#123; return new IteratorComposite(this.iterator()); &#125;&#125; 1234567891011121314package com.littlehui.design.composite;/** * Created by littlehui on 2018/1/18. */public class ForignDuck extends IteratorAnimal &#123; public void run() &#123; System.out.println("外地鸭跑"); &#125; public void each() &#123; System.out.println("外地鸭"); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637package com.littlehui.design.composite;import com.littlehui.design.iterate.AnimalIterator;import com.littlehui.design.iterate.HomeAnimalIterator;import com.littlehui.design.iterate.IteratorComposite;import java.util.ArrayList;import java.util.List;/** * Created by littlehui on 2018/1/18. */public class HomeAnimal extends IteratorAnimal implements AnimalType &#123; private List&lt;Animal&gt; homeAnimals = new ArrayList&lt;Animal&gt;(); public HomeAnimal() &#123; homeAnimals.add(new Pig()); homeAnimals.add(new Bird()); &#125; public void run() &#123; System.out.println("家养牲畜跑"); &#125; public void each() &#123; System.out.println("家养牲畜跑"); &#125; public AnimalIterator iterator() &#123; return new HomeAnimalIterator(homeAnimals); &#125; public AnimalIterator createIterator() &#123; return new IteratorComposite(this.iterator()); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package com.littlehui.design.composite;import com.littlehui.design.iterate.AnimalIterator;/** * Created by littlehui on 2018/1/18. */public class IteratorAnimal implements Animal &#123; public IteratorAnimal() &#123; &#125; public void run() &#123; &#125; public void each() &#123; &#125; public AnimalIterator iterator() &#123; final IteratorAnimal baseAnimal = this; return new AnimalIterator() &#123; public boolean hasNext() &#123; if (baseAnimal != null ) &#123; return true; &#125; return false; &#125; public Animal next() &#123; return baseAnimal; &#125; &#125;; &#125;&#125; 123456789101112131415package com.littlehui.design.composite;/** * Created by littlehui on 2018/1/18. */public class LocalDuck extends IteratorAnimal &#123; public void run() &#123; System.out.println("本地鸭跑"); &#125; public void each() &#123; System.out.println("本地鸭"); &#125;&#125; 123456789101112131415package com.littlehui.design.composite;/** * Created by littlehui on 2018/1/18. */public class Pig extends IteratorAnimal &#123; public void run() &#123; System.out.println("猪在跑"); &#125; public void each() &#123; System.out.println("猪"); &#125;&#125; Client:12345678910111213141516171819package com.littlehui.design.composite;import com.littlehui.design.iterate.AnimalIterator;/** * Created by littlehui on 2018/1/18. */public class Client &#123; public static void main(String[] args) &#123; HomeAnimal homeAnimal = new HomeAnimal(); AnimalIterator homeAnimalIterator = homeAnimal.createIterator(); while (homeAnimalIterator.hasNext()) &#123; Animal animal = homeAnimalIterator.next(); animal.run(); &#125; &#125;&#125; 迭代器组合部分 设计模式-组合模式 解析实际上，上面的代码分两个部分理解：1：家畜动物们的关联组合2：对动物们遍历的迭代组合(代码略)组合模式经常会应用到迭代模式，这里也都写上了。 场景HtmlPaser包，解析Html页面。就是典型的组合模式。 总结组合模式关注的重点是对对象的结合方式。结合后暴露统一的接口管理。正如上所表达的，动物们集合后通过组合迭代器的方式统一暴露了一个遍历的方法口。屏蔽了内部实现，调用端只需调用迭代方法就可以实现遍历管理了。有了迭代组合还可以个性化的筛选，等等趋向业务逻辑的实现。]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列：适配器模式]]></title>
    <url>%2F2017%2F11%2F09%2Fjava%2Fpatterndesign%2Fpatterndesign_6%2F</url>
    <content type="text"><![CDATA[概念 适配器模式是将一个类的接口，转换成客户期望 的另一个接口。适配器让原来接口不兼容的类可以合作。 实现 类图： 对象适配器 类适配器 Target:12345678package com.littlehui.design.adapter.target;/** * Created by littlehui on 2017/11/9. */public interface Target &#123; public void doTargetThings(String value);&#125; Adapter12345678910111213141516171819package com.littlehui.design.adapter.source;import com.littlehui.design.adapter.target.Target;/** * Created by littlehui on 2017/11/9. */public class Adapter implements Target &#123; Adaptee adaptee; public Adapter(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; public void doTargetThings(String value) &#123; adaptee.doSourceThings(value); &#125;&#125; Adaptee12345678910package com.littlehui.design.adapter.source;/** * Created by littlehui on 2017/11/9. */public class Adaptee &#123; public void doSourceThings(String value) &#123; System.out.println("value is : " + value + "adaptee"); &#125;&#125; ConcreteTarget1234567891011package com.littlehui.design.adapter.target;/** * Created by littlehui on 2017/11/9. */public class ConcreteTarget implements Target &#123; public void doTargetThings(String value) &#123; System.out.println("value is:" + value); &#125;&#125; Client:12345678910111213141516171819package com.littlehui.design.adapter;import com.littlehui.design.adapter.source.Adaptee;import com.littlehui.design.adapter.source.Adapter;import com.littlehui.design.adapter.target.ConcreteTarget;import com.littlehui.design.adapter.target.Target;/** * Created by littlehui on 2017/11/9. */public class Client &#123; public static void main(String[] args) &#123; Target target = new ConcreteTarget(); Target adaTarget = new Adapter(new Adaptee()); target.doTargetThings("意外"); adaTarget.doTargetThings("意外"); &#125;&#125; 以上利用组合的方式，以修改的接口包装适配者。这种实现方式称之为对象的适配器。它带来的有点是：被适配者的任意子类，都可以搭配适配器使用。 场景以Java举例，早先JDK里使用了枚举器（Enumeration)随着版本的更迭后来被 迭代器(Iterator)取代了。为了兼容之前的接口，枚举器仍然被保留着。并且枚举器添加了删除元素的接口。如果遇到保留着 枚举器的客户端代码，依赖于枚举接口，完全可以使用适配器模式将迭代器转换成枚举。 总结设计模式的原则有一条：组合优于继承。体现在适配器模式上就有两种适配方式。组合的称之为 对象时适配模式，继承的称之为对象适配模式。组合的有点是不仅可以适配某个类，还可以适配这个类的子类属于垂直扩展。类适配器不需要重新实现整个适配者。必要的时候覆盖被适配行为就可以。两种各有优劣。站在java的角度思考，类适配多更需要多继承的方式（虽然也可以用接口）。java不支持多继承。所以 建议使用对象适配。既组合。]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列：概况]]></title>
    <url>%2F2017%2F10%2F25%2Fjava%2Fpatterndesign%2Fparterndesign_0%2F</url>
    <content type="text"><![CDATA[概况 设计模式是对于Java变成过程中遇到的特定抽象场景总结出的一套通用方法,常用的用23种几年模式。 分类总体来说设计模式分为三大类： 创建型模式，共五种： 工厂方法模式 定义一个创建对象的接口，让子类决定将哪一个类实例化。使一个类实例化延迟到子类。 抽象工厂模式 提供一个创建一系列产品或相互依赖对象接口无需指定具体的类。 单例模式 保证一个类仅有一个实例，并提供一个访问它的全局访问。 建造者模式 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 原型模式 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 结构型模式，共七种： 适配器模式 将一个类的接口转换成客户希望的另一个接口，Adapter使原本由于接口不兼容而不能正常工作的类可以正常工作。 装饰器模式 动态地给一个对象添加一些额外的职责，就扩展功能而言，它比生成子类方式更加灵活。 代理模式 为其他对象提供一个代理以控制对这个对象的访问。 外观模式 为子系统中的一组接口提供一个一致的界面，Facade模式定义一个高层接口，这个接口使得这一子系统更加容易使用。 桥接模式 将抽象部分与实现部分分离，使它们可以独立变化。 组合模式 将对象组合成树形结构以表示 “部分-整体”的层次结构。它使得客户对单个对象和符合对象的使用具有一致性。 享元模式 运用共享技术有效支持大量细粒度对象。 行为型模式，共十一种： 策略模式 定义一系列算法，把他们封装起来，并且使它们可以相互替换，本模式使得算法的变化可以独立与使用它的客户端。 模板方法模式 定义一个操作中的算法骨架，而将一些步骤延迟到子类，Template Method使得子类可以不改变一个算法结构即可重新定义该算法某些特定步骤。 观察者模式 定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。 迭代器模式 提供一种方法顺序访问一个聚合对象中各个元素而又不暴露该对象内部表示。 责任链模式 为接触请求的发送者和接受者之间的耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条连传递该请求，知道有一个对象处理。 命令模式 将一个请求封装为一个对象，从而使可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可取消操作。 备忘录模式 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象回复到保存的状态。 状态模式 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎属于一个新的类。 访问者模式 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 中介者模式用一个中介对象来封装一系列对象交互，中介者使各对象不需要显示的相互引用，从而使得其耦合松散，而且可以独立的改变他们之间的交互。 解释器模式给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中句子。原则 开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。 里氏代换原则（Liskov Substitution Principle） 子类的能力必须大于等于父类，即父类可以使用的方法，子类都可以使用。 返回值也是同样的道理。假设一个父类方法返回一个List，子类返回一个ArrayList，这当然可以。如果父类方法返回一个ArrayList，子类返回一个List，就说不通了。这里子类返回值的能力是比父类小的。 还有抛出异常的情况。任何子类方法可以声明抛出父类方法声明异常的子类。而不能声明抛出父类没有声明的异常。一句话理解：所有使用父类的地方都可以被子类替换 依赖倒转原则（Dependence Inversion Principle） 面向接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle） 使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想， 从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 迪米特法则（最少知道原则）（Demeter Principle）一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle） 当聚合和继成都可以实现时候，应该使用聚合。聚合由于继承。 总结 上面提到的23种是经典和常用的模式。在实际生产中按照需求总结提取使用。有利于提高代码和程序功能的扩展维护性。然而也不能一味的以使用模式而是用，这就本末倒置了。随着更深入的理解和学习设计模式，会渐渐意识到：设计模式真正的的模式是 “无模式”。看似无招胜似有招。]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列：原型模式]]></title>
    <url>%2F2017%2F10%2F25%2Fjava%2Fpatterndesign%2Fparterndesign_5%2F</url>
    <content type="text"><![CDATA[概念 原型模式是特殊的创建模式，它创建对象不通过直接new的方式产生，而是通过已有的对象复制。 实现浅拷贝 类图： Product123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Product implements Serializable &#123; private String name; private String value; private ProductB productB; public ProductB getProductB() &#123; return productB; &#125; public void setProductB(ProductB productB) &#123; this.productB = productB; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; public void display() &#123; System.out.println("product name:" + this.name); System.out.println("product value:" + this.value); System.out.println("productB name:" + this.productB.getName()); &#125; public Product deepClone()&#123; try &#123; ByteArrayOutputStream bo = new ByteArrayOutputStream(); ObjectOutputStream oo = new ObjectOutputStream(bo); oo.writeObject(this); ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray()); ObjectInputStream oi = new ObjectInputStream(bi); return (Product)oi.readObject(); &#125; catch (IOException | ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return null; &#125; &#125;&#125; ProductB123456789101112public class ProductB implements Serializable &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; Client12345678910111213141516public class Client &#123; public static void main(String[] args) &#123; Product product = new Product(); ProductB productB = new ProductB(); productB.setName("B"); product.setName("X"); product.setValue("XX"); product.setProductB(productB); Product clone = product.deepClone(); clone.getProductB().setName("newXX"); product.display(); clone.display(); &#125;&#125; 执行结果：Connected to the target VM, address: ‘127.0.0.1:58904’, transport: ‘socket’product name:Xproduct value:XXproductB name:Bproduct name:Xproduct value:XXproductB name:newXXDisconnected from the target VM, address: ‘127.0.0.1:58904’, transport: ‘socket’ 深拷贝 类图： Product1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Product implements Cloneable &#123; private String name; private String value; private ProductB productB; public ProductB getProductB() &#123; return productB; &#125; public void setProductB(ProductB productB) &#123; this.productB = productB; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; public void display() &#123; System.out.println("product name:" + this.name); System.out.println("product value:" + this.value); System.out.println("productB name:" + this.productB.getName()); &#125; public Product clone() &#123; try &#123; return (Product)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; ProductB123456789101112public class ProductB &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; Client12345678910111213141516public class Client &#123; public static void main(String[] args) &#123; Product product = new Product(); ProductB productB = new ProductB(); productB.setName("B"); product.setName("X"); product.setValue("XX"); product.setProductB(productB); Product clone = product.clone(); clone.getProductB().setName("newXX"); product.display(); clone.display(); &#125;&#125; 执行结果：Connected to the target VM, address: ‘127.0.0.1:58962’, transport: ‘socket’product name:Xproduct value:XXproductB name:newXXproduct name:Xproduct value:XXproductB name:newXXDisconnected from the target VM, address: ‘127.0.0.1:58962’, transport: ‘socket’ 场景总结 浅拷贝 拷贝后的对象如果有嵌套的复杂对象，那么改变嵌套对象会跟着改变。只拷贝表层的对象信息。深拷贝，是所有的都拷贝，包括嵌套对象。这里的实现是通过序列化的方式实现。]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列：建造者模式]]></title>
    <url>%2F2017%2F10%2F25%2Fjava%2Fpatterndesign%2Fparterndesign_4%2F</url>
    <content type="text"><![CDATA[概念 当要创建的对象相对复杂，可以将复杂对象的创建过程分离成若干过程。此时只要改变不同过程中的参数就可以产生不同的实例。 实现 类图 代码Builder12345678910public interface Builder &#123; public void buildProductPartA(); public void buildProductPartB(); public void buildProductPartC(); public Product buildProduct();&#125; Director123456789public class Director &#123; public Product constructProduct(Builder productBuilder)&#123; productBuilder.buildProductPartA(); productBuilder.buildProductPartB(); productBuilder.buildProductPartC(); return productBuilder.buildProduct(); &#125;&#125; ProductBuilder12345678910111213141516171819202122232425public class ProductBuilder implements Builder &#123; private Product product; @Override public void buildProductPartA() &#123; &#125; @Override public void buildProductPartB() &#123; &#125; @Override public void buildProductPartC() &#123; &#125; @Override public Product buildProduct() &#123; return null; &#125;&#125; Product123public class Product &#123;&#125; Client1234567public class Client &#123; public static void main(String[] args) &#123; Director director = new Director(); director.constructProduct(new ProductBuilder()); &#125;&#125; 场景我们看饮料机的工作步骤可以分为 倒入水，倒入饮料剂，制造饮料。定义一个饮料机就可以当做建造饮料的过程。 总结 建造者模式的核心是把类的创建过程分解成一个个过程。每个过程是一个单独的执行流程，可以通过不同参数指定流程的结果。]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列：抽象工厂模式]]></title>
    <url>%2F2017%2F10%2F25%2Fjava%2Fpatterndesign%2Fparterndesign_3%2F</url>
    <content type="text"><![CDATA[概念 抽象工厂模式在原有的工厂方法模式上扩展，在工厂方面进行了抽象。从而增加产品规格的需求，可以更高地抽象成增加工厂类型。降低了耦合。 实现类图 代码Factory123456public interface Factory &#123; public Product createSoftProduct(); public Product createHardProduct();&#125; FactoryA123456789101112public class ProductFactoryA implements Factory &#123; public Product createSoftProduct() &#123; System.out.println("工厂A:"); return new SoftProductA(); &#125; public Product createHardProduct() &#123; System.out.println("工厂A:"); return new HardProductA(); &#125;&#125; FactoryB12345678910111213public class ProductFactoryB implements Factory &#123; public Product createSoftProduct() &#123; System.out.println("工厂B:"); return new SoftProductB(); &#125; public Product createHardProduct() &#123; System.out.println("工厂B:"); return new HardProductB(); &#125;&#125; Product123public interface Product &#123; public String getName();&#125; ProductB123456public class ProductB implements Product &#123; public String getName() &#123; return "我是产品B"; &#125;&#125; SoftProductB12345678910public class SoftProductB extends ProductB &#123; public SoftProductB() &#123; System.out.println("创建 产品B:特性:柔软"); &#125; public String getName() &#123; return super.getName() + "柔软"; &#125;&#125; HardProductB123456789public class HardProductB extends ProductB &#123; public HardProductB() &#123; System.out.println("创建 产品B:特性:坚硬"); &#125; public String getName() &#123; return super.getName() + "坚硬"; &#125;&#125; ProductA123456public class ProductA implements Product &#123; public String getName() &#123; return "我是产品A"; &#125;&#125; SoftProductA12345678910public class SoftProductA extends ProductA &#123; public SoftProductA() &#123; System.out.println("创建 产品A:特性:柔软"); &#125; public String getName() &#123; return super.getName() + "柔软"; &#125;&#125; HardProductA12345678910public class HardProductA extends ProductA &#123; public HardProductA() &#123; System.out.println("创建 产品A:特性:坚硬"); &#125; public String getName() &#123; return super.getName() + "坚硬"; &#125;&#125; Client12345678910111213141516public class Client &#123; public static void main(String[] args) &#123; Factory factoryA = new ProductFactoryA(); Factory factoryB = new ProductFactoryB(); Product productAHard = factoryA.createHardProduct(); System.out.println(productAHard.getName()); Product productBHard = factoryB.createHardProduct(); System.out.println(productBHard.getName()); Product productASoft = factoryA.createSoftProduct(); System.out.println(productASoft.getName()); Product productBSoft = factoryB.createSoftProduct(); System.out.println(productBSoft.getName()); &#125;&#125; 场景如上产品 族 A B都有两个子类型，或者说特性。Hard or Soft。如果某个时候业务需求添加产品族C。此时扩展就很方便了，只要实现产品C的工厂类，就可以。不用修改原来的代码，耦合度低。 总结 抽象工厂优点: 扩展产品族（类型）容易缺点: 扩展产品族下的子产品难，需要整体结构调整。]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列：工厂方法模式]]></title>
    <url>%2F2017%2F10%2F25%2Fjava%2Fpatterndesign%2Fparterndesign_2%2F</url>
    <content type="text"><![CDATA[概念 工厂与一类产品的关系。用于调用端从复杂的构造逻辑中解耦。 实现简单工厂模式产品：Product1234public interface Product &#123; public void methodOne(); public void methodTwo();&#125; ProductA12345678public class ProductA implements Product &#123; public void methodOne() &#123; System.out.print("A产品方法1"); &#125; public void methodTwo() &#123; System.out.print("A产品方法2"); &#125;&#125; ProductB12345678public class ProductB implements Product &#123; public void methodOne() &#123; System.out.print("B产品方法1"); &#125; public void methodTwo() &#123; System.out.print("B产品方法2"); &#125; &#125; 工厂：Factory123public interface Factory &#123; public Product createProduct(String type);&#125; SimpleFactory123456789101112public class SimpleFactory implements Factory &#123; public Product createProduct(String type) &#123; switch (type) &#123; case "A": return new ProductA(); case "B": return new ProductB(); default: return null; &#125; &#125;&#125; PS：这里用Java7的写法，switch支持String。 客户端：Client123456789public class Client &#123; public static void main(String[] args) &#123; Factory factory = new SimpleFactory(); Product product = factory.createProduct("A"); product.methodOne(); product.methodTwo(); //业务代码 &#125;&#125; 场景A是一个接口，它的实现由 ClassA1,ClassA2,ClassA3。B是一段业务代码，需要new一个A1并且进行操作。这时候就可以用工厂模式。某天业务的修改，需操作到另外一个ClassA2的方法。在工厂类进行修改就可以了。业务端代码就不用修改。 总结 工厂方法模式有良好的封装性，代码结构清晰。扩展性非常优秀。在增加产品类的情况下，只要适当地修改具体或扩展工厂类即可。调用者它只需要关心产品的接口。 可以对调用端调用复杂的构造逻辑进行解耦。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
        <category>工厂方法</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程系列：volatile关键字]]></title>
    <url>%2F2017%2F10%2F25%2Fjava%2Fmultithread%2Fmultithread_1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列：单例模式]]></title>
    <url>%2F2017%2F10%2F23%2Fjava%2Fpatterndesign%2Fparterndesign_1%2F</url>
    <content type="text"><![CDATA[概念单例模式，顾名思义就是在Java应用中，类的实例保证只有一个在JVM中。他有几个好处 减少创建开销 减少内存使用频率，GC压力 保证流程独立 实现第一种 饿汉法123456789101112public class Singleton &#123; private static Singleton singleton = new Singleton(); private Singleton() &#123; &#125; public static Singleton getSignleton()&#123; return singleton; &#125;&#125; 代码简单，但是无法延迟加载。 第二种 单线程安全1234567891011public class Singleton &#123; private static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 这种方式可以实现基本要求，但是在多线程情况下就会出现可能New出多个实例的情况。由此引入synchronized关键字，我们有如下实现： 第三种 多线程安全123456789101112131415public class Singleton &#123; private static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; &#125; 第二种方法引入了syncronized 关键字，在调用getInstance方法的时候进行了并发处理。然而在多线程情况下仍然有问题情况如下： a&gt;A、B线程同时进入了第一个if判断 b&gt;A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton(); c&gt;在new对象的过程中，由于JVM的优化，指令进行重排序，JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块。 d&gt;B进入synchronized块，由于instance此时不是null，因此它马上离开了synchronized块并将结果返回给调用该方法的程序。 e&gt;此时B线程打算使用Singleton实例，却发现它没有被初始化，于是错误发生了。 这里引入volatile关键字禁止对instance操作的指令重排。 第四种 多线程安全”多重锁检查””123456789101112131415public class Singleton &#123; private volatile static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; &#125; 这种方法就是有名的DCL的单利模式。基本已经完善多线程下的单例模式。需要提醒的是， volatile屏蔽指令重排的语义在JDK 1.5中才被修复，所以JDK1.5之前的JAVA无法使用这一方式。 第五种 静态内部类方法静态类方法：1234567891011public class Singleton &#123; private static class Holder &#123; private static Singleton singleton = new Singleton(); &#125; private Singleton()&#123;&#125; public static Singleton getSingleton()&#123; return Holder.singleton; &#125;&#125; 类只加载一次，所以这中方式也是线程安全的。不过以上的方法都存在一些问题： 进行序列化时需要额外的工作进行序列化(Serializable,transient,readResolve())等操作。否则每次序列化都是创建一个新的实例。 构造器虽然是私有的，但是还是可以通过反射来强行调用创建实例。一个方法是在构造器里判断已经创建过实例抛异常。如何更优雅地解决以上两个缺陷呢，我们可以使用枚举单例。 第六种 枚举方法12345678910public enum Singleton &#123; INSTANCE; private String name; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125;&#125; 枚举不仅线程安全，防止反射强行调用构造器外。还提供了自动化序列机制，繁殖序列化的时候创建新对象。更接近与”完美”的单利模式。 场景程序执行时候只需要一个实例执行的时候就可以用单例来：经典的场景有:线程池，驱动管理，通用的计算模块，工具类代码等等 总结 单例模式既熟悉，又陌生。看起来简单的功能，算法，要写好，无瑕疵，还是需要很大专研精神。避免遇到快很多坑。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
        <category>单例</category>
      </categories>
      <tags>
        <tag>设计模式，单例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM系列：JVM内存优化实例]]></title>
    <url>%2F2017%2F10%2F11%2Fjava%2Fjvm%2Fjvm_3%2F</url>
    <content type="text"><![CDATA[优化实例java application项目（非web项目） 改进前：1234567891011-Xms128m-Xmx128m-XX:NewSize=64m-XX:PermSize=64m-XX:+UseConcMarkSweepGC-XX:CMSInitiatingOccupancyFraction=78-XX:ThreadStackSize=128-Xloggc:logs/gc.log-Dsun.rmi.dgc.server.gcInterval=3600000-Dsun.rmi.dgc.client.gcInterval=3600000-Dsun.rmi.server.exceptionTrace=true 问题:permsize 设置较小,很容易达到报警范围(0.8)没有设置MaxPermSize，堆增长会带来额外压力。NewSize较大，old gen 剩余空间64m，一方面可能会带来old区容易增长到报警范围（监控数据显示oldgenused长期在50m左右，接近78%，容易出现full gc）,另一方面也存在promontion fail风险改进后：1234567891011121314151617181920212223-Xms128m-Xmx128m-Xmn24m-XX:PermSize=80m-XX:MaxPermSize=80m-Xss256k-XX:SurvivorRatio=1-XX:MaxTenuringThreshold=20-XX:+UseParNewGC-XX:+UseConcMarkSweepGC-XX:CMSInitiatingOccupancyFraction=75-XX:+UseCMSCompactAtFullCollection-XX:+CMSParallelRemarkEnabled-XX:CMSFullGCsBeforeCompaction=2-XX:SoftRefLRUPolicyMSPerMB=0-XX:+PrintClassHistogram-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-XX:+PrintHeapAtGC-Xloggc:logs/gc.log-Dsun.rmi.dgc.server.gcInterval=3600000-Dsun.rmi.dgc.client.gcInterval=3600000-Dsun.rmi.server.exceptionTrace=true 修改点：PermSize与MaxPermSize都设置为80，一方面避免non heap warn(报警阀值0.8 非对内存一般占用到60M以内），一方面避免堆伸缩带来的压力通过设置Xmn=24M及SurvivorRatio=1 使得Eden区=from space=to space=8M,降低了Eden区大小，降低YGC的时间(降低到3-4ms左右),同时通过设MaxTenuringThreshold=20，使得old gen的增长很缓慢。带来的问题是YGC的次数明显提高了很多。其他参数优化 修改后带来的好处见JVM参数设置再次改进后1234567891011121314151617181920212223-Xms128m-Xmx128m-Xmn36m-XX:PermSize=80m-XX:MaxPermSize=80m-Xss256k-XX:SurvivorRatio=1-XX:MaxTenuringThreshold=20-XX:+UseParNewGC-XX:+UseConcMarkSweepGC-XX:CMSInitiatingOccupancyFraction=73-XX:+UseCMSCompactAtFullCollection-XX:+CMSParallelRemarkEnabled-XX:CMSFullGCsBeforeCompaction=2-XX:SoftRefLRUPolicyMSPerMB=0-XX:+PrintClassHistogram-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-XX:+PrintHeapAtGC-Xloggc:logs/gc.log-Dsun.rmi.dgc.server.gcInterval=3600000-Dsun.rmi.dgc.client.gcInterval=3600000-Dsun.rmi.server.exceptionTrace=true 修改点： 在上面的基础上调整Xmn大小到36M，设置CMSInitiatingOccupancyFraction=73。 Dden区与Survivor区大小都增加到12M，通过CMSInitiatingOccupancyFraction计算公式,计算得出value为73是，可以避免promotion faild问题，同时满足堆内存监控报警值在80%：内存大小128M*80%=102.4M 102.4M-36M=66.4M(老生代达到此值报警） 老生代达到67.15M（92M*0.73）将发生Full GC，所以在老生代大小达到66.4M时也就是WARN报警时将很有可能出现Full GC。 增大了Eden和Survivor区的值，会减小YGC的次数，但由于空间变大理论上也会相应的增加YGC的时间，不过由于新生代本身就很小（才36M）这点儿变化可以忽略掉。实际的监控值显示YGC的时间在4-5ms之间。是可以接受范围。 SurvivorRatio 这个值还得在仔细考虑下,有待优化中 网上某个牛人的配置 :每天几百万pv一点问题都没有，网站没有停顿12345678910111213141516171819202122232425262728$JAVA_ARGS.=&quot;-Dresin.home=$SERVER_ROOT-server-Xms6000M-Xmx6000M-Xmn500M-XX:PermSize=500M-XX:MaxPermSize=500M-XX:SurvivorRatio=65536-XX:MaxTenuringThreshold=0-Xnoclassgc-XX:+DisableExplicitGC-XX:+UseParNewGC-XX:+UseConcMarkSweepGC-XX:+UseCMSCompactAtFullCollection-XX:CMSFullGCsBeforeCompaction=0-XX:+CMSClassUnloadingEnabled-XX:-CMSParallelRemarkEnabled-XX:CMSInitiatingOccupancyFraction=90-XX:SoftRefLRUPolicyMSPerMB=0-XX:+PrintClassHistogram-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-XX:+PrintHeapAtGC-Xloggc:log/gc.log&quot;; 说明一下， -XX:SurvivorRatio=65536 -XX:MaxTenuringThreshold=0就是去掉了救助空间；-Xnoclassgc禁用类垃圾回收，性能会高一点；-XX:+DisableExplicitGC禁止System.gc()，免得程序员误调用gc方法影响性能；-XX:+UseParNewGC，对年轻代采用多线程并行回收，这样收得快；带CMS参数的都是和并发回收相关的，不明白的可以上网搜索；CMSInitiatingOccupancyFraction，这个参数设置有很大技巧，基本上满足(Xmx-Xmn)(100-CMSInitiatingOccupancyFraction)/100&gt;=Xmn就不会出现promotion failed。在我的应用中Xmx是6000，Xmn是500，那么Xmx-Xmn是5500兆，也就是年老代有5500兆，CMSInitiatingOccupancyFraction=90说明年老代到90%满的时候开始执行对年老代的并发垃圾回收（CMS），这时还剩10%的空间是550010%=550兆，所以即使Xmn（也就是年轻代共500兆）里所有对象都搬到年老代里，550兆的空间也足够了，所以只要满足上面的公式，就不会出现垃圾回收时的promotion failed；SoftRefLRUPolicyMSPerMB这个参数我认为可能有点用，官方解释是softly reachable objects will remain alive for some amount of time after the last time they were referenced. The default value is one second of lifetime per free megabyte in the heap，我觉得没必要等1秒；123456789101112131415161718192021222324-Xmx4000M-Xms4000M-Xmn600M-XX:PermSize=500M-XX:MaxPermSize=500M-Xss256K-XX:+DisableExplicitGC-XX:SurvivorRatio=1-XX:+UseConcMarkSweepGC-XX:+UseParNewGC-XX:+CMSParallelRemarkEnabled-XX:+UseCMSCompactAtFullCollection-XX:CMSFullGCsBeforeCompaction=0-XX:+CMSClassUnloadingEnabled-XX:LargePageSizeInBytes=128M-XX:+UseFastAccessorMethods-XX:+UseCMSInitiatingOccupancyOnly-XX:CMSInitiatingOccupancyFraction=80-XX:SoftRefLRUPolicyMSPerMB=0-XX:+PrintClassHistogram-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-XX:+PrintHeapAtGC-Xloggc:log/gc.log 改进方案：上面方法不太好，因为没有用到救助空间，所以年老代容易满，CMS执行会比较频繁。我改善了一下，还是用救助空间，但是把救助空间加大，这样也不会有promotion failed。具体操作上，32位Linux和64位Linux好像不一样，64位系统似乎只要配置MaxTenuringThreshold参数，CMS还是有暂停。为了解决暂停问题和promotion failed问题，最后我设置-XX:SurvivorRatio=1 ，并把MaxTenuringThreshold去掉，这样即没有暂停又不会有promotoin failed，而且更重要的是，年老代和永久代上升非常慢（因为好多对象到不了年老代就被回收了），所以CMS执行频率非常低，好几个小时才执行一次，这样，服务器都不用重启了。某网友:123456789101112131415161718192021222324252627282930$JAVA_ARGS.=&quot;-Dresin.home=$SERVER_ROOT-server-Xmx3000M-Xms3000M-Xmn600M-XX:PermSize=500M-XX:MaxPermSize=500M-Xss256K-XX:+DisableExplicitGC-XX:SurvivorRatio=1-XX:+UseConcMarkSweepGC-XX:+UseParNewGC-XX:+CMSParallelRemarkEnabled-XX:+UseCMSCompactAtFullCollection-XX:CMSFullGCsBeforeCompaction=0-XX:+CMSClassUnloadingEnabled-XX:LargePageSizeInBytes=128M-XX:+UseFastAccessorMethods-XX:+UseCMSInitiatingOccupancyOnly-XX:CMSInitiatingOccupancyFraction=70-XX:SoftRefLRUPolicyMSPerMB=0-XX:+PrintClassHistogram-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-XX:+PrintHeapAtGC-Xloggc:log/gc.log&quot;; 64位jdk参考设置，年老代涨得很慢，CMS执行频率变小，CMS没有停滞，也不会有promotion failed问题，内存回收得很干净 总结 打印并分析进行垃圾回收的时间，内容，具体数值。如果有OOM导出OOM时内存使用情况。 分析垃圾回收时候的数据信息，（年轻区，年老区，方法区）查看OOM时内存使用情况。 优化的权重顺序可以按照，FullGc&gt;频繁YGC]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm调优</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM系列：JVM内存优化建议]]></title>
    <url>%2F2017%2F10%2F09%2Fjava%2Fjvm%2Fjvm_2%2F</url>
    <content type="text"><![CDATA[优化原则JAVA程序在运行时 加快GC速度 减少FullGC 减少停顿 杜绝GC出错 GC优化的策略本质上JVM运行中通过参数的变换调和达到运行平衡的过程。it is an art. 经验配置 垃圾搜集器新生代收集器：有Serial收集器、ParNew收集器、Parallel Scavenge收集器老生代收集器：Serial Old收集器、Parallel Old收集器、CMS收集器、G1收集器以上所有的垃圾收集器都会发生STW，只不过FGC的STW时间更长。 常用搜集器： CMSGC CMS(Concurrent Mark-Sweep)是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合，因此我们又叫它低延迟垃圾收集器。在启动JVM参数加上-XX:+UseConcMarkSweepGC ，这个参数表示对于老年代的回收采用CMS，注意此时新生代默认使用的是ParNew。CMS采用的基础算法是：标记—清除。 MSCGC vs CMSGC 和普通序列化整理（MSC）区别在于有三个mark阶段（实际上还有个预清理过程，但对于解释清楚CMSGC没有帮助就忽略了）。CMSGC的精髓在于因为做到了不STW的情况下进行mark，我们得到了更短的总STW时间，代价是因为并行mark产生了『脏数据』即在mark的同时又生成了需要mark的对象，我们必须再进行一次STW，并收尾（remark）。同时，我们要注意到得到更短的STW的同时，我们牺牲了系统吞吐量，CMSGC总吞吐量比ParOld要更低。 G1GC 作为最新的垃圾收集器，有可能在jdk9中成为默认的垃圾收集器。主要思路是将新生代老生代进一步分为多个region，每次gc可以针对部分region而不是整个堆内存。由此可以降低stw的单次最长时间，代价是可能在总时间上会更高。G1GC让系统在整体吞吐量略降的情况下变得更加平滑稳定。 响应时间优先的应用 年轻代选择尽可能设大,直到接近系统的最低响应时间限制(根据实际情况选择).在此种情况下,年轻代收集发生的频率也是最小的.同时,减少到达年老代的对象. 年老代选择年老代使用并发收集器,所以其大小需要小心设置,一般要考虑并发会话率和会话持续时间等一些参数.如果堆设置小了,可以会造成内存碎片,高回收频率以及应用暂停而使用传统的标记清除方式;如果堆大了,则需要较长的收集时间.最优化的方案,一般需要参考以下数据获得: 并发垃圾收集信息. 持久代并发收集次数. 传统GC信息. 花在年轻代和年老代回收上的时间比例。吞吐量优先的应用 年轻代选择尽可能的设置大,可能到达Gbit的程度.因为对响应时间没有要求,垃圾收集可以并行进行,一般适合8CPU以上的应用.避免设置过小.当新生代设置过小时会导致: YGC次数更加频繁 可能导致YGC对象直接进入旧生代,如果此时旧生代满了,会触发FGC. 年老代选择一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代.这样可以尽可能回收掉大部分短期对象,减少中期的对象,而年老代尽存放长期存活对象. 碎片问题因为年老代的并发收集器使用标记,清除算法,所以不会对堆进行压缩.当收集器回收时,他会把相邻的空间进行合并,这样可以分配给较大的对象.但是,当堆空间较小时,运行一段时间以后,就会出现”碎片”,如果并发收集器找不到足够的空间,那么并发收集器将会停止,然后使用传统的标记,清除方式进行回收.如果出现”碎片”,可能需要进行如下配置: -XX:+UseCMSCompactAtFullCollection:使用并发收集器时,开启对年老代的压缩.-XX:CMSFullGCsBeforeCompaction=0:上面配置开启的情况下,这里设置多少次Full GC后,对年老代进行压缩 promotion failed问题可能是两种原因产生： 1. 第一个原因是救助空间不够，救助空间里的对象还不应该被移动到年老代，但年轻代又有很多对象需要放入救助空间。 2. 第二个原因是年老代没有足够的空间接纳来自年轻代的对象；这两种情况都会转向Full GC，网站停顿时间较长。 用64位操作系统，Linux下64位的jdk比32位jdk要慢一些，但是吃得内存更多，吞吐量更大XMX和XMS设置一样大，MaxPermSize和MinPermSize设置一样大，这样可以减轻伸缩堆大小带来的压力 使用CMS的好处是用尽量少的新生代，经验值是128M－256M， 老生代利用CMS并行收集，这样能保证系统低延迟的吞吐效率。 cms的收集停顿时间非常的短，2G的内存， 大约20－80ms的应用程序停顿时间系统停顿的时候可能是GC的问题也可能是程序的问题，多用jmap和jstack查看，或者killall -3 java，然后查看java控制台日志，能看出很多问题。 如果用了缓存，那么年老代应该大一些，缓存的HashMap不应该无限制长，建议采用LRU算法的Map做缓存，LRUMap的最大长度也要根据实际情况设定。 采用并发回收时，年轻代小一点，年老代要大，因为年老大用的是并发回收，即使时间长点也不会影响其他程序继续运行，网站不会停顿JVM参数的设置(特别是 –Xmx –Xms –Xmn -XX:SurvivorRatio -XX:MaxTenuringThreshold等参数的设置没有一个固定的公式，需要根据PV old区实际数据 YGC次数等多方面来衡量。为了避免promotion faild可能会导致xmn设置偏小，也意味着YGC的次数会增多，处理并发访问的能力下降等问题。每个参数的调整都需要经过详细的性能测试，才能找到特定应用的最佳配置。 解决方方案一： 第一个原因最终解决办法是去掉救助空间，设置-XX:SurvivorRatio=65536 -XX:MaxTenuringThreshold=0即可， 第二个原因我的解决办法是设置CMSInitiatingOccupancyFraction为某个值（假设70），这样年老代空间到70%时就开始执行CMS，年老代有足够的空间接纳来自年轻代的对象。解决方案一的改进方案： 又有改进了，上面方法不太好，因为没有用到救助空间，所以年老代容易满，CMS执行会比较频繁。我改善了一下，还是用救助空间，但是把救助空间加大，这样也不会有promotion failed。具体操作上，32位Linux和64位Linux好像不一样，64位系统似乎只要配置MaxTenuringThreshold参数，CMS还是有暂停。为了解决暂停问题和promotion failed问题，最后我设置-XX:SurvivorRatio=1 ，并把MaxTenuringThreshold去掉，这样即没有暂停又不会有promotoin failed，而且更重要的是，年老代和永久代上升非常慢（因为好多对象到不了年老代就被回收了），所以CMS执行频率非常低，好几个小时才执行一次，这样，服务器都不用重启了。 -Xmx4000M -Xms4000M -Xmn600M -XX:PermSize=500M -XX:MaxPermSize=500M -Xss256K -XX:+DisableExplicitGC -XX:SurvivorRatio=1 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSClassUnloadingEnabled -XX:LargePageSizeInBytes=128M -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=80 -XX:SoftRefLRUPolicyMSPerMB=0 -XX:+PrintClassHistogram -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -Xloggc:log/gc.log CMSInitiatingOccupancyFraction值与Xmn的关系公式 上面介绍了promontion faild产生的原因是EDEN空间不足的情况下将EDEN与From survivor中的存活对象存入To survivor区时,To survivor区的空间不足，再次晋升到old gen区，而old gen区内存也不够的情况下产生了promontion faild从而导致full gc.那可以推断出：eden+from survivor &lt; old gen区剩余内存时，不会出现promontion faild的情况，即：(Xmx-Xmn)*(1-CMSInitiatingOccupancyFraction/100)&gt;=(Xmn-Xmn/(SurvivorRatior+2)) 进而推断出： CMSInitiatingOccupancyFraction &lt;=((Xmx-Xmn)-(Xmn-Xmn/(SurvivorRatior+2)))/(Xmx-Xmn)*100 例如： 当xmx=128 xmn=36 SurvivorRatior=1时 CMSInitiatingOccupancyFraction&lt;=((128.0-36)-(36-36/(1+2)))/(128-36)*100 =73.913 当xmx=128 xmn=24 SurvivorRatior=1时 CMSInitiatingOccupancyFraction&lt;=((128.0-24)-(24-24/(1+2)))/(128-24)*100=84.615… 当xmx=3000 xmn=600 SurvivorRatior=1时 CMSInitiatingOccupancyFraction&lt;=((3000.0-600)-(600-600/(1+2)))/(3000-600)*100=83.33 CMSInitiatingOccupancyFraction低于70% 需要调整xmn或SurvivorRatior值。 令： 网上一童鞋推断出的公式是：:(Xmx-Xmn)*(100-CMSInitiatingOccupancyFraction)/100&gt;=Xmn 这个公式个人认为不是很严谨，在内存小的时候会影响xmn的计算。 参考：http://www.cnblogs.com/redcreen/archive/2011/05/05/2038331.htmlhttp://www.jianshu.com/p/c9ac99b87d56]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm调优</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM系列：基础概念]]></title>
    <url>%2F2017%2F09%2F28%2Fjava%2Fjvm%2Fjvm_1%2F</url>
    <content type="text"><![CDATA[jvm内存区域分三种：栈，堆，方法区。设计上Java还可以使用到直接内存，在Java NIO包里使用DirectBuffer可以显示地调用申请堆外内存。 栈 栈是基于线程执行而言的，它描述的是一个线程执行的流程路线。并且在整个业务执行流程中需要用到的各种局部变量（简单类型保存值，对象保存地址），以及基本类型。 这个路线可以认为是通过方法区的程序执行流程，按照帧（Stack Frame)的方式一压入内存，在JVM内存 看起来就是Stack的存储。 栈的配置 JVM通过 -XSS指定配置每个线程所拥有栈大小。默认值随着虚拟机版本以及操作系统影响，官网上指定： In Java SE 6, the default on Sparc is 512k in the 32-bit VM, and 1024k in the 64-bit VM. On x86 Solaris/Linux it is 320k in the 32-bit VM and 1024k in the 64-bit VM. 。 栈的大小直接影响可以创建的线程数量。 线程数 = （系统空闲内存-堆内存（-Xms, -Xmx）- perm方法区内存(-XX:MaxPermSize)) / 线程栈大小(-Xss) 如上我们可知栈设置越小，可以创建的线程数就越多，但是也是有限制的。限制有两个方便： 操作系统配置也可以限制数量。例如ubuntu里/proc/sys/kernel/threads-max设置最大线程数。 异常 调用链太长，栈不够时会抛出StackOverFlow。一般是发生了递归而产生。 堆 堆是JVM最大的内存部分，它负责存放对象实例，JVM所有对象实例都在这里。（变量，对象属性但是不包括方法里的简单类型变量）。它保存了执行所需要的 各种东西。 堆的配置 参数名称 含义 默认值 其他 -Xms 初始堆大小 物理内存的1/64(&lt;1GB) 默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制. -Xmx 最大堆大小 物理内存的1/4(&lt;1GB) 默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制 -Xmn 年轻代大小 (1.4or lator) 注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8 -XX:NewSize 设置年轻代大小(for 1.3/1.4) -XX:MaxNewSize 年轻代最大值(for 1.3/1.4) -XX:PermSize 设置持久代(perm gen)初始值 物理内存的1/64 -XX:MaxPermSize 设置持久代最大值 物理内存的1/4 -Xss 每个线程的堆栈大小 JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右 一般小的应用，如果栈不很深， 应该是128k够用的大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:”-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了 -XX:ThreadStackSize Thread Stack Size (0 means use default stack size) [Sparc: 512; Solaris x86: 320 (was 256 prior in 5.0 and earlier); Sparc 64 bit: 1024; Linux amd64: 1024 (was 0 in 5.0 and earlier); all others 0.] -XX:NewRatio 年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代) -XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5 Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。 -XX:SurvivorRatio Eden区与Survivor区的大小比值 设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10 -XX:LargePageSizeInBytes 内存页的大小 不可设置过大， 会影响Perm的大小 =128m -XX:+UseFastAccessorMethods 原始类型的快速优化 -XX:+DisableExplicitGC 关闭System.gc() 这个参数需要严格的测试 -XX:MaxTenuringThreshold 垃圾最大年龄 如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率该参数只有在串行GC时才有效. -XX:+AggressiveOpts 加快编译 -XX:+UseBiasedLocking 锁机制的性能改善 -Xnoclassgc 禁用垃圾回收 -XX:SoftRefLRUPolicyMSPerMB 每兆堆空闲空间中SoftReference的存活时间 1s softly reachable objects will remain alive for some amount of time after the last time they were referenced. The default value is one second of lifetime per free megabyte in the heap -XX:PretenureSizeThreshold 对象超过多大是直接在旧生代分配 0 单位字节 新生代采用Parallel Scavenge GC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象. -XX:TLABWasteTargetPercent TLAB占eden区的百分比 1% -XX:+CollectGen0First FullGC时是否先YGC false 并行收集器相关参数 参数名称 含义 默认值 其他 -XX:+UseParallelGC Full GC采用parallel MSC 选择垃圾收集器为并行收集器.此配置仅对年轻代有效.即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集.(此项待验证) -XX:+UseParNewGC 设置年轻代为并行收集 可与CMS收集同时使用 JDK5.0以上,JVM会根据系统配置自行设置,所以无需再设置此值 -XX:ParallelGCThreads 并行收集器的线程数 此值最好配置与处理器数目相等 同样适用于CMS -XX:+UseParallelOldGC 年老代垃圾收集方式为并行收集(Parallel Compacting) 这个是JAVA 6出现的参数选项 -XX:MaxGCPauseMillis 每次年轻代垃圾回收的最长时间(最大暂停时间) 如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值. -XX:+UseAdaptiveSizePolicy 自动选择年轻代区大小和相应的Survivor区比例 设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例,以达到目标系统规定的最低相应时间或者收集频率等,此值建议使用并行收集器时,一直打开. -XX:GCTimeRatio 设置垃圾回收时间占程序运行时间的百分比 公式为1/(1+n) -XX:+ScavengeBeforeFullGC Full GC前调用YGC true Do young generation GC prior to a full GC. (Introduced in 1.4.1.) CMS相关参数 参数名称 含义 默认值 其他 -XX:+UseConcMarkSweepGC 使用CMS内存收集 测试中配置这个以后,-XX:NewRatio=4的配置失效了,原因不明.所以,此时年轻代大小最好用-Xmn设置.??? -XX:+AggressiveHeap 试图是使用大量的物理内存 长时间大内存使用的优化，能检查计算资源（内存， 处理器数量）至少需要256MB内存大量的CPU／内存， （在1.4.1在4CPU的机器上已经显示有提升） -XX:CMSFullGCsBeforeCompaction 多少次后进行内存压缩 由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生”碎片”,使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理. -XX:+CMSParallelRemarkEnabled 降低标记停顿 -XX+UseCMSCompactAtFullCollection 在FULL GC的时候， 对年老代的压缩 CMS是不会移动内存的， 因此， 这个非常容易产生碎片， 导致内存不够用， 因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。 可能会影响性能,但是可以消除碎片 -XX:+UseCMSInitiatingOccupancyOnly 使用手动定义初始化定义开始CMS收集 禁止hostspot自行触发CMS GC -XX:CMSInitiatingOccupancyFraction=70 使用cms作为垃圾回收 使用70％后开始CMS收集 92 为了保证不出现promotion failed(见下面介绍)错误,该值的设置需要满足以下公式CMSInitiatingOccupancyFraction计算公式 -XX:CMSInitiatingPermOccupancyFraction 设置Perm Gen使用到达多少比率时触发 92 -XX:+CMSIncrementalMode 设置为增量模式 用于单CPU情况 -XX:+CMSClassUnloadingEnabled 辅助信息 参数名称 含义 默认值 其他 -XX:+PrintGC 输出形式:[GC 118250K-&gt;113543K(130112K), 0.0094143secs][Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs] -XX:+PrintGCDetails 输出形式:[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs][GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs] -XX:+PrintGCTimeStamps -XX:+PrintGC:PrintGCTimeStamps 可与-XX:+PrintGC -XX:+PrintGCDetails混合使用 输出形式:11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs] -XX:+PrintGCApplicationStoppedTime 打印垃圾回收期间程序暂停的时间.可与上面混合使用 输出形式:Total time for which application threads were stopped: 0.0468229 seconds -XX:+PrintGCApplicationConcurrentTime 打印每次垃圾回收前,程序未中断的执行时间.可与上面混合使用 输出形式:Application time: 0.5291524 seconds -XX:+PrintHeapAtGC 打印GC前后的详细堆栈信息 -Xloggc:filename 把相关日志信息记录到文件以便分析.与上面几个配合使用 -XX:+PrintClassHistogram garbage collects before printing the histogram. -XX:+PrintTLAB 查看TLAB空间的使用情况 XX:+PrintTenuringDistribution 查看每次minor GC后新的存活周期的阈值 Desired survivor size 1048576 bytes, new threshold 7 (max 15) new threshold 7即标识新的存活周期的阈值为7。 方法区 又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量；方法区中包含的都是在程序中永远的唯一的元素。特别说明的是枚举 是存放在方法区，而单例是某个类在内存中唯一的对象实例，是存放在堆中的。 配置方法 -XX:PermSize=10M -XX:MaxPermSize=10M 值得一提的是 JAVA8 将方法区 改成了 MateSpace (元数据区。) 同时 PerSize MaxPermSize参数也移除了。带来了几个新的参数： -XX:MetaspaceSize，class metadata的初始空间配额，以bytes为单位，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当的降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize（如果设置了的话），适当的提高该值。 -XX:MaxMetaspaceSize，可以为class metadata分配的最大空间。默认是没有限制的。 -XX:MinMetaspaceFreeRatio,在GC之后，最小的Metaspace剩余空间容量的百分比，减少为class metadata分配空间导致的垃圾收集 -XX:MaxMetaspaceFreeRatio,在GC之后，最大的Metaspace剩余空间容量的百分比，减少为class metadata释放空间导致的垃圾收集XX:MaxMetaspaceSize总结图]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm调优</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis简介]]></title>
    <url>%2F2017%2F09%2F26%2Fredis%2Fredis_2%2F</url>
    <content type="text"><![CDATA[Redis简介 Redis 是一个非常快速的非关系内存型数据库。Redis非常有区分度的是它提供的5种不同类型的数据结构，其数据结构是有针对地为解决问题而生的数据结构，区分于其他数据库的一个显著特点。可以说，Redis核心问题和功能都围绕着五种数据结构展开的，另外，它方便的扩展功能，可以支持到数百GB级数据。 与其他数据库和软件的对比 Redis的特点决定了它在存储工具里的定位，它经常被用来与其他数据库进行对比。这里，我们介于内存键值存储 Memcached 与MongoDB对Redis进行一次比较。 名称 类型 存储 查询 附加功能 Redis 内存存储（in-memmory)的非关系数据库 字符串,列表，集合，散列表，有序集合 每种数据类型都有自己的专属命令，还有批操作和不完整的事务支持 发布与订阅，主从复制，持久化，脚本 Memcached 使用内存存储的键值缓存 键值之间的映射 创建，读取，更新删除等命令 多线程服务支持 MongoDB 硬盘存储的非关系文档存储 每个数据库可以包含多个个表，每个表包含多个schema 的BSON文档 更新，读取，删除，条件查询等命令 支持map-reduce操作，主从复制，分片，空间索引（spatial index） 使用Redis的理由Redis之于缓存界：使用memcached 时，没有原生的列表结构，只能用Append命令将数据添加到已有字符串末尾。可以认为那个字符串就是一个列表。但是删除这些就比较困难了。memcached采用的办法是通过黑名单来隐藏列表里的元素，从而避免对元素进行读取，更新，写入。相反地，Redis的LIST和SET允许用户直接添加或者删除元素。 Redis之于数据库：当数据库用于存储长期数据报告，报表。并将这些数据作为固定时间范围内聚合。数据库的做法是：将各个行插入一个报表中，通过扫描这些行进行聚合数据。这样就要频繁地对表里数据进行 读，写。Redis可以使用原子的INCR命令来进行聚合计算。并且Redis存储在内存里。并且查询不通过数据库的分析器，查询优化器等，所以对Redis存储的数据行随机写的速度是非常迅速的。Redis之于NoSql数据库：避免写入不必要的临时数据。免去了临时数据进行扫描删除的麻烦。可以改上程序的性能。]]></content>
  </entry>
  <entry>
    <title><![CDATA[HttpURLConnection Post请求自动重传机制]]></title>
    <url>%2F2017%2F09%2F26%2Fjava%2Fjava_1%2F</url>
    <content type="text"><![CDATA[背景故事 之前负责的一个商城项目，需要从供应商库进行订单下单同步，服务器间通讯通过http请求。 加密方式采用DES加密方式。在运行初期一切正常，几个月后供应商发现有重复订单存在，而客户端这边接收到异常生成订单异常信息，订单生成不同步。供应商的处理逻辑我们无从得知，只能从自身角度思考为什么会有这种问题，在排除了一系列原因后，定位到一个问题。那就是 HttpURLConnection的post请求重发机制。 场景再现Http请求是通过HttpUrlConnection封装的一套Java请求客户端 部分源码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 //请求的header如下 protected Map&lt;String, Object&gt; getDefaultHeaders() &#123; Map&lt;String, Object&gt; defaultHeaders = new HashMap&lt;&gt;(); defaultHeaders.put("Accept", "*/*"); defaultHeaders.put("Connection", "Keep-Alive"); defaultHeaders.put("User-Agent", "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1)"); defaultHeaders.put("Accept-Charset", "utf-8"); defaultHeaders.put("Content-Type", "application/x-www-form-urlencoded;charset=utf-8"); headers = defaultHeaders; return headers; &#125;//初始化 httpConnectionprotected void initConnection() throws IOException &#123; if ("POST".equals(method)) &#123; this.url = new URL(getUrl); this.postJson = JsonUtil.toJson(param); &#125; else &#123; this.url = new URL(getUrl + urlParams); &#125; httpConnection = (HttpURLConnection) url.openConnection(); for (String keyset : headers.keySet()) &#123; httpConnection.setRequestProperty(keyset, headers.get(keyset).toString()); &#125; /** * 然后把连接设为输出模式。URLConnection通常作为输入来使用，比如下载一个Web页。 * 通过把URLConnection设为输出，你可以把数据向你个Web页传送。： */ httpConnection.setRequestMethod(method); httpConnection.setUseCaches(false); if ("POST".equals(method)) &#123; httpConnection.setDoOutput(true); &#125; else &#123; httpConnection.setDoOutput(true); &#125; httpConnection.setDoInput(true); &#125; //执行Http请求 public String doRequest() &#123; this.toUrlParams(); OutputStreamWriter out = null; try &#123; this.initConnection(); // 一旦发送成功，用以下方法就可以得到服务器的回应： String sTotalString; InputStream urlStream; out = new OutputStreamWriter(httpConnection.getOutputStream(), charSet); if (method.equals("POST")) &#123; out.write(this.postJson); //向页面传递数据。post的关键所在！ &#125; // remember to clean up out.flush(); urlStream = httpConnection.getInputStream(); logger.debug("连接状态:" + urlStream.available()); //new InputStreamReader(l_urlStream,) sTotalString = IOUtil.in2Str(urlStream, charSet); return sTotalString; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new SystemException(e); &#125; finally &#123; if (out != null) &#123; try &#123; out.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new SystemException(e); &#125; &#125; httpConnection.disconnect(); &#125; &#125; Java代码调用doRequest通过HttpUrlConnection模拟一个Post请求。结果服务端会收到两次请求。 原因分析HttpURLConnection 采用 Sun 私有的一个 HTTP 协议实现类： HttpClient.java 12345678910111213141516171819202122232425262728293031323334353637public boolean parseHTTP(MessageHeader var1, ProgressSource var2, HttpURLConnection var3) throws IOException &#123; try &#123; this.serverInput = this.serverSocket.getInputStream(); if(this.capture != null) &#123; this.serverInput = new HttpCaptureInputStream(this.serverInput, this.capture); &#125; this.serverInput = new BufferedInputStream(this.serverInput); return this.parseHTTPHeader(var1, var2, var3); &#125; catch (SocketTimeoutException var6) &#123; if(this.ignoreContinue) &#123; this.closeServer(); &#125; throw var6; &#125; catch (IOException var7) &#123; this.closeServer(); this.cachedHttpClient = false; if(!this.failedOnce &amp;&amp; this.requests != null) &#123; this.failedOnce = true; if(!this.getRequestMethod().equals("CONNECT") &amp;&amp; !this.streaming &amp;&amp; (!var3.getRequestMethod().equals("POST") || retryPostProp)) &#123; this.openServer(); if(this.needsTunneling()) &#123; MessageHeader var5 = this.requests; var3.doTunneling(); this.requests = var5; &#125; this.afterConnect(); this.writeRequests(this.requests, this.poster); return this.parseHTTP(var1, var2, var3); &#125; &#125; throw var7; &#125; &#125; 当发生IOException就会执行判断是否进行重试。failedOnce 默认是 false，表示是否已经失败过一次了。这也就限制了最多发送 2 次请求。var3 是请求信息retryPostProp 默认是 true ，可以通过命令行参数( -Dsun.net.http.retryPost=false )来指定值。streaming：默认 false 。 true if we are in streaming mode (fixed length or chunked) 。 bug链接：http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6427251这个Bug很早就有了，归根结底原因就是sun提供的实现与Http对于Post请求的规范有不同。Http协议里Post不是幂等的，不能进行重试。 解决方案 使用Apache Client请求 修改JVM启动参数 添加：-Dsun.net.http.retryPost=false http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6427251 总结心得 http协议方面：http规定的部分是规范，实现有千种方法。有的符合协议，有的又有所区别，在对接过程中，指定接入方式，形成书面文档规范。有利于后续问题职责归属。 在寻找问题方面，无法完整获取所有信息时，从已掌握的信息出发，避免任何一点得出结论的依据。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[solr 的ecismax插件扩展方式]]></title>
    <url>%2F2017%2F09%2F19%2Fsearch%2Fsolr_2%2F</url>
    <content type="text"><![CDATA[前言 solr 通过插件的方式实现对edismax的支持。在熟悉了solr插件的执行流程后我，我们也可以对solr插件功能进行定制。实现更加强大的功能。 类图 ExtendedDismaxQParserPlugin NamedListInitializedPlugin 作用NameList作为solr存储map的方式，可以看成是一个key value容器。NameListInitializedPlugin是可以通过NameList初始化的插件。只有一个init方法。接收NameList参数。 SolrInfoMBean 作用提供Solr后台基础信息的Bean接口。3：QparserPlugin所有插件的父类，定义了默认方法，保存声明了所有solr已经实现的plugin。 ExtendedDismaxQparser ExtendDismaxQparser描述edismax支持的配置和方法，集合了edismax所需功能的各种操作。并创建 ExtendedSolrDismaxQueryParser,为其提供职责更为简明的操作环境。是edismax语法支持类。 ExtendSolrQueryParser QueryBuilderlucene 提供用于创建查询器的工厂类 可以被当做自定义解析器的子类，使得查询解析器更容易地集成到分析链中。生成查询可以定制化。所有默认lucene提供的query在这里创建 SolrQueryParserBaseSolr继承自QueryBuilder的类。作为Solr标准查询解析器的父类。Solr对lucene的扩展，加入了 MagicFieldName RawQuery等支持。初始化时读入 schema配置。可以修改这个类来扩展schema标签功能。 QueryParser默认的query解析器 SolrQueryParserSolr’s 的默认查询解析器schema驱动的经典lucene查询解析方式。 ExtendedSolrQueryParser作为ExtendedSolrQParser的内部类存在。实施最终的查询解析。 请求过程SolrDispatchFilter（doFilter,execute） -&gt;SolrCore.execute -&gt;RequestHandlerBase.handleRequest -&gt;SearchHandler.handleRequestBody//有可能执行多个Component//query,facet,group等等，这里每个查询特性对应每个SearchComponent-&gt;QueryComponent.process -&gt;SolrIndexSearcher(search,getDocListC) 描述edismax请求到 SearchHandler 分析调用的SearchComponent链，其中QueryComponent 通过defType选择 插件ExtendedDismaxQParserPlugin 创建queryParser初始化插件paraer QueryComponent prepare调用QParser rqparser = QParser.getParser(rankQueryString, defType, req);先解析出参数语法包含的解析器信息 QueryComponent 源码部分 关键方法: 123456789101112131415161718192021222324252627282930313233343536public static QParser getParser(String qstr, String defaultParser, SolrQueryRequest req) throws SyntaxError &#123; ... //存在字符 &#123;！需要分析参数需要什么样的查询解析器选定信息 if (qstr != null &amp;&amp; qstr.startsWith(QueryParsing.LOCALPARAM_START)) &#123; localParams = new ModifiableSolrParams(); localParamsEnd = QueryParsing.parseLocalParams(qstr, 0, localParams, globalParams); String val = localParams.get(QueryParsing.V); if (val != null) &#123; // val was directly specified in localParams via v=&lt;something&gt; or v=$arg valFollowedParams = false; &#125; else &#123; // use the remainder of the string as the value valFollowedParams = true; val = qstr.substring(localParamsEnd); localParams.set(QueryParsing.V, val); &#125; &#125; ... //localParams 语法解析出来的localParams是否需要特殊的解析器来解析查询。 if (localParams == null) &#123; parserName = defaultParser; &#125; else &#123; //显示的defType与解析出来的信息一起判断优先级来选定解析器名称 parserName = localParams.get(QueryParsing.TYPE,defaultParser); qstr = localParams.get("v"); &#125; parserName = parserName==null ? QParserPlugin.DEFAULT_QTYPE : parserName; //确定后通过名称获取解析插件 QParserPlugin qplug = req.getCore().getQueryPlugin(parserName); QParser parser = qplug.createParser(qstr, localParams, req.getParams(), req); ... return parser; &#125; 对edisMax查询操作，QueryComponet返回了 ExtendDismaxQparser 作为查询解析器作为后续的查询支持 。默认解析器 lucene 扩展功能扩展步骤：1:新建 XXPlugin 继承 QParserPlugin 实现方法： 123456//定义插件名称，用于配置指定public static String NAME = "XXXqueryPlus";@Overridepublic QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) &#123; return new XXXQParser(qstr, localParams, params, req);&#125; 2:创建XXXQParser继承QParser, XXXSolrQueryParser继承SolrQueryParser可以采用组合方式，也可以采用内部类的方式。在XXXQParser里重写 parser()方法12345678@Overridepublic Query parse() throws SyntaxError &#123; //返回具体的 查询Query //可以结合XXXSolrQueryParser方法返回. //this.parser() --&gt; XXSolrQueryParser.parser()。 //提交给 SolrQuerybase执行，只要根据需要重写 SolrQueryBase里的 // protected Query getFieldQuery(String field, String queryText, //boolean quoted, boolean raw)方法即可。&#125; 3:solrConfig里配置123456&lt;requestHandler name="standard" class="solr.SearchHandler" default="true"&gt; &lt;lst name="defaults"&gt; &lt;str name="defType"&gt;XXXqueryPlus&lt;/str&gt; &lt;/lst&gt;&lt;/requestHandler&gt;]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>solr</tag>
        <tag>edismax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构介绍]]></title>
    <url>%2F2017%2F09%2F18%2Fredis%2FRedisshujujiegou%2F</url>
    <content type="text"><![CDATA[Redis数据结构介绍 Redis数据结构分为 STRING,LIST,SET,HASH,ZSET五种。与其他数据库或者缓存有相互对应关系。又有他自己的特点。 结构类型 值类型 读写能力 STRING 字符串，整数，浮点数，基本类型 对整个字符串或者字符串其中的一部分进行操作，对整数和浮点数进行自增或者自减 LIST 一个链表，链表上的每个节点都包含了一个字符串 从链表的两端推入或者弹出元素，根据偏移量对链表进行修剪，读取单个或者多个元素；根据值查找或者移除元素 SET 包含字符串的无序搜集器（unordered collection)，并且被包含的每个字符串都是独一无二，各不相同的 添加，获取，移除单个元素；检查一个元素是否存在于集合中；计算交集，并集，差集；从集合里随机获取元素 HASH 包含键值对的无序散列表 添加、获取、移除单个键值对；获取所有键值对 ZSET(有序集合) 字符串成员（member）与浮点数值（score）之间的有序映射，元素的排列顺序由分值的大小决定 添加、获取、删除、单个元素；根据分值范围（染个）或者成员来获取元素 字符串（STRING)基本操作： 命令 行为 GET 获取存储在给定键值中的值 SET 设置存储在给定键中的值 DEL 删除存储在给定键中的值（所有类型适用） 列表（List)基本操作： 命令 行为 RPUSH 给定的值推入列表的右端 LRANGE 获取列表在给定范围上的所有值 LINDEX 获取在列表给定位置上的单个元素 LPOP 从列表的左端弹出一个值，并返回被弹出的值 集合（SET） 和集合一样可以存储多个字符串，不同的是 列表中可以村粗多个相同的字符串。而集合则通过使用散列来保证自己存储的每个字符串都是各自不同的（这些散列只有键没有键值） 基本操作： 命令 行为 SADD 将给定元素添加到集合 SMEMBERS 返回集合包含的所有元素 SISMEMBER 检查给定元素是存在于集合中 SREM 如果给定的元素存在于集合中，那么移除这个元素 另外的操作SINTER,SUNION, SDIFF 分别执行交集计算、并集计算和差集计算。 散列（HASH） Redis的散列可以存储多个键值间的映射。其值，可以是字符串有可以是数字值。也可以对散列存储的值进行自增或自减。 散列在很多方面就是一个缩小版的Redis，不少字符串都有相应的散列版本。 基本操作： 命令 行为 HSET 在散列里面关联起给定的键值对 HGET 获取指定散列键的值 HGETALL 获取散列包含所有键值对 HDEL 如果给定键存在于散列里，那么移除这个键 Redis的散列可以看做文档数据库里的文档，在开发过程中可以很好的对应。在关系书库里可以看做关系数据库里的行。散列、文档、数据行这三者都允许用户同时访问或者修改一个火多个域。 有序集（ZSET） 和散列一样，有序集都用于存储键值对：有序集合的键称为 成员（member）每个成员都各不相同；有序集的值被称为分值（score）必须为浮点数。是唯一一个可以根据成员访问元素，又可以根据分值以及分值的排序来访问元素的结构。 基本操作： 命令 行为 ZADD 将一个带有给定成分值的成员添加到有序集合里 ZRANGE 根据元素在有序排列中所处处的位置，从有序集合中获取多个元素 ZRANGEBYSCORE 获取有序集合给定分值范围内的所有属性 ZREM 如果给定成员存在，移除这个成员]]></content>
      <categories>
        <category>缓存</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql缓存与Memcached,Redis区别]]></title>
    <url>%2F2017%2F09%2F18%2Fmysql%2FMysql_1%2F</url>
    <content type="text"><![CDATA[前言 我们在做Web开发的时候从至上而下的技术分层里，缓存始终贯穿其中。浏览器层–》业务层–》数据库层。每个层面上的缓存都有各自的功能与场景。我们今天探讨下业务层到数据库层上缓存的功能和区别。 业务层缓存MemcachedMemcached 严格上讲还不能说是完整的分布式缓存系统。它有很多第三方工具支撑其分布式功能。Memcached 通过内部固定的大小的chunk预申请内存数据。使得分配和回收内存的效率很高。读写性能也很高。64k对象的情况下，单机QPS可以达到15W以上。Memcached 的集群架构中，单个节点对其他节点是相互独立的，没有数据方面的通信。不具备failover能力。Memcached 支持多语言，有相当的稳定性。 RedisRedis 显著的特点是不仅支持普通的K，V 类型存储，还支持其独特的 五种数据结构 详见Redis数据结构Redis 也支持集群，Redis支持的集群是Master-Slave模式。其有点是可以在宕机时切换到备份机。可用性方面有一定的提升。Redis 单纯当做缓存存储在内存时速度和Memcached不相上下。存储到硬盘时，性能和速度会下降很多，介于 Memcahced 和mysql之间。Redis 有特殊的订阅功能，使得它经常被用于当做内存队列使用。Redis 扩展方面不如Memcached，无法做到持续的线性扩容。目前支持通过复制的方式，产生一主多备架构并升级容量。 数据库层缓存mysql缓存MySQL将缓存分为Buffer缓存和Cache缓存。Buffer缓存:由于硬盘的写入速度过慢，或者频繁的I/O，对于硬盘来说是极大的效率浪费。那么可以等到缓存中储存一定量的数据之后，一次性的写入到硬盘中。Buffer 缓存主要用于写数据，提升I/O性能。Cache 缓存:Cache 是在开启缓存功能前提下，在通过的每次sql进行hash计算，生成此条sql的唯一hash作为存储的Key值。SO select是区分大小写的。生成缓存之后，如果涉及的table有任何数据的变动（整个talbe),所有的cache就会被删除。如果Cache缓存已经存储满，则启用LRU算法，进行数据淘汰。淘汰掉最远未使用的数据，从而开辟新的存储空间。不过对于特大型的网站，依靠这种策略很难缓解高频率的读请求，一般会把访问非常频繁的数据静态化，直接由nginx返还给用户。程序和数据库I/O设备交互的越少，则效率越高。 问题既然有Memcached,Redis 为什么还要用Mysql缓存呢？ 解答 从整体架构上看，Memcached和Redis支持扩展分布式缓存。适用于大型Web项目。单从单节点功能上看，Mysql由于自身的cache 删除方式。使得其缓存有相对的局限性。并且无法简单的管控。需要更好的使用的话，需要对业务上进行更详尽细致的分析。在数据库的逻辑设计层面细分出能够说回合mysql缓存的场景。单节点，数据简单，无太多修改的数据面前，但根据场景来，mysql缓存还是有一定价值的。比Memcached Redis简单易用，效率更好。 参考：https://dev.mysql.com/doc/refman/5.7/en/query-cache.html]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux expect ssh自动登录详解]]></title>
    <url>%2F2017%2F09%2F14%2Flinux%2Flinux%20expect%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[简介 Expect是用于自动化交互式应用程序的工具，如telnet，ftp，passwd，fsck，rlogin，tip等。使用起来很简单。 使用方法 首行加上/usr/bin/expect spawn: 后面加上需要执行的shell 命令，比如说spawn sudo touch testfile expect: 只有spawn 执行的命令结果才会被expect 捕捉到，因为spawn 会启动一个进程，只有这个进程的相关信息才会被捕捉到，主要包括：标准输入的提示信息，eof 和timeout。 send 和send_user：send 会将expect 脚本中需要的信息发送给spawn 启动的那个进程，而send_user 只是回显用户发出的信息，类似于shell 中的echo 而已。 实例1:远程拷贝文件1234567891011121314151617181920set timeout 10set host [lindex $argv 0]set username [lindex $argv 1]set password [lindex $argv 2]set src_file [lindex $argv 3]set dest_file [lindex $argv 4]spawn scp $src_file $username@$host:$dest_file expect &#123; &quot;(yes/no)?&quot; &#123; send &quot;yes\n&quot; expect &quot;*assword:&quot; &#123; send &quot;$password\n&quot;&#125; &#125; &quot;*assword:&quot; &#123; send &quot;$password\n&quot; &#125; &#125; expect &quot;100%&quot; expect eof 2:执行远程命令1234567891011121314151617181920set timeout 10set host [lindex $argv 0]set username [lindex $argv 1]set password [lindex $argv 2]set cmd [lindex $argv 3]spawn ssh -t -p $port $username@$host &apos;cmd&apos; expect &#123; &quot;(yes/no)?&quot; &#123; send &quot;yes\n&quot; expect &quot;*assword:&quot; &#123; send &quot;$password\n&quot;&#125; &#125; &quot;*assword:&quot; &#123; send &quot;$password\n&quot; &#125; &#125; expect &quot;100%&quot; expect eof 3：与SSH合用 123/usr/bin/expect &lt;&lt;-EOF//TODO这里写expect脚本 EOF]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[alfred结合七牛实现快速插入markdown格式图片]]></title>
    <url>%2F2017%2F09%2F13%2Fblog%2Falfred%E7%BB%93%E5%90%88%E4%B8%83%E7%89%9B%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8F%92%E5%85%A5markdown%E6%A0%BC%E5%BC%8F%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[详细过程可以访问：https://github.com/tiann/markdown-img-upload 问题修复 由于retina截屏的图片会放大，所以在markdown脚本里做了处理：有遇到缩放的会进行指定宽度大小。所以会插入&lt;img 标签。但是这不符合markdown的图片方式，这里做了一下改进。将 计算后的size插入七牛的样式图片里就可以解决。 打开workflow的脚本修改保存1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# coding: utf-8from clipboard import get_paste_img_filefrom upload import upload_qiniuimport utilimport osimport subprocessimport sysimport timeif not os.path.exists(util.CONFIG_FILE): util.generate_config_file()config = util.read_config()if not config: util.notice('请先设置你的七牛图床信息') util.open_with_editor(util.CONFIG_FILE) sys.exit(0)url = '%s/%s' % (config['url'], config['prefix'])styleprefix = 'imageView2/2/w/'stylesubfix = '/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim'mkdprefix='![图片]('mkdsubfix=')'img_file, need_format, format = get_paste_img_file()if img_file: # has image # use time to generate a unique upload_file name, we can not use the tmp file name upload_name = "%s.%s" % (int(time.time() * 1000), format) if need_format: size_str = subprocess.check_output('sips -g pixelWidth %s | tail -n1 | cut -d" " -f4' % img_file.name, shell=True) size = int(size_str.strip()) / 2 #markdown_url = '&lt;img src="%s/%s-1960" width="%d"/&gt;' % (url, upload_name, size) markdown_url = '%s%s/%s?%s%d%s%s' % (mkdprefix, url, upload_name, styleprefix, size, stylesubfix, mkdsubfix) else: markdown_url = '%s%s/%s-960%s' % (mkdprefix, url, upload_name, mkdsubfix) # make it to clipboard os.system("echo '%s' | pbcopy" % markdown_url) os.system('osascript -e \'tell application "System Events" to keystroke "v" using command down\'') upload_file = util.try_compress_png(img_file, format!='gif') if not upload_qiniu(upload_file.name, upload_name): util.notice("上传图片到图床失败，请检查网络后重试")else: util.notice("剪切版里没有图片！") 上面是我修改后的脚本信息，修改的地方是：1markdown_url = &apos;%s%s/%s?%s%d%s%s&apos; % (mkdprefix, url, upload_name, styleprefix, size, stylesubfix, mkdsubfix) 注意这两个变量12styleprefix = &apos;imageView2/2/w/&apos; stylesubfix =&apos;/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim&apos; 根据自己的七牛图片拼装 markdown_url即可。我这里用的是通过改变七牛提供的链接图片 size 进行替换。中间拼装计算好的原始图片size即变成正常大小。既： styleprefix + size + stylesubfix]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>alfred</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[solr高级查询edismax函数详解]]></title>
    <url>%2F2017%2F09%2F11%2Fsearch%2Fsolr%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2edismax%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言 最近遇到solr查询中加入字段权重的需求，自然而然地想到了edismax这个功能。通过系统的学习和文档阅读，大概了解solr 对于函数式查询的支持方式。为了便于记忆，这里对常用公式进行整理说明。 使用方式详细见官方文档介绍，这里不做说明，我们重点讲solr edismax所涉及到的函数。 bf函数列表 constant 支持小数点的常量例如，1.5，查询表达式就是：_val_:1.5 fieldvalue 返回numberic field的名字.域必须是index的，非multivalue。格式为该域的名字。如果这个域没值，就返回0 ord ord，返回你要查询的那个特定的值在这个顺序中的排名。 非multiValued的，当没有值存在的时候，将返回0 例如：某个特定的域只能去三个值，“apple”、“banana”、“pear”，那么ord（“apple”）=1，ord（“banana”）=2，ord（“pear”）=3 需要注意的是，ord（）这个函数，依赖于值在索引中的位置，所以当有文档被删除、或者添加的时候，ord（）的值就会发生变化。当你使用MultiSearcher的时候，这个值也就是不定的了。 rord 函数将会返回与ord相对应的倒排序的排名。 格式: rord(myIndexedField). sum 就是表示多个数值的“和”。 格式： sum(x,1) sum(x,y) sum(sqrt(x),log(y),z,0.5) product 多个参数的乘积，参数可以是数值，也可以是函数，当为函数时，表示为此函数的计算值乘积。 格式： product(x,2) product(x,y) div 两个参数做除法。支持函数参数 格式： div(x,y) div(sum(x,100),max(y,1)) pow 幂值计算，pow(x,y)=x^y 。支持函数参数。 格式： pow(x,0.5) 标识开方 pow(x, log(y)) abs 返回表达式的绝对值，支持函数参数。 格式： abx(-5) abc(x) log返回对数操作，支持函数参数。格式：log(x)log(sum(x,100)) sqrt返回平方根。与pow(x，0.5)一样。格式：sqrt(2)sqrt(sum(x,100)) map区间检测如果 min&lt;=x&lt;=max，那么map(x,min,max,target)=target，如果x不在[min,max]这个区间内，那么map(x,min,max,target)=x. scala限制参数区间例如：scale(x,minTarget,maxTarget) 这个函数将会把x的值限制在[minTarget,maxTarget]范围内。 query计算subquery查询分数例如：query(subquery,default)表示返回给定的subquery的分数，如果subquery与文档不匹配，那么将会返回默认值。任何的查询类型都是受支持的。可以通过引用的方式，也可以直接指定查询串。q=product(popularity, query({!dismax v=’solr rocks’})) 将会返回popularity和通过dismax 查询得到的分数的乘积q=product(popularity, query($qq)&amp;qq={!dismax}solr rocks) 跟上一个例子的效果是一样的。不过这里使用的是引用的方式q=product(popularity, query($qq,0.1)&amp;qq={!dismax}solr rocks) 在前一个例子的基础上又加了一个默认值。 linear线性函数计算例如：liner(x,m,c)其中 x为变量或者函数，m,c为常量。整个函数取值为： xm+c的值。liner(x,2,4)=2x+4 reciprecip(x,m,a,b) 函数表达式 a/(m*x+b)其中，m、a、b是常量，x是变量或者一个函数。当a=b，并且x&gt;=0的时候，这个函数的最大值是1，值的大小随着x的增大而减小。 max比较大小例如：max(x,c) x可以为变量或者函数，c为常数，返回两个之间最大值。 场景应用 某地的新闻网页库中原本的逻辑是对仓库里的数据字段 subject，message进行搜索。默认是通过score检索字段匹配得分进行排序输出。随着时间的推移，大量的搜索可能会展示两年前，三年前匹配度更高的数据，这些搜索结果明显不合适的。那么我们需要对其进行改造，加入发布时间权重排序。 原本的参数： 1subject:武则天 OR message:武则天 搜索得出结果： 文档得分： 上面我们可以看到，tid为666811的文档排在第一位，得分27.811375 它的dateline时间是：1239781944明显早于第二位 tid：10364925的 1503334472，得分：26.519054。第三位是 tid:9759987 得分：26.511488。这样的搜索结果显然不是很令人满意的。 开启edismax 加入 1bf=sqrt(log(dateline))^100 搜索得出结果： 文档得分： 经过调整，我们得出的结果中排在第一位的是 tid:9759987 其时间dateline是1473820016 得分：330.85 是原本的第三位。原来的排第一的 tid:666811排在了第三位，得分 329.40 原来的第二tid:10364925 得分：329.50 调整后的排序大致满足我们的需求。那么为什么调整后会变成这样的排序呢？ 首先我们要清楚solr的打分机制默认是通过匹配度计算文档相似度得来的。也就是第一次搜索的默认得分，引入edismax的bf函数后我们来分析下最终的结果是怎样，以第一次搜索排名前三的数据为例子： tid | dateline | 初始得分 | 引入bf重新计算 —|—|—|— 666811 | 1239781944 | 27.811382 | 329.40198 10364925 | 1503334472 | 26.519054 |329.50174 9759987 | 1473820016 | 26.511488 | 330.85834 根据bf=sqrt(log(dateline))^100 分别计算上面三个的新得分 1234567891011121314151617sqrt(log(1239781944)) = 3.0155174194591075 权重乘100 得: 301.55174194591075再加 27.811382 =329.36312394591073sqrt(log(1503334472)) = 3.029365546794402权重乘100 得:302.9365546794402再加 26.519054=329.45560867944016sqrt(log(1473820016)) = 3.0279439311841663权重乘100 得:302.79439311841663再加 26.511488=329.3058811184166 纳尼。很奇怪为什么 9759987 计算最小 不对劲 于是翻看原来前面查询的debug列表分析仔细看原来是原图： 添加edismax后： 对比以上靓图，原来是我们的Qparser不一样。在普通查询的时候我么使用的是定制化的 SWMCLuceneQparser 查询解析器。而 用edimax后，解析器变成了 ExtendDismaxQparser 这两个差别在于 定制化的 SWMCLuceneQparser会将查询字段通过IK分词转换后进行查询。其parsedquery_tostring 变成1&quot;parsedquery&quot;:&quot;PhraseQuery(subject:\&quot;武 则 天\&quot;) PhraseQuery(message:\&quot;武 则 天\&quot;)&quot;, ExtendDismaxQparser的 parsedquery_tostringshi :1&quot;parsedquery_toString&quot;:&quot;+((subject:武 subject:则 subject:天) (message:武 message:则 message:天)) (sqrt(log(long(dateline))))^10.0&quot;, 两者稍有不同，所以在计算最终权重的时候有些差异。]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>solr</tag>
        <tag>edismax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo技术博客搭建日记]]></title>
    <url>%2F2017%2F09%2F02%2Fblog%2Fhexo%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[9月2号听说Hexo 案例1 案例2 9月3号了解Hexo搭建博客方式 hexo搭建参考1 hexo搭建参考2 hexo主题 9月5号搭建完成 9月6号添加域名解析 9月7号添加Gitment评论功能 Gitment的github地址 9月9号配置结合alfred + 七牛 快捷插入markdown图片工具 Github地址 9月11号第一篇文章登陆 9月12号完善主题配置 9月13日添加站点收录 npm install hexo-generator-sitemap –save npm install hexo-generator-baidu-sitemap –save 搜索引擎站点收录]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>IntelliJ IDEA</tag>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
</search>
