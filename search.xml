<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>多数据源项目下dubbo调用，获取的数据源不正确</title>
    <url>/2022/12/01/bugfix/bugfix_0/</url>
    <content><![CDATA[<p>##背景<br>每天定时任务会跑一次下个月的表是否存在，然后进行建表。dubbo调用。在线程上配置了 datasource选取规则。</p>
<p>初始化的时候会判断是否有建下个月的表，这个操作需要通过schema.xxx操作。但是shardingsphere不支持schema.xxx操作。所以我们创建了两个数据源，shardingDatasource和dataSource</p>
<p>1：如果 schema.xxx操作的话用 dataSource。<br>2：非schema.xxx操作的 用shardingDataSource。</p>
<p>在线程执行的时候通过ThreadLocal变量缓存dataSource。但是忘记cleanThreadLocal值了。<br>在短连接的时候是正常的，在长链接的调用下会有以下错误逻辑发生比如dubbo调用下的异常：</p>
<p>1：如果某次执行 获取了一个 dubboThread1，这个线程执行 先获取了未分表的数据源。并缓存了，如果没有清除数据源，下次拿到的还是这个数据源。</p>
<p>2：dubbo 协议的provider-consumer 链接是1：1，所以执行一次后，这个链接并没有被销毁，某个下单请求获取到了 这个dubboThread1，由于这个线程链接已经在1 操作中获取到了未分表的数据源 dataSource。就在母表上进行了业务操作。创建订单成功，但是订单所在的表示错误的。</p>
<p>3：回调来的请求操作是另外一个节点进行处理，获取到的是 dubboThread2 这个dubboThread2 未获取到数据源，所以按照上面的规则进行初始化数据源并缓存 得到shardingDatasource。根据订单号选择的是订单号归属的分表，此时无法找到这个订单。所以报错。</p>
<h2 id="bug修复"><a href="#bug修复" class="headerlink" title="bug修复"></a>bug修复</h2><p>在定时任务结束后清理dataSource类型缓存。</p>
]]></content>
      <categories>
        <category>bug</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>alfred结合七牛实现快速插入markdown格式图片</title>
    <url>/2017/09/13/blog/alfred%E7%BB%93%E5%90%88%E4%B8%83%E7%89%9B%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8F%92%E5%85%A5markdown%E6%A0%BC%E5%BC%8F%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p><a href="https://github.com/tiann/markdown-img-upload" target="_blank" rel="noopener">详细过程可以访问：https://github.com/tiann/markdown-img-upload</a></p>
<h2 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h2><blockquote>
<p>由于retina截屏的图片会放大，所以在markdown脚本里做了处理：有遇到缩放的会进行指定宽度大小。所以会插入&lt;img 标签。但是这不符合markdown的图片方式，这里做了一下改进。将 计算后的size插入七牛的样式图片里就可以解决。</p>
</blockquote>
<p>打开workflow的脚本修改保存<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">from</span> clipboard <span class="keyword">import</span> get_paste_img_file</span><br><span class="line"><span class="keyword">from</span> upload <span class="keyword">import</span> upload_qiniu</span><br><span class="line"><span class="keyword">import</span> util</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(util.CONFIG_FILE):</span><br><span class="line">    util.generate_config_file()</span><br><span class="line"></span><br><span class="line">config = util.read_config()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> config:</span><br><span class="line">    util.notice(<span class="string">'请先设置你的七牛图床信息'</span>)</span><br><span class="line">    util.open_with_editor(util.CONFIG_FILE)</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">url = <span class="string">'%s/%s'</span> % (config[<span class="string">'url'</span>], config[<span class="string">'prefix'</span>])</span><br><span class="line">styleprefix = <span class="string">'imageView2/2/w/'</span></span><br><span class="line">stylesubfix = <span class="string">'/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim'</span></span><br><span class="line">mkdprefix=<span class="string">'![图片]('</span></span><br><span class="line">mkdsubfix=<span class="string">')'</span></span><br><span class="line">img_file, need_format, format = get_paste_img_file()</span><br><span class="line"><span class="keyword">if</span> img_file:</span><br><span class="line">    <span class="comment"># has image</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># use time to generate a unique upload_file name, we can not use the tmp file name</span></span><br><span class="line"></span><br><span class="line">    upload_name = <span class="string">"%s.%s"</span> % (int(time.time() * <span class="number">1000</span>), format) </span><br><span class="line">    <span class="keyword">if</span> need_format:</span><br><span class="line">        size_str = subprocess.check_output(<span class="string">'sips -g pixelWidth %s | tail -n1 | cut -d" " -f4'</span> % img_file.name, shell=<span class="literal">True</span>)</span><br><span class="line">        size = int(size_str.strip()) / <span class="number">2</span></span><br><span class="line">        <span class="comment">#markdown_url = '&lt;img src="%s/%s-1960" width="%d"/&gt;' % (url, upload_name, size)</span></span><br><span class="line">	    </span><br><span class="line">        markdown_url = <span class="string">'%s%s/%s?%s%d%s%s'</span> % (mkdprefix, url, upload_name, styleprefix, size, stylesubfix, mkdsubfix)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        markdown_url = <span class="string">'%s%s/%s-960%s'</span> % (mkdprefix, url, upload_name, mkdsubfix)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make it to clipboard</span></span><br><span class="line">    os.system(<span class="string">"echo '%s' | pbcopy"</span> % markdown_url)</span><br><span class="line">    os.system(<span class="string">'osascript -e \'tell application "System Events" to keystroke "v" using command down\''</span>)</span><br><span class="line">    upload_file = util.try_compress_png(img_file, format!=<span class="string">'gif'</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> upload_qiniu(upload_file.name, upload_name): util.notice(<span class="string">"上传图片到图床失败，请检查网络后重试"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    util.notice(<span class="string">"剪切版里没有图片！"</span>)</span><br></pre></td></tr></table></figure></p>
<p>上面是我修改后的脚本信息，修改的地方是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">markdown_url = &apos;%s%s/%s?%s%d%s%s&apos; % (mkdprefix, url, upload_name, styleprefix, size, stylesubfix, mkdsubfix)</span><br></pre></td></tr></table></figure></p>
<p>注意这两个变量<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">styleprefix = &apos;imageView2/2/w/&apos;  </span><br><span class="line">stylesubfix =&apos;/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim&apos;</span><br></pre></td></tr></table></figure></p>
<p>根据自己的七牛图片拼装 markdown_url即可。我这里用的是通过改变七牛提供的链接图片 size 进行替换。<br>中间拼装计算好的原始图片size即变成正常大小。<br>既： styleprefix + size + stylesubfix</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>alfred</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo技术博客搭建日记</title>
    <url>/2017/09/02/blog/hexo%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>9月2号听说Hexo  </p>
<ul>
<li><a href="http://blog.didispace.com/books/" target="_blank" rel="noopener">案例1</a>  </li>
<li><a href="http://www.itmuch.com" target="_blank" rel="noopener">案例2</a>  </li>
</ul>
<p>9月3号了解Hexo搭建博客方式  </p>
<ul>
<li><a href="http://www.youmeek.com/hexo/" target="_blank" rel="noopener">hexo搭建参考1</a>  </li>
<li><a href="http://www.jianshu.com/p/a417262815a6" target="_blank" rel="noopener">hexo搭建参考2</a>  </li>
<li><a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">hexo主题</a>  </li>
</ul>
<p>9月5号搭建完成</p>
<p>9月6号添加域名解析</p>
<p>9月7号添加Gitment评论功能</p>
<ul>
<li><a href="https://github.com/littlehui/gitment" target="_blank" rel="noopener">Gitment的github地址</a>  </li>
</ul>
<p>9月9号配置结合alfred + 七牛 快捷插入markdown图片工具</p>
<ul>
<li><a href="https://github.com/tiann/markdown-img-upload" target="_blank" rel="noopener">Github地址</a>  </li>
</ul>
<p>9月11号第一篇文章登陆</p>
<p>9月12号完善主题配置</p>
<p>9月13日添加站点收录</p>
<blockquote>
<p>npm install hexo-generator-sitemap –save<br>  npm install hexo-generator-baidu-sitemap –save</p>
</blockquote>
<ul>
<li><a href="http://www.cnblogs.com/tengj/p/5357879.html" target="_blank" rel="noopener">搜索引擎站点收录</a></li>
</ul>
<p>七牛后面需要域名绑定并且实名认证。所以改用自建图床，zimg。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>IntelliJ IDEA</tag>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket,WebSocket,HTML5</title>
    <url>/2018/02/06/http/hexo/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>对Web项目来讲，一般都用http请求来解决。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>Socket 和 WebSocket 有哪些区别和联系？</li>
<li>WebSocket 和 HTML5 是什么关系？</li>
<li>必须在浏览器中才能使用 WebSocket 吗？</li>
<li>WebSocket 能和 Socket 一样传输 raw 数据么？</li>
<li>WebSocket 和 Socket 相比会多耗费流量么？</li>
</ul>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>选择了 WebSocket 技术之后，不可避免的，我要将它和其他协议以及技术做一下比较。最常见的，就是需要比较 WebSocket 与 HTTP、Socket 技术的异同。</p>
<p>WebSocket 是为了满足基于 Web 的日益增长的实时通信需求而产生的。在传统的 Web 中，要实现实时通信，通用的方式是采用 HTTP 协议不断发送请求。但这种方式即浪费带宽（HTTP HEAD 是比较大的），又消耗服务器 CPU 占用（没有信息也要接受请求）。（下图来自 WebSocket.org）</p>
<p>Latency comparison between the polling and WebSocket applications</p>
<p>而是用 WebSocket 技术，则会大幅降低上面提到的消耗：（下图来自websocket.org）</p>
<p>Comparison of the unnecessary network throughput overhead between the polling and the WebSocket applications</p>
<p>关于更详细的描述，尹立的这篇文章讲得非常好：WebSocket（2）–为什么引入WebSocket协议 。</p>
<p>那么，WebSocket 到底与 HTTP 协议到底是一个什么样的关系呢？它和 Socket 又有什么联系？这就要讲到 OSI 模型和 TCP/IP 协议族。</p>
<h3 id="OSI-模型与-TCP-IP"><a href="#OSI-模型与-TCP-IP" class="headerlink" title="OSI 模型与 TCP/IP"></a>OSI 模型与 TCP/IP</h3><p>以下是 维基百科 中关于OSI 模型的说明：</p>
<p>开放式系统互联通信参考模型（英语：Open System Interconnection Reference Model，ISO/IEC 7498-1），简称为OSI模型（OSI model），一种概念模型，由国际标准化组织（ISO）提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。</p>
<p>而 TCP/IP 协议可以看做是对 OSI 模型的一种简化（以下内容来自 维基百科）：</p>
<p>它将软件通信过程抽象化为四个抽象层，采取协议堆叠的方式，分别实作出不同通信协议。协议套组下的各种协议，依其功能不同，被分别归属到这四个阶层之中7，常被视为是简化的七层OSI模型。</p>
<p>这里有一张图详细介绍了 TCP/IP 协议族中的各个协议在 OSI模型 中的分布，一图胜千言（下图来自 科来）：</p>
<p>TCP/IP 和 OSI 模型</p>
<p>TCP/IP 协议和 OSI 模型的内容，在互联网上有很多。我没有必要再次介绍它们。在这里，我们只需要知道，HTTP、WebSocket 等协议都是处于 OSI 模型的最高层： 应用层 。而 IP 协议工作在网络层（第3层），TCP 协议工作在传输层（第4层）。</p>
<p>至于 OSI 模型的各个层次都有什么系统和它们对应，这里有篇很好的文章可以满足大家的求知欲：OSI七层模型详解 。</p>
<ol start="3">
<li>WebSocket、HTTP 与 TCP<br>从上面的图中可以看出，HTTP、WebSocket 等应用层协议，都是基于 TCP 协议来传输数据的。我们可以把这些高级协议理解成对 TCP 的封装。</li>
</ol>
<p>既然大家都使用 TCP 协议，那么大家的连接和断开，都要遵循 TCP 协议中的三次握手和四次握手 ，只是在连接之后发送的内容不同，或者是断开的时间不同。</p>
<p>更详细内容可阅读：wireshark抓包图解 TCP三次握手/四次挥手详解</p>
<p>对于 WebSocket 来说，它必须依赖 HTTP 协议进行一次握手 ，握手成功后，数据就直接从 TCP 通道传输，与 HTTP 无关了。</p>
<ol start="4">
<li>Socket 与 WebScoket<br>Socket 其实并不是一个协议。它工作在 OSI 模型会话层（第5层），是为了方便大家直接使用更底层协议（一般是 TCP 或 UDP ）而存在的一个抽象层。</li>
</ol>
<p>最早的一套 Socket API 是 Berkeley sockets ，采用 C 语言实现。它是 Socket 的事实标准，POSIX sockets 是基于它构建的，多种编程语言都遵循这套 API，在 JAVA、Python 中都能看到这套 API 的影子。</p>
<p>下面摘录一段更容易理解的文字（来自 http和socket之长连接和短连接区别）：</p>
<p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>
<p>Socket是什么</p>
<p>Socket通信过程</p>
<p>主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。</p>
<p>而 WebSocket 则不同，它是一个完整的 应用层协议，包含一套标准的 API 。</p>
<p>所以，从使用上来说，WebSocket 更易用，而 Socket 更灵活。</p>
<ol start="5">
<li>HTML5 与 WebSocket<br>WebSocket API 是 HTML5 标准的一部分， 但这并不代表 WebSocket 一定要用在 HTML 中，或者只能在基于浏览器的应用程序中使用。</li>
</ol>
<p>实际上，许多语言、框架和服务器都提供了 WebSocket 支持，例如：</p>
<p>基于 C 的 libwebsocket.org<br>基于 Node.js 的 Socket.io<br>基于 Python 的 ws4py<br>基于 C++ 的 WebSocket++<br>Apache 对 WebSocket 的支持： Apache Module mod_proxy_wstunnel<br>Nginx 对 WebSockets 的支持： NGINX as a WebSockets Proxy 、 NGINX Announces Support for WebSocket Protocol 、WebSocket proxying<br>lighttpd 对 WebSocket 的支持：mod_websocket</p>
<p><a href="http://blog.csdn.net/yuanyuanispeak/article/details/51729191" target="_blank" rel="noopener">原文链接</a></p>
]]></content>
      <categories>
        <category>http</category>
        <category>WebSocket</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>HttpURLConnection Post请求自动重传机制</title>
    <url>/2017/09/26/java/java_1/</url>
    <content><![CDATA[<h2 id="背景故事"><a href="#背景故事" class="headerlink" title="背景故事"></a>背景故事</h2><blockquote>
<p>之前负责的一个商城项目，需要从供应商库进行订单下单同步，服务器间通讯通过http请求。 加密方式采用DES加密方式。在运行初期一切正常，几个月后<br>供应商发现有重复订单存在，而客户端这边接收到异常生成订单异常信息，订单生成不同步。供应商的处理逻辑我们无从得知，只能从自身角度思考为什么会有这<br>种问题，在排除了一系列原因后，定位到一个问题。那就是 HttpURLConnection的post请求重发机制。</p>
</blockquote>
<h2 id="场景再现"><a href="#场景再现" class="headerlink" title="场景再现"></a>场景再现</h2><p>Http请求是通过HttpUrlConnection封装的一套Java请求客户端 部分源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//请求的header如下</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">getDefaultHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Map&lt;String, Object&gt; defaultHeaders = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">     defaultHeaders.put(<span class="string">"Accept"</span>, <span class="string">"*/*"</span>);</span><br><span class="line">     defaultHeaders.put(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br><span class="line">     defaultHeaders.put(<span class="string">"User-Agent"</span>, <span class="string">"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1)"</span>);</span><br><span class="line">     defaultHeaders.put(<span class="string">"Accept-Charset"</span>, <span class="string">"utf-8"</span>);</span><br><span class="line">     defaultHeaders.put(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded;charset=utf-8"</span>);</span><br><span class="line">     headers = defaultHeaders;</span><br><span class="line">     <span class="keyword">return</span> headers;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化 httpConnection</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="string">"POST"</span>.equals(method)) &#123;</span><br><span class="line">         <span class="keyword">this</span>.url = <span class="keyword">new</span> URL(getUrl);</span><br><span class="line">         <span class="keyword">this</span>.postJson = JsonUtil.toJson(param);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.url = <span class="keyword">new</span> URL(getUrl + urlParams);</span><br><span class="line">     &#125;</span><br><span class="line">     httpConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">     <span class="keyword">for</span> (String keyset : headers.keySet()) &#123;</span><br><span class="line">         httpConnection.setRequestProperty(keyset, headers.get(keyset).toString());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 然后把连接设为输出模式。URLConnection通常作为输入来使用，比如下载一个Web页。</span></span><br><span class="line"><span class="comment">      * 通过把URLConnection设为输出，你可以把数据向你个Web页传送。：</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     httpConnection.setRequestMethod(method);</span><br><span class="line">     httpConnection.setUseCaches(<span class="keyword">false</span>);</span><br><span class="line">     <span class="keyword">if</span> (<span class="string">"POST"</span>.equals(method)) &#123;</span><br><span class="line">         httpConnection.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         httpConnection.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     httpConnection.setDoInput(<span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//执行Http请求</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">doRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.toUrlParams();</span><br><span class="line">     OutputStreamWriter out = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.initConnection();</span><br><span class="line">         <span class="comment">// 一旦发送成功，用以下方法就可以得到服务器的回应：</span></span><br><span class="line">         String sTotalString;</span><br><span class="line">         InputStream urlStream;</span><br><span class="line">         out = <span class="keyword">new</span> OutputStreamWriter(httpConnection.getOutputStream(), charSet);</span><br><span class="line">         <span class="keyword">if</span> (method.equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line">             out.write(<span class="keyword">this</span>.postJson); <span class="comment">//向页面传递数据。post的关键所在！</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// remember to clean up</span></span><br><span class="line">         out.flush();</span><br><span class="line">         urlStream = httpConnection.getInputStream();</span><br><span class="line">         logger.debug(<span class="string">"连接状态:"</span> + urlStream.available());</span><br><span class="line">         <span class="comment">//new InputStreamReader(l_urlStream,)</span></span><br><span class="line">         sTotalString = IOUtil.in2Str(urlStream, charSet);</span><br><span class="line">         <span class="keyword">return</span> sTotalString;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(e);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 out.close();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(e);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         httpConnection.disconnect();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>Java代码调用doRequest通过HttpUrlConnection模拟一个Post请求。结果服务端会收到两次请求。</p>
<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>HttpURLConnection 采用 Sun 私有的一个 HTTP 协议实现类： HttpClient.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">parseHTTP</span><span class="params">(MessageHeader var1, ProgressSource var2, HttpURLConnection var3)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.serverInput = <span class="keyword">this</span>.serverSocket.getInputStream();</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.capture != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.serverInput = <span class="keyword">new</span> HttpCaptureInputStream(<span class="keyword">this</span>.serverInput, <span class="keyword">this</span>.capture);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.serverInput = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">this</span>.serverInput);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.parseHTTPHeader(var1, var2, var3);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketTimeoutException var6) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.ignoreContinue) &#123;</span><br><span class="line">                <span class="keyword">this</span>.closeServer();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> var6;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var7) &#123;</span><br><span class="line">            <span class="keyword">this</span>.closeServer();</span><br><span class="line">            <span class="keyword">this</span>.cachedHttpClient = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">this</span>.failedOnce &amp;&amp; <span class="keyword">this</span>.requests != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.failedOnce = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="keyword">this</span>.getRequestMethod().equals(<span class="string">"CONNECT"</span>) &amp;&amp; !<span class="keyword">this</span>.streaming &amp;&amp; (!var3.getRequestMethod().equals(<span class="string">"POST"</span>) || retryPostProp)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.openServer();</span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>.needsTunneling()) &#123;</span><br><span class="line">                        MessageHeader var5 = <span class="keyword">this</span>.requests;</span><br><span class="line">                        var3.doTunneling();</span><br><span class="line">                        <span class="keyword">this</span>.requests = var5;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">this</span>.afterConnect();</span><br><span class="line">                    <span class="keyword">this</span>.writeRequests(<span class="keyword">this</span>.requests, <span class="keyword">this</span>.poster);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.parseHTTP(var1, var2, var3);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> var7;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当发生IOException就会执行判断是否进行重试。<br>failedOnce 默认是 false，表示是否已经失败过一次了。这也就限制了最多发送 2 次请求。<br>var3 是请求信息<br>retryPostProp 默认是 true ，可以通过命令行参数( -Dsun.net.http.retryPost=false )来指定值。<br>streaming：默认 false 。 true if we are in streaming mode (fixed length or chunked) 。</p>
<p>bug链接：<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6427251" target="_blank" rel="noopener">http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6427251</a><br>这个Bug很早就有了，归根结底原因就是sun提供的实现与Http对于Post请求的规范有不同。Http协议里Post不是幂等的，不能进行重试。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li>使用Apache Client请求</li>
<li>修改JVM启动参数 添加：-Dsun.net.http.retryPost=false</li>
</ol>
<p><a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6427251" target="_blank" rel="noopener">http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6427251</a></p>
<h2 id="总结心得"><a href="#总结心得" class="headerlink" title="总结心得"></a>总结心得</h2><ul>
<li>http协议方面：http规定的部分是规范，实现有千种方法。有的符合协议，有的又有所区别，在对接过程中，指定接入方式，形成书面文档规范。有利于后续<br>问题职责归属。</li>
<li>在寻找问题方面，无法完整获取所有信息时，从已掌握的信息出发，避免任何一点得出结论的依据。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>Twitter Snowflake 有序ID生成算法</title>
    <url>/2018/01/31/java/java_2/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>分布式系统，各种系统平台建设中，需要用到全局唯一的ID场景，可以统一地进行一些简单的统计和排序。这时候我们需要一个统一的ID生成系统来做这个事情。<br>Twitter Snowflake 可以作为一个满足基础需求的原始样本算法。可以以此为蓝本开发自己的业务ID生成算法。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>snowflake的结构如下(每部分用-分开):<br>0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000<br>第一位为未使用，接下来的41位为毫秒级时间(41位的长度可以使用69年)，然后是5位datacenterId和5位workerId(10位的长度最多支持部署1024个节点） ，最后12位是毫秒内的计数（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号）<br>一共加起来刚好64位，为一个Long型。(转换成字符串后长度最多19)<br>snowflake生成的ID整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和workerId作区分），并且效率较高。经测试snowflake每秒能够产生26万个ID。</p>
<h3 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Twitter_Snowflake&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * SnowFlake的结构如下(每部分用-分开):&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截)</span></span><br><span class="line"><span class="comment"> * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 加起来刚好64位，为一个Long型。&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnowflakeIdWorker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==============================Fields===========================================</span></span><br><span class="line">    <span class="comment">/** 开始时间截 (2015-01-01) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> twepoch = <span class="number">1420041600000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 机器id所占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据标识id所占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterIdBits = <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 支持的最大数据标识id，结果是31 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxDatacenterId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 序列在id中占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 机器ID向左移12位 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdShift = sequenceBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据标识id向左移17位(12+5) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 时间截向左移22位(5+5+12) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 工作机器ID(0~31) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据中心ID(0~31) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> datacenterId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 毫秒内序列(0~4095) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 上次生成ID的时间截 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==============================Constructors=====================================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workerId 工作ID (0~31)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> datacenterId 数据中心ID (0~31)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnowflakeIdWorker</span><span class="params">(<span class="keyword">long</span> workerId, <span class="keyword">long</span> datacenterId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"worker Id can't be greater than %d or less than 0"</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"datacenter Id can't be greater than %d or less than 0"</span>, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.workerId = workerId;</span><br><span class="line">        <span class="keyword">this</span>.datacenterId = datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==============================Methods==========================================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得下一个ID (该方法是线程安全的)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SnowflakeId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    String.format(<span class="string">"Clock moved backwards.  Refusing to generate id for %d milliseconds"</span>, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是同一时间生成的，则进行毫秒内序列</span></span><br><span class="line">        <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="comment">//毫秒内序列溢出</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//阻塞到下一个毫秒,获得新的时间戳</span></span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//时间戳改变，毫秒内序列重置</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上次生成ID的时间截</span></span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移位并通过或运算拼到一起组成64位的ID</span></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) <span class="comment">//</span></span><br><span class="line">                | (datacenterId &lt;&lt; datacenterIdShift) <span class="comment">//</span></span><br><span class="line">                | (workerId &lt;&lt; workerIdShift) <span class="comment">//</span></span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞到下一个毫秒，直到获得新的时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastTimestamp 上次生成ID的时间截</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">tilNextMillis</span><span class="params">(<span class="keyword">long</span> lastTimestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回以毫秒为单位的当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间(毫秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">timeGen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==============================Test=============================================</span></span><br><span class="line">    <span class="comment">/** 测试 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SnowflakeIdWorker idWorker = <span class="keyword">new</span> SnowflakeIdWorker(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> id = idWorker.nextId();</span><br><span class="line">            System.out.println(Long.toBinaryString(id));</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>ID生成</tag>
      </tags>
  </entry>
  <entry>
    <title>软件设计原则</title>
    <url>/2018/07/06/java/java_3/</url>
    <content><![CDATA[<h3 id="一些软件设计的原则"><a href="#一些软件设计的原则" class="headerlink" title="一些软件设计的原则"></a>一些软件设计的原则</h3><pre><code>软件设计的原则不单单只是软件开发，可能推广到其他生产活动中。甚至我们生活中遇到问题的思考。
</code></pre><h4 id="Don’t-Repeat-Yourself-DRY"><a href="#Don’t-Repeat-Yourself-DRY" class="headerlink" title="Don’t Repeat Yourself(DRY)"></a>Don’t Repeat Yourself(DRY)</h4><pre><code>DRY是最简单法则。它关注的是我们在两个地方发现一些相似代码后。我们需要把他们共性抽离出来，形成一个唯一的方法。并改变现有地方的代码，以适合的参数调用新的方法。
</code></pre><h4 id="Keep-It-Simple-Stupid"><a href="#Keep-It-Simple-Stupid" class="headerlink" title="Keep It Simple,Stupid"></a>Keep It Simple,Stupid</h4><pre><code>KISS原则在设计上是备受推崇的。在家装，界面，操作设计上。它的哲学是：把一个简单的事情搞复杂是一件简单的事情，但是把一个复杂的事情变简单，是件复杂的事情。
</code></pre><h4 id="面向接口变成，非面向实现编程"><a href="#面向接口变成，非面向实现编程" class="headerlink" title="面向接口变成，非面向实现编程"></a>面向接口变成，非面向实现编程</h4><pre><code>注重接口而不是实现，依赖接口而不是实现。这是由于接口的抽象是稳定的，实现则是多样化的。稳定的事物在操作起来更有安全感。
</code></pre><h4 id="你可能不真正需要它原则"><a href="#你可能不真正需要它原则" class="headerlink" title="你可能不真正需要它原则"></a>你可能不真正需要它原则</h4><pre><code>只考虑设计必须的功能，避免过度设计。实现目前需要的功能，在以后考虑需要更多功能时候，再进行添加。
如无必要，无增加复杂性。软件开发是一场沟通博弈。
</code></pre><h4 id="迪米特法则（Law-of-Demeter"><a href="#迪米特法则（Law-of-Demeter" class="headerlink" title="迪米特法则（Law of Demeter)"></a>迪米特法则（Law of Demeter)</h4><pre><code>迪米特法则又称之为 &quot;最少知识原则&quot; 它来源于1987年荷兰大学的一个Demeter项目。又被称作&quot;不要和陌生人说话&quot;

如果你想让你的狗跑的话 ，你会对狗狗说还是要对四条腿说？
如果你去买东西，你是把钱缴费电源，还是把钱包交给店员让他自己拿？

简言之，在对象调用对象的时候只出现一个&quot;.&quot; dog.run() 而非 dog.getFouLeg().move()
</code></pre><h4 id="面向对象的S-O-L-I-D法则"><a href="#面向对象的S-O-L-I-D法则" class="headerlink" title="面向对象的S O L I D法则"></a>面向对象的S O L I D法则</h4><pre><code>一般来说这是面向对象的五大设计原则。但是，我们可以把这些原则用于所有的软件开发。
</code></pre><h5 id="Simple-Responsiblility-Principle-SRP-职责单一原则"><a href="#Simple-Responsiblility-Principle-SRP-职责单一原则" class="headerlink" title="Simple Responsiblility Principle(SRP) - 职责单一原则"></a>Simple Responsiblility Principle(SRP) - 职责单一原则</h5><pre><code>其核心思想是：一个类，只做一件事。并把事做好。它只有一个引起它变化的原因。它可以看做是低耦合高内聚的在面向对象上的引申，将职责定义为引发
变化的原因，提高内聚性来减少引起变化的外因。职责过多，引起变化的原因就变多。一般情况下设计成引起变化的因素只有一类就好。职责与职责之间不
产生依赖。从而降低了耦合度。

正向例子：Unix/Linux
反向例子：Windows
</code></pre><h4 id="Open-Closed-Principle（OCP-开闭原则"><a href="#Open-Closed-Principle（OCP-开闭原则" class="headerlink" title="Open/Closed Principle（OCP)-开闭原则"></a>Open/Closed Principle（OCP)-开闭原则</h4><pre><code>核心思想是：模块是可以扩展的，不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。

对扩展开放：意味着有新的需求或者变化时，可以对现有代码进行扩展。以适应新的业务需求。
对修改封闭：意味着一旦设计完成，就可以独立完成其工作。而不要对类进行任何修改。
</code></pre><h4 id="Likov-substitution-principle-LSP-里氏代换原则"><a href="#Likov-substitution-principle-LSP-里氏代换原则" class="headerlink" title="Likov substitution principle(LSP) - 里氏代换原则"></a>Likov substitution principle(LSP) - 里氏代换原则</h4><pre><code>子类必须能够被替换成他们的基类。
既：子类在任何地方时候都可以被他们的基类替换，代码还能正常工作。不应该在代码里进行if/else对子类的类型进行判断的条件。
LSP是开闭原则的一个重要保证。它也是我们进行类设计的重要思考条件。就像&quot;蜗牛不是牛&quot;，&quot;鲸鱼是鱼&quot;其判断条件方式就是里氏族代换原则来的。
</code></pre><h4 id="Interface-Segregation-Principle-ISP-接口隔离原则"><a href="#Interface-Segregation-Principle-ISP-接口隔离原则" class="headerlink" title="Interface Segregation Principle(ISP) - 接口隔离原则"></a>Interface Segregation Principle(ISP) - 接口隔离原则</h4><pre><code>接口隔离是把功能实现在接口中，而不是类中，使用多个专门的接口比使用单一的总接口要好。
例子：电脑有很多使用方式。比如：看电影，聊天，看电影，上网，变成等等。如果把这些都申明在电脑的抽象类里。那么我们的上网本，PC机，服务器
这些都要实现所有的这些接口。就太复杂了。所以，我们把这些功能都隔离开，比如：看电影接口，聊天接口，上网接口。这样不同功能的电脑就可以有
选择地进行继承实现这些接口。

这个原则让我们可以使用&quot;搭积木&quot;的方式进行软件开发。 Java中的Event listener 和Adapter就是用这种原则实现的。
</code></pre><h4 id="Dependency-Inversion-Priciple-DIP-依赖倒置原则"><a href="#Dependency-Inversion-Priciple-DIP-依赖倒置原则" class="headerlink" title="Dependency Inversion Priciple(DIP) - 依赖倒置原则"></a>Dependency Inversion Priciple(DIP) - 依赖倒置原则</h4><pre><code>高层不应该依赖低层的实现。而是依赖于高层抽象。
墙面的开关不应该依赖于点灯的开关实现，而是依赖于一个抽象开关标准接口。当我们扩展程序时候，我们的开关同样可以控制其他不同的等，甚至不同的
电器。也就是说点灯和其他电器集成并实现我们的标准开关接口，我们的开关产商可以不需要关于要控制什么样的设备，只需要关心哪个标准开关就行。这
就是依赖倒置原则。
</code></pre><h4 id="Common-Closure-Principle-CCP-共同封闭原则"><a href="#Common-Closure-Principle-CCP-共同封闭原则" class="headerlink" title="Common Closure Principle(CCP) - 共同封闭原则"></a>Common Closure Principle(CCP) - 共同封闭原则</h4><pre><code>一个包中所有的类应该对同一种类型的变化关闭。一个变化影响一个包。便影响了包中的所有类。一个简单的说法是:一起修改的类，应该组合在一起（同个包里）
如果有需要改代码，我们希望所有的修改发生在意个包里，而不是分布在很多包里CCP实际上是对包的只能的相似进行聚合。对包的分配有指导作用。
</code></pre>]]></content>
      <categories>
        <category>java</category>
        <category>设计</category>
      </categories>
      <tags>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>linux expect ssh自动登录详解</title>
    <url>/2017/09/14/linux/linux%20expect%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Expect是用于自动化交互式应用程序的工具，如telnet，ftp，passwd，fsck，rlogin，tip等。使用起来很简单。</p>
</blockquote>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol>
<li>首行加上/usr/bin/expect</li>
<li>spawn: 后面加上需要执行的shell 命令，比如说spawn sudo touch testfile</li>
<li>expect: 只有spawn 执行的命令结果才会被expect 捕捉到，因为spawn 会启<br>动一个进程，只有这个进程的相关信息才会被捕捉到，主要包括：标准输入的提<br>示信息，eof 和timeout。</li>
<li>send 和send_user：send 会将expect 脚本中需要的信息发送给spawn 启动<br>的那个进程，而send_user 只是回显用户发出的信息，类似于shell 中的echo 而<br>已。</li>
</ol>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>1:远程拷贝文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set timeout 10</span><br><span class="line">set host [lindex $argv 0]</span><br><span class="line">set username [lindex $argv 1]</span><br><span class="line">set password [lindex $argv 2]</span><br><span class="line">set src_file [lindex $argv 3]</span><br><span class="line">set dest_file [lindex $argv 4]</span><br><span class="line">spawn scp  $src_file $username@$host:$dest_file</span><br><span class="line">   expect &#123;</span><br><span class="line">           &quot;(yes/no)?&quot;</span><br><span class="line">            &#123;</span><br><span class="line">                send &quot;yes\n&quot;</span><br><span class="line">                expect &quot;*assword:&quot; &#123; send &quot;$password\n&quot;&#125;</span><br><span class="line">             &#125;</span><br><span class="line">           &quot;*assword:&quot;</span><br><span class="line">             &#123;</span><br><span class="line">                 send &quot;$password\n&quot;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   expect &quot;100%&quot;</span><br><span class="line">   expect eof</span><br></pre></td></tr></table></figure></p>
<p>2:执行远程命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set timeout 10</span><br><span class="line">set host [lindex $argv 0]</span><br><span class="line">set username [lindex $argv 1]</span><br><span class="line">set password [lindex $argv 2]</span><br><span class="line">set cmd [lindex $argv 3]</span><br><span class="line"></span><br><span class="line">spawn ssh -t -p $port $username@$host &apos;cmd&apos;  </span><br><span class="line">   expect &#123;</span><br><span class="line">       &quot;(yes/no)?&quot;</span><br><span class="line">            &#123;</span><br><span class="line">                send &quot;yes\n&quot;</span><br><span class="line">                expect &quot;*assword:&quot; &#123; send &quot;$password\n&quot;&#125;</span><br><span class="line">             &#125;</span><br><span class="line">           &quot;*assword:&quot;</span><br><span class="line">             &#123;</span><br><span class="line">                 send &quot;$password\n&quot;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   expect &quot;100%&quot;</span><br><span class="line">   expect eof</span><br></pre></td></tr></table></figure></p>
<p>3：与SSH合用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/bin/expect &lt;&lt;-EOF</span><br><span class="line">//TODO这里写expect脚本 </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器性能评估</title>
    <url>/2017/11/21/linux/linux_2/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>Web服务在部署到Linux系统运行期间，可能会遇到各种问题。程序上的BUG，数据上的问题，这些排查起来较为简单。当排除这些问题后，往往需要深入到服务器<br>层面来寻找影响程序运行的稳定因素。</p>
</blockquote>
<h3 id="基本信息查看"><a href="#基本信息查看" class="headerlink" title="基本信息查看"></a>基本信息查看</h3><h4 id="CPU信息查看"><a href="#CPU信息查看" class="headerlink" title="CPU信息查看"></a>CPU信息查看</h4><ol>
<li><p>查看CPU个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq | wc -l</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看CPU中core个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;cpu cores&quot; | wc -l</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看CPU逻辑个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;processor&quot; | wc -l</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>逻辑CPU数 = 物理CPU个数*核心数</p>
<h4 id="内存信息查看"><a href="#内存信息查看" class="headerlink" title="内存信息查看"></a>内存信息查看</h4><ol>
<li>内存使用情况<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#free -m</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:         64376      37881      26494          0        308      17273</span><br><span class="line">-/+ buffers/cache:      20299      44076</span><br><span class="line">Swap:        16383          0      16383</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>total: 总内存数</li>
<li>used: 已用内存数</li>
<li>free: 空闲内存  </li>
<li>shared: 多进程共享的内存总数  </li>
<li>- buffers/cache: 已用缓存总数 used-buffer-cached  </li>
<li>+ buffers/cache: 可用缓存数 free+buffer+cached  </li>
<li>Buffer Cache 用于针对磁盘块的写  </li>
<li>Page Cache用于针对文件inode的读写，这些cache能够缩短I/O时间  </li>
<li>free / used是系统可用/暂用的内存   </li>
</ul>
<p>对于程序来说 -/+ buffers/cache是可用/占用内存，因为 buffers/cache很容易就会被使用到</p>
<h4 id="硬盘查看"><a href="#硬盘查看" class="headerlink" title="硬盘查看"></a>硬盘查看</h4><ol>
<li><p>查看硬盘分区信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看文件系统磁盘暂用情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看硬盘的I/O性能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iostat -d -k 1</span><br><span class="line"></span><br><span class="line">Linux 2.6.32-358.el6.x86_64 (fzck-10-59-107-216.h.173ops.com) 	2017年11月21日 	_x86_64_	(32 CPU)</span><br><span class="line"></span><br><span class="line">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class="line">sda              13.35        31.70       161.99 2867672698 14655271354</span><br><span class="line">sdb               0.86        17.77        29.61 1607620286 2679034433</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>参数解释：</p>
<ul>
<li>tps：该设备每秒的传输次数（Indicate the number of transfers per second that were issued to the device.）。”一次传输”意思是”一次I/O请求”。多个逻辑请求可能会被合并为”一次I/O请求”。”一次传输”请求的大小是未知的。</li>
<li>kB_read/s：每秒从设备（drive expressed）读取的数据量；</li>
<li>kB_wrtn/s：每秒向设备（drive expressed）写入的数据量；</li>
<li>kB_read：读取的总数据量；</li>
<li>kB_wrtn：写入的总数量数据量；这些单位都为Kilobytes。</li>
</ul>
<p>指定监控的设备名称为sda，该命令的输出结果和上面命令完全相同。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iostat -d sda 2</span><br></pre></td></tr></table></figure></p>
<p>默认监控所有的硬盘设备，现在指定只监控sda。 </p>
<h5 id="x-参数"><a href="#x-参数" class="headerlink" title="-x 参数"></a>-x 参数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iostat -d -x -k 1 10</span><br><span class="line"></span><br><span class="line">Linux 2.6.32-358.el6.x86_64 (fzck-10-59-107-216.h.173ops.com) 	2017年11月21日 	_x86_64_	(32 CPU)</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.01    28.67    1.47   11.89    31.70   161.99    29.01     0.01    0.57    2.76    0.30   0.16   0.21</span><br><span class="line">sdb               0.00     0.00    0.47    0.39    17.77    29.61   109.69     0.00    1.61    0.55    2.87   0.38   0.03</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line">sdb               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line">sdb               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br></pre></td></tr></table></figure>
<ul>
<li>rrqm/s：每秒这个设备相关的读取请求有多少被Merge了（当系统调用需要读取数据的时候，VFS将请求发到各个FS，如果FS发现不同的读取请求读取的是相同Block的数据，FS会将这个请求合并Merge）；</li>
<li>wrqm/s：每秒这个设备相关的写入请求有多少被Merge了.  </li>
<li>rsec/s：每秒读取的扇区数.  </li>
<li>wsec/：每秒写入的扇区数。 </li>
<li>rKB/s：The number of read requests that were issued to the device per second；  </li>
<li>wKB/s：The number of write requests that were issued to the device per second；  </li>
<li>avgrq-sz 平均请求扇区的大小  </li>
<li>avgqu-sz 是平均请求队列的长度。毫无疑问，队列长度越短越好。     </li>
<li>await：  每一个IO请求的处理的平均时间（单位是微秒毫秒）。这里可以理解为IO的响应时间，一般地系统IO响应时间应该低于5ms，如果大于10ms就比较大了。  <pre><code>这个时间包括了队列时间和服务时间，也就是说，一般情况下，await大于svctm，它们的差值越小，则说明队列时间越短，反之差值越大，队列时间越长，说明系统出了问题。  
</code></pre></li>
<li>svctm    表示平均每次设备I/O操作的服务时间（以毫秒为单位）。如果svctm的值与await很接近，表示几乎没有I/O等待，磁盘性能很好，如果await的值远高于svctm的值，则表示I/O队列等待太长，         系统上运行的应用程序将变慢。<br>%util： 在统计时间内所有处理IO时间，除以总共统计时间。例如，如果统计间隔1秒，该设备有0.8秒在处理IO，而0.2秒闲置，那么该设备的%util = 0.8/1 = 80%，所以该参数暗示了设备的繁忙程度<br>。一般地，如果该参数是100%表示设备已经接近满负荷运行了（当然如果是多磁盘，即使%util是100%，因为磁盘的并发能力，所以磁盘使用未必就到了瓶颈）。</li>
</ul>
<h3 id="内存性能指标"><a href="#内存性能指标" class="headerlink" title="内存性能指标"></a>内存性能指标</h3><h3 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h3><h3 id="网络IO指标"><a href="#网络IO指标" class="headerlink" title="网络IO指标"></a>网络IO指标</h3><h4 id="系统评估指标"><a href="#系统评估指标" class="headerlink" title="系统评估指标"></a>系统评估指标</h4><table>
<thead>
<tr>
<th>性能因素</th>
<th>好</th>
<th>坏</th>
<th>糟糕  </th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU</td>
<td>user% + sys% &lt; 70%</td>
<td>user% + sys% =85%</td>
<td>user% + sys% &gt;= 90%</td>
</tr>
<tr>
<td>内存</td>
<td>Swap In(si) = 0 Swap Out(so) = 0</td>
<td>Per CPU with 10 pages/s</td>
<td>More Swap In &amp; Swap Out</td>
</tr>
<tr>
<td>磁盘</td>
<td>iowait%&lt; 20%</td>
<td>iowat%=35%</td>
<td>iowat% &gt;= 50%</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux自动删除N天日志</title>
    <url>/2017/11/20/linux/linux_1/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>web在部署到linux环境后，一般都是把日志等级设置加高。只输出Error信息或者直接关闭Log。但是某些系统需要搜集容器的access日志来做数据分析。<br>如果本地存储的话，日子久了，日志就越来越大。占用大量磁盘资源，直接影响到系统的正常运行。所以，这种情况下，对日志做定期清理，是成本最低的方法了。</p>
</blockquote>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="删除文件脚本"><a href="#删除文件脚本" class="headerlink" title="删除文件脚本"></a>删除文件脚本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find 对应目录 -mtime +天数 -name &quot;文件名&quot; -exec rm -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p>例如:删除3天前 /opt/logs下 search开头的日志。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find /opt/logs/ -mtime +3 -name &quot;search*.log&quot; exec rm -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure></p>
<p>说明：<br>find：linux的查找命令，用户查找指定条件的文件<br>/opt/logs/：想要进行清理的任意目录；<br>-mtime：标准语句写法；<br>+3：查找30天前的文件，这里用数字代表天数；<br>“search*.log”：支持范式匹配<br>-exec：执行<br>rm -rf：强制删除命令<br>{} \; ：固定写法，一对大括号+空格++; </p>
<h4 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h4><p>将以上命令放置到可执行shell脚本中再通过cron调度执行。<br>创建shell:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch ~/bin/auto-del-30-days-ago-log.sh</span><br><span class="line">chmod +x auto-del-30-days-ago-log.sh</span><br></pre></td></tr></table></figure></p>
<p>编辑shell脚本<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim auto-del-3-days-ago-log.sh</span><br></pre></td></tr></table></figure></p>
<p>内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">find /opt/logs/ -mtime +3 -name &quot;search*.log&quot; exec rm -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure></p>
<p>添加计划调度：<br>执行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 0 * * * ~/auto-del-3-days-ago-log.sh &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure></p>
<p>设置是每天凌晨0点10分执行auto-del-3-days-ago-log.sh文件进行数据清理任务了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>THE END.</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>系统维护</tag>
      </tags>
  </entry>
  <entry>
    <title>linux免密码登录</title>
    <url>/2018/01/17/linux/linux_3/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有两台机器 A,B。现在要实现A访问B免密码登录。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="生成秘钥"><a href="#生成秘钥" class="headerlink" title="生成秘钥"></a>生成秘钥</h4><p>在A主机上执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -f rsa_for_174</span><br><span class="line"></span><br><span class="line">回车</span><br><span class="line">回车</span><br><span class="line">回车</span><br></pre></td></tr></table></figure></p>
<ul>
<li>-t 类型</li>
<li>-f 指定生成秘钥文件名</li>
</ul>
<h4 id="追加认证"><a href="#追加认证" class="headerlink" title="追加认证"></a>追加认证</h4><ul>
<li>将生成的秘钥拷贝到B主机，可以手动ftp，也可以用命令。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -i ~/.ssh/CY6034_rsa_4096 ./rsa_for_174.pub root@10.5.121.144:~/.ssh/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -i CY6034_rsa_4096 root@10.5.121.144</span><br></pre></td></tr></table></figure>
<p>追加<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/rsa_for_174 &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></p>
<p>DONE</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux手动修改/etc/shadow和/etc/passwd中的用户密码</title>
    <url>/2018/07/02/linux/linux_4/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在玩GameShell这小玩意儿，发现没有root权限。于是想办法获取到。发现官方有提供img镜像下载。</p>
<h3 id="img操作"><a href="#img操作" class="headerlink" title="img操作"></a>img操作</h3><p>1：查看img信息:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ 17:15:11-root@hadoop214:img ]<span class="comment">#fdisk -lu clockworkos_v0.1.img</span></span><br><span class="line"></span><br><span class="line">Disk clockworkos_v0.1.img: 7948 MB, 7948206080 bytes, 15523840 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x9d1726e4</span><br><span class="line"></span><br><span class="line">               Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">clockworkos_v0.1.img1            8192       93814       42811+   c  W95 FAT32 (LBA)</span><br><span class="line">clockworkos_v0.1.img2           94208    15523839     7714816   83  Linux</span><br></pre></td></tr></table></figure></p>
<p>可以看到linxu文件从 94208 开始 扇区大小512k<br>所以<br>94208*512=48234496<br>2：挂载img<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -o loop,offset=48234496 clockworkos_v0.1.img /home/gameshell/img/clockpi</span><br></pre></td></tr></table></figure></p>
<h3 id="密码修改"><a href="#密码修改" class="headerlink" title="密码修改"></a>密码修改</h3><p>1.手动修改/etc/shadow中的用户密码<br>/etc/shadow文件说明：</p>
<ul>
<li>第一字段：用户名（也被称为登录名），在/etc/shadow中，用户名和/etc/passwd 是相同的，这样就把passwd 和shadow中用的用户记录联系在一起；这个字段是非空的；</li>
<li>第二字段：密码（已被加密），这个字段是非空的；</li>
<li>第三字段：上次修改口令的时间；这个时间是从1970年01月01日算起到最近一次修改口令的时间间隔（天数），您可以通过passwd 来修改用户的密码，然后查看/etc/shadow中此字段的变化；</li>
<li>第四字段：两次修改口令间隔最少的天数；如果这个字段的值为空，帐号永久可用；</li>
<li>第五字段：两次修改口令间隔最多的天数；如果这个字段的值为空，帐号永久可用；</li>
<li>第六字段：提前多少天警告用户口令将过期；如果这个字段的值为空，帐号永久可用；</li>
<li>第七字段：在口令过期之后多少天禁用此用户；如果这个字段的值为空，帐号永久可用；</li>
<li>第八字段：用户过期日期；此字段指定了用户作废的天数（从1970年的1月1日开始的天数），如果这个字段的值为空，帐号永久可用；</li>
<li>第九字段：保留字段，目前为空，以备将来发展之用；</li>
</ul>
<p>/etc/shadow中格式如下</p>
<p>#testaccount:$1$acQMceF9$1SaCpG2qiKKA3eGolU4Fp0:13402:0:99999:7:::<br>彩色段为加密后的密码，$1$表示采用的是md5加密，绿色段是简单的字符串，蓝色段为加密后的密码</p>
<p>只要删除 $1$acQMceF9$1SaCpG2qiKKA3eGolU4Fp0 它后，就删除了密码</p>
<p>2.linux忘记登陆密码修改/etc/passwd也可以</p>
<p>很简单的一个技巧，给大家介绍一下<br>在这个界面 按任意键<br>按 e键(编辑命令之前启动)<br>选择第二项 在按e键(修改选定的命令在启动)<br>输入single (注意空格)进入单用户模式<br>选择b 启动<br>输入 vi /etc/passwd<br>root:x:0:0:root:/root:/bin/bash<br>光标移至x下面按delete 键 删除它<br>输入：x！<br>输入reboot重启<br>重启后你会发现 没让你输密码，破译成功</p>
<p>原理解释：<br>在 /etc/passwd 的文件里 保存着用户的信息文件 root:x:0:0:Administrator:/root:/bin/bash</p>
<p>在这一句中</p>
<p>root就是用户名，</p>
<p>x是密码标志，只是说明密码的存放位置，具体呢是放在/etc/passwd的 至于密码别想了 全 是密文保存，看不懂的</p>
<p>0 用户id号</p>
<p>0 组id号</p>
<p>administrator估计是我在装系统的时候，原来的名字没改（虚拟机默认用户名），是用户说 明的意思，</p>
<p>root 用户的家目录</p>
<p>/bin/bash 记录着用户登陆后所拥有的权限，即所拥有的shell</p>
<p>那么我们把密码标示删掉之后，自然就不会有问你密码的对话框了</p>
<p>当然</p>
<p>GRUB这个引导装载程序是可以设密码的</p>
<p>不过 设密码 我们可以光启 ，用安装光盘进入安全模式，在把密码清除</p>
<p>光启 是可以设BIOS密码的，</p>
<p>BIOS 密码是可以拆机箱 扣电池的</p>
<p>那这么说来 传说中的linux岂不是很不安全，通常所说的安全是基于网络的 ，意思是连接互联网后，对方通过网络途径入侵你的linux计算机是很困难的，这种破译的方法只是以防万一，在万一你忘记密码的时候使用的，至于物理安全，那就看你怎么保护了.</p>
<p>本文转载于：<a href="http://blog.chinaunix.net/uid-15797451-id-3041560.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-15797451-id-3041560.html</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>【rabbitMq学习1】MQ的基本概念</title>
    <url>/2022/07/11/mq/rabbitmq_core_1/</url>
    <content><![CDATA[<p>##MQ的基本概念</p>
<p>MQ全称 Message Queue(消息队列)，是在消息的传输过程中保存消息的容器。多用于分布式系统之间进行通信。</p>
]]></content>
      <categories>
        <category>mq</category>
      </categories>
      <tags>
        <tag>rabbitMq</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql缓存与Memcached,Redis区别</title>
    <url>/2017/09/18/mysql/Mysql_1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>我们在做Web开发的时候从至上而下的技术分层里，缓存始终贯穿其中。浏览器层–》业务层–》数据库层。每个层面上的缓存都有各自的功能与场景。我们今天探讨下业务层到数据库层上缓存的功能和区别。</p>
</blockquote>
<h2 id="业务层缓存"><a href="#业务层缓存" class="headerlink" title="业务层缓存"></a>业务层缓存</h2><h3 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h3><p>Memcached 严格上讲还不能说是完整的分布式缓存系统。它有很多第三方工具支撑其分布式功能。<br>Memcached 通过内部固定的大小的chunk预申请内存数据。使得分配和回收内存的效率很高。读写性能也很高。64k对象的情况下，单机QPS可以达到15W以上。<br>Memcached 的集群架构中，单个节点对其他节点是相互独立的，没有数据方面的通信。不具备failover能力。<br>Memcached 支持多语言，有相当的稳定性。</p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>Redis 显著的特点是不仅支持普通的K，V 类型存储，还支持其独特的 五种数据结构 详见<a href="http://www.lilhui.com/2017/0918/redis/Redis数据结构">Redis数据结构</a><br>Redis 也支持集群，Redis支持的集群是Master-Slave模式。其有点是可以在宕机时切换到备份机。可用性方面有一定的提升。<br>Redis 单纯当做缓存存储在内存时速度和Memcached不相上下。存储到硬盘时，性能和速度会下降很多，介于 Memcahced 和mysql之间。<br>Redis 有特殊的订阅功能，使得它经常被用于当做内存队列使用。<br>Redis 扩展方面不如Memcached，无法做到持续的线性扩容。目前支持通过复制的方式，产生一主多备架构并升级容量。</p>
<h2 id="数据库层缓存"><a href="#数据库层缓存" class="headerlink" title="数据库层缓存"></a>数据库层缓存</h2><h3 id="mysql缓存"><a href="#mysql缓存" class="headerlink" title="mysql缓存"></a>mysql缓存</h3><p>MySQL将缓存分为Buffer缓存和Cache缓存。<br>Buffer缓存:<br>由于硬盘的写入速度过慢，或者频繁的I/O，对于硬盘来说是极大的效率浪费。那么可以等到缓存中储存一定量的数据之后，一次性的写入到硬盘中。Buffer 缓存主要用于写数据，提升I/O性能。<br>Cache 缓存:<br>Cache 是在开启缓存功能前提下，在通过的每次sql进行hash计算，生成此条sql的唯一hash作为存储的Key值。SO select是区分大小写的。<br>生成缓存之后，如果涉及的table有任何数据的变动（整个talbe),所有的cache就会被删除。如果Cache缓存已经存储满，则启用LRU算法，进行数据淘汰。淘汰掉最远未使用的数据，从而开辟新的存储空间。<br>不过对于特大型的网站，依靠这种策略很难缓解高频率的读请求，一般会把访问非常频繁的数据静态化，直接由nginx返还给用户。<br>程序和数据库I/O设备交互的越少，则效率越高。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="既然有Memcached-Redis-为什么还要用Mysql缓存呢？"><a href="#既然有Memcached-Redis-为什么还要用Mysql缓存呢？" class="headerlink" title="既然有Memcached,Redis 为什么还要用Mysql缓存呢？"></a>既然有Memcached,Redis 为什么还要用Mysql缓存呢？</h3><ul>
<li>解答</li>
</ul>
<p>从整体架构上看，Memcached和Redis支持扩展分布式缓存。适用于大型Web项目。<br>单从单节点功能上看，Mysql由于自身的cache 删除方式。使得其缓存有相对的局限性。并且无法简单的管控。需要更好的使用的话，需要对业务上进行更详尽细致的分析。<br>在数据库的逻辑设计层面细分出能够说回合mysql缓存的场景。<br>单节点，数据简单，无太多修改的数据面前，但根据场景来，mysql缓存还是有一定价值的。比Memcached Redis简单易用，效率更好。</p>
<p>参考：<br><a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/query-cache.html</a></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Communications link failure 问题解决</title>
    <url>/2019/11/01/mysql/Mysql_2/</url>
    <content><![CDATA[<h2 id="症状"><a href="#症状" class="headerlink" title="症状"></a>症状</h2><blockquote>
<p>节点挂机一个晚上后会首次请求会 Communications link failure</p>
</blockquote>
<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>产生 Communications link failure是由于使用了被关闭的数据库连接导致。</p>
<h2 id="关键配置分析"><a href="#关键配置分析" class="headerlink" title="关键配置分析"></a>关键配置分析</h2><p>maxEvictableIdleTimeMillis配置，默认25200000毫秒 deruid连接最大存活时间。</p>
<p>minEvictableIdleTimeMillis 300 秒 druid连接最小存活时间</p>
<p>mysql wait_close 时间 8小时</p>
<p>httpProxy连数据库的 代理 超时时间 1000秒</p>
<p>testWhileidle  空闲时间检测配置300秒。300秒检测一次，如果连接年龄大于300秒，则回收。</p>
<p>minIdle  配置为1  连接池最小少保留一个连接。</p>
<h3 id="几种连接会被关闭的情况："><a href="#几种连接会被关闭的情况：" class="headerlink" title="几种连接会被关闭的情况："></a>几种连接会被关闭的情况：</h3><p>1：当数据库连接超过8小时，会被mysql关闭。</p>
<p>2：当一次查询大量数据超过1000秒，会被httpProxy关闭。</p>
<p>3：连接存活时间大于300秒，并且是空闲的，会被testWhileidle关闭。druid关闭。</p>
<h2 id="综合分析："><a href="#综合分析：" class="headerlink" title="综合分析："></a>综合分析：</h2><p>基于以上三种关闭情况是不会产生 communications link failure的。但是由于minIdle配置的是1，在druid进行空闲连接清理的时候总有一个被保留，当这个连接超过了mysql_close的8小时后，会被mysql关闭。<br>此时如果有请求过来，就会使用这个连接，导致 Communications link failure。至此破案。</p>
<p>我们实际情况，就是隔夜后，第二天早上初次请求发生了这种状况。分析过后以上的情况后，建议使用druid的配置注意如下：  </p>
<ol>
<li>设置maxEvictableIdleTimeMillis（最大生存时间）也要小于数据库连接超时时间1000s</li>
<li>配置时，mysql的wait_timeout &gt;nginx的 proxy_connect_timeout &gt; druid的maxEvictableIdleTimeMillis.</li>
<li>优化慢查询，将支付平台可能的最长允许sql执行时间设置给proxy_timeout</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>缓存</tag>
        <tag>druid</tag>
      </tags>
  </entry>
  <entry>
    <title>linux dump现场工具</title>
    <url>/2019/07/17/linux/linux_6/</url>
    <content><![CDATA[<h2 id="linux-dump工具"><a href="#linux-dump工具" class="headerlink" title="linux dump工具"></a>linux dump工具</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### use demo ###</span></span><br><span class="line"><span class="comment"># 1)upload dump.sh</span></span><br><span class="line"><span class="comment"># 2)dos2unix dump.sh;chmod +x dump.sh</span></span><br><span class="line"><span class="comment"># 3)usage: </span></span><br><span class="line"><span class="comment">#   1. /data/sh/java/dump.sh /tmp/dump /usr/local/java/jdk1.8.0_05 23554</span></span><br><span class="line"><span class="comment">#   2. /data/sh/java/dump.sh /tmp/dump /usr/local/java/jdk1.8.0_05 23554 -F</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### parameter description ###</span></span><br><span class="line"><span class="comment"># 1 ./tmp/dump is save dump file dir. </span></span><br><span class="line"><span class="comment"># 2 /usr/local/java/jdk1.8.0_05 is java_home. </span></span><br><span class="line"><span class="comment"># 3 23554 is java-pid. </span></span><br><span class="line"><span class="comment"># 4 -F force jvm dum, optional.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">declare</span> SNAPSHOT_BASE_DIRECTORY=<span class="variable">$1</span></span><br><span class="line"><span class="built_in">declare</span> JAVA_HOME=<span class="variable">$2</span></span><br><span class="line"><span class="built_in">declare</span> PID=<span class="variable">$3</span></span><br><span class="line"><span class="built_in">declare</span> JVM_FORCE_OPTS=<span class="variable">$4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remove the last '/' char</span></span><br><span class="line">JAVA_HOME=<span class="variable">$&#123;JAVA_HOME/%\//&#125;</span></span><br><span class="line">SNAPSHOT_BASE_DIRECTORY=<span class="variable">$&#123;SNAPSHOT_BASE_DIRECTORY/%\//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">declare</span> FULL_TIME_FORMAT=<span class="string">"+%Y-%m-%d_%H_%M_%S_%N"</span></span><br><span class="line"><span class="built_in">declare</span> SHORT_TIME_FORMAT=<span class="string">"+%H-%M-%S-%N"</span></span><br><span class="line"><span class="built_in">declare</span> TIMESTAMP=`date <span class="string">""</span><span class="variable">$&#123;FULL_TIME_FORMAT&#125;</span><span class="string">""</span> `</span><br><span class="line"><span class="built_in">declare</span> RESULT_DIRECTORY=<span class="variable">$&#123;SNAPSHOT_BASE_DIRECTORY&#125;</span>/<span class="variable">$&#123;PID&#125;</span>/<span class="variable">$&#123;TIMESTAMP&#125;</span></span><br><span class="line"><span class="built_in">declare</span> RUN_LOG_PATH=<span class="string">"<span class="variable">$&#123;RESULT_DIRECTORY&#125;</span>/run.log"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">run_log</span></span>()&#123;</span><br><span class="line">    <span class="built_in">declare</span> log_msg=<span class="string">"<span class="variable">$(date ""$&#123;FULL_TIME_FORMAT&#125;"")</span>: <span class="variable">$1</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;log_msg&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;log_msg&#125;</span> &gt;&gt;<span class="variable">$&#123;RUN_LOG_PATH&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">is_no_null</span></span>()&#123;</span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="variable">$1</span> ];<span class="keyword">then</span></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	<span class="built_in">return</span> 1;</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">is_valid_number</span></span>()&#123;</span><br><span class="line">    is_no_null <span class="variable">$1</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$1</span> -gt 0 ] 2&gt;/dev/null ;<span class="keyword">then</span></span><br><span class="line">	<span class="built_in">return</span> 1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">echo_blank_line</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">valid_param</span></span>()&#123;</span><br><span class="line">    <span class="keyword">if</span> [ ! -d <span class="variable">$&#123;RESULT_DIRECTORY&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">	mkdir -p <span class="variable">$&#123;RESULT_DIRECTORY&#125;</span></span><br><span class="line">	run_log <span class="string">"tip: Create RESULT_DIRECTORY=<span class="variable">$&#123;RESULT_DIRECTORY&#125;</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    run_log <span class="string">"tip: RESULT_DIRECTORY=<span class="variable">$&#123;RESULT_DIRECTORY&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">    is_no_null <span class="variable">$&#123;SNAPSHOT_BASE_DIRECTORY&#125;</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line">	run_log <span class="string">"Param 1 SNAPSHOT_BASE_DIRECTORY is no exist and exit ,such as /tmp/dump"</span></span><br><span class="line">	<span class="built_in">exit</span> 1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	run_log <span class="string">"tip: SNAPSHOT_BASE_DIRECTORY=<span class="variable">$&#123;SNAPSHOT_BASE_DIRECTORY&#125;</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;JAVA_HOME&#125;</span>"</span> ];<span class="keyword">then</span></span><br><span class="line">	run_log <span class="string">"tip: JAVA HOME: <span class="variable">$&#123;JAVA_HOME&#125;</span>"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	run_log <span class="string">"Param2 JAVA_HOME is no exist and exit ,such as /usr/local/java/jdk1.8.0_05"</span></span><br><span class="line">	<span class="built_in">exit</span> 2;</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    is_valid_number <span class="variable">$&#123;PID&#125;</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line">	run_log <span class="string">"Param3 PID is invalid and exit"</span></span><br><span class="line">	<span class="built_in">exit</span> 3;</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line">valid_param</span><br><span class="line">run_log <span class="string">"RESULT_DIRECTORY=<span class="variable">$&#123;RESULT_DIRECTORY&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">machine_dump</span></span>()&#123;</span><br><span class="line">    <span class="built_in">declare</span> filename=<span class="variable">$1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">type</span> <span class="variable">$1</span> &gt;/dev/null 2&gt;&amp;1 &amp;&amp; &#123;</span><br><span class="line">	    run_log <span class="string">"Start <span class="variable">$1</span> <span class="variable">$2</span> dump"</span></span><br><span class="line">	    <span class="built_in">declare</span> timestamp=$(date <span class="string">""</span><span class="variable">$&#123;SHORT_TIME_FORMAT&#125;</span><span class="string">""</span>);</span><br><span class="line">	    run_log <span class="string">"Execute <span class="variable">$1</span> <span class="variable">$2</span> &gt;&gt; <span class="variable">$&#123;RESULT_DIRECTORY&#125;</span>/machine_<span class="variable">$&#123;filename&#125;</span>_<span class="variable">$&#123;timestamp&#125;</span>.dump"</span></span><br><span class="line">	    <span class="variable">$1</span> <span class="variable">$2</span> &gt;&gt; <span class="variable">$&#123;RESULT_DIRECTORY&#125;</span>/machine_<span class="variable">$&#123;filename&#125;</span>_<span class="variable">$&#123;timestamp&#125;</span>.dump</span><br><span class="line">	    run_log <span class="string">"End <span class="variable">$1</span> <span class="variable">$2</span> dump"</span></span><br><span class="line">	echo_blank_line</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">machine_dump_pipeline</span></span>()&#123;</span><br><span class="line">    <span class="built_in">declare</span> filename=<span class="variable">$1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">type</span> <span class="variable">$2</span> &gt;/dev/null 2&gt;&amp;1 &amp;&amp; &#123;</span><br><span class="line">	run_log <span class="string">"Start <span class="variable">$2</span> <span class="variable">$3</span> | <span class="variable">$4</span> dump"</span></span><br><span class="line">	<span class="built_in">declare</span> timestamp=$(date <span class="string">""</span><span class="variable">$&#123;SHORT_TIME_FORMAT&#125;</span><span class="string">""</span>);</span><br><span class="line">	run_log <span class="string">"Execute <span class="variable">$2</span> <span class="variable">$3</span> | <span class="variable">$4</span> &gt;&gt; <span class="variable">$&#123;RESULT_DIRECTORY&#125;</span>/machine_<span class="variable">$&#123;filename&#125;</span>_<span class="variable">$&#123;timestamp&#125;</span>.dump"</span></span><br><span class="line">	<span class="variable">$2</span> <span class="variable">$3</span> | <span class="variable">$4</span> &gt;&gt; <span class="variable">$&#123;RESULT_DIRECTORY&#125;</span>/machine_<span class="variable">$&#123;filename&#125;</span>_<span class="variable">$&#123;timestamp&#125;</span>.dump</span><br><span class="line">	    run_log <span class="string">"End <span class="variable">$2</span> <span class="variable">$3</span> | <span class="variable">$4</span> dump"</span></span><br><span class="line">	echo_blank_line</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 times interval 1s</span></span><br><span class="line"><span class="built_in">declare</span> machine_static_frequency=<span class="string">"1 3"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># machine real time statistics information</span></span><br><span class="line">echo_blank_line</span><br><span class="line">machine_dump_pipeline <span class="string">"top-50-process"</span> top <span class="string">"-b"</span> <span class="string">"head -n 50"</span> </span><br><span class="line">machine_dump free -glt</span><br><span class="line">machine_dump vmstat <span class="string">"-t <span class="variable">$&#123;machine_static_frequency&#125;</span>"</span></span><br><span class="line">machine_dump mpstat <span class="string">"-A <span class="variable">$&#123;machine_static_frequency&#125;</span>"</span></span><br><span class="line">machine_dump iostat <span class="string">"<span class="variable">$&#123;machine_static_frequency&#125;</span>"</span></span><br><span class="line">machine_dump iotop <span class="string">"-o -b -n 3"</span></span><br><span class="line">machine_dump netstat <span class="string">"-an"</span></span><br><span class="line">machine_dump lsof <span class="string">"-p <span class="variable">$&#123;PID&#125;</span>"</span></span><br><span class="line"><span class="comment"># machine history statistics information</span></span><br><span class="line">machine_dump sar -A</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">get_pid_user</span></span>()&#123;</span><br><span class="line">    user_tip=`ps u -p <span class="variable">$1</span> | tail -n 1 | awk <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line">    is_valid_number <span class="variable">$&#123;user_tip&#125;</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$&#123;user_tip&#125;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> `cat /etc/passwd |grep x:<span class="variable">$&#123;user_tip&#125;</span> | awk -F <span class="string">':'</span> <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PID_USER=`get_pid_user <span class="variable">$&#123;PID&#125;</span>`</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">jvm_dump</span></span>()&#123;</span><br><span class="line">    <span class="built_in">declare</span> filename;</span><br><span class="line">    <span class="keyword">if</span> [ ! -z <span class="variable">$3</span> ];<span class="keyword">then</span></span><br><span class="line">	filename=<span class="variable">$3</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	filename=<span class="variable">$1</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    run_log <span class="string">"Start <span class="variable">$1</span> <span class="variable">$2</span> dump"</span></span><br><span class="line">    <span class="built_in">declare</span> timestamp=$(date <span class="string">""</span><span class="variable">$&#123;SHORT_TIME_FORMAT&#125;</span><span class="string">""</span>);</span><br><span class="line">    run_log <span class="string">"su -l <span class="variable">$&#123;PID_USER&#125;</span> -s /bin/bash -c \"<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin/<span class="variable">$1</span> <span class="variable">$2</span> \" &gt;&gt;  <span class="variable">$&#123;RESULT_DIRECTORY&#125;</span>/jvm_<span class="variable">$&#123;filename&#125;</span>_<span class="variable">$&#123;timestamp&#125;</span>.dump"</span></span><br><span class="line">    su -l <span class="variable">$&#123;PID_USER&#125;</span> -s /bin/bash -c <span class="string">"<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin/<span class="variable">$1</span> <span class="variable">$2</span> "</span> &gt;&gt; <span class="variable">$&#123;RESULT_DIRECTORY&#125;</span>/jvm_<span class="variable">$&#123;filename&#125;</span>_<span class="variable">$&#123;timestamp&#125;</span>.dump</span><br><span class="line">    run_log <span class="string">"End <span class="variable">$1</span> <span class="variable">$2</span> dump"</span></span><br><span class="line">    echo_blank_line</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8 times interval 1s</span></span><br><span class="line"><span class="built_in">declare</span> jvm_static_frequency=<span class="string">"1000 8"</span></span><br><span class="line"><span class="comment"># jvm real time statistics information</span></span><br><span class="line">jvm_dump jinfo <span class="string">"<span class="variable">$&#123;PID&#125;</span>"</span></span><br><span class="line">jvm_dump jstat <span class="string">"-gcutil <span class="variable">$&#123;PID&#125;</span> <span class="variable">$&#123;jvm_static_frequency&#125;</span>"</span> <span class="string">"jstat-gcutil"</span></span><br><span class="line"></span><br><span class="line">machine_dump_pipeline <span class="string">"top-100-high-thread"</span> top <span class="string">"-H -b -n 1 -p  <span class="variable">$&#123;PID&#125;</span>"</span> <span class="string">"head -n 100"</span></span><br><span class="line">chown <span class="variable">$&#123;PID_USER&#125;</span>:<span class="variable">$&#123;PID_USER&#125;</span> <span class="variable">$&#123;RESULT_DIRECTORY&#125;</span></span><br><span class="line"><span class="comment"># topH have must together with jstack</span></span><br><span class="line">jvm_dump jstack <span class="string">"<span class="variable">$&#123;JVM_FORCE_OPTS&#125;</span> <span class="variable">$&#123;PID&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dump </span></span><br><span class="line"><span class="function"><span class="title">jvm_head_dump</span></span>()&#123;</span><br><span class="line">    run_log <span class="string">"Start jmap  <span class="variable">$1</span> dump"</span></span><br><span class="line">    <span class="built_in">declare</span> timestamp=$(date <span class="string">""</span><span class="variable">$&#123;SHORT_TIME_FORMAT&#125;</span><span class="string">""</span>);</span><br><span class="line">    run_log <span class="string">"su -l <span class="variable">$&#123;PID_USER&#125;</span> -s /bin/bash -c \"<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin/jmap <span class="variable">$&#123;JVM_FORCE_OPTS&#125;</span> -dump:format=b,file=<span class="variable">$&#123;RESULT_DIRECTORY&#125;</span>/jvm_jmap_<span class="variable">$&#123;timestamp&#125;</span>.hprof <span class="variable">$1</span>\""</span></span><br><span class="line">    <span class="comment">#su -l $&#123;PID_USER&#125; -s /bin/bash -c "$&#123;JAVA_HOME&#125;/bin/jmap $&#123;JVM_FORCE_OPTS&#125; -dump:format=b,file=$&#123;RESULT_DIRECTORY&#125;/jvm_jmap_$&#123;timestamp&#125;.hprof $1" </span></span><br><span class="line">    <span class="variable">$&#123;JAVA_HOME&#125;</span>/bin/jmap <span class="variable">$&#123;JVM_FORCE_OPTS&#125;</span> -dump:format=b,file=<span class="variable">$&#123;RESULT_DIRECTORY&#125;</span>/jvm_jmap_<span class="variable">$&#123;timestamp&#125;</span>.hprof <span class="variable">$1</span></span><br><span class="line">    run_log <span class="string">"End jmap <span class="variable">$1</span> dump"</span></span><br><span class="line">    echo_blank_line</span><br><span class="line">&#125;</span><br><span class="line">jvm_head_dump <span class="variable">$&#123;PID&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># statistics all kinds of tcp status</span></span><br><span class="line">cat <span class="variable">$&#123;RESULT_DIRECTORY&#125;</span>/machine_netstat*.dump | awk <span class="string">'/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;'</span> &gt; <span class="variable">$&#123;RESULT_DIRECTORY&#125;</span>/machine_netstat_status_statistics.dump</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>dump</tag>
      </tags>
  </entry>
  <entry>
    <title>awk基础</title>
    <url>/2019/06/05/linux/linux_5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>awk是由Alfred Aho, Peter Weinberger和 Brian Kernighan三人创造的，wak由三人的姓氏的首个字母组成<br>早期是在unix上实现的。在unix上的叫gawk既GNU awk</p>
</blockquote>
<h1 id="awk语法"><a href="#awk语法" class="headerlink" title="awk语法"></a>awk语法</h1><ul>
<li>awk命令形式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk [-F|-f|-v] <span class="string">'BEGIN&#123;&#125;//&#123;command1;command2&#125;END&#123;&#125;'</span> file</span><br></pre></td></tr></table></figure>
<ul>
<li>命令解释</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>[-F &#124; -f &#124; -v]</td>
<td>-F指定分隔符，f调用脚本，-v 定义变量， var=value</td>
</tr>
<tr>
<td>‘ ‘</td>
<td>引用代码块</td>
</tr>
<tr>
<td>BEGIN</td>
<td>初始代码块，在对每一行进行处理之前，初始化代码，主要是引用全局变量，设置FS分隔符</td>
</tr>
<tr>
<td>//</td>
<td>匹配代码块。可以是字符串或正则表达式</td>
</tr>
<tr>
<td>{}</td>
<td>命令代码块。包含一条或者多条命令，多条命令用分号分隔</td>
</tr>
<tr>
<td>END</td>
<td>结尾代码块。在对每一行进行处理之后再执行的代码块，主要是进行最终计算或输出结尾摘要信息</td>
</tr>
</tbody>
</table>
<ul>
<li>awk内置变量</li>
</ul>
<table>
<thead>
<tr>
<th>变量名</th>
<th>解释</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>FILENAME</td>
<td>awk浏览的文件名</td>
<td></td>
</tr>
<tr>
<td>FNR</td>
<td>与NR类似，多文件记录不递增，每个文件都从1开始</td>
<td></td>
</tr>
<tr>
<td>FS</td>
<td>设置输入字段分隔符，同-F选项</td>
<td></td>
</tr>
<tr>
<td>NF</td>
<td>浏览记录的字段个数</td>
<td>awk ‘{print NF}’ file  //显示每行有多少字段</td>
</tr>
<tr>
<td>$NF</td>
<td>最后一个字段的值</td>
<td>awk ‘{print $NF}’ file    //将每行第NF个字段的值打印出来</td>
</tr>
<tr>
<td>NR</td>
<td>已读的记录数，理解为行号，多文件行号递增</td>
<td>awk ‘NR==5{print}’  file    //显示第5行</td>
</tr>
<tr>
<td>OFS</td>
<td>输出数据时，每个字段间以OFS制定的字符作为分隔符</td>
<td>awk ‘{print $3,$5,$4}’ OFS=”\n” file</td>
</tr>
<tr>
<td>ORS</td>
<td>输出数据时，每行记录间以OFS制定的字符作为分羹</td>
<td>awk ‘{print $3,$5,$4}’ ORS=”\n” file</td>
</tr>
</tbody>
</table>
<h1 id="awk的大参数"><a href="#awk的大参数" class="headerlink" title="awk的大参数"></a>awk的大参数</h1><ul>
<li><p>参数模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk [-F|-f|-v] <span class="string">'BEGIN&#123;&#125; // &#123;command1; command2&#125; END&#123;&#125;'</span> file</span><br></pre></td></tr></table></figure>
</li>
<li><p>-F制定分隔符</p>
</li>
</ul>
<blockquote>
<p>可以不写，默认用空格。一个或多个连续的空格看做一个分隔符，也可以定义多个分隔符，<br>如果： -F[./]是指，同时以 “.”和”/“作为分隔符。</p>
</blockquote>
<ul>
<li>-f与 -v</li>
</ul>
<p>略</p>
<h1 id="awky的引用代码块"><a href="#awky的引用代码块" class="headerlink" title="awky的引用代码块"></a>awky的引用代码块</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk [-F|-f|-v] ‘BEGIN&#123;&#125; // &#123;command1; command2&#125; END&#123;&#125;’ file</span><br></pre></td></tr></table></figure>
<ul>
<li>操作符</li>
</ul>
<p>引用代码块是一个编程环境，支持条件运算，逻辑运算等。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>等于，精确比较</td>
<td>awk ‘$3==”48” {print $0}’ file    只打印第3个字段等于”48”的记录</td>
</tr>
<tr>
<td>!=</td>
<td>不等于，精确比较</td>
<td>awk ‘$1 != “abc”‘ file    //提取第一个字段不是abc的行</td>
</tr>
<tr>
<td>~</td>
<td>匹配，与==相比不是精确比较</td>
<td>awk ‘{if ($4~/abc/) print $0}’ file    //表示如果第四个字段包含abc，就打印整行</td>
</tr>
<tr>
<td>!~</td>
<td>不匹配，不精确比较</td>
<td>awk ‘$0 !~ /abc/‘ file      打印整条不包含abc的记录</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>和</td>
<td>awk ‘{if ( $1==”a” &amp;&amp; $2==”b” ) print $0}’ file    //如果第1、第2个字段值是a和b，打印整行</td>
</tr>
<tr>
<td>&#124;&#124;</td>
<td>或</td>
<td>awk ‘{if ($1==”a” &#124;&#124; $1==”b”) print $0}’ temp    //如果第1、第2个字段值是a或b，打印整行</td>
</tr>
<tr>
<td>></td>
<td>大于</td>
<td>awk ‘$1&gt;500 {print $2}’ file     //如果字段1的值大于500，则打印字段2</td>
</tr>
<tr>
<td>>=</td>
<td>大于等于</td>
<td>awk ‘$1&gt;=400 {print $2}’ file     //如果字段1的值大于等于400，则打印字段2</td>
</tr>
<tr>
<td>\&lt;</td>
<td>小于</td>
<td>awk ‘$1&lt;200 {print $2}’ file     //如果字段1的值小于200，则打印字段2</td>
</tr>
<tr>
<td>\&lt;=</td>
<td>小于等于</td>
<td>awk ‘$1&lt;=100 {print $2}’ file     //如果字段1的值小于等于100，则打印字段2</td>
</tr>
<tr>
<td>+</td>
<td>加</td>
<td>awk ‘{print $3+10}’ file    //字段3数值加10</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>awk ‘{print $3-10}’ file    //字段3数值减10</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>awk ‘{print $3*10}’ file    //字段3数值乘10</td>
</tr>
<tr>
<td>\/</td>
<td>除</td>
<td>awk ‘{print $3/10}’ file    //字段3数值除10</td>
</tr>
</tbody>
</table>
<ul>
<li>字符匹配代码块</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk [-F|-f|-v] ‘BEGIN&#123;&#125; // &#123;command1; command2&#125; END&#123;&#125;’ file</span><br></pre></td></tr></table></figure>
<ol>
<li>字符匹配代码支持针对字符串的操作</li>
</ol>
<ol start="2">
<li>字符匹配代码块支持正则表达式</li>
</ol>
<ul>
<li>if语句</li>
</ul>
<ol>
<li>必须在{}里，且比较内容用()扩起来，支持if else</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F: <span class="string">'&#123;if($1~/abc/) print $1&#125;'</span> file     //简写</span><br><span class="line"></span><br><span class="line">awk -F: <span class="string">'&#123;if($1~/abc/) &#123;print $1&#125;&#125;'</span>  file    //全写</span><br><span class="line"></span><br><span class="line">awk -F: <span class="string">'&#123;if($1~/abc/) &#123;print $1&#125; else &#123;print $2&#125;&#125;'</span> file    //if...else...</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>有时不用if语句也可以实现同样的效果图，如<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F: <span class="string">'&#123;if($1~/abc/) &#123;print $1&#125;&#125;'</span> file    //<span class="variable">$1</span>为指定内容才显示</span><br><span class="line"></span><br><span class="line">awk -F: <span class="string">'$1~/abc/ &#123;print $1&#125;'</span> file    //与上面相同效果，没有用<span class="keyword">if</span>语句，条件写在‘’外</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>while语句</li>
</ul>
<blockquote>
<p>与其他语言的while语句类似，条件为True时执行循环语句，False时不执行。</p>
</blockquote>
<ul>
<li>数组</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -anp|awk <span class="string">'NR!=1&#123;a[$6]++&#125; END&#123;for (i in a) print i,"\t",a[i]&#125;'</span></span><br><span class="line"></span><br><span class="line">netstat -anp|awk <span class="string">'NR!=1&#123;a[$6]++&#125; END&#123;for (i in a) printf "%-20s %-10s %-5s \n", i,"\t",a[i]&#125;'</span></span><br></pre></td></tr></table></figure>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><ol>
<li>指定输出  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F: <span class="string">'&#123;print NF&#125;'</span> helloworld.sh                                                       //输出文件每行有多少字段</span><br><span class="line"></span><br><span class="line">awk -F: <span class="string">'&#123;print $1,$2,$3,$4,$5&#125;'</span> helloworld.sh                                 //输出前5个字段</span><br><span class="line"></span><br><span class="line">awk -F: <span class="string">'&#123;print $1,$2,$3,$4,$5&#125;'</span> OFS=<span class="string">'\t'</span> helloworld.sh                 //输出前5个字段并使用制表符分隔输出</span><br><span class="line"></span><br><span class="line">awk -F: <span class="string">'&#123;print NR,$1,$2,$3,$4,$5&#125;'</span> OFS=<span class="string">'\t'</span> helloworld.sh           //制表符分隔输出前5个字段，并打印行号</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>指定分隔符并且输出  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F<span class="string">'[:#]'</span> <span class="string">'&#123;print NF&#125;'</span>  helloworld.sh                                                  //指定多个分隔符: <span class="comment">#，输出每行多少字段</span></span><br><span class="line"></span><br><span class="line">awk -F<span class="string">'[:#]'</span> <span class="string">'&#123;print $1,$2,$3,$4,$5,$6,$7&#125;'</span> OFS=<span class="string">'\t'</span> helloworld.sh   //制表符分隔输出多字段</span><br><span class="line"></span><br><span class="line">awk -F<span class="string">'[:#/]'</span> <span class="string">'&#123;print NF&#125;'</span> helloworld.sh                                               //指定三个分隔符，并输出每行字段数</span><br><span class="line"></span><br><span class="line">awk -F<span class="string">'[:#/]'</span> <span class="string">'&#123;print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12&#125;'</span> helloworld.sh     //制表符分隔输出多字段</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>简单计算  </li>
</ol>
<p>计算/home目录下，普通文件的大小，使用KB作为单位</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -l|awk <span class="string">'BEGIN&#123;sum=0&#125; !/^d/&#123;sum+=$5&#125; END&#123;print "total size is:",sum/1024,"KB"&#125;'</span></span><br><span class="line"></span><br><span class="line">ls -l|awk <span class="string">'BEGIN&#123;sum=0&#125; !/^d/&#123;sum+=$5&#125; END&#123;print "total size is:",int(sum/1024),"KB"&#125;'</span>         //int是取整的意思</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>统计  </li>
</ol>
<p>统计netstat -anp 状态为LISTEN和CONNECT的连接数量分别是多少</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -anp|awk <span class="string">'$6~/LISTEN|CONNECTED/&#123;sum[$6]++&#125; END&#123;for (i in sum) printf "%-10s %-6s %-3s \n", i," ",sum[i]&#125;'</span></span><br></pre></td></tr></table></figure>
<p>统计/home目录下不同用户的普通文件的总数是多少？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -anp|awk <span class="string">'$6~/LISTEN|CONNECTED/&#123;sum[$6]++&#125; END&#123;for (i in sum) printf "%-10s %-6s %-3s \n", i," ",sum[i]&#125;'</span></span><br></pre></td></tr></table></figure>
<p>统计/home目录下不同用户的普通文件的总数是多少？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -l|awk <span class="string">'NR!=1 &amp;&amp; !/^d/&#123;sum[$3]++&#125; END&#123;for (i in sum) printf "%-6s %-5s %-3s \n",i," ",sum[i]&#125;'</span></span><br></pre></td></tr></table></figure>
<p>统计/home目录下不同用户的普通文件的大小总size是多少？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -l|awk <span class="string">'NR!=1 &amp;&amp; !/^d/&#123;sum[$3]+=$5&#125; END&#123;for (i in sum) printf "%-6s %-5s %-3s %-2s \n",i," ",sum[i]/1024/1024,"MB"&#125;'</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>复杂表格输出  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123;math=0;eng=0;com=0;printf "Lineno.   Name    No.    Math   English   Computer    Total\n";printf "------------------------------------------------------------\n"&#125;&#123;math+=$3; eng+=$4; com+=$5;printf "%-8s %-7s %-7s %-7s %-9s %-10s %-7s \n",NR,$1,$2,$3,$4,$5,$3+$4+$5&#125; END&#123;printf "------------------------------------------------------------\n";printf "%-24s %-7s %-9s %-20s \n","Total:",math,eng,com;printf "%-24s %-7s %-9s %-20s \n","Avg:",math/NR,eng/NR,com/NR&#125;'</span> test0</span><br><span class="line"></span><br><span class="line">cat test0  </span><br><span class="line"></span><br><span class="line">Marry   2143 78 84 77</span><br><span class="line"></span><br><span class="line">Jack    2321 66 78 45</span><br><span class="line"></span><br><span class="line">Tom     2122 48 77 71</span><br><span class="line"></span><br><span class="line">Mike    2537 87 97 95</span><br><span class="line"></span><br><span class="line">Bob     2415 40 57 62</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title>【Mysql深入理解系列1】数据结构</title>
    <url>/2021/05/11/mysql/mysql_deep_1/</url>
    <content><![CDATA[<h2 id="数据结构基础"><a href="#数据结构基础" class="headerlink" title="数据结构基础"></a>数据结构基础</h2><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li><p>二叉树：可能产生单边链，对查询效率就很低。</p>
</li>
<li><p>红黑树：二插平衡树。 树的高度会很高。</p>
</li>
<li><p>B树：<br><img src="https://images.lilhui.com/d618d928c25644e37922e3e6175a156a" alt="图片"></p>
</li>
</ul>
<ol>
<li>非叶子节点也有存data。一个元素占用1K。一个NODE最大 16个元素。</li>
<li>所以数量大的话，树高度也会很高。</li>
</ol>
<p>PS：大概估计是1kb 总共能存16个元素</p>
<ul>
<li>B+树：<br>平衡，且树矮<br>索引的基本结构：B+树</li>
</ul>
<ol>
<li>非叶子节点不存储data，只存储所以。</li>
<li>叶子节点包含所有索引字段</li>
<li>叶子节点用指针连接。提高访问的性能。</li>
</ol>
<p><img src="https://images.lilhui.com/27e421c5da22e9d5b06447d5212dff64" alt="图片"></p>
<p>一个NODE(树的节点） 16K</p>
<p>按照页来分配，一个16K。<br>一次磁盘IO很慢，内存很快。所以比较费时间的是从磁盘node到NODE查询。</p>
<p>一个索引8B<br>一个地址6B</p>
<p>16KB可以放  16KB/(8+6)个元素1170</p>
<p>那么2层的B+tree<br>1170 * 1170 = 1368900</p>
<p>叶子节点有data一个NODE放16个元素。一个元素1K.<br>算上叶子节点 1170 <em> 1170 </em> 16<br>个元素。<br>大概2000多万。<br>树的高度3</p>
<p>所以只要3次IO。根节点常住内存。</p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="mysam"><a href="#mysam" class="headerlink" title="mysam"></a>mysam</h3><p><img src="https://images.lilhui.com/58d102c4891d5aad217c14d7187c0a70" alt="图片"></p>
<p>叶子节点存的数据地址。</p>
<h3 id="innodb"><a href="#innodb" class="headerlink" title="innodb"></a>innodb</h3><p><img src="https://images.lilhui.com/a3cabd170f1ab82feabb8dad5119086c" alt="图片"></p>
<p>叶子节点存的是具体的data值。</p>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>MyInSam<br>ID主键是非聚簇索引。</p>
<p>Inodb<br>ID主键是聚簇索引。</p>
<h2 id="关于主键"><a href="#关于主键" class="headerlink" title="关于主键"></a>关于主键</h2><ol>
<li><p>建立索引：<br>组织B+。如果没有索引的话，选择第一列所有元素都不相等的元素来组织。如果没找到，建立一个隐藏列。这个隐藏列是唯一ID 组织B+树。</p>
</li>
<li><p>整型ID的作用：<br>在建立索引和查询索引的过程中，会进行多次的比大小。Int效率高。如果是String的话必须每个字符都要对比。并且占用空间也小，节省固态硬盘，节省成本。</p>
</li>
<li><p>自增：<br>HASH索引下。很快可以对应到磁盘文件地址。<br><img src="https://images.lilhui.com/4ddc87ded96ce3bc73dc860621133b47" alt="图片"><br>优点：等值查询很快。<br>缺点：范围查询效率不好。并且会产生HAHD冲突。</p>
</li>
</ol>
<ol start="4">
<li><p>聚簇索引和非聚簇索引那个快？<br>聚簇索引会比较快。</p>
</li>
<li><p>非主键索引：<br><img src="https://images.lilhui.com/7b45a9e7e7db9ddba1b4fea568e3401f" alt="图片"><br>非聚簇索引的叶子节点的数据放的是聚簇索引索引节点值。<br>PS：INODB只有一个聚簇索引。<br>为什么不直接放数据？节约存储空间，可以多存放非常多数据。</p>
</li>
</ol>
<h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>联合索引底层存储</p>
<ul>
<li>索引是帮助Mysql搞笑查询排好序的数据结构。</li>
</ul>
<p>联合索引也是排好序的数据结构。</p>
<p><img src="https://images.lilhui.com/ecea37f94b3fa604553ce6eb6c765788" alt="图片"></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>【Mysql深入理解系列2】执行计划</title>
    <url>/2021/05/11/mysql/mysql_deep_2/</url>
    <content><![CDATA[<h2 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h2><p>分析sql执行数据<br>explain</p>
<p>语法：<br>explain ${sql}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain extended select * from (select * from film where id = 1) tmp;</span><br><span class="line">show warnings;</span><br></pre></td></tr></table></figure>
<p>TYPE 类型：</p>
<ol>
<li><p>SYSTEM:查询的整张表只有1个 select （select 1 from)</p>
</li>
<li><p>const:查询的结果跟const有的比。select 1 from</p>
</li>
<li><p>eq_ref:使用的唯一索引，效率仅次于 const</p>
</li>
<li><p>ref:普通索引，可能查出多条。或者唯一索引的部分前缀。联合索引等。</p>
</li>
<li><p>range:索引查出了范围集。</p>
</li>
</ol>
<p>以上都是走索引。</p>
<p>优化的方向</p>
<ol start="6">
<li><p>index:全索引扫描。尽量优化。</p>
</li>
<li><p>ALL:全聚簇索引扫描。</p>
</li>
</ol>
<p>索引选择有优化，有的全表扫描效率更高就不选择索引。</p>
<p>如果结果集二级索引和主键索引全包含的情况下：<br>有主键索引也有二级索引，会优先索引二级索引。主键索引比较大。</p>
<ul>
<li>key_len</li>
</ul>
<p>组合索引(联合索引)，说明用到了多长的索引。</p>
<p>key_len计算规则：</p>
<ol>
<li>字符串<br>char(n) :字节长短<br>varchar(n): 3n+2。 +2存储字符串长度。</li>
<li>数值类型<br>tinyint:1字节。<br>smallint:2字节。<br>int：4字节。<br>bigint: 8字节。</li>
<li>时间类型<br>date: 3字节<br>timestamp:4字节</li>
</ol>
<h2 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h2><ol>
<li>Using index说明<br>查询的结果集在索引里，不用回表。</li>
</ol>
<ul>
<li>覆盖索引<br>一种查找方式，结果集在一颗索引树里。不用回表。</li>
</ul>
<ol start="2">
<li>Using where<br>使用了where但是没有被索引覆盖。</li>
<li>Using index condition<br>查询的列不完全被索引覆盖，where条件中是一个前导列的范围。</li>
<li>Using templrary,Using index<br>Using templrary 使用了临时表。</li>
</ol>
<p>查询语句有distint但是没有走索引的话，会在内存里建立临时表去重。如果有走索引的话，会在所以查询的时候直接进行distinc去重。变成</p>
<ol start="5">
<li>Using fileSort</li>
</ol>
<p>查询里有order by。但是没有建立索引。<br>如果有建索引会变成 Using index。因为索引已经是排好序了。</p>
<p>将用外部排序二不是所以你排序，数据较小时从内存排序。否则需要在磁盘完成。</p>
<ol start="6">
<li>select tables optimized away<br>有max,min查询。使用了索引。</li>
</ol>
<ul>
<li>like查询</li>
</ul>
<p>like ‘ts%’  会使用索引<br>like ‘%ts’  不会使用索引。但是可以优化成全覆盖索引</p>
<ul>
<li>原则：<br>少用or</li>
</ul>
<p>因为or一次就是扫描一次。or多次可能比全表扫还慢。</p>
<ul>
<li>范围查找优化</li>
</ul>
<p>select * from employee where age &gt; 10 and age &lt; 1000<br>可能不走索引，印为mysql判断后可能全表扫描会比较快。</p>
<h2 id="索引总结表"><a href="#索引总结表" class="headerlink" title="索引总结表"></a>索引总结表</h2><p><img src="https://images.lilhui.com/c6d412fcc1a203a0538fdd1c70c19c5a" alt="图片"></p>
<p>like kk%相当于=常量，%kk和%kk%相当于范围。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>执行计划</tag>
      </tags>
  </entry>
  <entry>
    <title>【Mysql深入理解系列4】索引优化1</title>
    <url>/2021/05/11/mysql/mysql_deep_4/</url>
    <content><![CDATA[<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><ol>
<li>详解</li>
<li>优化索引选择探究</li>
<li>索引优化Orderby与Group byy</li>
<li>UsingfileSort文件排序详解。</li>
<li>索引设计原则与实战。</li>
</ol>
<h2 id="索引优化原则"><a href="#索引优化原则" class="headerlink" title="索引优化原则"></a>索引优化原则</h2><p>避免ALL权标扫描。即时没走索引也要避免回表</p>
<p>扫描行数不决定查询快慢，还有回表啊什么的影响。大多情况下不用去改mysql的优化查询。（force dindex 不一定会更快)</p>
<p>PS:</p>
<ol>
<li>字符串不加单引号索引失效。<br>2.</li>
</ol>
<p>三个键的组合索引，范围查询放中间或者后面是可以走索引的。</p>
<p>1.</p>
<ol start="2">
<li>强制走索引。扫描行数可能少了，但是执行时间并不一定减少。</li>
<li>覆盖索引优化。</li>
<li>in和or在表数量比较大的情况下回走索引，在表记录不多的情况下选择走权标扫描。</li>
<li><p>like kk%不管表数据量大小都会走索引。</p>
<p>概念：索引下推。like KK%就是用到了索引下推优化。</p>
</li>
</ol>
<p>索引下推5.6引入的。<br>索引下推查询：在二级索引树过滤完like的字段后会再过滤后面条件的内容。符合的话进行会标。所谓的索引下面在推断。<br>非下推（5.6之前）：在二级索引树过滤完like后没进行后面条件判断，直接回表，在回表的内容里在进行筛选。</p>
<p>索引下推意味着每次索引后，要再进行比对。like结果集少的话（like  xxx%)，比对就比较快。mysql会使用。如果数量非常大的话(column &gt; xxx)，每次都要比对，不一定比回表快。</p>
<p>使用 trace进行分析。列出explain sql执行的过程，mysql各个节点预估的消耗量。</p>
<h2 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h2><ol>
<li>mysql支持两种方式的排序filesort 和index, Using Index是指Mysql扫描索引本身完成排序，index效率高，filesort效率低。</li>
<li>order by 满足两种情况会使用Using index<ol>
<li>order by语句使用索引最左前列。</li>
<li>使用where子句与order by子句条件组合满足索引最左前列。</li>
</ol>
</li>
<li>尽量在索引列上完成排序，遵循索引建立的最左前缀法则。</li>
<li>如果 order by的条件不在索引列上，就会产生Using filesort</li>
<li>能用覆盖索引尽量用覆盖索引。</li>
<li>group by 与order by很类似。其实质是先排序后分组，遵照索引创建顺序的最左前缀法则。对group by的优化如果不需要排序的可以加上order by null禁止排序。注意，where高于having,能卸载where先定条件就不要去having限定。</li>
</ol>
<p>单路排序：<br>一次性取出满足条件行的所有字段，在sortbuffer中进行排序，用trace工具可以看到sort_mode信息显示。sort_key,additional_files或者 sort_key,packed_additional_fileds<br>不用回表。占用内存大。<br>双路排序：<br>根据条件取出相应的排序字段和可以直接定位行数据的ID,然后在sort buffer中进行爱旭。排序完后需要取回其他需要的字段、用trace工具可以看到sort_mode信息显示 sort_key,rowid。<br>需要回表，暂用内存小。</p>
<p>可设置max_length_for_sort_data默认1024 。如果参与排序的字段小于这个的话，使用单路排序。如果大于的话，会使用双路排序。一般不去设置。</p>
<p>sort_buffer 排序内存。如果它比较小的话可以适当把max_length_for_sort_data配置小点，让优化器选择双路排序。（双路排序用ID,不用tmpfile)</p>
<p>sort_buffer可以考虑配置更大的max_length_for_sort_data从而使用单路排序。</p>
<p>非DBA就不要去调整了。</p>
<h2 id="怎么建索引"><a href="#怎么建索引" class="headerlink" title="怎么建索引"></a>怎么建索引</h2><p>建完表后，一般主体的业务开发完后，把跟表相关的sql语句都拉出来。根据sql语句建索引。</p>
<p>原则：</p>
<ol>
<li>代码先行，主体业务完成后，建索引。</li>
<li>联合索引尽量覆盖到你业务的所有查询。order by group by这些都需要考虑。</li>
<li>不要在小基数字段上建立索引。</li>
<li>长字符串可以采用前缀索引。varchar(255) 建索引耗费太大的空间，可以 Key index（name(20),age,position)。前缀的一部分进行建索引</li>
<li>where 与order by冲突时优先where</li>
<li>基于慢sql查询进行建索引。slow_query_log=1</li>
</ol>
<p>（provice,city,sex,age)<br>age一般范围查询，放后面，在实际查询中，查询可以把 sex按照in塞进去，这样age就可以走索引。一般一个组合索引里保持只有一个范围查询的字段。<br><img src="https://images.lilhui.com/aa90f7ad0a50d0a3deda306e02928495" alt="图片"></p>
<p><img src="https://images.lilhui.com/ed89b7e3209bc61303bd845e73385d67" alt="图片"></p>
<p>经验：10个字段左右的表。一个表里建2-3个组合二级索引就差不多了。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>索引优化</tag>
      </tags>
  </entry>
  <entry>
    <title>【Mysql深入理解系列5】索引优化2</title>
    <url>/2021/05/11/mysql/mysql_deep_5/</url>
    <content><![CDATA[<ol>
<li>分页查询优化详解。</li>
<li>表JOIN关联原理以及优化。</li>
<li>表COUNT查询优化。</li>
<li>阿里巴巴MYSQL规范解读。</li>
<li>MYSQL数据类型选择分析。</li>
</ol>
<h2 id="分页查询优化"><a href="#分页查询优化" class="headerlink" title="分页查询优化"></a>分页查询优化</h2><p>一般的分页：<br>select * from employee limit 1,100</p>
<ul>
<li>优化方式：</li>
</ul>
<ol>
<li><p>根据自增连续主键排序的分页：<br>改成 id&gt;xxx limit 10;</p>
</li>
<li><p>用innerjoin来改写。<br>select <em> from employees order by name limit 90000,5可以改写成：<br>select </em> from employees e inner join(select id from employees order by name limit 90000,5) ed on e.id = ed.id</p>
</li>
</ol>
<h2 id="表JOIN关联"><a href="#表JOIN关联" class="headerlink" title="表JOIN关联"></a>表JOIN关联</h2><p>select * from t1 inner join t2 on t1.a = t2.a</p>
<p>在Mysql的实现中，Nested-Loop Join有3种实现的算法：</p>
<p>Simple Nested-Loop Join：SNLJ，简单嵌套循环连接<br>Index Nested-Loop Join：INLJ，索引嵌套循环连接<br>Block Nested-Loop Join：BNLJ，缓存块嵌套循环连接</p>
<ol>
<li><p>嵌套循环链接  Nested-LoopJoin</p>
</li>
<li><p>Simple Nested-Loop</p>
</li>
</ol>
<p>简单嵌套循环连接实际上就是简单粗暴的嵌套循环，如果table1有1万条数据，table2有1万条数据，那么数据比较的次数=1万 * 1万 =1亿次，这种查询效率会非常慢。</p>
<ol start="2">
<li>Index Nested-Loop</li>
</ol>
<p>索引嵌套循环连接是基于索引进行连接的算法，索引是基于内层表的，通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录进行比较， 从而利用索引的查询减少了对内层表的匹配次数，优势极大的提升了 join的性能：</p>
<p>使用场景：只有内层表join的列有索引时，才能用到Index Nested-LoopJoin进行连接。<br>由于用到索引，如果索引是辅助索引而且返回的数据还包括内层表的其他数据，则会回内层表查询数据，多了一些IO操作。</p>
<p><img src="https://images.lilhui.com/0f2bfaffe86c00fb7e8c28bf07b0b22a" alt="图片"></p>
<ol start="3">
<li>基于块的嵌套循环链接Block Nested-Loop Join算法<br>把驱动表的数据读入到join_buffer然后被驱动表扫描，与join_buffer的数据做对比。<br>极端条件下，会过滤 t1 数量 * t2 数量词。</li>
</ol>
<p>缓存块嵌套循环连接通过一次性缓存多条数据，把参与查询的列缓存到Join Buffer 里，然后拿join buffer里的数据批量与内层表的数据进行匹配，从而减少了内层循环的次数（遍历一次内层表就可以批量匹配一次Join Buffer里面的外层表数据）。</p>
<p>当不使用Index Nested-Loop Join的时候，默认使用Block Nested-Loop Join。</p>
<p><img src="https://images.lilhui.com/9a0f921f3deb3e7b727b293323d809ca" alt="图片"></p>
<p>什么是Join Buffer？<br>（1）Join Buffer会缓存所有参与查询的列而不是只有Join的列。<br>（2）可以通过调整join_buffer_size缓存大小<br>（3）join_buffer_size的默认值是256K，join_buffer_size的最大值在MySQL 5.1.22版本前是4G-1，而之后的版本才能在64位操作系统下申请大于4G的Join Buffer空间。<br>（4）使用Block Nested-Loop Join算法需要开启优化器管理配置的optimizer_switch的设置block_nested_loop为on，默认为开启。</p>
<ul>
<li>优化JOIN</li>
</ul>
<ol>
<li>用小结果集驱动大结果集，减少外层循环的数据量，从而减少内层循环次数：<br>如果小结果集和大结果集连接的列都是索引列，mysql在内连接时也会选择用小结果集驱动大结果集，因为索引查询的成本是比较固定的，这时候外层的循环越少，join的速度便越快。</li>
<li><p>为匹配的条件增加索引：争取使用INLJ，减少内层表的循环次数</p>
</li>
<li><p>增大join buffer size的大小：当使用BNLJ时，一次缓存的数据越多，那么内层表循环的次数就越少</p>
</li>
<li><p>减少不必要的字段查询：<br>（1）当用到BNLJ时，字段越少，join buffer 所缓存的数据就越多，内层表的循环次数就越少；<br>（2）当用到INLJ时，如果可以不回表查询，即利用到覆盖索引，则可能可以提示速度。（未经验证，只是一个推论</p>
</li>
</ol>
<h2 id="in和exsits优化"><a href="#in和exsits优化" class="headerlink" title="in和exsits优化"></a>in和exsits优化</h2><p>exists少用，能用join替代用join。<br>记住。小表驱动大表。</p>
<h2 id="表COUNT执行"><a href="#表COUNT执行" class="headerlink" title="表COUNT执行"></a>表COUNT执行</h2><p>5.7版本 count(1),count(id),count(*)一样，几乎不用管。</p>
<p>分析：count(1) 不取值按行累加。count(*)也一样。count(字段) 拿出值走二级索引。count(id)走聚簇索引。<br>聚簇索引一般比二级索引大，所以count(字段有索引)比count(id)效率大一点点。</p>
<ul>
<li>常见优化方法<br>维护表数据量。</li>
</ul>
<p>innodb为什么不维护全表数量。是因为MVCC。多版本数据控制。不同的事务count（*）可能不一样。</p>
<ol>
<li>count(*)</li>
</ol>
<p>2.<br>对总记录数没有特别精确可以用：</p>
<pre><code>show table status like &apos;employees&apos;;
</code></pre><ol start="3">
<li>redis维护。数据库缓存双写一致代价很高。</li>
<li>增加数据库计数表。</li>
</ol>
<h2 id="阿里巴巴Mysql规范手册解读"><a href="#阿里巴巴Mysql规范手册解读" class="headerlink" title="阿里巴巴Mysql规范手册解读"></a>阿里巴巴Mysql规范手册解读</h2><p>单标行不要超过500万行，或者单标容量超过2G，推荐分表。<br>如果预计三年后的数据量根本达不到这个级别，就不要在建表时就进行分表。</p>
<ul>
<li>索引规约</li>
</ul>
<ol>
<li>有唯一键字段，即使是组合字段，也要建成唯一字段。</li>
<li>超过三个表不能进行join.</li>
<li>在varchar上建立索引，必须指定索引长度。</li>
<li>页面搜索严禁使用做模糊或者全模糊。这种场景适合走搜索引擎。</li>
</ol>
<ul>
<li>数据类型选择</li>
</ul>
<p><img src="https://images.lilhui.com/8a29aa20c1f33d5b34044ff19706cf61" alt="图片"></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>【Mysql深入理解系列3】执行原理</title>
    <url>/2021/05/11/mysql/mysql_deep_3/</url>
    <content><![CDATA[<h2 id="登录建立连接"><a href="#登录建立连接" class="headerlink" title="登录建立连接"></a>登录建立连接</h2><ol>
<li>登录维持session</li>
<li>建立连接，权限缓存<ul>
<li>权限缓存在链接里。不用每次查询都校验。效率高。</li>
</ul>
</li>
</ol>
<p>查看链接数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show processlist;</span><br></pre></td></tr></table></figure></p>
<p>my.conf</p>
<p>query_cache_type<br>一般不用。</p>
<p>查看缓存命中情况。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status like &apos;%Qcache%&apos;&apos;</span><br></pre></td></tr></table></figure></p>
<p>为什么这种缓存是鸡肋？</p>
<p>缓存的时候会经常刷新，不适用热点业务。</p>
<p><img src="https://images.lilhui.com/28ffc030006c338903910a74f6106973" alt="图片"></p>
<h2 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h2><p>sql语句拆分成语法树。</p>
<p>语法树：结构化的存储。<br><img src="https://images.lilhui.com/52eb397078359404e10612797ab9fc85" alt="图片"></p>
<p>语法树拆分后的使用场景：<br>在分布式事务中 二阶段提交。<br>commit,rollback</p>
<ol>
<li>通过语法树会记录反向操作。在回滚的时候直接rollback。</li>
<li>补偿机制。构建补偿sql。进行回滚重放。<br>3.<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2></li>
</ol>
<p>条件查询，会判断哪种效率高用哪种，或者判断用哪种索引或者不用索引。</p>
<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>调用响应的引擎执行操作。</p>
<h2 id="bin-log归档"><a href="#bin-log归档" class="headerlink" title="bin-log归档"></a>bin-log归档</h2><p>不小心删了库怎么找回来？</p>
<p>server层实现的 bin-log技术。</p>
<p>bin-log记录的逻辑语句的影响。</p>
<p>bin-log格式有三种statement，row，mixed</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binlog-format=ROW</span><br><span class="line">sync-binlog=1</span><br></pre></td></tr></table></figure>
<p>statement:记录的是这条操作语句的逻辑， 产生结果的过程。<br>row: 记录这个语句影响那条记录之后的结果。<br>row: mixed两种都记录。</p>
<p>如果记录的是statement</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update * from xxx where h=xx or b=xxx</span><br></pre></td></tr></table></figure>
<p>优化器走的索引不一致，可能产生主从不一致。</p>
<p>所以最好bin-log用row</p>
<h2 id="bin-log恢复"><a href="#bin-log恢复" class="headerlink" title="bin-log恢复"></a>bin-log恢复</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush logs;</span><br></pre></td></tr></table></figure>
<p>重新开个bin-log文件进行记录。</p>
<p>恢复<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqlbinlog --no-defaults /**/*/mysql-bin.00001 | mysql -uroot -p xxx</span><br></pre></td></tr></table></figure></p>
<p>参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--start-position</span><br><span class="line">--end-position</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>执行原理</tag>
      </tags>
  </entry>
  <entry>
    <title>【Mysql深入理解系列6】事务隔离级别</title>
    <url>/2021/05/11/mysql/mysql_deep_6/</url>
    <content><![CDATA[<h2 id="事务隔离级别深入理解"><a href="#事务隔离级别深入理解" class="headerlink" title="事务隔离级别深入理解"></a>事务隔离级别深入理解</h2><ol>
<li>Mysql事务级ACID特性详解</li>
<li>Mysql事务隔离级别详解</li>
<li>Mysql锁机制详解</li>
<li>Mysql锁优化建议</li>
</ol>
<h2 id="事务隔离级别ACID"><a href="#事务隔离级别ACID" class="headerlink" title="事务隔离级别ACID"></a>事务隔离级别ACID</h2><h3 id="事务及其ACID属性。"><a href="#事务及其ACID属性。" class="headerlink" title="事务及其ACID属性。"></a>事务及其ACID属性。</h3><p>事务的特性 ACID:</p>
<p>ACID是原子性，一致性，持久性，独立性的缩写。</p>
<p>原子性：一个操作不是成功就是失败，要么执行成功，要么执行失败。</p>
<p>一致性：事务的索引规则，约束等不受破坏。事务开始中，所有相关的数据结果都必须保持状态一致，比如一个事务对三个数据进行修改，事务结束后三个状态必须都是被修改过的，保持一致。</p>
<p>隔离性： 每个事务之间不要相互影响。A事务查的结果不要被别的影响。就是说A事务执行过程中，结果集不能变。</p>
<p>持久性：事务完成后的对结果产生影响要持久。不能一会儿变来变去。</p>
<h3 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h3><ol>
<li>更新丢失(脏写)</li>
</ol>
<p>事务A对数据进行+1，事务B对数据进行-1。B的更新操作把A覆盖掉了。</p>
<ol start="2">
<li>脏读</li>
</ol>
<p>事务A读取了事务B还未提交的数据，但是事务B进行了回滚。事务A读到了脏数据。</p>
<ol start="3">
<li>不可重复读</li>
</ol>
<p>事务A读取了数据1，但是被B修改成了2，事务A再读变成了2。与之前的不同。</p>
<ol start="5">
<li>幻影读</li>
</ol>
<p>事务A，count了一个数据块，事务B插入了一条数据，事务A再进行count的 时候数据变了。</p>
<p>以上问题都是事务隔离性问题。所以要引入事务隔离级别来解决这些问题。</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p><img src="https://images.lilhui.com/0368e43298acb164abd6e8d86ede311a" alt="图片"></p>
<p>事务隔离级别是Mysql提供的预设的几种级别。</p>
<ol>
<li>未提交读：事务T在读取数据的时候并未对数据进行加锁，事务T在修改数据的时候对数据增加行级共享锁，这种隔离级别没解决脏读。</li>
<li>已提交读：事务T在读取数据时增加行级共享锁，读取一旦结束，立即释放；事务T在修改数据时增加行级排它锁，直到事务结束才释放，这种隔离级别解决了脏读。</li>
<li>可重复读：事务T在数据读取时，必须增加行级共享锁，直到事务结束；事务T在修改数据过程中，必须增加行级排它锁，直到数据结束；这种隔离级别没解决幻读。</li>
<li>序列化：事务T在读取数据时，必须先增加表级共享锁，直到事务结束时才释放；事务T在修改数据时，必须先增加表级排它锁，直到事务结束才释放。</li>
</ol>
<p>这些隔离级别采用的是<br>MVCC:multi version concurrency controller</p>
<h2 id="锁机制详解"><a href="#锁机制详解" class="headerlink" title="锁机制详解"></a>锁机制详解</h2><p>锁机制是事务隔离级别的实现方式</p>
<h3 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h3><p>性能上分：悲观锁，乐观锁。<br>数据库操作上分：读锁，写锁。<br>从数据库的操作力度来分：表锁，行锁。</p>
<ul>
<li>表锁<br>开销小，加锁快。锁力度大， 一般在离线操作数据迁移的时候进行，比较少会用。</li>
<li>读锁（s)<br>可以进行共享读。</li>
<li>写锁（x)<br>不能进行写。也不能进行读。</li>
</ul>
<p>重点</p>
<ul>
<li>行锁<br>开销大，加锁慢。<br>innodb支持行锁。支持事务。</li>
<li>间隙锁<br>innodb采用间隙锁，在可重复读级别解决了幻读问题。</li>
<li>临键锁（next-ke）<br>行锁 + 间隙锁</li>
</ul>
<h2 id="锁优化建议"><a href="#锁优化建议" class="headerlink" title="锁优化建议"></a>锁优化建议</h2><h3 id="行锁分析"><a href="#行锁分析" class="headerlink" title="行锁分析"></a>行锁分析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status like &apos;innodb_row_locks&apos;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查看事务</span><br><span class="line">select * from INFORMATION_SCHEMA_INNODB_TRX</span><br><span class="line"></span><br><span class="line">-- 查看锁</span><br><span class="line"></span><br><span class="line">select * from INFORMATION_SCHEMA_INNODB_LOCKS</span><br><span class="line"></span><br><span class="line">-- 查看锁等待</span><br><span class="line"></span><br><span class="line">select * from INFORMATION_SCHEMA_INNODB_LOCK_WAITS</span><br><span class="line"></span><br><span class="line">-- 释放锁。trx_mysql_thread_id可以从INNODB_TRX表里查看到</span><br><span class="line"></span><br><span class="line">kill trx_mysql_thread_id</span><br></pre></td></tr></table></figure>
<h3 id="锁优化建议-1"><a href="#锁优化建议-1" class="headerlink" title="锁优化建议"></a>锁优化建议</h3><ol>
<li>尽可能让所有数据检索都通过索引来完成，避免误索引锁升级为表锁。</li>
<li>合理设计索引，尽量缩小锁的范围。</li>
<li>尽可能减少检索条件范围，避免间隙锁。</li>
<li>尽量控制事务大小，减少锁定资源和时间长度，涉及事务加锁的sql尽量放在事务后执行。</li>
<li>尽可能低级别事务隔离。</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>【Mysql深入理解系列8】Mysql慢查询工具</title>
    <url>/2021/06/01/mysql/mysql_deep_8/</url>
    <content><![CDATA[<h2 id="几个参数"><a href="#几个参数" class="headerlink" title="几个参数"></a>几个参数</h2><ul>
<li>slow_query_log</li>
</ul>
<p>这个参数设置为ON，可以捕获执行时间超过一定数值的SQL语句。</p>
<ul>
<li>long_query_time</li>
</ul>
<p>当SQL语句执行时间超过此数值时，就会被记录到日志中，建议设置为1或者更短。</p>
<ul>
<li>slow_query_log_file</li>
</ul>
<p>记录日志的文件名。</p>
<ul>
<li>log_queries_not_using_indexes</li>
</ul>
<p>这个参数设置为ON，可以捕获到所有未使用索引的SQL语句，尽管这个SQL语句有可能执行得挺快。</p>
<h2 id="几个命令"><a href="#几个命令" class="headerlink" title="几个命令"></a>几个命令</h2><ul>
<li>SHOW PROCESSLIST</li>
</ul>
<p><strong><em>Id列</em></strong>：一个标识，你要kill一个语句的时候很有用，用命令杀掉此查询 /*/mysqladmin kill 进程号。</p>
<p><strong><em>User列</em></strong>：显示单前用户，如果不是root，这个命令就只显示你权限范围内的sql语句。</p>
<p><strong><em>Host列</em></strong>：显示这个语句是从哪个ip的哪个端口上发出的。用于追踪出问题语句的用户。</p>
<p><strong><em>db列</em></strong>：显示这个进程目前连接的是哪个数据库。</p>
<p><strong><em>Command列</em></strong>：显示当前连接的执行的命令，一般就是休眠（sleep），查询（query），连接（connect）。</p>
<p><strong><em>Time列</em></strong>：此这个状态持续的时间，单位是秒。</p>
<p><strong><em>State列</em></strong>：显示使用当前连接的sql语句的状态，很重要的列，后续会有所有的状态的描述，请注意，state只是语句执行中的某一个状态，一个 sql语句，以查询为例，可能需要经过copying to tmp table，Sorting result，Sending data等状态才可以完成</p>
<p><strong><em>Info列</em></strong>；显示这个sql语句，因为长度有限，所以长的sql语句就显示不全，但是一个判断问题语句的重要依据。</p>
<p>这个命令中最关键的就是state列，MySQL列出的状态主要有以下几种：</p>
<p><strong><em>Checking table</em></strong>：正在检查数据表（这是自动的）。</p>
<p><strong><em>Closing tables</em></strong>：正在将表中修改的数据刷新到磁盘中，同时正在关闭已经用完的表。这是一个很快的操作，如果不是这样的话，就应该确认磁盘空间是否已经满了或者磁盘是否正处于重负中。</p>
<p><strong><em>Connect Out</em></strong>：复制从服务器正在连接主服务器。</p>
<p><strong><em>Copying to tmp table on disk</em></strong>：由于临时结果集大于tmp_table_size，正在将临时表从内存存储转为磁盘存储以此节省内存。</p>
<p><strong><em>Creating tmp table</em></strong>：正在创建临时表以存放部分查询结果。</p>
<p><strong><em>deleting from main table</em></strong>：服务器正在执行多表删除中的第一部分，刚删除第一个表。</p>
<p><strong><em>deleting from reference tables</em></strong>：服务器正在执行多表删除中的第二部分，正在删除其他表的记录。</p>
<p><strong><em>Flushing tables</em></strong>：正在执行FLUSH TABLES，等待其他线程关闭数据表。</p>
<p><strong><em>Killed</em></strong>：发送了一个kill请求给某线程，那么这个线程将会检查kill标志位，同时会放弃下一个kill请求。MySQL会在每次的主循环中检查kill标志位，不过有些情况下该线程可能会过一小段才能死掉。如果该线程程被其他线程锁住了，那么kill请求会在锁释放时马上生效。</p>
<p><strong><em>Locked</em></strong>：被其他查询锁住了。</p>
<p><strong><em>Sending data</em></strong>：正在处理SELECT查询的记录，同时正在把结果发送给客户端。</p>
<p><strong><em>Sorting for group</em></strong>：正在为GROUP BY做排序。</p>
<p><strong><em>Sorting for order</em></strong>：正在为ORDER BY做排序。</p>
<p><strong><em>Opening tables</em></strong>：这个过程应该会很快，除非受到其他因素的干扰。例如，在执ALTER TABLE或LOCK TABLE语句行完以前，数据表无法被其他线程打开。正尝试打开一个表。</p>
<p><strong><em>Removing duplicates</em></strong>：正在执行一个SELECT DISTINCT方式的查询，但是MySQL无法在前一个阶段优化掉那些重复的记录。因此，MySQL需要再次去掉重复的记录，然后再把结果发送给客户端。</p>
<p><strong><em>Reopen table</em></strong>：获得了对一个表的锁，但是必须在表结构修改之后才能获得这个锁。已经释放锁，关闭数据表，正尝试重新打开数据表。</p>
<p><strong><em>Repair by sorting</em></strong>：修复指令正在排序以创建索引。</p>
<p><strong><em>Repair with keycache</em></strong>：修复指令正在利用索引缓存一个一个地创建新索引。它会比Repair by sorting慢些。</p>
<p><strong><em>Searching rows for update</em></strong>：正在讲符合条件的记录找出来以备更新。它必须在UPDATE要修改相关的记录之前就完成了。</p>
<p><strong><em>Sleeping</em></strong>：正在等待客户端发送新请求.</p>
<p><strong><em>System lock</em></strong>：正在等待取得一个外部的系统锁。如果当前没有运行多个mysqld服务器同时请求同一个表，那么可以通过增加–skip-external-locking参数来禁止外部系统锁。</p>
<p><strong><em>Upgrading lock</em></strong>：INSERT DELAYED正在尝试取得一个锁表以插入新记录。</p>
<p><strong><em>Updating</em></strong>：正在搜索匹配的记录，并且修改它们。</p>
<p><strong><em>User Lock</em></strong>：正在等待GET_LOCK()。</p>
<p><strong><em>Waiting for tables</em></strong>：该线程得到通知，数据表结构已经被修改了，需要重新打开数据表以取得新的结构。然后，为了能的重新打开数据表，必须等到所有其他线程关闭这个表。以下几种情况下会产生这个通知：FLUSH TABLES tbl_name, ALTER TABLE, RENAME TABLE, REPAIR TABLE, ANALYZE TABLE,或OPTIMIZE TABLE。</p>
<p><strong><em>waiting for handler insert</em></strong>：INSERT DELAYED已经处理完了所有待处理的插入操作，正在等待新的请求。</p>
<p>大部分状态对应很快的操作，只要有一个线程保持同一个状态好几秒钟，那么可能是有问题发生了，需要检查一下。</p>
<p>还有其他的状态没在上面中列出来，不过它们大部分只是在查看服务器是否有存在错误是才用得着。</p>
<ul>
<li>explain</li>
</ul>
<p><strong><em>table列</em></strong>：显示这一行的数据是关于哪张表的</p>
<p><strong><em>type列</em></strong>：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL</p>
<p><strong><em>possible_keys 列</em></strong>：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句</p>
<p><strong><em>key列</em></strong>：实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句 中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引</p>
<p><strong><em>key_len列</em></strong>：使用的索引的长度。在不损失精确性的情况下，长度越短越好</p>
<p><strong><em>ref列</em></strong>：显示索引的哪一列被使用了，如果可能的话，是一个常数</p>
<p><strong><em>rows列</em></strong>：MYSQL认为必须检查的用来返回请求数据的行数</p>
<p><strong><em>Extra列</em></strong>：关于MYSQL如何解析查询的额外信息。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>sql优化</tag>
      </tags>
  </entry>
  <entry>
    <title>【Mysql深入理解系列7】MVCC与BufferPool缓存机制</title>
    <url>/2021/05/11/mysql/mysql_deep_7/</url>
    <content><![CDATA[<h2 id="MVCC与BufferPool"><a href="#MVCC与BufferPool" class="headerlink" title="MVCC与BufferPool"></a>MVCC与BufferPool</h2><ol>
<li>Undo 日志版本链与ReadView机制详解。</li>
<li>MVCC多版本并发控制详解。</li>
<li>Innodb引擎BufferPoll缓存机制详解。</li>
<li>Redo与Undo日志详解。</li>
</ol>
<h2 id="MVCC多版本并发控制机制"><a href="#MVCC多版本并发控制机制" class="headerlink" title="MVCC多版本并发控制机制"></a>MVCC多版本并发控制机制</h2><ul>
<li><p>Undo日志版本链</p>
<p>事务开始时候会生成一个Undo日志。包括数据值，事务ID。<br>Redview活跃的事务列表。</p>
</li>
</ul>
<p>ReadView 可见，不可见</p>
<p><img src="https://images.lilhui.com/594f8a7c21a2fb8500ab6bf155f8e190" alt="图片"></p>
<p>在可重复读隔离级别，当事务开启，执行任何查询sql时会生成当前事务的一致性视图read-view，该视图在事务结束之前都不会变化(如果是读已提交隔离级别在每次执行查询sql时都会重新生成)，这个视图由执行查询时所有未提交事务id数组（数组里最小的id为min_id）和已创建的最大事务id（max_id）组成，事务里的任何sql查询结果需要从对应版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。</p>
<p>Mysql会将Undo链分成三个集合</p>
<p>已提交事务，未提交与已提交事务，未开始事务。</p>
<p><img src="https://images.lilhui.com/53f7864bd44cbd2bf09196927571ea6a" alt="图片"></p>
<h3 id="版本链对比规则"><a href="#版本链对比规则" class="headerlink" title="版本链对比规则"></a>版本链对比规则</h3><ol>
<li>如果 row 的 trx_id 落在绿色部分( trx_id&lt;min_id )，表示这个版本是已提交的事务生成的，这个数据是可见的。<br>如果 row 的 trx_id 落在红色部分( trx_id&gt;max_id )，表示这个版本是由将来启动的事务生成的，是不可见的(若row 的 trx_id 就是当前自己的事务是可见的）。</li>
<li>如果 row 的 trx_id 落在黄色部分(min_id &lt;=trx_id&lt;= max_id)，那就包括两种情况：<br>a. 若 row 的 trx_id 在视图数组中，表示这个版本是由还没提交的事务生成的，不可见(若 row 的 trx_id 就是当前自己的事务是可见的)；<br>b. 若 row 的 trx_id 不在视图数组中，表示这个版本是已经提交了的事务生成的，可见。</li>
</ol>
<h3 id="Innodb引擎BufferPool"><a href="#Innodb引擎BufferPool" class="headerlink" title="Innodb引擎BufferPool"></a>Innodb引擎BufferPool</h3><h4 id="Redo与Undo"><a href="#Redo与Undo" class="headerlink" title="Redo与Undo"></a>Redo与Undo</h4><p>BufferPool是Innodb中的一块内存，缓存池。用于更新日志时缓存数据。</p>
<p><img src="https://images.lilhui.com/d2cca03ebe91a9727cd5bf1223a4f2e7" alt="图片"></p>
<p>update数据过程。</p>
<ol>
<li>加载叶子节点到innodb引擎中。 bufferPool</li>
<li>写undo日志</li>
<li>更新缓存日志。</li>
<li>写redo日志</li>
<li>准备提交事务，redo日志写入磁盘。（commit)</li>
<li>准备提交事务，写binlog。所有存储引擎都有些binlog日志的操作。</li>
<li>写一个commit标记到redo日志。为了redo与binlog数据一致。</li>
<li>随机写入磁盘以page为单位写入。</li>
</ol>
<p>当bufferPool丢失，redo日志可以用来还原。</p>
<p>BufferPool非常重要，整个mysql的增删改查都先进过BufferPool。为什么这么设计？提高效率。基于内存效率更高。</p>
<p>BufferPool过程中会进行undo和redo的读写。这样效率高吗？</p>
<p>undo,redo是顺序写。数据库是随机写。顺序效率&gt;随机 (2倍以上性能)</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>MVCC</tag>
      </tags>
  </entry>
  <entry>
    <title>SP image 128G 1.0版本发布 RG350M专用</title>
    <url>/2021/08/29/opendingux/spimge1/</url>
    <content><![CDATA[<h2 id="SP-image-1-0"><a href="#SP-image-1-0" class="headerlink" title="SP image 1.0"></a>SP image 1.0</h2><p>在开源掌机圈不误正业了很久，一直在寻找一款软件硬件兼备的理想掌机。但是以目前的市场状况,希望渺茫。与其等商家完善，不如自己动手，于是本人基于 Simplemenu 9.0 + 官方底包整合了一个 128G 镜像，完成很久了，虽然还有一些不完善的地方，但是玩着还不错。独乐乐，不如众乐乐，发布出来一起交流体验。感谢所有为开源软件做出努力的人。本镜像禁止商用！！</p>
<h2 id="镜像特性："><a href="#镜像特性：" class="headerlink" title="镜像特性："></a>镜像特性：</h2><h3 id="前端："><a href="#前端：" class="headerlink" title="前端："></a>前端：</h3><ul>
<li>底包基于官方包</li>
<li>基于Simplemenu9.0</li>
<li>支持中文游戏列表。</li>
<li>支持三种主题：EpicCody，GBA35Remix,OA</li>
</ul>
<h4 id="快捷键说明"><a href="#快捷键说明" class="headerlink" title="快捷键说明"></a>快捷键说明</h4><ol>
<li>开始：调出设置屏幕。</li>
<li>选择：Rom 选项。让我们选择自动启动、模拟器（如果为所选部分定义了多个模拟器）和超频。</li>
<li>上：选择上一场比赛/上一节/上一组</li>
<li>向下：选择下一场比赛/下一节/下一组</li>
<li>左：跳到当前部分的上一页。</li>
<li>右：跳到当前部分的下一页。</li>
<li>R1：在菜单和全屏模式之间切换。</li>
<li>R2：刷新当前部分（以防您在菜单运行时添加了一些 ROM）。在 RFW 中使用“B+R1”。</li>
<li>A：启动游戏/程序。</li>
<li>X：在常规列表，将游戏标记为收藏，在收藏夹部分，将其从收藏夹列表中删除。</li>
<li>L2 转到藏夹列表。</li>
<li>B：<br>如果按下并松开，它会将您带回一屏。<br>如果按住，则在游戏列表中时，它充当与其他键组合的热键</li>
<li>B + 左：跳到上一个字母。</li>
<li>B + 右：跳到下一个字母。</li>
<li>B + Up：转到上一部分，不显示徽标。</li>
<li>B + 向下：转到下一部分，不显示徽标。</li>
<li>B+选择：随机选择。</li>
<li>B + X：删除选定的 rom，无需确认。不适用于收藏夹部分或应用和游戏部分。</li>
<li>B + A：如果模拟器支持作为独立应用程序运行，则启动模拟器本身而不是 rom。</li>
<li>游戏列表页面按住select可以选择执行的模拟器。目前以下有多个模拟器选择<ol>
<li>MD</li>
<li>GBA</li>
<li>SNES</li>
<li>FBA</li>
</ol>
</li>
</ol>
<h3 id="模拟器："><a href="#模拟器：" class="headerlink" title="模拟器："></a>模拟器：</h3><ol>
<li>移植了fba-a320 三国战纪等游戏满帧。（可以在游戏列表按select进行切换模拟器）</li>
<li>pocketsnes 修复浪漫沙迦，圣剑传说3字体显示（感谢CC的技术支持）</li>
<li>picodrive 升级到1.97</li>
<li>fba 拳皇等游戏硬件拉升，可以全屏。不会有右边的竖纹。</li>
</ol>
<h3 id="ROM"><a href="#ROM" class="headerlink" title="ROM:"></a>ROM:</h3><ol>
<li>所有ROM名字以第一个拼音字母开头。在游戏列表按B+上，下 进行索引。</li>
<li>snes,nes，GBA,FBA 适配了几百个金手指。方便游玩。（部分金手指可能无效）</li>
</ol>
<h2 id="部分截图"><a href="#部分截图" class="headerlink" title="部分截图"></a>部分截图</h2><ul>
<li>游戏截图</li>
</ul>
<p><img src="https://images.lilhui.com/5e6c48f4407a1b7c8d60769d12690898" alt="图片"></p>
<ul>
<li>金手指</li>
</ul>
<p><img src="https://images.lilhui.com/f0cdf5d5e460317f3b455a5f61e108c4" alt="图片"></p>
<ul>
<li>拳皇97硬件拉升支持全屏</li>
</ul>
<p><img src="https://images.lilhui.com/67c67fc18d28785279aeff01ee206ccd" alt="图片"></p>
<ul>
<li><p>封面Logo<br><img src="https://images.lilhui.com/f78dd6c53989f836bfd91941ca0efd5e" alt="图片"></p>
</li>
<li><p>前端设置</p>
</li>
</ul>
<p><img src="https://images.lilhui.com/028e35ca11509b8882656dc8b2ed268f" alt="图片"></p>
<ul>
<li>选择模拟器（select)</li>
</ul>
<p><img src="https://images.lilhui.com/5d53d9f4bb6ce97abfbcafde7a37de0d" alt="图片"></p>
<ul>
<li>收藏夹（L2)</li>
</ul>
<p><img src="https://images.lilhui.com/604d1e36a9c847c4fa9ab524d2026ac5" alt="图片"></p>
<ul>
<li>FBA街机Logo</li>
</ul>
<p><img src="https://images.lilhui.com/c4fd3e9186227d32742ad50db2efdc69" alt="图片"></p>
<ul>
<li>游戏列表中文</li>
</ul>
<p><img src="https://images.lilhui.com/3466ad0aa40e58603f6ba02410f0c606" alt="图片"></p>
<h2 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h2><p>链接：<a href="https://pan.baidu.com/s/1QkROboHxoFIjIm59sVGuhg" target="_blank" rel="noopener">https://pan.baidu.com/s/1QkROboHxoFIjIm59sVGuhg</a><br>提取码：87bs</p>
<p>本镜像用于玩家交流使用，禁止商用！！</p>
]]></content>
      <categories>
        <category>opendingux</category>
      </categories>
      <tags>
        <tag>开源掌机</tag>
        <tag>simplemenu</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构介绍</title>
    <url>/2017/09/18/redis/Redisshujujiegou/</url>
    <content><![CDATA[<h2 id="Redis数据结构介绍"><a href="#Redis数据结构介绍" class="headerlink" title="Redis数据结构介绍"></a>Redis数据结构介绍</h2><blockquote>
<p>Redis数据结构分为 STRING,LIST,SET,HASH,ZSET五种。与其他数据库或者缓存有相互对应关系。又有他自己的特点。</p>
</blockquote>
<table>
<thead>
<tr>
<th>结构类型</th>
<th>值类型</th>
<th>读写能力</th>
</tr>
</thead>
<tbody>
<tr>
<td>STRING</td>
<td>字符串，整数，浮点数，基本类型</td>
<td>对整个字符串或者字符串其中的一部分进行操作，对整数和浮点数进行自增或者自减</td>
</tr>
<tr>
<td>LIST</td>
<td>一个链表，链表上的每个节点都包含了一个字符串</td>
<td>从链表的两端推入或者弹出元素，根据偏移量对链表进行修剪，读取单个或者多个元素；根据值查找或者移除元素</td>
</tr>
<tr>
<td>SET</td>
<td>包含字符串的无序搜集器（unordered collection)，并且被包含的每个字符串都是独一无二，各不相同的</td>
<td>添加，获取，移除单个元素；检查一个元素是否存在于集合中；计算交集，并集，差集；从集合里随机获取元素</td>
</tr>
<tr>
<td>HASH</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、移除单个键值对；获取所有键值对</td>
</tr>
<tr>
<td>ZSET(有序集合)</td>
<td>字符串成员（member）与浮点数值（score）之间的有序映射，元素的排列顺序由分值的大小决定</td>
<td>添加、获取、删除、单个元素；根据分值范围（染个）或者成员来获取元素</td>
</tr>
</tbody>
</table>
<h3 id="字符串（STRING"><a href="#字符串（STRING" class="headerlink" title="字符串（STRING)"></a>字符串（STRING)</h3><p>基本操作：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>获取存储在给定键值中的值</td>
</tr>
<tr>
<td>SET</td>
<td>设置存储在给定键中的值</td>
</tr>
<tr>
<td>DEL</td>
<td>删除存储在给定键中的值（所有类型适用）</td>
</tr>
</tbody>
</table>
<h3 id="列表（List"><a href="#列表（List" class="headerlink" title="列表（List)"></a>列表（List)</h3><p>基本操作：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>RPUSH</td>
<td>给定的值推入列表的右端</td>
</tr>
<tr>
<td>LRANGE</td>
<td>获取列表在给定范围上的所有值</td>
</tr>
<tr>
<td>LINDEX</td>
<td>获取在列表给定位置上的单个元素</td>
</tr>
<tr>
<td>LPOP</td>
<td>从列表的左端弹出一个值，并返回被弹出的值</td>
</tr>
</tbody>
</table>
<h3 id="集合（SET）"><a href="#集合（SET）" class="headerlink" title="集合（SET）"></a>集合（SET）</h3><blockquote>
<p>和集合一样可以存储多个字符串，不同的是 列表中可以村粗多个相同的字符串。而集合则通过使用散列来保证自己存储的每个字符串都是各自不同的（这些散列只有键没有键值）</p>
</blockquote>
<p>基本操作：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>SADD</td>
<td>将给定元素添加到集合</td>
</tr>
<tr>
<td>SMEMBERS</td>
<td>返回集合包含的所有元素</td>
</tr>
<tr>
<td>SISMEMBER</td>
<td>检查给定元素是存在于集合中</td>
</tr>
<tr>
<td>SREM</td>
<td>如果给定的元素存在于集合中，那么移除这个元素</td>
</tr>
</tbody>
</table>
<p>另外的操作<br>SINTER,SUNION, SDIFF 分别执行交集计算、并集计算和差集计算。</p>
<h3 id="散列（HASH）"><a href="#散列（HASH）" class="headerlink" title="散列（HASH）"></a>散列（HASH）</h3><blockquote>
<p>Redis的散列可以存储多个键值间的映射。其值，可以是字符串有可以是数字值。也可以对散列存储的值进行自增或自减。</p>
</blockquote>
<blockquote>
<p>散列在很多方面就是一个缩小版的Redis，不少字符串都有相应的散列版本。</p>
</blockquote>
<p>基本操作：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>HSET</td>
<td>在散列里面关联起给定的键值对</td>
</tr>
<tr>
<td>HGET</td>
<td>获取指定散列键的值</td>
</tr>
<tr>
<td>HGETALL</td>
<td>获取散列包含所有键值对</td>
</tr>
<tr>
<td>HDEL</td>
<td>如果给定键存在于散列里，那么移除这个键</td>
</tr>
</tbody>
</table>
<p>Redis的散列可以看做文档数据库里的文档，在开发过程中可以很好的对应。在关系书库里可以看做关系数据库里的行。散列、文档、数据行这三者都允许用户同时访问或者修改一个火多个域。</p>
<h3 id="有序集（ZSET）"><a href="#有序集（ZSET）" class="headerlink" title="有序集（ZSET）"></a>有序集（ZSET）</h3><blockquote>
<p>和散列一样，有序集都用于存储键值对：有序集合的键称为 成员（member）每个成员都各不相同；有序集的值被称为分值（score）必须为浮点数。是唯一一个可以根据成员访问元素，又可以根据分值以及分值的排序来访问元素的结构。</p>
</blockquote>
<p>基本操作：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZADD</td>
<td>将一个带有给定成分值的成员添加到有序集合里</td>
</tr>
<tr>
<td>ZRANGE</td>
<td>根据元素在有序排列中所处处的位置，从有序集合中获取多个元素</td>
</tr>
<tr>
<td>ZRANGEBYSCORE</td>
<td>获取有序集合给定分值范围内的所有属性</td>
</tr>
<tr>
<td>ZREM</td>
<td>如果给定成员存在，移除这个成员</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>缓存</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis简介</title>
    <url>/2017/09/26/redis/redis_2/</url>
    <content><![CDATA[<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><blockquote>
<p>Redis 是一个非常快速的非关系内存型数据库。Redis非常有区分度的是它提供的5种不同类型的数据结构，其数据结构是有针对地为解决问题而生的数据结构，区分于其他数据库的一个显著特点。可以说，Redis核心问题和功能都围绕着五种数据结构展开的，另外，它方便的扩展功能，可以支持到数百GB级数据。</p>
</blockquote>
<h3 id="与其他数据库和软件的对比"><a href="#与其他数据库和软件的对比" class="headerlink" title="与其他数据库和软件的对比"></a>与其他数据库和软件的对比</h3><p> Redis的特点决定了它在存储工具里的定位，它经常被用来与其他数据库进行对比。这里，我们介于内存键值存储 Memcached 与MongoDB对Redis进行一次比较。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>存储</th>
<th>查询</th>
<th>附加功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Redis</td>
<td>内存存储（in-memmory)的非关系数据库</td>
<td>字符串,列表，集合，散列表，有序集合</td>
<td>每种数据类型都有自己的专属命令，还有批操作和不完整的事务支持</td>
<td>发布与订阅，主从复制，持久化，脚本</td>
</tr>
<tr>
<td>Memcached</td>
<td>使用内存存储的键值缓存</td>
<td>键值之间的映射</td>
<td>创建，读取，更新删除等命令</td>
<td>多线程服务支持</td>
</tr>
<tr>
<td>MongoDB</td>
<td>硬盘存储的非关系文档存储</td>
<td>每个数据库可以包含多个个表，每个表包含多个schema 的BSON文档</td>
<td>更新，读取，删除，条件查询等命令</td>
<td>支持map-reduce操作，主从复制，分片，空间索引（spatial index）</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="使用Redis的理由"><a href="#使用Redis的理由" class="headerlink" title="使用Redis的理由"></a>使用Redis的理由</h3><p>Redis之于缓存界：使用memcached 时，没有原生的列表结构，只能用Append命令将数据添加到已有字符串末尾。可以认为那个字符串就是一个列表。但是删除这些就比较困难了。memcached采用的办法是通过黑名单来隐藏列表里的元素，从而避免对元素进行读取，更新，写入。相反地，Redis的LIST和SET允许用户直接添加或者删除元素。</p>
<hr>
<p>Redis之于数据库：当数据库用于存储长期数据报告，报表。并将这些数据作为固定时间范围内聚合。数据库的做法是：将各个行插入一个报表中，通过扫描这些行进行聚合数据。这样就要频繁地对表里数据进行</p>
<hr>
<p>读，写。Redis可以使用原子的INCR命令来进行聚合计算。并且Redis存储在内存里。并且查询不通过数据库的分析器，查询优化器等，所以对Redis存储的数据行随机写的速度是非常迅速的。<br>Redis之于NoSql数据库：避免写入不必要的临时数据。免去了临时数据进行扫描删除的麻烦。可以改上程序的性能。</p>
]]></content>
  </entry>
  <entry>
    <title>Spring boot gateway 网关压测时配置异常，导致服务返回405</title>
    <url>/2022/12/01/bugfix/bugfix_1/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>网关选用的是Spring-boot-gateway，网关配置使用nacos持久化。</p>
<h2 id="Spring的网关源码分析"><a href="#Spring的网关源码分析" class="headerlink" title="Spring的网关源码分析"></a>Spring的网关源码分析</h2><p>通过网关的源码分析，StripPrefixGatewayFilterFactory 通过parts值来截断请求的前缀。正常的是1，在执行过程中被刷新成了5。导致截断请求错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.running.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">     # 30s 触发一次定时任务</span><br><span class="line">      <span class="keyword">this</span>.watchFuture = <span class="keyword">this</span>.taskScheduler.scheduleWithFixedDelay(</span><br><span class="line">            <span class="keyword">this</span>::nacosServicesWatch, <span class="keyword">this</span>.properties.getWatchDelay());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nacosServicesWatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 此处nacos 啥都没干, 就强制发送一个更新命令, 正常情况需要判断 service 是否存在更新</span></span><br><span class="line">   <span class="comment">// 因此此处可以作为修复bug的触发点</span></span><br><span class="line">   <span class="comment">// nacos doesn't support watch now , publish an event every 30 seconds.</span></span><br><span class="line">   <span class="keyword">this</span>.publisher.publishEvent(</span><br><span class="line">         <span class="keyword">new</span> HeartbeatEvent(<span class="keyword">this</span>, nacosWatchIndex.getAndIncrement()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="路由配置刷新机制"><a href="#路由配置刷新机制" class="headerlink" title="路由配置刷新机制"></a>路由配置刷新机制</h2><p>Spring gateway 启动后会缓存路由配置，并且，每隔30秒会从缓存刷新配置到具体的路由执行类。<br>在刷新路由配置的方法里加入了监控日志：<br>RouteDefinitionRouteLocator.loadGatewayFilters</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ConfigurationUtils.bind(configuration, properties,</span><br><span class="line">      factory.shortcutFieldPrefix(), definition.getName(), validator);</span><br><span class="line"></span><br><span class="line">if (configuration instanceof StripPrefixGatewayFilterFactory.Config) &#123;</span><br><span class="line">   StripPrefixGatewayFilterFactory.Config stripConfig = (StripPrefixGatewayFilterFactory.Config)configuration;</span><br><span class="line">   if (stripConfig.getParts() &gt; 2) &#123;</span><br><span class="line">      String errorMessage = &quot;parts 异常：&quot; +  stripConfig.getParts()</span><br><span class="line">            + &quot;definition:&quot; + definition</span><br><span class="line">            + &quot;properties:&quot; + properties</span><br><span class="line">            + &quot;id:&quot; + id;</span><br><span class="line">      log.error(errorMessage, new RuntimeException(errorMessage));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>properties 是个Map，存放的是待刷新的part值，configuration 是被刷新的配置类，有一个属性 int parts。通过网关通过ConfigurationUtils.bind 来注入 configuration中的parts值。<br>以上代码修改后的异常日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2022-07-15 13:46:38,233 - parts 异常：5definition:FilterDefinition&#123;name=&apos;StripPrefix&apos;, args=&#123;parts=1&#125;&#125;properties:&#123;parts=1&#125;id:pay-api-web</span><br><span class="line">java.lang.RuntimeException: parts 异常：5definition:FilterDefinition&#123;name=&apos;StripPrefix&apos;, args=&#123;parts=1&#125;&#125;properties:&#123;parts=1&#125;id:pay-api-web</span><br><span class="line">	at org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator.loadGatewayFilters(RouteDefinitionRouteLocator.java:183)</span><br><span class="line">	at org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator.getFilters(RouteDefinitionRouteLocator.java:212)</span><br><span class="line">	at org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator.convertToRoute(RouteDefinitionRouteLocator.java:143)</span><br><span class="line">	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:100)</span><br><span class="line">	at reactor.core.publisher.FluxFlatMap$FlatMapMain.drainLoop(FluxFlatMap.java:664)</span><br></pre></td></tr></table></figure>
<p>可以看到在绑定后的 值是5. 但是properties里的是 {parts=1}。 说明bug发生在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ConfigurationUtils.bind(configuration, properties,</span><br><span class="line">      factory.shortcutFieldPrefix(), definition.getName(), validator);</span><br></pre></td></tr></table></figure>
<p>这一行ConfigurationUtils.bind 调用的是Spring 底层JavaBeanBinder的bind方法<br>进一步分析JavaBeanBinder.bind</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private &lt;T&gt; boolean bind(BeanSupplier&lt;T&gt; beanSupplier, BeanPropertyBinder propertyBinder, BeanProperty property) &#123;</span><br><span class="line">   String propertyName = property.getName();</span><br><span class="line">   ResolvableType type = property.getType();</span><br><span class="line">   Supplier&lt;Object&gt; value = property.getValue(beanSupplier);</span><br><span class="line">   Annotation[] annotations = property.getAnnotations();</span><br><span class="line">   //这行在设置后返回bound=5。有错！</span><br><span class="line">   Object bound = propertyBinder.bindProperty(propertyName,</span><br><span class="line">         Bindable.of(type).withSuppliedValue(value).withAnnotations(annotations));</span><br><span class="line">   if (bound == null) &#123;</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line">   if (property.isSettable()) &#123;</span><br><span class="line">      property.setValue(beanSupplier, bound);</span><br><span class="line">   &#125;</span><br><span class="line">   else if (value == null || !bound.equals(value.get())) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;No setter found for property: &quot; + property.getName());</span><br><span class="line">   &#125;</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object bound = propertyBinder.bindProperty(propertyName,</span><br><span class="line">         Bindable.of(type).withSuppliedValue(value).withAnnotations(annotations));</span><br></pre></td></tr></table></figure>
<p>JavaBeanBinder 是spring boot底层bean属性处理类。</p>
<h2 id="bind过程分析"><a href="#bind过程分析" class="headerlink" title="bind过程分析"></a>bind过程分析</h2><p>propertyBinder.bindProperty的后续调用链路<br>-&gt;Binder.bind<br>-&gt;BindConverter.cover<br>-&gt;TypeConverterSupport.convertIfNecessary<br>-&gt;TypeConverterSupport.doConvertValue<br>-&gt;TypeConverterSupport.doConvertTextValue</p>
<p>doConvertTextValue方法有两行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">editor.setAsText(newTextValue);</span><br><span class="line">return editor.getValue();</span><br></pre></td></tr></table></figure>
<p>editor是通过PropertyEditorRegistrySupport.createDefaultEditors()初始化，一个类型一个对象。在执行的时候通过propertyEditorRegistry.getDefaultEditor(requiredType)获取。 如果requiredType相同，获取的就是同一个对象。<br>所以当有2次调用获取的editor相同，就可能有并发问题。时序如下：<br>A：editor.setAsText(1)<br>B：editor.setAsText(5)<br>A: return editor.getValue();<br>此时A获取到的就是5。与期望的值不同。造成执行错误。</p>
<h2 id="错误分析总结"><a href="#错误分析总结" class="headerlink" title="错误分析总结"></a>错误分析总结</h2><ol>
<li>spring cloud gateway和nacos30秒一次心跳，每次心跳会从内存中刷新路由规则到执行对象。<br>刷新过程调用的是ConfigurationUtils.bind方法，此方法依赖的PropertyEditor。对象对于每个类型是单例的，如果同时有2个相同类型的值进行bind，可能产生并发问题。</li>
<li>压测时gateway的负载高。RouteDefinitionRouteLocator.getRoutes()方法并发调用RouteDefinitionRouteLocator.loadGatewayFilters。</li>
<li>RouteDefinitionRouteLocator.loadGatewayFilters依赖的方法ConfigurationUtils.bind有并发问题 导致路由配置错乱。</li>
</ol>
<h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p>重现方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactoryAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.FilterDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.OrderedGatewayFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.factory.GatewayFilterFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.factory.StripPrefixGatewayFilterFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.factory.StripPrefixGatewayFilterFactory.Config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.support.ConfigurationUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.support.HasRouteId;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.spel.standard.SpelExpressionParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ActiveProfiles;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.Validator;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/7/18 22:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span>()</span></span><br><span class="line">@ActiveProfiles("local")</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteDefinitionRouteLocatorTest</span>   <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   Logger logger = LoggerFactory.getLogger(RouteDefinitionRouteLocatorTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> Validator validator;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> SpelExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;GatewayFilterFactory&gt; gatewayFilterFactoryList;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, GatewayFilterFactory&gt; gatewayFilterFactories = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">concurrentTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * assume we have below gateway route config</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       - id: r1</span></span><br><span class="line"><span class="comment">       uri: lb://service1</span></span><br><span class="line"><span class="comment">       predicates:</span></span><br><span class="line"><span class="comment">       - Path=/gateway/auth/**</span></span><br><span class="line"><span class="comment">       filters:</span></span><br><span class="line"><span class="comment">       - StripPrefix=1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - id: r2</span></span><br><span class="line"><span class="comment">       uri: lb://service2</span></span><br><span class="line"><span class="comment">       predicates:</span></span><br><span class="line"><span class="comment">       - Path=/gateway/api/business/**</span></span><br><span class="line"><span class="comment">       filters:</span></span><br><span class="line"><span class="comment">       - StripPrefix=2</span></span><br><span class="line"><span class="comment">       * then we can construct the  FilterDefinition to mock this config</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      FilterDefinition f1 = <span class="keyword">new</span> FilterDefinition();</span><br><span class="line">      f1.setName(<span class="string">"StripPrefix"</span>);</span><br><span class="line">      f1.setArgs(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">      f1.getArgs().put(<span class="string">"_genkey_0"</span>, <span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">      FilterDefinition f2 = <span class="keyword">new</span> FilterDefinition();</span><br><span class="line">      f2.setName(<span class="string">"Retry"</span>);</span><br><span class="line">      f2.setArgs(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">      f2.getArgs().put(<span class="string">"retries"</span>, <span class="string">"5"</span>);</span><br><span class="line"></span><br><span class="line">      Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">               loadGatewayFilters(<span class="string">"r1"</span>, Lists.newArrayList(f1));</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;, <span class="string">"prefix1"</span>);</span><br><span class="line"></span><br><span class="line">      Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">               loadGatewayFilters(<span class="string">"r2"</span>, Lists.newArrayList(f2));</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;, <span class="string">"prefix2"</span>);</span><br><span class="line"></span><br><span class="line">      Thread t22 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">               loadGatewayFilters(<span class="string">"r2"</span>, Lists.newArrayList(f2));</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;, <span class="string">"prefix2"</span>);</span><br><span class="line"></span><br><span class="line">      Thread t11 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">               loadGatewayFilters(<span class="string">"r1"</span>, Lists.newArrayList(f1));</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;, <span class="string">"prefix1"</span>);</span><br><span class="line"></span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">      t11.start();</span><br><span class="line">      t22.start();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (t1.isInterrupted() || t11.isInterrupted() || t2.isInterrupted() || t22.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function">List&lt;GatewayFilter&gt; <span class="title">loadGatewayFilters</span><span class="params">(String id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          List&lt;FilterDefinition&gt; filterDefinitions)</span> </span>&#123;</span><br><span class="line">      ArrayList&lt;GatewayFilter&gt; ordered = <span class="keyword">new</span> ArrayList&lt;&gt;(filterDefinitions.size());</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filterDefinitions.size(); i++) &#123;</span><br><span class="line">         FilterDefinition definition = filterDefinitions.get(i);</span><br><span class="line">         GatewayFilterFactory factory = <span class="keyword">this</span>.gatewayFilterFactories</span><br><span class="line">                 .get(definition.getName());</span><br><span class="line">         <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"Unable to find GatewayFilterFactory with name "</span></span><br><span class="line">                            + definition.getName());</span><br><span class="line">         &#125;</span><br><span class="line">         Map&lt;String, String&gt; args = definition.getArgs();</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"RouteDefinition "</span> + id + <span class="string">" applying filter "</span> + args + <span class="string">" to "</span></span><br><span class="line">                    + definition.getName());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         Map&lt;String, Object&gt; properties = factory.shortcutType().normalize(args,</span><br><span class="line">                 factory, <span class="keyword">this</span>.parser, <span class="keyword">this</span>.beanFactory);</span><br><span class="line"></span><br><span class="line">         Object configuration = factory.newConfig();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*          //加锁解决</span></span><br><span class="line"><span class="comment">            synchronized (this) &#123;</span></span><br><span class="line"><span class="comment">                ConfigurationUtils.bind(configuration, properties,</span></span><br><span class="line"><span class="comment">                        factory.shortcutFieldPrefix(), definition.getName(), validator);</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line"></span><br><span class="line">         ConfigurationUtils.bind(configuration, properties,</span><br><span class="line">                 factory.shortcutFieldPrefix(), definition.getName(), validator);</span><br><span class="line">         <span class="comment">// some filters require routeId</span></span><br><span class="line">         <span class="comment">// <span class="doctag">TODO:</span> is there a better place to apply this?</span></span><br><span class="line">         <span class="keyword">if</span> (configuration <span class="keyword">instanceof</span> HasRouteId) &#123;</span><br><span class="line">            HasRouteId hasRouteId = (HasRouteId) configuration;</span><br><span class="line">            hasRouteId.setRouteId(id);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         GatewayFilter gatewayFilter = factory.apply(configuration);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//asset statement start</span></span><br><span class="line">         <span class="keyword">if</span> (configuration <span class="keyword">instanceof</span> StripPrefixGatewayFilterFactory.Config) &#123;</span><br><span class="line">            <span class="keyword">int</span> parts = ((Config) configuration).getParts();</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.equals(<span class="string">"r1"</span>, id) &amp;&amp; !StringUtils.equals(<span class="string">"1"</span>, String.valueOf(parts))) &#123;</span><br><span class="line">               logger.error(<span class="string">"for router id r1,expect parts is 1,but actual is &#123;&#125;"</span>, parts);</span><br><span class="line">               Thread.currentThread().interrupt();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(<span class="string">"r2"</span>, id) &amp;&amp; !StringUtils</span><br><span class="line">                    .equals(<span class="string">"5"</span>, String.valueOf(parts))) &#123;</span><br><span class="line">               logger.error(<span class="string">"for router id r2,expect parts is 2,but actual is &#123;&#125;"</span>, parts);</span><br><span class="line">               Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//asset statement end</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (gatewayFilter <span class="keyword">instanceof</span> Ordered) &#123;</span><br><span class="line">            ordered.add(gatewayFilter);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ordered.add(<span class="keyword">new</span> OrderedGatewayFilter(gatewayFilter, i + <span class="number">1</span>));</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> ordered;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Before</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      gatewayFilterFactoryList.forEach(</span><br><span class="line">              factory -&gt; <span class="keyword">this</span>.gatewayFilterFactories.put(factory.name(), factory));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>bug</category>
      </categories>
      <tags>
        <tag>gateway</tag>
      </tags>
  </entry>
  <entry>
    <title>秒杀系统架构优化思路</title>
    <url>/2018/05/17/http/http_2/</url>
    <content><![CDATA[<p>本文曾在“架构师之路”上发布过，近期支援Qcon-AS大会，在微信群里分享了该话题，故对原文进行重新整理与发布。</p>
<h3 id="一、秒杀业务为什么难做"><a href="#一、秒杀业务为什么难做" class="headerlink" title="一、秒杀业务为什么难做"></a>一、秒杀业务为什么难做</h3><p>1）im系统，例如qq或者微博，每个人都读自己的数据（好友列表、群列表、个人信息）；</p>
<p>2）微博系统，每个人读你关注的人的数据，一个人读多个人的数据；</p>
<p>3）秒杀系统，库存只有一份，所有人会在集中的时间读和写这些数据，多个人读一个数据。</p>
<p>例如：小米手机每周二的秒杀，可能手机只有1万部，但瞬时进入的流量可能是几百几千万。</p>
<p>又例如：12306抢票，票是有限的，库存一份，瞬时流量非常多，都读相同的库存。读写冲突，锁非常严重，这是秒杀业务难的地方。那我们怎么优化秒杀业务的架构呢？</p>
<h3 id="二、优化方向"><a href="#二、优化方向" class="headerlink" title="二、优化方向"></a>二、优化方向</h3><p>优化方向有两个（今天就讲这两个点）：</p>
<p>（1）将请求尽量拦截在系统上游（不要让锁冲突落到数据库上去）。传统秒杀系统之所以挂，请求都压倒了后端数据层，数据读写锁冲突严重，并发高响应慢，几乎所有请求都超时，流量虽大，下单成功的有效流量甚小。以12306为例，一趟火车其实只有2000张票，200w个人来买，基本没有人能买成功，请求有效率为0。</p>
<p>（2）充分利用缓存，秒杀买票，这是一个典型的读多些少的应用场景，大部分请求是车次查询，票查询，下单和支付才是写请求。一趟火车其实只有2000张票，200w个人来买，最多2000个人下单成功，其他人都是查询库存，写比例只有0.1%，读比例占99.9%，非常适合使用缓存来优化。好，后续讲讲怎么个“将请求尽量拦截在系统上游”法，以及怎么个“缓存”法，讲讲细节。</p>
<h3 id="三、常见秒杀架构"><a href="#三、常见秒杀架构" class="headerlink" title="三、常见秒杀架构"></a>三、常见秒杀架构</h3><p>常见的站点架构基本是这样的（绝对不画忽悠类的架构图）</p>
<p>（1）浏览器端，最上层，会执行到一些JS代码</p>
<p>（2）站点层，这一层会访问后端数据，拼html页面返回给浏览器</p>
<p>（3）服务层，向上游屏蔽底层数据细节，提供数据访问</p>
<p>（4）数据层，最终的库存是存在这里的，mysql是一个典型（当然还有会缓存）</p>
<p>这个图虽然简单，但能形象的说明大流量高并发的秒杀业务架构，大家要记得这一张图。</p>
<p>后面细细解析各个层级怎么优化。</p>
<h3 id="四、各层次优化细节"><a href="#四、各层次优化细节" class="headerlink" title="四、各层次优化细节"></a>四、各层次优化细节</h3><h4 id="第一层，客户端怎么优化（浏览器层，APP层）"><a href="#第一层，客户端怎么优化（浏览器层，APP层）" class="headerlink" title="第一层，客户端怎么优化（浏览器层，APP层）"></a>第一层，客户端怎么优化（浏览器层，APP层）</h4><p>问大家一个问题，大家都玩过微信的摇一摇抢红包对吧，每次摇一摇，就会往后端发送请求么？回顾我们下单抢票的场景，点击了“查询”按钮之后，系统那个卡呀，进度条涨的慢呀，作为用户，我会不自觉的再去点击“查询”，对么？继续点，继续点，点点点。。。有用么？平白无故的增加了系统负载，一个用户点5次，80%的请求是这么多出来的，怎么整？</p>
<p>（a）产品层面，用户点击“查询”或者“购票”后，按钮置灰，禁止用户重复提交请求；</p>
<p>（b）JS层面，限制用户在x秒之内只能提交一次请求；</p>
<p>APP层面，可以做类似的事情，虽然你疯狂的在摇微信，其实x秒才向后端发起一次请求。这就是所谓的“将请求尽量拦截在系统上游”，越上游越好，浏览器层，APP层就给拦住，这样就能挡住80%+的请求，这种办法只能拦住普通用户（但99%的用户是普通用户）对于群内的高端程序员是拦不住的。firebug一抓包，http长啥样都知道，js是万万拦不住程序员写for循环，调用http接口的，这部分请求怎么处理？</p>
<h4 id="第二层，站点层面的请求拦截"><a href="#第二层，站点层面的请求拦截" class="headerlink" title="第二层，站点层面的请求拦截"></a>第二层，站点层面的请求拦截</h4><p>怎么拦截？怎么防止程序员写for循环调用，有去重依据么？ip？cookie-id？…想复杂了，这类业务都需要登录，用uid即可。在站点层面，对uid进行请求计数和去重，甚至不需要统一存储计数，直接站点层内存存储（这样计数会不准，但最简单）。一个uid，5秒只准透过1个请求，这样又能拦住99%的for循环请求。</p>
<p>5s只透过一个请求，其余的请求怎么办？缓存，页面缓存，同一个uid，限制访问频度，做页面缓存，x秒内到达站点层的请求，均返回同一页面。同一个item的查询，例如车次，做页面缓存，x秒内到达站点层的请求，均返回同一页面。如此限流，既能保证用户有良好的用户体验（没有返回404）又能保证系统的健壮性（利用页面缓存，把请求拦截在站点层了）。</p>
<p>页面缓存不一定要保证所有站点返回一致的页面，直接放在每个站点的内存也是可以的。优点是简单，坏处是http请求落到不同的站点，返回的车票数据可能不一样，这是站点层的请求拦截与缓存优化。</p>
<p>好，这个方式拦住了写for循环发http请求的程序员，有些高端程序员（黑客）控制了10w个肉鸡，手里有10w个uid，同时发请求（先不考虑实名制的问题，小米抢手机不需要实名制），这下怎么办，站点层按照uid限流拦不住了。</p>
<h4 id="第三层-服务层来拦截（反正就是不要让请求落到数据库上去）"><a href="#第三层-服务层来拦截（反正就是不要让请求落到数据库上去）" class="headerlink" title="第三层 服务层来拦截（反正就是不要让请求落到数据库上去）"></a>第三层 服务层来拦截（反正就是不要让请求落到数据库上去）</h4><p>服务层怎么拦截？大哥，我是服务层，我清楚的知道小米只有1万部手机，我清楚的知道一列火车只有2000张车票，我透10w个请求去数据库有什么意义呢？没错，请求队列！</p>
<p>对于写请求，做请求队列，每次只透有限的写请求去数据层（下订单，支付这样的写业务）</p>
<p>1w部手机，只透1w个下单请求去db</p>
<p>3k张火车票，只透3k个下单请求去db</p>
<p>如果均成功再放下一批，如果库存不够则队列里的写请求全部返回“已售完”。</p>
<p>对于读请求，怎么优化？cache抗，不管是memcached还是redis，单机抗个每秒10w应该都是没什么问题的。如此限流，只有非常少的写请求，和非常少的读缓存mis的请求会透到数据层去，又有99.9%的请求被拦住了。</p>
<p>当然，还有业务规则上的一些优化。回想12306所做的，分时分段售票，原来统一10点卖票，现在8点，8点半，9点，…每隔半个小时放出一批：将流量摊匀。</p>
<p>其次，数据粒度的优化：你去购票，对于余票查询这个业务，票剩了58张，还是26张，你真的关注么，其实我们只关心有票和无票？流量大的时候，做一个粗粒度的“有票”“无票”缓存即可。</p>
<p>第三，一些业务逻辑的异步：例如下单业务与 支付业务的分离。这些优化都是结合 业务 来的，我之前分享过一个观点“一切脱离业务的架构设计都是耍流氓”架构的优化也要针对业务。</p>
<p>好了，最后是数据库层</p>
<p>浏览器拦截了80%，站点层拦截了99.9%并做了页面缓存，服务层又做了写请求队列与数据缓存，每次透到数据库层的请求都是可控的。db基本就没什么压力了，闲庭信步，单机也能扛得住，还是那句话，库存是有限的，小米的产能有限，透这么多请求来数据库没有意义。</p>
<p>全部透到数据库，100w个下单，0个成功，请求有效率0%。透3k个到数据，全部成功，请求有效率100%。</p>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>上文应该描述的非常清楚了，没什么总结了，对于秒杀系统，再次重复下我个人经验的两个架构优化思路：</p>
<p>（1）尽量将请求拦截在系统上游（越上游越好）；</p>
<p>（2）读多写少的常用多使用缓存（缓存抗读压力）；</p>
<p>浏览器和APP：做限速</p>
<p>站点层：按照uid做限速，做页面缓存</p>
<p>服务层：按照业务做写请求队列控制流量，做数据缓存</p>
<p>数据层：闲庭信步</p>
<p>并且：结合业务做优化</p>
<h3 id="六、Q-amp-A"><a href="#六、Q-amp-A" class="headerlink" title="六、Q&amp;A"></a>六、Q&amp;A</h3><p>问题1、按你的架构，其实压力最大的反而是站点层，假设真实有效的请求数有1000万，不太可能限制请求连接数吧，那么这部分的压力怎么处理？</p>
<p>答：每秒钟的并发可能没有1kw，假设有1kw，解决方案2个：</p>
<p>（1）站点层是可以通过加机器扩容的，最不济1k台机器来呗。</p>
<p>（2）如果机器不够，抛弃请求，抛弃50%（50%直接返回稍后再试），原则是要保护系统，不能让所有用户都失败。</p>
<p>问题2、“控制了10w个肉鸡，手里有10w个uid，同时发请求” 这个问题怎么解决哈？</p>
<p>答：上面说了，服务层写请求队列控制</p>
<p>问题3：限制访问频次的缓存，是否也可以用于搜索？例如A用户搜索了“手机”，B用户搜索“手机”，优先使用A搜索后生成的缓存页面？</p>
<p>答：这个是可以的，这个方法也经常用在“动态”运营活动页，例如短时间推送4kw用户app-push运营活动，做页面缓存。</p>
<p>问题4：如果队列处理失败，如何处理？肉鸡把队列被撑爆了怎么办？</p>
<p>答：处理失败返回下单失败，让用户再试。队列成本很低，爆了很难吧。最坏的情况下，缓存了若干请求之后，后续请求都直接返回“无票”（队列里已经有100w请求了，都等着，再接受请求也没有意义了）</p>
<p>问题5：站点层过滤的话，是把uid请求数单独保存到各个站点的内存中么？如果是这样的话，怎么处理多台服务器集群经过负载均衡器将相同用户的响应分布到不同服务器的情况呢？还是说将站点层的过滤放到负载均衡前？</p>
<p>答：可以放在内存，这样的话看似一台服务器限制了5s一个请求，全局来说（假设有10台机器），其实是限制了5s 10个请求，解决办法：</p>
<p>1）加大限制（这是建议的方案，最简单）</p>
<p>2）在nginx层做7层均衡，让一个uid的请求尽量落到同一个机器上</p>
<p>问题6：服务层过滤的话，队列是服务层统一的一个队列？还是每个提供服务的服务器各一个队列？如果是统一的一个队列的话，需不需要在各个服务器提交的请求入队列前进行锁控制？</p>
<p>答：可以不用统一一个队列，这样的话每个服务透过更少量的请求（总票数/服务个数），这样简单。统一一个队列又复杂了。</p>
<p>问题7：秒杀之后的支付完成，以及未支付取消占位，如何对剩余库存做及时的控制更新？</p>
<p>答：数据库里一个状态，未支付。如果超过时间，例如45分钟，库存会重新会恢复（大家熟知的“回仓”），给我们抢票的启示是，开动秒杀后，45分钟之后再试试看，说不定又有票哟~</p>
<p>问题8：不同的用户浏览同一个商品 落在不同的缓存实例显示的库存完全不一样 请问老师怎么做缓存数据一致或者是允许脏读？</p>
<p>答：目前的架构设计，请求落到不同的站点上，数据可能不一致（页面缓存不一样），这个业务场景能接受。但数据库层面真实数据是没问题的。</p>
<p>问题9：就算处于业务把优化考虑“3k张火车票，只透3k个下单请求去db”那这3K个订单就不会发生拥堵了吗？</p>
<p>答：（1）数据库抗3k个写请求还是ok的；（2）可以数据拆分；（3）如果3k扛不住，服务层可以控制透过去的并发数量，根据压测情况来吧，3k只是举例；</p>
<p>问题10；如果在站点层或者服务层处理后台失败的话，需不需要考虑对这批处理失败的请求做重放？还是就直接丢弃？</p>
<p>答：别重放了，返回用户查询失败或者下单失败吧，架构设计原则之一是“fail fast”。</p>
<p>问题11.对于大型系统的秒杀，比如12306，同时进行的秒杀活动很多，如何分流？</p>
<p>答：垂直拆分</p>
<p>问题12、额外又想到一个问题。这套流程做成同步还是异步的？如果是同步的话，应该还存在会有响应反馈慢的情况。但如果是异步的话，如何控制能够将响应结果返回正确的请求方？</p>
<p>答：用户层面肯定是同步的（用户的http请求是夯住的），服务层面可以同步可以异步。</p>
<p>问题13、秒杀群提问：减库存是在那个阶段减呢？如果是下单锁库存的话，大量恶意用户下单锁库存而不支付如何处理呢？</p>
<p>答：数据库层面写请求量很低，还好，下单不支付，等时间过完再“回仓”，之前提过了。</p>
]]></content>
      <categories>
        <category>系统架构</category>
      </categories>
      <tags>
        <tag>秒杀，高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>网站QPS,TPS 预估方法</title>
    <url>/2018/05/17/http/http_tps/</url>
    <content><![CDATA[<h4 id="QPS-TPS是每秒响应的查询数量或处理的事务数量"><a href="#QPS-TPS是每秒响应的查询数量或处理的事务数量" class="headerlink" title="QPS/TPS是每秒响应的查询数量或处理的事务数量"></a>QPS/TPS是每秒响应的查询数量或处理的事务数量</h4><h4 id="一、TPS："><a href="#一、TPS：" class="headerlink" title="一、TPS："></a>一、TPS：</h4><p>Transactions Per Second（每秒传输的事物处理个数），即服务器每秒处理的事务数。TPS包括一条消息入和一条消息出，加上一次用户数据库访问。（业务TPS = CAPS × 每个呼叫平均TPS）</p>
<p>TPS是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</p>
<p>一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。系统整体处理能力取决于处理能力较低模块的TPS值。</p>
<h4 id="二、QPS："><a href="#二、QPS：" class="headerlink" title="二、QPS："></a>二、QPS：</h4><p>每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。</p>
<p>对应fetches/sec，即每秒的响应请求数，也即是较大吞吐能力</p>
<p>======================================================================================================</p>
<p>QPS = req/sec = 请求数/秒</p>
<p>【QPS计算PV和机器的方式】</p>
<p>QPS统计方式 [一般使用 http_load 进行统计]<br>QPS = 总请求数 / ( 进程总数 *   请求时间 )<br>QPS: 单个进程每秒请求服务器的成功次数</p>
<p>单台服务器每天PV计算<br>公式1：每天总PV = QPS <em> 3600 </em> 6<br>公式2：每天总PV = QPS <em> 3600 </em> 8</p>
<p>服务器计算<br>服务器数量 =   ceil( 每天总PV / 单台服务器每天总PV )</p>
<p>【峰值QPS和机器计算公式】</p>
<p>原理：每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间<br>公式：( 总PV数 <em> 80% ) / ( 每天秒数 </em> 20% ) = 峰值时间每秒请求数(QPS)<br>机器：峰值时间每秒QPS / 单台机器的QPS   = 需要的机器</p>
<ul>
<li>问：每天300w PV 的在单台机器上，这台机器需要多少QPS？<br>答：( 3000000 <em> 0.8 ) / (86400 </em> 0.2 ) = 139 (QPS)</li>
</ul>
<p>问：如果一台机器的QPS是58，需要几台机器来支持？<br>答：139 / 58 = 3</p>
<p>PS：下面是性能测试的主要概念和计算公式，记录下：<br>一．系统吞度量要素：<br>  一个系统的吞度量（承压能力）与request对CPU的消耗、外部接口、IO等等紧密关联。单个reqeust 对CPU消耗越高，外部系统接口、IO影响速度越慢，系统吞吐能力越低，反之越高。<br>系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间<br>        QPS（TPS）：每秒钟request/事务 数量<br>        并发数： 系统同时处理的request/事务数<br>        响应时间：  一般取平均响应时间<br>（很多人经常会把并发数和TPS理解混淆）<br>理解了上面三个要素的意义之后，就能推算出它们之间的关系：<br>QPS（TPS）= 并发数/平均响应时间    或者   并发数 = QPS<em>平均响应时间<br>        一个典型的上班签到系统，早上8点上班，7点半到8点的30分钟的时间里用户会登录签到系统进行签到。公司员工为1000人，平均每个员上登录签到系统的时长为5分钟。可以用下面的方法计算。<br>QPS = 1000/(30</em>60) 事务/秒<br>平均响应时间为 = 5<em>60  秒<br>并发数= QPS</em>平均响应时间 = 1000/(30<em>60) </em>(5*60)=166.7<br>        一个系统吞吐量通常由QPS（TPS）、并发数两个因素决定，每套系统这两个值都有一个相对极限值，在应用场景访问压力下，只要某一项达到系统较高值，系统的吞吐量就上不去了，如果压力继续增大，系统的吞吐量反而会下降，原因是系统超负荷工作，上下文切换、内存等等其它消耗导致系统性能下降。<br>决定系统响应时间要素<br>我们做项目要排计划，可以多人同时并发做多项任务，也可以一个人或者多个人串行工作，始终会有一条关键路径，这条路径就是项目的工期。<br>系统一次调用的响应时间跟项目计划一样，也有一条关键路径，这个关键路径是就是系统影响时间；<br>关键路径是有CPU运算、IO、外部系统响应等等组成。<br>二．系统吞吐量评估：<br>我们在做系统设计的时候就需要考虑CPU运算、IO、外部系统响应因素造成的影响以及对系统性能的初步预估。<br>而通常境况下，我们面对需求，我们评估出来的出来QPS、并发数之外，还有另外一个维度：日PV。<br>通过观察系统的访问日志发现，在用户量很大的情况下，各个时间周期内的同一时间段的访问流量几乎一样。比如工作日的每天早上。只要能拿到日流量图和QPS我们就可以推算日流量。<br>通常的技术方法：</p>
<pre><code>1. 找出系统的较高TPS和日PV，这两个要素有相对比较稳定的关系（除了放假、季节性因素影响之外）
2. 通过压力测试或者经验预估，得出较高TPS，然后跟进1的关系，计算出系统较高的日吞吐量。B2B中文和淘宝面对的客户群不一样，这两个客户群的网络行为不应用，他们之间的TPS和PV关系比例也不一样。
</code></pre><p>A)淘宝<br>淘宝流量图：</p>
<p>淘宝的TPS和PV之间的关系通常为  较高TPS：PV大约为 1 : 11<em>3600 （相当于按较高TPS访问11个小时，这个是商品详情的场景，不同的应用场景会有一些不同）<br>B) B2B中文站<br>B2B的TPS和PV之间的关系不同的系统不同的应用场景比例变化比较大，粗略估计在1 : 8个小时左右的关系（09年对offerdetail的流量分析数据）。旺铺和offerdetail这两个比例相差很大，可能是因为爬虫暂的比例较高的原因导致。<br>在淘宝环境下，假设我们压力测试出的TPS为100，那么这个系统的日吞吐量=100</em>11*3600=396万<br>这个是在简单（单一url）的情况下，有些页面，一个页面有多个request，系统的实际吞吐量还要小。<br>无论有无思考时间（T_think），测试所得的TPS值和并发虚拟用户数(U_concurrent)、Loadrunner读取的交易响应时间（T_response）之间有以下关系（稳定运行情况下）：<br>TPS=U_concurrent / (T_response+T_think)。<br>并发数、QPS、平均响应时间三者之间关系</p>
<p>   上图横坐标是并发用户数。绿线是CPU使用率；紫线是吞吐量，即QPS；蓝线是时延。<br>    开始，系统只有一个用户，CPU工作肯定是不饱合的。一方面该服务器可能有多个cpu，但是只处理单个进程，另一方面，在处理一个进程中，有些阶段可能是IO阶段，这个时候会造成CPU等待，但是有没有其他请 求进程可以被处理）。随着并发用户数的增加，CPU利用率上升，QPS相应也增加（公式为QPS=并发用户数/平均响应时间。）随着并发用户数的增加，平均响应时间也在增加，而且平均响应时间的增加是一个指数增加曲线。而当并发数增加到很大时，每秒钟都会有很多请求需要处理，会造成进程（线程）频繁切换，反正真正用于处理请求的时间变少，每秒能够处 理的请求数反而变少，同时用户的请求等待时间也会变大，甚至超过用户的心理底线。<br>来源：<a href="http://www.cnblogs.com/jackei/" target="_blank" rel="noopener">http://www.cnblogs.com/jackei/</a><br>软件性能测试的基本概念和计算公式<br>一、软件性能的关注点<br>对一个软件做性能测试时需要关注那些性能呢？<br>我们想想在软件设计、部署、使用、维护中一共有哪些角色的参与，然后再考虑这些角色各自关注的性能点是什么，作为一个软件性能测试工程师，我们又该关注什么？<br>首先，开发软件的目的是为了让用户使用，我们先站在用户的角度分析一下，用户需要关注哪些性能。<br>对于用户来说，当点击一个按钮、链接或发出一条指令开始，到系统把结果已用户感知的形式展现出来为止，这个过程所消耗的时间是用户对这个软件性能的直观印象。也就是我们所说的响应时间，当相应时间较小时，用户体验是很好的，当然用户体验的响应时间包括个人主观因素和客观响应时间，在设计软件时，我们就需要考虑到如何更好地结合这两部分达到用户较佳的体验。如：用户在大数据量查询时，我们可以将先提取出来的数据展示给用户，在用户看的过程中继续进行数据检索，这时用户并不知道我们后台在做什么。<br>用户关注的是用户操作的相应时间。<br>其次，我们站在管理员的角度考虑需要关注的性能点。<br>1、 相应时间<br>2、 服务器资源使用情况是否合理<br>3、 应用服务器和数据库资源使用是否合理<br>4、 系统能否实现扩展<br>5、 系统最多支持多少用户访问、系统较大业务处理量是多少<br>6、 系统性能可能存在的瓶颈在哪里<br>7、 更换那些设备可以提高性能<br>8、 系统能否支持7×24小时的业务访问<br>再次，站在开发（设计）人员角度去考虑。<br>1、 架构设计是否合理<br>2、 数据库设计是否合理<br>3、 代码是否存在性能方面的问题<br>4、 系统中是否有不合理的内存使用方式<br>5、 系统中是否存在不合理的线程同步方式<br>6、 系统中是否存在不合理的资源竞争<br>那么站在性能测试工程师的角度，我们要关注什么呢？<br>一句话，我们要关注以上所有的性能点。<br>二、软件性能的几个主要术语<br>1、响应时间：对请求作出响应所需要的时间<br>网络传输时间：N1+N2+N3+N4<br>应用服务器处理时间：A1+A3<br>数据库服务器处理时间：A2<br>响应时间=N1+N2+N3+N4+A1+A3+A2<br>2、并发用户数的计算公式<br>系统用户数：系统额定的用户数量，如一个OA系统，可能使用该系统的用户总数是5000个，那么这个数量，就是系统用户数。<br>同时在线用户数：在一定的时间范围内，较大的同时在线用户数量。<br>同时在线用户数=每秒请求数RPS（吞吐量）+并发连接数+平均用户思考时间<br>平均并发用户数的计算：C=nL / T<br>其中C是平均的并发用户数，n是平均每天访问用户数（login session），L是一天内用户从登录到退出的平均时间（login session的平均时间），T是考察时间长度（一天内多长时间有用户使用系统）<br>并发用户数峰值计算：C^约等于C + 3<em>根号C<br>其中C^是并发用户峰值，C是平均并发用户数，该公式遵循泊松分布理论。<br>3、吞吐量的计算公式<br>指单位时间内系统处理用户的请求数<br>从业务角度看，吞吐量可以用：请求数/秒、页面数/秒、人数/天或处理业务数/小时等单位来衡量<br>从网络角度看，吞吐量可以用：字节/秒来衡量<br>对于交互式应用来说，吞吐量指标反映的是服务器承受的压力，他能够说明系统的负载能力<br>以不同方式表达的吞吐量可以说明不同层次的问题，例如，以字节数/秒方式可以表示数要受网络基础设施、服务器架构、应用服务器制约等方面的瓶颈；已请求数/秒的方式表示主要是受应用服务器和应用代码的制约体现出的瓶颈。<br>当没有遇到性能瓶颈的时候，吞吐量与虚拟用户数之间存在一定的联系，可以采用以下公式计算：F=VU </em> R /<br>其中F为吞吐量，VU表示虚拟用户个数，R表示每个虚拟用户发出的请求数，T表示性能测试所用的时间<br>4、性能计数器<br>是描述服务器或操作系统性能的一些数据指标，如使用内存数、进程时间，在性能测试中发挥着“监控和分析”的作用，尤其是在分析统统可扩展性、进行新能瓶颈定位时有着非常关键的作用。<br>资源利用率：指系统各种资源的使用情况，如cpu占用率为68%，内存占用率为55%，一般使用“资源实际使用/总的资源可用量”形成资源利用率。<br>5、思考时间的计算公式<br>Think Time，从业务角度来看，这个时间指用户进行操作时每个请求之间的时间间隔，而在做新能测试时，为了模拟这样的时间间隔，引入了思考时间这个概念，来更加真实的模拟用户的操作。<br>在吞吐量这个公式中F=VU <em> R / T说明吞吐量F是VU数量、每个用户发出的请求数R和时间T的函数，而其中的R又可以用时间T和用户思考时间TS来计算：R = T / TS<br>下面给出一个计算思考时间的一般步骤：<br>A、首先计算出系统的并发用户数<br>C=nL / T F=R×C<br>B、统计出系统平均的吞吐量<br>F=VU </em> R / T R×C = VU <em> R / T<br>C、统计出平均每个用户发出的请求数量<br>R=u</em>C*T/VU<br>D、根据公式计算出思考时间<br>TS=T/R</p>
]]></content>
      <categories>
        <category>系统架构</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>TPS</tag>
      </tags>
  </entry>
  <entry>
    <title>许式伟、张宴——系统架构运维思路对话</title>
    <url>/2018/07/10/java/java_4/</url>
    <content><![CDATA[<h3 id="许式伟：作为系统架构师，您一般会从哪些方面来保证网站的高可用性（降低故障时间）？"><a href="#许式伟：作为系统架构师，您一般会从哪些方面来保证网站的高可用性（降低故障时间）？" class="headerlink" title="许式伟：作为系统架构师，您一般会从哪些方面来保证网站的高可用性（降低故障时间）？"></a>许式伟：作为系统架构师，您一般会从哪些方面来保证网站的高可用性（降低故障时间）？</h3><p>张宴：很多因素都会导致网站发生故障，从而影响网站的高可用性，比如服务器硬件故障、软件系统故障、IDC机房故障、程序上线前测试未发现的Bug、遭受分布式攻击、突发访问人数剧增等。</p>
<p>一套良好的网站系统架构，应该尽可能地避免只有一台服务器、一个数据库、一套软件节点等单点故障的存在。单点故障一旦发生，将直接导致网站服务不可用，恢复正常服务所需的时间也比较长，甚至还可能无法恢复。负载均衡集群、双节点热备、分布式处理等都可以用来解决单点故障，比如提供相同业务的Web服务器、MySQL数据库从库，都可以构建负载均衡集群。一旦集群中的一台服务器、一个服务出现故障，自动实时摘除，对用户来说是不可感知的，不会影响到整个网站的访问，可以为运维工程师留下足够的时间去排查和解决故障。</p>
<p>对于重要的MySQL数据库主库，我们习惯于从硬件层和软件层来实现热备，避免单点。越是复杂的设备，发生故障的概率越大。在磁盘没有损坏的情况下，应用程序导致服务器宕机的概率，远高于简单的磁盘阵列宕机的概率。所以，从硬件层解决的话，可以在两台服务器上安装相同的数据库版本、进行相同的配置，用SAS或SCSI线连接一台磁盘阵列，将数据库数据文件存放到盘阵上。正常情况下用服务器A挂载盘阵分区，启动MySQL，绑定虚拟IP；如果服务器A宕机，则用服务器B挂载盘阵分区，启动MySQL，接管虚拟IP。从软件层解决的话，则可以借助DRBD等软件做镜像。（主从同步，负载均衡、高可用、缓存）</p>
<p>IDC机房发生故障的概率较小，但如果发生的话，影响面也是最大的。如果所有服务器都托管在一个IDC机房，一旦该机房遭遇长时间流量攻击、断电、断网、地方政策性封网等，通常只能联系IDC去处理，除此之外束手无策，解决时间也比较长。如果成本允许，将网站服务器分布在两个以上的IDC机房，当某个IDC发生故障时，可以临时切换DNS域名解析来优先恢复服务。</p>
<p>虽然程序代码上线前，经过了测试人员的严格测试，但测试环境和生产环境毕竟有差异，所以一些会急剧影响性能、正常服务的Bug往往在程序上线之后，才会被发现，这就要求我们在发现Bug后，能够迅速回滚到上一正常版本。我们在SVN的基础上，开发了Web代码发布系统，会将每个发布版本之间的文件变更记录下来，一键实现程序代码在多台Web服务器上的发布和回滚。</p>
<p>遭遇DDOS分布式拒绝服务攻击，使用防火墙来对付半连接、假IP，还算比较容易。而那种专挑复杂动态应用程序URL进行的分布式CC攻击，来源为真实IP、真实HTTP请求，具有模拟正规浏览器User-Agent、单个IP的每秒请求数不高、有成千上万个攻击源等特征，很难与正常访问区分开，比较难对付。但是，正常通过浏览器访问一个URL，会加载该URL中引入的JavaScript脚本、CSS样式、图片等文件。遇到CC攻击，需要及时分析日志，找出访问量异常上涨的URL，然后用事先写好的shell脚本找出哪些IP的请求只访问了该URL，而不加载该URL引入的文件，对这些IP进行自动封锁。</p>
<p>系统架构设计时，需要事先考虑到高于目前访问量多少倍的突发访问。对于网游站点来说，访问量受广告集中时间段投放、线上活动的影响较大，带宽峰值时间不固定，对于静态内容，可以使用商业CDN，按实际使用量计费。对于动态内容，如果遇到突发访问人数剧增，超过现有服务器处理能力，最简单的临时处理办法就是增加服务器。上架新服务器需要时间，但是，同一个IDC机房内，可以借助其他业务的服务器，在不同端口开启一组新进程，加入到原有负载均衡池中。另外，可以临时关闭一些Web中的次要功能，来减少服务器消耗。</p>
<h3 id="许式伟：您在任务切分上，有什么经验分享？您通过哪些手段保证任务的独立性？"><a href="#许式伟：您在任务切分上，有什么经验分享？您通过哪些手段保证任务的独立性？" class="headerlink" title="许式伟：您在任务切分上，有什么经验分享？您通过哪些手段保证任务的独立性？"></a>许式伟：您在任务切分上，有什么经验分享？您通过哪些手段保证任务的独立性？</h3><p>张宴：相信很多人都遇到过这种情况：在一个老项目上修改、增加一些新功能所花费的时间，不比重新来做一个包含所有功能的新项目时间用得少。一个需要长期维护的项目，不可避免地会面临老员工的离职、新员工的接手，很多时候，项目代码的可维护性将决定一个项目的生存周期。让一个新员工在规定开发时间的压力下，去面对一个文档不够详细、陌生的、功能复杂的庞大项目，短时间弄明白所有功能逻辑不是一件容易的事。所以，任务需要切分，将一个大的任务切分成一个个小模块之后，各模块之间可以做到代码独立，互不影响，可维护性也大大增强。</p>
<p>关于任务切分，我以本人今年负责的两个重要项目架构设计为例来介绍一下。在第一个项目：金山游戏官网的《用户行为分析系统》中，由于数据挖掘计算需要消耗较高的内存、CPU资源，一台服务器的处理能力不够，而商业的分布式数据仓库价格又太贵，所以，只有从程序应用中下手，进行任务切分。我们先按需要挖掘的数据指标，将整个数据挖掘任务切分成多个数据挖掘插件，每个插件可以在不同的服务器上运行，多个插件可以同时在多台服务器上。多个数据挖掘插件之间，如果用到相同的某项数据，那么，就将该项数据以冗余方式，复制几份提供给需要的插件，从而实现插件之间无交互、无关联，保证了超大数据量下插件的运算速度。</p>
<p>在第二个项目：金山游戏新版运营管理系统中，则将整个任务切分成了PHP Web管理界面、PHP Web API功能接口、C/C++中间件引擎三部分。这是一种分层结构切分，最上层的“PHP Web管理界面”调用“PHP Web API功能接口”，“PHP Web API功能接口”调用运行在游戏服务器端的“C/C++中间件引擎”，“C/C++中间件引擎”与“游戏服务器端进程”通过TCP、UDP二进制协议、信号、命令行等多种方式通信。四者之间相对独立，代码无关联，通过一层层API接口实现交互。“PHP Web管理界面”负责通用界面实现。“PHP Web API功能接口”内部，又按接入的游戏模块、子功能模块进行了更细的切分，各功能模块之间通过内部API交互。“C/C++中间件引擎”大而全，不处理具体指令，但兼容TCP、UDP、HTTP、HTTPS/SSL、信号、命令行等大多数通信方式，负责和各种类型的游戏服务端交互。这是一套完全由API接口驱动的系统架构，一款新游戏接入运营管理系统时，只需在“PHP Web API功能接口”中增加一个模块；一个游戏新管理功能的增加，只需要在“PHP Web API功能接口”中增加一个子模块。通过任务切分，将复杂功能简单化，也将原来接入一款新游戏所需要的几个月时间，缩短为1~2周。</p>
<h3 id="许式伟：您通过哪些手段，来保障产品的质量？您倾向于多久更新一次您的网站？"><a href="#许式伟：您通过哪些手段，来保障产品的质量？您倾向于多久更新一次您的网站？" class="headerlink" title="许式伟：您通过哪些手段，来保障产品的质量？您倾向于多久更新一次您的网站？"></a>许式伟：您通过哪些手段，来保障产品的质量？您倾向于多久更新一次您的网站？</h3><p>张宴：Web产品质量主要体现在架构、功能、性能、安全、代码唯一性、兼容性等方面。</p>
<p>架构方面，我会先设计一套架构方案，然后让和项目相关的人员、专家组成员参与进来，一起探讨和论证架构的利弊，提出改进意见，保证架构的可行性。所有重要项目的技术方案需要经过专家组的评估。</p>
<p>功能、性能方面，则会由专门的测试人员进行功能测试、压力测试、安全扫描，测试环境分为线下测试环境、线上准测试环境。</p>
<p>在代码唯一性方面，我们开发了一个Web配置信息管理平台及相关PHP扩展，提供给系统工程师，用于配置信息的统一管理。在新项目中，PHP程序配置文件中将不再出现MySQL、Memcached等各类IP和端口信息，统一用Web配置信息管理平台给出的变量代替。从“开发环境→线下测试环境→线上测试环境→线上正式环境”，连接的数据库各不相同，导致PHP开发工程师经常搞混淆或忘了修改，通过Web配置信息管理平台，使得PHP代码中的配置文件，在四个环境中无须作任何修改，保证了代码的一致性，降低了出错率，从而确保了产品质量。</p>
<p>在兼容性方面，我们从操作系统到PHP、MySQL版本，都保持开发环境、测试环境、线上环境的统一，所有的Web服务运行在CentOS Linux系统上。由于大多数PHP程序员习惯于在Windows上编写代码，而我们的程序中调用的一些接口、PHP扩展，只能在Linux下运行。为此，我们开发了一个小工具，可以将多名程序员在各自本机Windows上搭建的nginx虚拟主机、编写的程序文件，映射到一台Linux服务器，用Linux上的php-cgi执行Windows上的PHP代码。这样，PHP程序员修改完本机代码，保存一下，即可调试，多人之间互不影响。自己调试通过后，可以在Windows直接点击鼠标右键，将修改的代码提交到SVN版本库。</p>
<p>Web 2.0时代，讲究网站更新的实时性，动态网站不用说，静态网站的内容发布也要保证实时。我们开发了一款名为Sersync的开源软件（<a href="http://code.google.com/p/sersync/），使用Linux" target="_blank" rel="noopener">http://code.google.com/p/sersync/），使用Linux</a> 2.6内核的inotify监控Linux文件系统事件，被监听目录下如果有文件发生修改，Sersync将通过内核自动捕获到事件，并将该文件利用rsync同步到CDN源站服务器。Sersync仅仅同步发生增、删、改事件的单个文件或目录，不像rsync镜像同步那样需要比对双方服务器整个目录下数千万的文件，并且支持多线程同步，因此效率非常高。金山游戏官网的CMS内容发布系统，无论网站编辑通过Web还是FTP上传图片、视频、附件，还是系统工程师直接去CMS发布服务器上增加、修改、删除文件，干完这些事情后不用做任何处理，Sersync 会自动将发生增、删、改事件的文件同步到CDN源站服务器，并可以在文件同步完成后，自动调用CDN缓存刷新接口，主动刷新发生修改、删除的文件的访问URL。</p>
<h3 id="许式伟：您在面试时，通常关注应聘者的哪些方面？哪些问题经常会问呢？"><a href="#许式伟：您在面试时，通常关注应聘者的哪些方面？哪些问题经常会问呢？" class="headerlink" title="许式伟：您在面试时，通常关注应聘者的哪些方面？哪些问题经常会问呢？"></a>许式伟：您在面试时，通常关注应聘者的哪些方面？哪些问题经常会问呢？</h3><p>张宴：第一，需要具备岗位要求的基础技能知识，这方面我不再详述。</p>
<p>第二，注重项目经验与积累，不看重学历与工作年限。做一个项目，犹如打一场战役，身经百战，积累下来的成功经验可以让工作更得心应手，失败经验可以避免走很多弯路。</p>
<p>第三，能够在1~2个以上技术领域精通。所谓术业有专攻，能够在某几项技术领域做到精通的人，相信对于新的技术领域或者从未有过相关经验的新项目，也能够轻松胜任，做到尽善尽美。</p>
<p>第四，关注应聘者的知识广度。如今的项目，已经告别个人英雄时代，讲究团队的协作。知识面越广，尽管在非专攻领域的深度可能不够，但是，知己知彼，可以站在一个更高的角度上看问题，这对于团队协作开发、项目融合的益处是显而易见的。</p>
<p>第五，具备良好的领悟能力、思考能力、设计能力、创新能力。基础技能知识不够可以学习，经验不足可以积累，技术不精通可以钻研，知识面不广可以开拓，但要培养这四项能力，是一件非常困难的事。要打造一支优秀的团队，这四项能力不可缺少，它们的重要度甚至超过以上的四方面要求。</p>
<p>我不会经常去问固定的问题，但所问的问题，几乎都跟以上的这些方面相关。</p>
<h3 id="许式伟：您曾尝试开放自己的程序代码吗？您对中国国内开源社区的现状有何看法？"><a href="#许式伟：您曾尝试开放自己的程序代码吗？您对中国国内开源社区的现状有何看法？" class="headerlink" title="许式伟：您曾尝试开放自己的程序代码吗？您对中国国内开源社区的现状有何看法？"></a>许式伟：您曾尝试开放自己的程序代码吗？您对中国国内开源社区的现状有何看法？</h3><p>张宴：是否开源自己的程序代码，跟所在公司或部门的性质有着密切的关系。如果是在研发驱动型企业或部门，程序代码是公司生存的命脉，需要与竞争对手拼技术和保持技术领先的优势，因此，很难支持开源事业。反之，如果是在运营驱动型企业或部门，技术是用来提高运营质量、运营水平的工具之一。将纯粹的技术代码或产品，从公司的业务产品中提取出来，进行开<br>源，可以按照开源产品的要求，提高公司内部技术产品的规范化、标准化，还可以引用更广大用户的使用、反馈和意见，解决未发现的潜在Bug，改进代码质量，提升技术水平。对于提高运营质量、运营水平来说，益处多多。我也尝试开源自己的一些代码，例如简单消息队列服务HTTPSQS（<a href="http://code.google.com/p/httpsqs/）、MySQL" target="_blank" rel="noopener">http://code.google.com/p/httpsqs/）、MySQL</a> HTTP/REST客户端MySQL-UDF-HTTP（<a href="http://code.google.com/p/mysql-udf-http/），同时，也鼓励团队成员尝试开源，例如刚才提到的自动同步软件Sersync。" target="_blank" rel="noopener">http://code.google.com/p/mysql-udf-http/），同时，也鼓励团队成员尝试开源，例如刚才提到的自动同步软件Sersync。</a></p>
<p>国内的开源社区在不断壮大，很多知名互联网公司都开源了自己的一些产品，但大多数还只停留在开源产品的使用、技术交流、汉化层面，真正参与到开源产品编码中的人还是较少，很多开源产品最终还是由原作者或原公司团队维护。国内开源社区的道路仍然漫长。</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>【Redis学习1】核心数据结构与高性能原理</title>
    <url>/2022/06/29/redis/redis_core_1/</url>
    <content><![CDATA[<h2 id="Redis-单线程为什么还能这么快？"><a href="#Redis-单线程为什么还能这么快？" class="headerlink" title="Redis 单线程为什么还能这么快？"></a>Redis 单线程为什么还能这么快？</h2><p>因为它所有的数据都在内存中，所有的运算都是内存级别的运算，而且单线程避免了多线程的切换性 能损耗问题。正因为 Redis 是单线程，所以要小心使用<br>Redis 指令，对于那些耗时的指令(比如 keys)，一定要谨慎使用，一不小心就可能会导致 Redis 卡顿。</p>
<h2 id="Redis单线程如何处理那么多的并发客户端链接？"><a href="#Redis单线程如何处理那么多的并发客户端链接？" class="headerlink" title="Redis单线程如何处理那么多的并发客户端链接？"></a>Redis单线程如何处理那么多的并发客户端链接？</h2><p>Redis的<strong>IO多路复用</strong>：redis利用epoll来实现IO多路复用，将连接信息和事件放到队列中，依次放到 文件事件分派器，事件分派器将事件分发给事件处理器。</p>
<p><img src="https://images.lilhui.com/3d76aa01f1678c619f175331f40e982d" alt="图片"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看redis支持的最大连接数，在redis.conf文件中可修改<span class="comment"># maxclients 10000 </span></span></span><br><span class="line">        127.0.0.1:6379&gt; CONFIG GET maxclients </span><br><span class="line">        ##1) "maxclients" 4 </span><br><span class="line">        ##2) "10000"</span><br></pre></td></tr></table></figure>
<h2 id="一些高级命令"><a href="#一些高级命令" class="headerlink" title="一些高级命令"></a>一些高级命令</h2><p>keys: 全量遍历，用来列出所有满足特定正则字符串规则的key.性能比较差。避免使用。<br>scan: 渐进式遍历。SCAN cursor [MATCH pattern] [COUNT count]</p>
<p>scan 参数提供了三个参数，第一个是 cursor 整数值(hash桶的索引值)，第二个是 key 的正则模式， 第三个是一次遍历的key的数量(参考值，底层遍历的数量不一定)，并不是符合条件的结果数量。第 一次遍历时，cursor 值为 0，然后将返回结果中第一个整数值作为下一次遍历的 cursor。一直遍历 到返回的 cursor 值为 0 时结束。<br>注意：但是scan并非完美无瑕， 如果在scan的过程中如果有键的变化（增加、 删除、 修改） ，那 么遍历效果可能会碰到如下问题： 新增的键可能没有遍历到， 遍历出了重复的键等情况， 也就是说 scan并不能保证完整的遍历出来所有的键， 这些是我们在开发时需要考虑的。</p>
<p>Info：查看redis服务运行信息，分为 9 大块，每个块都有非常多的参数，这 9 个块分别是:</p>
<p>Server 服务器运行的环境参数<br>Clients 客户端相关信息<br>Memory 服务器运行内存统计数据<br>Persistence 持久化信息<br>Stats 通用统计数据<br>Replication 主从复制相关信息<br>CPU CPU 使用情况<br>Cluster 集群信息<br>KeySpace 键值对统计数量信息</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><img src="https://images.lilhui.com/5a5b50442717feb7d0a23dd21b64d570" alt="图片"></p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">字符串常用操作</span><br><span class="line">SET  key  value 			//存入字符串键值对</span><br><span class="line">MSET  key  value [key value ...] 	//批量存储字符串键值对</span><br><span class="line">SETNX  key  value 		//存入一个不存在的字符串键值对</span><br><span class="line">GET  key 			//获取一个字符串键值</span><br><span class="line">MGET  key  [key ...]	 	//批量获取字符串键值</span><br><span class="line">DEL  key  [key ...] 		//删除一个键</span><br><span class="line">EXPIRE  key  seconds 		//设置一个键的过期时间(秒)</span><br><span class="line"></span><br><span class="line">原子加减</span><br><span class="line">INCR  key 			//将key中储存的数字值加1</span><br><span class="line">DECR  key 			//将key中储存的数字值减1</span><br><span class="line">INCRBY  key  increment 		//将key所储存的值加上increment</span><br><span class="line">DECRBY  key  decrement 	//将key所储存的值减去decrement</span><br><span class="line"></span><br><span class="line">计数器</span><br><span class="line">INCR article:readcount:&#123;文章id&#125;</span><br><span class="line">GET article:readcount:&#123;文章id&#125; </span><br><span class="line"></span><br><span class="line">Web集群session共享</span><br><span class="line">spring session + redis实现session共享</span><br><span class="line"></span><br><span class="line">分布式系统全局序列号	</span><br><span class="line">INCRBY  orderId  1000</span><br></pre></td></tr></table></figure>
<h3 id="Hash结构"><a href="#Hash结构" class="headerlink" title="Hash结构"></a>Hash结构</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hash常用操作</span><br><span class="line">HSET  key  field  value 			//存储一个哈希表key的键值</span><br><span class="line">HSETNX  key  field  value 		//存储一个不存在的哈希表key的键值</span><br><span class="line">HMSET  key  field  value [field value ...] 	//在一个哈希表key中存储多个键值对</span><br><span class="line">HGET  key  field 				//获取哈希表key对应的field键值</span><br><span class="line">HMGET  key  field  [field ...] 		//批量获取哈希表key中多个field键值</span><br><span class="line">HDEL  key  field  [field ...] 		//删除哈希表key中的field键值</span><br><span class="line">HLEN  key				//返回哈希表key中field的数量</span><br><span class="line">HGETALL key				//返回哈希表key中所有的键值</span><br><span class="line"></span><br><span class="line">HINCRBY  key  field  increment 		//为哈希表key中field键的值加上增量increment</span><br><span class="line"></span><br><span class="line">对象缓存</span><br><span class="line">HMSET  user  &#123;userId&#125;:name  zhuge  &#123;userId&#125;:balance  1888</span><br><span class="line">HMSET  user  1:name  zhuge  1:balance  1888</span><br><span class="line">HMGET  user  1:name  1:balance</span><br></pre></td></tr></table></figure>
<p><img src="https://images.lilhui.com/8ea1cfd959c1da3d3febafbff977c492" alt="图片"><br>表内容<br><img src="https://images.lilhui.com/50e1a804785e735f677e9844230bb37d" alt="图片"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">电商购物车</span><br><span class="line">1）以用户id为key</span><br><span class="line">2）商品id为field</span><br><span class="line">3）商品数量为value</span><br><span class="line"></span><br><span class="line">购物车操作</span><br><span class="line">添加商品hset cart:1001 10088 1</span><br><span class="line">增加数量hincrby cart:1001 10088 1</span><br><span class="line">商品总数hlen cart:1001</span><br><span class="line">删除商品hdel cart:1001 10088</span><br><span class="line">获取购物车所有商品hgetall cart:1001</span><br></pre></td></tr></table></figure>
<ul>
<li>hash结构的优点<br>优点<br>1）同类数据归类整合储存，方便数据管理<br>2）相比string操作消耗内存与cpu更小<br>3）相比string储存更节省空间</li>
<li>hash结构的缺点<br>缺点<br>过期功能不能使用在field上，只能用在key上<br>Redis集群架构下不适合大规模使用</li>
</ul>
<h3 id="List结构"><a href="#List结构" class="headerlink" title="List结构"></a>List结构</h3><p><img src="https://images.lilhui.com/ff9c0592b6fc90f5b541809cbd3cb90c" alt="图片"></p>
<ul>
<li><p>常用操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">List常用操作</span><br><span class="line">LPUSH  key  value [value ...] 		//将一个或多个值value插入到key列表的表头(最左边)</span><br><span class="line">RPUSH  key  value [value ...]	 	//将一个或多个值value插入到key列表的表尾(最右边)</span><br><span class="line">LPOP  key			//移除并返回key列表的头元素</span><br><span class="line">RPOP  key			//移除并返回key列表的尾元素</span><br><span class="line">LRANGE  key  start  stop		//返回列表key中指定区间内的元素，区间以偏移量start和stop指定</span><br><span class="line"></span><br><span class="line">BLPOP  key  [key ...]  timeout	//从key列表表头弹出一个元素，若列表中没有元素，阻塞等待					timeout秒,如果timeout=0,一直阻塞等待</span><br><span class="line">BRPOP  key  [key ...]  timeout 	//从key列表表尾弹出一个元素，若列表中没有元素，阻塞等待					timeout秒,如果timeout=0,一直阻塞等待</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用场景</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">常用数据结构</span><br><span class="line">Stack(栈) = LPUSH + LPOP</span><br><span class="line">Queue(队列）= LPUSH + RPOP</span><br><span class="line">Blocking MQ(阻塞队列）= LPUSH + BRPOP</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://images.lilhui.com/ff9c0592b6fc90f5b541809cbd3cb90c" alt="图片"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">微博消息和微信公号消息</span><br><span class="line">诸葛老师关注了MacTalk，备胎说车等大V</span><br><span class="line">1）MacTalk发微博，消息ID为10018</span><br><span class="line">LPUSH  msg:&#123;诸葛老师-ID&#125;  10018</span><br><span class="line">2）备胎说车发微博，消息ID为10086</span><br><span class="line">LPUSH  msg:&#123;诸葛老师-ID&#125; 10086</span><br><span class="line">3）查看最新微博消息</span><br><span class="line">LRANGE  msg:&#123;诸葛老师-ID&#125;  0  4</span><br></pre></td></tr></table></figure>
<p><img src="https://images.lilhui.com/62e6f348f1bde713939375c504320454" alt="图片"></p>
<h3 id="Set结构"><a href="#Set结构" class="headerlink" title="Set结构"></a>Set结构</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Set常用操作</span><br><span class="line">SADD  key  member  [member ...]			//往集合key中存入元素，元素存在则忽略，</span><br><span class="line">							若key不存在则新建</span><br><span class="line">SREM  key  member  [member ...]			//从集合key中删除元素</span><br><span class="line">SMEMBERS  key					//获取集合key中所有元素</span><br><span class="line">SCARD  key					//获取集合key的元素个数</span><br><span class="line">SISMEMBER  key  member			//判断member元素是否存在于集合key中</span><br><span class="line">SRANDMEMBER  key  [count]			//从集合key中选出count个元素，元素不从key中删除</span><br><span class="line">SPOP  key  [count]				//从集合key中选出count个元素，元素从key中删除</span><br><span class="line"></span><br><span class="line">Set运算操作</span><br><span class="line">SINTER  key  [key ...] 				//交集运算</span><br><span class="line">SINTERSTORE  destination  key  [key ..]		//将交集结果存入新集合destination中</span><br><span class="line">SUNION  key  [key ..] 				//并集运算</span><br><span class="line">SUNIONSTORE  destination  key  [key ...]		//将并集结果存入新集合destination中</span><br><span class="line">SDIFF  key  [key ...] 				//差集运算</span><br><span class="line">SDIFFSTORE  destination  key  [key ...]		//将差集结果存入新集合destination中</span><br><span class="line"></span><br><span class="line">微信抽奖小程序</span><br><span class="line">1）点击参与抽奖加入集合</span><br><span class="line">SADD key &#123;userlD&#125;</span><br><span class="line">2）查看参与抽奖所有用户</span><br><span class="line">SMEMBERS key	  </span><br><span class="line">3）抽取count名中奖者</span><br><span class="line">SRANDMEMBER key [count] / SPOP key [count]</span><br></pre></td></tr></table></figure>
<p><img src="https://images.lilhui.com/a73277f489af351a18afef12a4a309ad" alt="图片"></p>
<ul>
<li>应用场景</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">微信微博点赞，收藏，标签</span><br><span class="line">1) 点赞</span><br><span class="line">SADD  like:&#123;消息ID&#125;  &#123;用户ID&#125;</span><br><span class="line">2) 取消点赞</span><br><span class="line">SREM like:&#123;消息ID&#125;  &#123;用户ID&#125;</span><br><span class="line">3) 检查用户是否点过赞</span><br><span class="line">SISMEMBER  like:&#123;消息ID&#125;  &#123;用户ID&#125;</span><br><span class="line">4) 获取点赞的用户列表</span><br><span class="line">SMEMBERS like:&#123;消息ID&#125;</span><br><span class="line">5) 获取点赞用户数 </span><br><span class="line">SCARD like:&#123;消息ID&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://images.lilhui.com/a9e7bcdfdb7f96bf0f13595f44c40792" alt="图片"></p>
<ul>
<li>集合操作<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SINTER set1 set2 set3  &#123; c &#125;</span><br><span class="line">SUNION set1 set2 set3  &#123; a,b,c,d,e &#125;</span><br><span class="line">SDIFF set1 set2 set3  &#123; a &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://images.lilhui.com/a32160b24d2b4685bad068eb3afd1ca2" alt="图片"></p>
<ul>
<li>集合操作实现微博关注模型</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">集合操作实现微博微信关注模型</span><br><span class="line">1) 诸葛老师关注的人: </span><br><span class="line"><span class="meta">zhugeSet-&gt;</span><span class="bash"> &#123;guojia, xushu&#125;</span></span><br><span class="line">2) 杨过老师关注的人:</span><br><span class="line"><span class="meta"> yangguoSet--&gt;</span><span class="bash"> &#123;zhuge, baiqi, guojia, xushu&#125;</span></span><br><span class="line">3) 郭嘉老师关注的人: </span><br><span class="line"><span class="meta">guojiaSet-&gt;</span><span class="bash"> &#123;zhuge, yangguo, baiqi, xushu, xunyu)</span></span><br><span class="line">4) 我和杨过老师共同关注: </span><br><span class="line">SINTER zhugeSet yangguoSet--&gt; &#123;guojia, xushu&#125;</span><br><span class="line">5) 我关注的人也关注他(杨过老师): </span><br><span class="line">SISMEMBER guojiaSet yangguo </span><br><span class="line">SISMEMBER xushuSet yangguo</span><br><span class="line">6) 我可能认识的人: </span><br><span class="line">SDIFF yangguoSet zhugeSet-&gt;(zhuge, baiqi&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://images.lilhui.com/a389d879e58447147e4ce1ddcab47473" alt="图片"></p>
<p><img src="https://images.lilhui.com/31491901442e1895639eab5095e5eee6" alt="图片"></p>
<ul>
<li>集合操作实现电商商品筛选</li>
</ul>
<p><img src="https://images.lilhui.com/3783a4643c2467640defa05085821cd7" alt="图片"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SADD  brand:huawei  P40</span><br><span class="line">SADD  brand:xiaomi  mi-10</span><br><span class="line">SADD  brand:iPhone iphone12</span><br><span class="line">SADD os:android  P40  mi-10</span><br><span class="line">SADD cpu:brand:intel  P40  mi-10</span><br><span class="line">SADD ram:8G  P40  mi-10  iphone12</span><br><span class="line"></span><br><span class="line">SINTER  os:android  cpu:brand:intel  ram:8G   &#123;P40，mi-10&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Zset有序集合结构"><a href="#Zset有序集合结构" class="headerlink" title="Zset有序集合结构"></a>Zset有序集合结构</h3><p><img src="https://images.lilhui.com/f693785556dbdb72de891f82df20830d" alt="图片"></p>
<ul>
<li><p>ZSet常用操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ZSet常用操作</span><br><span class="line">ZADD key score member [[score member]…]	//往有序集合key中加入带分值元素</span><br><span class="line">ZREM key member [member …]		//从有序集合key中删除元素</span><br><span class="line">ZSCORE key member 			//返回有序集合key中元素member的分值</span><br><span class="line">ZINCRBY key increment member		//为有序集合key中元素member的分值加上increment </span><br><span class="line">ZCARD key				//返回有序集合key中元素个数</span><br><span class="line">ZRANGE key start stop [WITHSCORES]	//正序获取有序集合key从start下标到stop下标的元素</span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]	//倒序获取有序集合key从start下标到stop下标的元素</span><br></pre></td></tr></table></figure>
</li>
<li><p>ZSet集合操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ZUNIONSTORE destkey numkeys key [key ...] 	//并集计算</span><br><span class="line">ZINTERSTORE destkey numkeys key [key …]	//交集计算</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用场景</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Zset集合操作实现排行榜</span><br><span class="line">1）点击新闻</span><br><span class="line">ZINCRBY  hotNews:20190819  1  守护香港</span><br><span class="line">2）展示当日排行前十</span><br><span class="line">ZREVRANGE  hotNews:20190819  0  9  WITHSCORES </span><br><span class="line">3）七日搜索榜单计算</span><br><span class="line">ZUNIONSTORE  hotNews:20190813-20190819  7 </span><br><span class="line">hotNews:20190813  hotNews:20190814... hotNews:20190819</span><br><span class="line">4）展示七日排行前十</span><br><span class="line">ZREVRANGE hotNews:20190813-20190819  0  9  WITHSCORES</span><br></pre></td></tr></table></figure>
<p><img src="https://images.lilhui.com/5c41f408bd96434d668b17cb147b8603" alt="图片"></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>【Redis学习4】redis底层核心设计原理</title>
    <url>/2022/07/06/redis/redis_core_4/</url>
    <content><![CDATA[<h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><p>simple dynamic string<br>redis 3.2以前<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> len; <span class="comment">//32 bit 0-2 32次方-1</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds</span><br></pre></td></tr></table></figure></p>
<p>redis3.2以后</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line">sdshdr5</span><br><span class="line">sdshdr8</span><br><span class="line">sdshdr16</span><br><span class="line">sdshdr32</span><br><span class="line">sdshdr64</span><br></pre></td></tr></table></figure>
<p>对sdshdr做了优化和细分;<br>内存对齐：<br><img src="https://images.lilhui.com/054ba99b9267ed34e17460afff4d24bf" alt="图片"></p>
<h3 id="key类型"><a href="#key类型" class="headerlink" title="key类型"></a>key类型</h3><p>string</p>
<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>string,hash,set, sorted set,list</p>
<ul>
<li>K-V: 是一个dict数据类型。<br>海量数据的存储：</li>
</ul>
<ol>
<li>数组: O(1)</li>
<li>链表: O(N)</li>
<li>树： long(N)</li>
</ol>
<p>arr[4]<br>hash(key) -&gt; 自然数%4 。变成索引。</p>
<p>hash(k1) % 4 = 0<br>hash(k2) % 4 = 1<br>hash(k3) % 4 = 1</p>
<p>arr[0] -&gt; (k1, v1,next -&gt; null)<br>arr[1,2] -&gt; (k3, v3, next -&gt; k2) (k2, v2, next -&gt; null)</p>
<p>当数组容量很大时，hash碰撞加剧。数据结构由数组变成了链表，时间复杂度从O(1)退化成<br>O(N) 此时需要进行扩容。</p>
<p>k2,k3碰撞了怎么办？</p>
<ol>
<li>开放地址法。</li>
<li>链表法</li>
<li>头插法（redis使用的方式）</li>
</ol>
<p>redisDB的设计<br>redis总共16个Db 索引从0-15<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    dict *expires;</span><br><span class="line">    dict *blocking_keys;</span><br><span class="line">    dict *watched_keys;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> expires_cursor;</span><br><span class="line">    <span class="built_in">list</span> *defrag_later;</span><br><span class="line">&#125; redisDb;</span><br><span class="line"></span><br><span class="line">_typedef <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span>_</span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];<span class="comment">//ht : hashTable的缩小</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators;</span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdate, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size; <span class="comment">// hashtable 容量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask; <span class="comment">//size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used; <span class="comment">//hashtable元素个数 used/size = 1</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"><span class="comment">//redis值类型对象封装 string,list,set,hash, zset</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">//约束能够对redis key进行的操作 lpush，get什么的</span></span><br><span class="line">    unsiged type:<span class="number">4</span>;  <span class="comment">// 4bit,string hash</span></span><br><span class="line">    <span class="comment">//object encoding key 支持。对应的值在redis底层用的编码形式</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// 4bit</span></span><br><span class="line">    unsigined lru:LRU_BITS;</span><br><span class="line">    <span class="comment">//管理内存，引用计数法！这里表示引用的数量。0的时候可以进行回收。</span></span><br><span class="line">    <span class="keyword">int</span> refcount;  <span class="comment">//4 byte</span></span><br><span class="line">    <span class="comment">//指向数据的地址</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;      <span class="comment">//8byte</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p>
<p>扩容方法 。原有容量 *2.<br>rehash迁移方式：1. 渐进式迁移。2. 定时迁移。</p>
<p>set xxx // set是对 string操作。所以 type xxx也是string<br>lpush xxx // lpush 操作 type xxx 是list</p>
]]></content>
  </entry>
  <entry>
    <title>【Redis学习5】redis新版本特性</title>
    <url>/2022/07/06/redis/redis_core_5/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis，新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>solr 跨数据中心复制 CDCR升级过程</title>
    <url>/2018/06/14/search/solr_3/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>公司使用solr作为底层搜索引擎已经运行好多年了。从solr的 4.*版本到现在的 6.4.1经历了若干个大版本的修改和升级。稳定性一直在提高。</p>
</blockquote>
<h3 id="SOLR-CDCR简介"><a href="#SOLR-CDCR简介" class="headerlink" title="SOLR CDCR简介"></a>SOLR CDCR简介</h3><pre><code>跨数据中心复制。是solr从6.0开始的新功能。其目标是实现两个数据集群间的备份。通过合理的二次开发，可以实现异地容灾的功能。
</code></pre><h3 id="原有架构"><a href="#原有架构" class="headerlink" title="原有架构"></a>原有架构</h3><h3 id="升级后架构"><a href="#升级后架构" class="headerlink" title="升级后架构"></a>升级后架构</h3><h3 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程</h3><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>solr</tag>
        <tag>cdcr</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch 配置解释</title>
    <url>/2018/10/31/search/es_1/</url>
    <content><![CDATA[<h2 id="elasticsearch-yml"><a href="#elasticsearch-yml" class="headerlink" title="elasticsearch.yml"></a>elasticsearch.yml</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># ======================== Elasticsearch Configuration =========================</span><br><span class="line">#</span><br><span class="line"># NOTE: Elasticsearch comes with reasonable defaults for most settings.</span><br><span class="line">#       Before you set out to tweak and tune the configuration, make sure you</span><br><span class="line">#       understand what are you trying to accomplish and the consequences.</span><br><span class="line">#</span><br><span class="line"># The primary way of configuring a node is via this file. This template lists</span><br><span class="line"># the most important settings you may want to configure for a production cluster.</span><br><span class="line">#</span><br><span class="line"># Please consult the documentation for further information on configuration options:</span><br><span class="line"># https://www.elastic.co/guide/en/elasticsearch/reference/index.html</span><br><span class="line">#</span><br><span class="line"># ---------------------------------- Cluster -----------------------------------</span><br><span class="line">#</span><br><span class="line"># Use a descriptive name for your cluster:</span><br><span class="line">#</span><br><span class="line">cluster.name: localCluster</span><br><span class="line">#</span><br><span class="line"># ------------------------------------ Node ------------------------------------</span><br><span class="line">#</span><br><span class="line"># Use a descriptive name for the node:</span><br><span class="line"># 默认从   /lib/elasticsearch-6.4.2.jar!config/names.txt选择一个</span><br><span class="line">node.name: node-1</span><br><span class="line">#</span><br><span class="line"># Add custom attributes to the node:</span><br><span class="line">#</span><br><span class="line">#node.attr.rack: r1</span><br><span class="line">#</span><br><span class="line"># ----------------------------------- Paths ------------------------------------</span><br><span class="line">#</span><br><span class="line"># Path to directory where to store the data (separate multiple locations by comma):</span><br><span class="line">#</span><br><span class="line">path.data: /Users/littlehui/WorkSpaces/Office/Search/es/search/data</span><br><span class="line">#</span><br><span class="line"># Path to log files:</span><br><span class="line">#</span><br><span class="line">path.logs: /Users/littlehui/WorkSpaces/Office/Search/es/search/logs</span><br><span class="line">#</span><br><span class="line"># ----------------------------------- Memory -----------------------------------</span><br><span class="line">#</span><br><span class="line"># Lock the memory on startup:</span><br><span class="line">#</span><br><span class="line">bootstrap.memory_lock: true</span><br><span class="line">#</span><br><span class="line"># Make sure that the heap size is set to about half the memory available</span><br><span class="line"># on the system and that the owner of the process is allowed to use this</span><br><span class="line"># limit.</span><br><span class="line">#</span><br><span class="line"># Elasticsearch performs poorly when the system is swapping the memory.</span><br><span class="line">#</span><br><span class="line"># ---------------------------------- Network -----------------------------------</span><br><span class="line">#</span><br><span class="line"># Set the bind address to a specific IP (IPv4 or IPv6):</span><br><span class="line">#</span><br><span class="line">network.host: 127.0.0.1</span><br><span class="line">#</span><br><span class="line"># Set a custom port for HTTP:</span><br><span class="line">#</span><br><span class="line">http.port: 9200</span><br><span class="line">#</span><br><span class="line"># For more information, consult the network module documentation.</span><br><span class="line">#</span><br><span class="line"># --------------------------------- Discovery ----------------------------------</span><br><span class="line">#</span><br><span class="line"># Pass an initial list of hosts to perform discovery when new node is started:</span><br><span class="line"># The default list of hosts is [&quot;127.0.0.1&quot;, &quot;[::1]&quot;]</span><br><span class="line">#</span><br><span class="line"># 当启动节点时，通过这个Ip列表进行发现，组建集群默认节点127.0.0.1，标识ipv4的回环地址</span><br><span class="line"># [::1]ipv6的回环地址</span><br><span class="line">#</span><br><span class="line"># es1.x默认组播 multicast</span><br><span class="line"># es2.x 默认单播 unicast</span><br><span class="line"># 注意：如果发现其他服务器中的es服务，可以不指定端口 （9300），如果发现同一个服务器的es服务，需要制定端口。</span><br><span class="line">#</span><br><span class="line"># 多播用于动态扩展配置</span><br><span class="line"># discovery.zen.ping.multicast</span><br><span class="line"># group,port,ttl,address</span><br><span class="line">#</span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;127.0.0.1:9300&quot;, &quot;127.0.0.1:9301&quot;, &quot;127.0.0.1:9302&quot;]</span><br><span class="line">#</span><br><span class="line"># Prevent the &quot;split brain&quot; by configuring the majority of nodes (total number of master-eligible nodes / 2 + 1):</span><br><span class="line">#</span><br><span class="line">discovery.zen.minimum_master_nodes: 2</span><br><span class="line"># 节点间心跳 秒</span><br><span class="line">discovery.zen.ping_timeout: 10</span><br><span class="line">#</span><br><span class="line"># For more information, consult the zen discovery module documentation.</span><br><span class="line">#</span><br><span class="line"># ---------------------------------- Gateway -----------------------------------</span><br><span class="line">#</span><br><span class="line"># Block initial recovery after a full cluster restart until N nodes are started:</span><br><span class="line">#</span><br><span class="line">#gateway.recover_after_nodes: 3</span><br><span class="line">#</span><br><span class="line"># For more information, consult the gateway module documentation.</span><br><span class="line">#</span><br><span class="line"># ---------------------------------- Various -----------------------------------</span><br><span class="line">#</span><br><span class="line"># Require explicit names when deleting indices:</span><br><span class="line">#</span><br><span class="line">#action.destructive_requires_name: true</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>es，配置</tag>
      </tags>
  </entry>
  <entry>
    <title>solr 的edismax插件扩展方式</title>
    <url>/2017/09/19/search/solr_2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>solr 通过插件的方式实现对edismax的支持。在熟悉了solr插件的执行流程后我，我们也可以对solr插件功能进行定制。实现更加强大的功能。</p>
</blockquote>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><ul>
<li>ExtendedDismaxQParserPlugin</li>
</ul>
<p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1505899037285.png?imageView2/2/w/531/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<ol>
<li>NamedListInitializedPlugin 作用<br>NameList作为solr存储map的方式，可以看成是一个key value容器。<br>NameListInitializedPlugin是可以通过NameList初始化的插件。只有一个init方法。接收NameList参数。</li>
<li>SolrInfoMBean 作用<br>提供Solr后台基础信息的Bean接口。<br>3：QparserPlugin<br>所有插件的父类，定义了默认方法，保存声明了所有solr已经实现的plugin。</li>
</ol>
<ul>
<li>ExtendedDismaxQparser</li>
</ul>
<p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1505899337351.png?imageView2/2/w/266/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片">  </p>
<p>ExtendDismaxQparser<br>描述edismax支持的配置和方法，集合了edismax所需功能的各种操作。并创建 ExtendedSolrDismaxQueryParser,为其提供职责更为简明的操作环境。是edismax语法支持类。</p>
<ul>
<li>ExtendSolrQueryParser</li>
</ul>
<p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1505900285118.png?imageView2/2/w/393/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<ol>
<li><p>QueryBuilder<br>lucene 提供用于创建查询器的工厂类</p>
<p>可以被当做自定义解析器的子类，使得查询解析器更容易地集成到分析链中。生成查询可以定制化。<br>所有默认lucene提供的query在这里创建</p>
</li>
</ol>
<ol start="2">
<li><p>SolrQueryParserBase<br>Solr继承自QueryBuilder的类。作为Solr标准查询解析器的父类。Solr对lucene的扩展，加入了 MagicFieldName RawQuery等支持。初始化时读入 schema配置。可以修改这个类来扩展schema标签功能。</p>
</li>
<li><p>QueryParser<br>默认的query解析器</p>
</li>
<li>SolrQueryParser<br>Solr’s 的默认查询解析器schema驱动的经典lucene查询解析方式。</li>
<li>ExtendedSolrQueryParser<br>作为ExtendedSolrQParser的内部类存在。实施最终的查询解析。</li>
</ol>
<h2 id="请求过程"><a href="#请求过程" class="headerlink" title="请求过程"></a>请求过程</h2><p>SolrDispatchFilter（doFilter,execute）</p>
<p>-&gt;SolrCore.execute</p>
<p>-&gt;RequestHandlerBase.handleRequest</p>
<p>-&gt;SearchHandler.handleRequestBody<br>//有可能执行多个Component<br>//query,facet,group等等，这里每个查询特性对应每个SearchComponent<br>-&gt;QueryComponent.process</p>
<p>-&gt;SolrIndexSearcher(search,getDocListC)  </p>
<blockquote>
<p>描述<br>edismax请求到 SearchHandler 分析调用的SearchComponent链，其中QueryComponent 通过defType选择 插件ExtendedDismaxQParserPlugin 创建queryParser初始化插件paraer</p>
</blockquote>
<p>QueryComponent prepare调用<br>QParser rqparser = QParser.getParser(rankQueryString, defType, req);<br>先解析出参数语法包含的解析器信息</p>
<p> QueryComponent 源码部分 关键方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> QParser <span class="title">getParser</span><span class="params">(String qstr, String defaultParser, SolrQueryRequest req)</span> <span class="keyword">throws</span> SyntaxError </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"> <span class="comment">//存在字符 &#123;！需要分析参数需要什么样的查询解析器选定信息</span></span><br><span class="line"> <span class="keyword">if</span> (qstr != <span class="keyword">null</span> &amp;&amp; qstr.startsWith(QueryParsing.LOCALPARAM_START)) &#123;</span><br><span class="line">   localParams = <span class="keyword">new</span> ModifiableSolrParams();</span><br><span class="line">   localParamsEnd = QueryParsing.parseLocalParams(qstr, <span class="number">0</span>, localParams, globalParams);</span><br><span class="line"></span><br><span class="line">   String val = localParams.get(QueryParsing.V);</span><br><span class="line">   <span class="keyword">if</span> (val != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// val was directly specified in localParams via v=&lt;something&gt; or v=$arg</span></span><br><span class="line">     valFollowedParams = <span class="keyword">false</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// use the remainder of the string as the value</span></span><br><span class="line">     valFollowedParams = <span class="keyword">true</span>;</span><br><span class="line">     val = qstr.substring(localParamsEnd);</span><br><span class="line">     localParams.set(QueryParsing.V, val);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//localParams 语法解析出来的localParams是否需要特殊的解析器来解析查询。</span></span><br><span class="line">  <span class="keyword">if</span> (localParams == <span class="keyword">null</span>) &#123;</span><br><span class="line">   parserName = defaultParser;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">//显示的defType与解析出来的信息一起判断优先级来选定解析器名称</span></span><br><span class="line">   parserName = localParams.get(QueryParsing.TYPE,defaultParser);</span><br><span class="line">   qstr = localParams.get(<span class="string">"v"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> parserName = parserName==<span class="keyword">null</span> ? QParserPlugin.DEFAULT_QTYPE : parserName;</span><br><span class="line"> <span class="comment">//确定后通过名称获取解析插件</span></span><br><span class="line"> QParserPlugin qplug = req.getCore().getQueryPlugin(parserName);</span><br><span class="line"> QParser parser =  qplug.createParser(qstr, localParams, req.getParams(), req);</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">return</span> parser;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>对edisMax查询操作，QueryComponet返回了 ExtendDismaxQparser 作为查询解析器作为后续的查询支持 。<br>默认解析器 lucene  </p>
<h2 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h2><p>扩展步骤：<br>1:新建 XXPlugin 继承 QParserPlugin<br> 实现方法：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义插件名称，用于配置指定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String NAME = <span class="string">"XXXqueryPlus"</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> QParser <span class="title">createParser</span><span class="params">(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XXXQParser(qstr, localParams, params, req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2:创建XXXQParser继承QParser, XXXSolrQueryParser继承SolrQueryParser<br>可以采用组合方式，也可以采用内部类的方式。在XXXQParser里重写 parser()方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Query <span class="title">parse</span><span class="params">()</span> <span class="keyword">throws</span> SyntaxError </span>&#123;</span><br><span class="line">    <span class="comment">//返回具体的 查询Query</span></span><br><span class="line">    <span class="comment">//可以结合XXXSolrQueryParser方法返回.</span></span><br><span class="line">    <span class="comment">//this.parser() --&gt; XXSolrQueryParser.parser()。</span></span><br><span class="line">    <span class="comment">//提交给 SolrQuerybase执行，只要根据需要重写 SolrQueryBase里的</span></span><br><span class="line">    <span class="comment">//    protected Query getFieldQuery(String field, String queryText, //boolean quoted, boolean raw)方法即可。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3:solrConfig里配置<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">requestHandler</span> <span class="attr">name</span>=<span class="string">"standard"</span> <span class="attr">class</span>=<span class="string">"solr.SearchHandler"</span> <span class="attr">default</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lst</span> <span class="attr">name</span>=<span class="string">"defaults"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">str</span> <span class="attr">name</span>=<span class="string">"defType"</span>&gt;</span>XXXqueryPlus<span class="tag">&lt;/<span class="name">str</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">lst</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">requestHandler</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>solr</tag>
        <tag>edismax</tag>
      </tags>
  </entry>
  <entry>
    <title>solr tlog详解</title>
    <url>/2018/07/02/search/solr_4/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>solr</tag>
        <tag>tlog</tag>
      </tags>
  </entry>
  <entry>
    <title>【tomcat调优系列2】Tomcat响应数据过程</title>
    <url>/2022/11/18/tomcat/tomcat_2/</url>
    <content><![CDATA[<h2 id="Tomcat响应数据过程"><a href="#Tomcat响应数据过程" class="headerlink" title="Tomcat响应数据过程"></a>Tomcat响应数据过程</h2><h3 id="关键部件解释"><a href="#关键部件解释" class="headerlink" title="关键部件解释"></a>关键部件解释</h3><ol>
<li>OutputStream： 用于response的输出流。Tomcat这里是CoyoteOutputStream</li>
<li>OutputBuffer: 输出流的缓冲</li>
<li>ByteChunk: OutputBuffer的一个对象，缓冲的，缓冲区。</li>
<li>ByteChunk的buff构成，大小8192.</li>
<li>ByteOutputChannel：ByteChunk的out。缓冲区的数据流向的渠道。其实就是socket.</li>
<li>realWriteBytes方法：ByteOutputChannel的方法。会把src的数据发送给对应的驱动。</li>
<li>org.apache.coyote.Response：发送逻辑</li>
</ol>
<h3 id="触发缓冲区标记的发送"><a href="#触发缓冲区标记的发送" class="headerlink" title="触发缓冲区标记的发送"></a>触发缓冲区标记的发送</h3><ol>
<li>缓冲区满的情况：ByteChunk.append -&gt; out.realWriteBytes(src,off,len)。换冲突的大小为8192 ByteChunk</li>
<li>缓冲区没满：调用outputStream.flush</li>
</ol>
<h3 id="ouputStream-flush的方法"><a href="#ouputStream-flush的方法" class="headerlink" title="ouputStream.flush的方法"></a>ouputStream.flush的方法</h3><ol>
<li>判断是否发送过响应头，没发送则发送相应头。</li>
<li>调用ByteChunk的flushBuffer方法，把缓冲区的数据发送出去。</li>
<li>发送时候是从 ByteBuffer 发送到SocketBuffer(也是ByteChunk实现的)。SocketBuffer发送给socket</li>
</ol>
<h3 id="coyoteResponse-doWrite-outputChunk"><a href="#coyoteResponse-doWrite-outputChunk" class="headerlink" title="coyoteResponse.doWrite(outputChunk)"></a>coyoteResponse.doWrite(outputChunk)</h3><ol>
<li>调用方法：outputBuffer.doWrite(chunk, this).OutputBuffer是InternalOutputBuffer。</li>
<li>该doWrite⽅法中，⾸先会判断响应头是否已经发送，如果没有发送，则会构造响应头，并发响应头发送给 socketBuffer，发送完响应头，会调⽤响应的output的activeFilters，对于不同的响应体需要使⽤不同的 发送逻辑。⽐如ChunkedOutputFilter是⽤来发送分块响应体的，IdentityOutputFilter是⽤来发送 Content-length响应体的，VoidOutputFilter不会真正的把数据发送出去。</li>
<li>在构造响应头时，会识别响应体应该通过什么OutputFilter来发送，如果响应中存在content-length那么 则使⽤IdentityOutputFilter来发送响应体，否则使⽤ChunkedOutputFilter，当然还有⼀些异常情况下会 使⽤VoidOutputFilter，表示不会发送响应体。</li>
</ol>
<h3 id="响应的Content-lenth什么时候确定"><a href="#响应的Content-lenth什么时候确定" class="headerlink" title="响应的Content-lenth什么时候确定"></a>响应的Content-lenth什么时候确定</h3><p>答案是：当请求在servlet中执⾏完成后，会调⽤response.finishResponse()⽅法，该⽅法会调⽤ outputBuffer.close()，该outputBuffer就是org.apache.catalina.connector.OutputBuffer，该⽅法会 判断响应体是否已发送，如果在调⽤这个close时响应头还没有发送，则表示响应体的数据在之前⼀直没有 发送过，⼀直存在了第⼀层缓冲区中，并且⼀直没有塞满该缓冲区，因为该缓冲区如果被塞满了，则会发 送响应头，所以当执⾏到close⽅法是，响应头还没发送过，那么缓冲区中的数据就是响应体全部的数据， 即，缓冲区数据的⻓度就是content-length。 反之，在调⽤close⽅法之前，就已经发送过数据了，那么响应头中就没有content-length，就会⽤ ChunkedOutputFilter来发送数据。</p>
<p>并且在执⾏close⽅法时，会先将响应头的数据发送给socketbuffer，然后将第⼀层缓冲区的数据通过对应 的OutputFilter发送给socketbuffer，然后调⽤OutputFilter的end⽅法，IdentityOutputFilter的end⽅ 法实现很简单，⽽ChunkedOutputFilter的end⽅法则相对做的事情更多⼀点，因为 ChunkedOutputFilter的doWrite⼀次只会发送⼀块数据，所以end要负责循环调⽤doWrite⽅法，把全部 的数据库发送完。</p>
<p>最后将socketbuffer中的数据发送给socket。</p>
]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>调优</tag>
      </tags>
  </entry>
  <entry>
    <title>【tomcat调优系列1】Tomcat的请求过程</title>
    <url>/2022/11/18/tomcat/tomcat_1/</url>
    <content><![CDATA[<h2 id="Tomcat请求过程"><a href="#Tomcat请求过程" class="headerlink" title="Tomcat请求过程"></a>Tomcat请求过程</h2><h3 id="几个部件："><a href="#几个部件：" class="headerlink" title="几个部件："></a>几个部件：</h3><ol>
<li>Endpoint： tomcat接收socket链接的组件。</li>
<li>Socket：请求的通道链接</li>
<li>InputBuffer. InternalInputBuffer,AbstractInputBuffer：缓冲内存</li>
<li>Request：请求对象</li>
<li>MessageBytes: 请求对象的消息内容</li>
<li>ByteChunk：</li>
<li>Connection：Java层面的链接对象</li>
<li>Servlet：处理请求的组件</li>
<li>Response：请求处理后的返回</li>
</ol>
<h3 id="请求过程"><a href="#请求过程" class="headerlink" title="请求过程"></a>请求过程</h3><ul>
<li>请求的解析</li>
</ul>
<ol>
<li>Endpoint接收socket链接。</li>
<li>从socket中获取数据并缓存到InputBuffer。BIO是InternalInputBuffer继承自AbstractInputBuffer</li>
<li>从InputBuffer中解析请求。将完整的请求协议和请求体封装到Request对象。</li>
<li>Request中的messageByte进行标记。标记url,header,请求体等。</li>
<li>解析头，解析请求。</li>
<li>初始化请求头的一些参数：Connextion keepalive，Content-length等。包括请求体处理的InputFilter</li>
<li>将请求交给容器</li>
</ol>
<ul>
<li>请求的处理</li>
</ul>
<ol start="8">
<li>容器将请求分发到具体的Servlet进行处理。</li>
<li>Servlet处理请求利用Response进行响应。将返回的数据写入缓冲区，调用flush或者close时，把缓冲区的数据发送给socket.</li>
<li>servlet处理完请求后，检查是否需要把响应数据发送给socket.</li>
<li>看请求体是否处理结束，是否还有剩余数据，如果有剩余数据，把这些数据处理掉。以便获取下个请求的数据。</li>
<li>回到第一步处理下一个请求。</li>
</ol>
]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>调优</tag>
      </tags>
  </entry>
  <entry>
    <title>【tomcat调优系列3】Tomcat底层BIO和NIO实现原理</title>
    <url>/2022/11/22/tomcat/tomcat_3/</url>
    <content><![CDATA[<h2 id="Tomcat-IO选择历史"><a href="#Tomcat-IO选择历史" class="headerlink" title="Tomcat IO选择历史"></a>Tomcat IO选择历史</h2><ol>
<li>Tomcat7时默认用的BIO,同步阻塞。可以通过配置修改为NIO</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"org.apache.coyote.http11.Http11Ni oProtocol"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Tomcat8.5以后默认用的是NIO.</li>
</ol>
<h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>Socket通信过程分两个部分：</p>
<ol>
<li>连接准备</li>
<li>拷贝内核缓存到用户缓存。<br>阻塞和非阻塞的概念是在连接准备阶段的描述。</li>
</ol>
<h2 id="Tomcat的BIO实现"><a href="#Tomcat的BIO实现" class="headerlink" title="Tomcat的BIO实现"></a>Tomcat的BIO实现</h2><ol>
<li>JioEndpoint的Acceptor线程负责循环阻塞接收sock连接。</li>
<li>每接收到一个socket连接就包装成SocketProcessor扔进线程池Executor.SocketProcessor是一个Runnable</li>
<li>SocketProcess负责从scoket阻塞读取数据，并且向socket中阻塞写入数据。</li>
</ol>
<p>Acceptor现成数量默认为1，可以通过acceptorThreadCount参数进行配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">name</span>=<span class="string">"tomcatThreadPool"</span> <span class="attr">namePrefix</span>=<span class="string">"catalina-exec-"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">maxThreads</span>=<span class="string">"150"</span> <span class="attr">minSpareThreads</span>=<span class="string">"4"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"org.apache.coyote.http11.Http11Ni oProtocol"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">"8443"</span> <span class="attr">executor</span>=<span class="string">"tomcatThreadPool"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>Tomcat中每个Connector都会创建一个线程池，并且默认值：</p>
<ol>
<li>最小线程数量10</li>
<li>最大线程数量20</li>
</ol>
<p>使用BIO处理请求时：</p>
<ol>
<li>当请求数量比较大时，可以提高Acceptor线程数量，提高接收请求的速率。</li>
<li>当请求比较耗时时，可以提高线程池Executor的最大线程数量。</li>
</ol>
<p>原理图：</p>
<p><img src="https://images.lilhui.com/1f62e4fafb4b3b53161a55d323656dc1" alt="图片"></p>
<h2 id="Tomcat的NIO实现"><a href="#Tomcat的NIO实现" class="headerlink" title="Tomcat的NIO实现"></a>Tomcat的NIO实现</h2><p>NIO非阻塞接收socket连接，非阻塞从socket读取数据，非阻塞将数据写入socket中。</p>
<p>在Tomcat中，只有从socket读取请求行，请求头数据时是非阻塞的。在读取请求体是阻塞的，响应数据也是阻塞的。</p>
]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>bio</tag>
        <tag>nio</tag>
      </tags>
  </entry>
  <entry>
    <title>监控URL返回非200后执行重启脚本</title>
    <url>/2022/02/11/tools/tools_1/</url>
    <content><![CDATA[<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">TARGET_ADDR=$1</span><br><span class="line">TARGET_STATE=0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while true ;do</span><br><span class="line"></span><br><span class="line">    echo `date +"%Y-%m-%d %H:%M:%S"` start access $&#123;TARGET_ADDR&#125; &gt;&gt; statusMonitor.log</span><br><span class="line">    if [ $TARGET_STATE -gt 3 ];then</span><br><span class="line">        echo `date +"%Y-%m-%d %H:%M:%S"` can not  access $&#123;TARGET_ADDR&#125; ,service will reboot!</span><br><span class="line">        echo "&amp;&amp;&amp;&amp;&amp;&amp; reboot server!"</span><br><span class="line">        nohup ~/bin/restart.sh &gt;&gt; restart.log 2&gt;&amp;1 &amp;</span><br><span class="line">        sleep 360</span><br><span class="line">        let TARGET_STATE=0</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    HTTP_CODE=`curl -I -m 10 -o /dev/null -s -w %&#123;http_code&#125;"\n" $&#123;TARGET_ADDR&#125;`</span><br><span class="line">    if [ "$&#123;HTTP_CODE&#125;" != 200 ];then</span><br><span class="line">        echo `date +"%Y-%m-%d %H:%M:%S"` The $&#123;TARGET_STATE&#125; time  can not access</span><br><span class="line">        echo "****** Error:  Down!" &gt;&gt; statusMonitor.log</span><br><span class="line">        let TARGET_STATE=TARGET_STATE+1</span><br><span class="line">    else</span><br><span class="line">        echo "###### success" &gt;&gt; statusMonitor.log</span><br><span class="line">    fi</span><br><span class="line">    sleep 10</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./checkRunningStatus.sh www.lilhui.com &amp;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>【好文】滴滴出行技术总监：关于技术选型的那些事儿</title>
    <url>/2018/07/27/article/article_1/</url>
    <content><![CDATA[<p>转载：<a href="https://news.cnblogs.com/n/563792/" target="_blank" rel="noopener">https://news.cnblogs.com/n/563792/</a></p>
<blockquote>
<p>杜欢，滴滴出行技术总监，负责滴滴小巴业务的技术管理工作。在互联网领域已经有十年工作经验，曾就职于微软、百度，也曾自主创业两次，来到滴滴之后也经历过很多项目和业务的变化，是一个“什么都懂”工程师，对前端、客户端、服务端、运维等方面都有不少实战经验。平时是一个 ACG 宅，也喜欢阅读各种技术和非技术的文章扩大视野，不愿主动交谈，但一旦放松了就聊到停不下来。</p>
</blockquote>
<h3 id="技术选型案例"><a href="#技术选型案例" class="headerlink" title="技术选型案例"></a>技术选型案例</h3><p>　　今天会聊技术选型这个话题，主要就是因为我经历相对比较丰富，亲历过不少项目选型的过程，自己也做过不少靠谱或者不靠谱的决策，在这个方面也有些自己的思考。我想先从几个案例开始，像讲故事一样聊聊选型背后的事，作为话题的开始。<br>　　在我刚开始工作时就经历过一次很大的选型事件，我是这件事情的旁观者。当时公司希望做一个非常酷炫的手机界面系统，恰逢 Windows Vista 一系列新技术的发布，包括 WPF、Silverlight、C# 这些技术非常火，公司对它们抱有极高的期望，所以就想第一时间用在新一代 Windows Mobile 上面。确实界面开发和各种效果可以做的很酷炫也节省了界面开发时间，但是很尴尬的遇到了另外一个问题，性能问题。<br>　　这些东西都是跑在移动设备上面，当年的移动设备内存能有 32MB，CPU 能到 1GHz 就很不错了，根本不能很好的支撑这一整套界面系统对性能的要求。后来，当公司发现确实在当时的硬件环境下突破性能问题，就对所有界面做了一次重写，回到了用 C++ 和各种 API 传统写界面方式上才解决问题，这里面涉及到将近一千名工程师一年多的时间，可以说是个很大的人力和时间的损失。<br>　　当时我还不是很理解，为什么公司不能更早一点止损，后来我慢慢发现，这真的是当局者迷，当一个决策作出之后大家就天然的希望能通过努力来解决眼前的问题，结果反而越陷越深。这也意味着最初选型的时候得十分谨慎，特别是选型影响面巨大时保守点会更好。<br>　　后来加入了真正的互联网公司，我看到了技术选型是稳定压倒一切。比如 gcc、linux 内核这些非常底层和关键的东西，在互联网公司里基本不会去追最新版，只是保持了解和跟进，非常克制的将一些 patch 和功能引入到线上环境，真正上线也会经历相当久的灰度验证过程。<br>　　我印象挺深的是当年（2009 年）对 lighttpd 和 apache 的选型，当时 lighttpd 单机性能明显优于 apache，同时也支持 php 扩展，能够以 mod 形式运行 php，看起来使用 lighttpd 全面替换 apache 就好了，但实际上为了业务稳定性，真正的用法是将 lighttpd 做反向代理，后面还是使用 apache + mod_php 来提供服务。这里面的思考就是对于一个新技术的天然不信任，在技术接受程度还不够高且公司内没有人能吃透这个技术的情况下，不愿意让自己的业务做第一个吃螃蟹的人。<br>　　谨慎确实是个美德，不过如果在一个非常追求速度的业务里，这可能也意味着过于保守，会延误时机。<br>　　我在自己创业的过程中选型就比较激进，也玩的比较 high。<br>　　比如我会积极的使用 MongoDB，我对它灵活的数据结构、强大的查询语句和内置的高可用机制等非常认可，当它刚刚 1.0 的时候就将它用在一些不重要的数据上，后来等到 2.x 发布后就开始尝试用在新业务上作为核心数据库。我也曾经遇到一些严重的坑，比如数据损坏、扩容不及时造成停机等，但是由于业务对这些问题容忍度较高，同时也有一些兜底方案，所以还不至于成为业务瓶颈，总体来说利大于弊，可以节省业务开发人员的宝贵时间。<br>　　我也曾决策使用 Node.js 作为主力服务器开发工具，当时（2013 年）因为客户端要使用 Javascript 作为主力语言，服务端和客户端会有不少能够复用的代码，所以挺想使用 Node.js 来提升开发效率。<br>　　为了验证 Node.js 是否靠谱，我自己通读了源码、阅读了不少相关文章、看了下官方 release note 及社区活跃程度（github issues、stackoverflow 讨论等）、还做了一些基本的压测，最后的结论是，它的性能可以满足要求，在稳定性方面基本合格，考虑到只是用它做无状态服务，且单台服务器上都会跑多个实例（当时使用 supervisord 管理），简单的崩溃不会对系统有明显影响，再加上当时确实也有些公司将它作为主力服务，所以最终选择了它。<br>　　后来加入滴滴后，我在技术选型方面综合了以前所有的经验，有做得好的，也有犯错的时候。<br>　　2015 年滴滴有一个很大的内部代码重构项目，涉及到服务端和客户端大量代码。客户端的技术选型做的相对较好，针对当时代码库多业务耦合严重，大家开发时候模块间冲突频繁的问题，评估并引入了 cocoapods 和 maven/gradle 作为 iOS 和 Android 的项目拆分工具，并且通过代码重构，将客户端项目分成几个独立的仓库，可以让业务独立开发的同时，也能通过构建脚本轻松的整合成一个完成的 app。<br>　　服务端的选型则比较错误，当时考虑到滴滴的业务模式非常类似于 erlang 的 actor 模型，一个叫车流程会涉及到非常多可复用的 actor，如果我们直接实现一个分布式的 actor 模型和数据流管理机制，那么很多问题就迎刃而解了。可是当时并不存在一套这样的机制，我们自己在实现的时候采用 Go + kafka 分别实现 actor 和数据流存储，过程中遇到了 kafka 消息丢失不好定位、actor 模型过于抽象不容易在整个团队贯彻执行等问题，最终放弃了整个方案。</p>
<h3 id="技术选型方法论"><a href="#技术选型方法论" class="headerlink" title="技术选型方法论"></a>技术选型方法论</h3><p>技术选型关键需要思考三个角度：技术、业务和人。</p>
<h4 id="角度之一：技术"><a href="#角度之一：技术" class="headerlink" title="角度之一：技术"></a>角度之一：技术</h4><p>　　技术选型首先考虑的当然是技术本身，这里提到的技术包括语言、框架、工具、设计模式、开发模式等。<br>　　在选择技术时有两个大原则。第一，要取其长避其短；第二，要关注技术的发展前景。<br>　　每种技术都是有它特定的适用场景的，“没有银弹”。开发者经常犯的错误就是盲目追新，当一个新语言、框架、工具出现后，特别是开发者自己学会了这种新技术后，就会有种“拿着锤子找钉子”的感觉，将新技术滥用于各种项目。<br>　　比如最近几年 Go 在国内很火，我自己也非常使用它开发项目，但绝对不应该将它用于所有项目。Go 的优点是上手快、运行时性能高、方便的使用多核运算能力等，经常被提起的特性是超轻线程 goroutine、内置的内存队列 chan、极快的编译速度，非常适合于编写各种无状态应用服务，无需使用任何的第三方框架都能轻松写出一个高性能的 http 服务。<br>　　但它的缺点也非常明显，最痛的一点是 gc。Go 在设计之初就号称要实现一个世界上最优秀的 gc，可惜直到今天也还差的较远，最近一年才实现了 jvm 几年前就做到的并发 gc，并且没有很好的方法解决内存碎片和对象过多带来的性能问题。这些缺陷使得 Go 不太适合做有状态服务，特别不适合做内存管理相关的服务，在这些场景里面还是 C/C++ 更加可靠。<br>　　技术的发展前景也是一个重要考虑因素。有些技术设计的很好，比如我个人挺喜欢一个叫做 Io 的语言，但我不会把它用于真实项目，因为这个语言缺乏社区和长期支持，就算设计理念写的再好，里面也必然有各种 bug 和不足，如果没人能够解决就会带来严重的问题。技术的“前景”可以从几个维度来判断，有没有长期规划、有没有持续投入的人或者社区、问题解决的速度如何、业界使用案例及口碑、源码质量。<br>　　选择一个技术最低限的标准是，技术的生命周期必须显著长于项目的生命周期。想象一下，如果项目还没做完这个技术就不被维护了，那将是怎样一种窘境。拿去年很火的 Vue.js 来说，尤大在规划、投入和解决问题速度方面都没有问题，这是这个技术能火起来的基本保障，再加上设计优雅、源码确实写的不错，它的成功并不偶然。可以预见，随着尤大全职开发这个框架并且社区贡献者越来越多，Vue.js 能持续几年应该问题不大。<br>　　滴滴的 web app，比如微信钱包里面的滴滴入口，就在去年年底全面改用 Vue.js 重构了一版，我们就是看中了 Vue.js 在移动应用开发中的优势再加上对它的前景有信心。在重构前，我们为了确认 Vue.js 真的能承担如此大任，公共前端团队在 2016 年花了半年的时间整体梳理和评估了 Vue.js 1.0 和 2.0 的全部源码，为此还出了一本书，在公司大规模使用前也在滴滴小巴业务和行程分享功能里做了试点，效果非常不错，最终才真正下定决心广泛推广。<br>　　技术的发展前景是动态变化的，当一个技术走向了末路，我们也应该勇敢的扬弃。拿 jQuery 为例，最开始它是前端开发的必需品，当时很多前端同学离开了 $ 函数就不会写代码了，它在简化 DOM 操作、抹平浏览器间差异做出了极其重要的贡献。但是随着浏览器越来越标准和趋同，jQuery 的亮点已经不再吸引人，它的插件开发模式逐步被模块化开发给取代，再加上各种历史包袱，它所适用的项目也会变得越来越少，新项目在选型的时候就不推荐优先考虑 jQuery 了。<br>　　对于一家大型公司来说，其核心业务的技术选型更需谨慎，看前景时甚至需要考虑技术的独立性。依然把 Go 当做一个例子，当前核心 Go Authors 基本都受雇于 Google，也没有一个独立运作的基金会来负责语言的长期维护，更没有一个公开透明的决策机制来决定语言的未来，假如 Google 出于某种原因停止投入或者改变语言的发展方向，那么这对一家大型公司来说可能会是毁灭性打击。立志于成为一家千亿美元规模的公司，或者是 Google 的潜在竞争对手，在选择使用 Go 时就应该更加谨慎，不要盲从。</p>
<h4 id="角度之二：业务"><a href="#角度之二：业务" class="headerlink" title="角度之二：业务"></a>角度之二：业务</h4><p>　　技术选型必须贴着业务来选择，不同业务阶段会有不同的选型方式。<br>　　处于初创期的业务，选型的关键词是“灵活”。只要一个技术够用且开发效率足够高，那么就可以选择它。初创的业务往往带有风险性和不确定性，朝令夕改、反复试错是常态，技术必须适应业务的节奏，然后才是其他方面。MongoDB 是一个很好的例子，相比 MySQL，它的数据结构灵活多变，相比一般的 KV 存储，它又具有类似 SQL 的复杂查询能力，再加上它内置的傻瓜式高可用和水平扩展机制，让它能够很好的适应初创业务对效率的追求。<br>　　等业务进入稳定期，选型的关键词是“可靠”。技术始终是业务的基石，当业务稳定了技术不稳，那就会成为业务的一块短板，就必须要修正。当年 Twitter 放弃 RoR 选择 Java 系框架，这就是个很好的例子。RoR 以快速开发著称，但同时 ruby 的性能非常有限，Twitter 工程团队针对 ruby 虚拟机做了非常多性能优化可是依然不能达到预期，再加上当时的 Twitter 为了提升前端体验，全面使用模块化和异步化的方法加载页面，服务端已经基本不怎么负责渲染页面，而专注于提供各种 RESTful API，RoR 的优势也不太明显了。<br>　　当业务步入维护期，选型的关键词是“妥协”。代码永远有变乱的趋势，一般经过一两年就有必要对代码来一次大一点的重构。在这种时候，必须得正视各种遗留代码的迁移成本，如果改变技术选型会带来遗留代码重写，这背后带来的代价业务无法承受，那么我们就不得不考虑在现有技术选型之上做一些小修小补或者螺旋式上升的重构。<br>　　正因为技术选型和业务相关，我们能够观察到一些很明显的现象：新技术往往被早期创业团队或大公司的新兴业务使用；中大型公司的核心业务则更倾向于用一些稳定了几年的技术；一个公司如果长期使用一种技术，就会倾向于一直使用下去，甚至连版本都不更新的使用下去。这现象背后都是有道理的。</p>
<h4 id="角度之三：人"><a href="#角度之三：人" class="headerlink" title="角度之三：人"></a>角度之三：人</h4><p>　　技术选型过程中最终影响决策的还是人本身，这里要强调一下，我说的“人”是指的个人，而不是团队。<br>　　技术选型的决策流程一定得专制。决策者可以在调研的时候体恤民情，并把团队现状当做一个因素考虑进来，但绝对不能采用类似“少数服从多数”、“按着大家习惯来”的方式选型。专制可以使技术选型更加的客观，考虑的更加全面，并且使得权责统一。<br>　　并不是每个人都懂得怎么为项目负责，一个基层的开发人员思考的更多的可能是技术是否有挑战、能否做出彩、甚至未来好不好找工作，这些主观因素可能会给选型带来灾难性的后果。专制也使得“螺旋式上升”成为可能，很多时候我们没法一蹴而就的使用某种技术，这时候需要有一个领路人，带着大家坚定的朝一条曲折的路线前进才能获得成功。<br>　　技术选型也非常依赖于人的能力。选型是一件很难被标准化的过程，选型的决策质量跟人的眼界、经验、业务敏感度、逻辑性等息息相关。就我自己来说，我在面临一个选型问题时首先考虑的是去学习，看看公司内外类似的问题如何解决的，避免自己闭门造车，然后思考所有的可能性，列举最核心需要考虑的因素，心里列一个方案优劣对比，最后将这些逻辑整理清楚，落地成一个决策。<br>　　滴滴在决策客户端动态化方向时就是以这样的方式来进行的，我们将业界所有可能的方案都拿出来，理解他们的优缺点，然后在某次会议上几个核心同学在白板上列了一张表格，以考虑的因素为行，可能的方案为列，分别评估各个方案在每种因素里的优劣势，最终确定了一个结论。我们选择的路是偏向于客户端开发的动态化方案，在保留所有代码和工具链的前提下做到对开发者透明的动态化，这样能让整体迁移和维护代价变得最小，当然，这条路开发难度也相当大，幸好我们当时也找到了最合适的人，我们依然可以在能接受的时间里实现整个方案。<br>　　培养技术选型的能力<br>　　可以看到，要想做好技术选型还是挺难的，要想做好得有足够的知识积累和实际踩坑的经历才行。如果一个不太懂得如何选型的新人想学着做好这件事，那可以先从小项目开始做尝试，慢慢积累经验。技术选型对人来说最重要的还是“逻辑性”，每一个决策背后都藏着许多假设和事实，我们通过不断挑战这些背后的东西来逐步成长。<br>　　比如在需要使用缓存来加快数据访问速度的场景中，我们可能会很自然的选择 redis 作为缓存服务。这看似“直觉”的决策，背后也是由一系列假设和事实组成。可以问自己一连串问题，看看在具体的场景下这个决策是不是真的正确，例如，缓存服务有没有 redis 之外的选项、是否可以在内存里直接缓存、redis 是否稳定、redis 性能是否满足需求、数据库访问速度瓶颈究竟在哪等等问题，很可能最终结果还是“ 使用 redis 做缓存”这个直观方案，但正因为有分析的过程，让我们在下一次做决策可以更迅速、更自信。<br>　　如何保持敏感性和广度<br>　　技术选型是个很需要经验的活，得有大量的信息积累和输入，再根据具体现实情况输出一个结果。我们在选型的时候最忌讳的是临时抱佛脚、用网上收集一些碎片知识来决策，这是非常危险的，我们得确保自己所有思考都是基于以前的事实，还要弄清楚这些事实背后的假设，这都需要让知识内化形成经验。<br>　　我一直在想，“经验”的本质是什么，有什么方法能够确定自己的经验增长了，而不是不断在重复一些很熟悉的东西。我现在的结论是，经验等于“知识索引”的完备程度。<br>　　我们一生中会积累很多的知识，如果把我们的大脑比作数据库的话，那我们一定有一部分脑存储贡献给了内容的索引，它能帮助我们将关联知识更快的取出来，并且辅助决策。经验增长等同于我们知识索引的增长，意味着我们能轻易的调动更多的关联知识来做更全面的决策。<br>　　要想建立好这个知识索引，我们得保持技术敏感性和广度，也就是要做到持续的信息输入、内化，并发现信息之间的关联性，建立索引，记下来。说起来容易，做起来还是挺有难度的。<br>　　首先难在信息输入量大，忘记了怎么办。我们的大脑不是磁盘，不常用的知识就会忘记，忘记了就跟没看过是一回事。我的经验是一定要对知识进行压缩，记住的是最关键的细节，并且反复的去回味这个细节。<br>　　比如我学习各种语言的时候就会非常留意一些最有特色的语法特性和应用场景，像 C++，我一直记得很早以前看过的细节，像编译器默认会生成哪些类方法，默认析构、拷贝构造、operator = 等，默认生成的类方法有哪些场景需要显示禁用，什么时候要在构造函数用 explicit 等，我看这些细节已经超过十五年的时间了，依然记忆尤新。<br>　　看起来好像有点难度，实际上不难，大家想想自己学过的英文单词，再怎么样最常见的几百个英文单词还是能清楚的记得含义的，而技术的知识点其实压缩之后会远小于英文单词的个数，记忆负担不会有想象中那么大。<br>　　然后难在信息更新速度太快，跟不上技术发展怎么办。我学习了非常多技术之后就会发现这确实是个难解的问题，像前端开发，每年都会有新的框架和开发方式出现，ES7 的语法如果不去提前了解，过两年可能连 Javascript 语法都看不懂了。<br>　　我在这个问题上也是有些焦虑的，不过多少还是有应对的方式，就是坚持碎片化学习，增量更新过时的内容，只要形成习惯也还是能够慢慢的找到自己的节奏。如果有些技术实在细节太多，比如 Node.js 这种，我以前曾经通读过源码，仔细研究过内部设计，但随着它不断发展现在我也不太敢说对它内部有多熟悉，那我会考虑大胆的放弃追新，等着我可能需要用它的时候再统一更新到最新的知识。<br>　　最后难在信息究竟如何存入知识索引，知识太零散形成不了体系，建不了索引怎么办。最入门的做法是看书，看别人是怎么将知识变成一个个章节的信息。要想掌握建立索引背后的方法论，我的经验是先从两个相近的技术开始，找到建索引的感觉，然后再铺开去学习更多知识。有这样困惑的开发者往往在学习方面有些贪心，觉得自己记性好可以囫囵吞枣式的将知识强行内化，这样做短期可以，长期还是会遗忘，也形成不了经验。<br>　　其实技术知识之间非常像，有很多共性的点可以挖掘。比如客户端和前端开发，各个框架在 View 生命周期管理、消息派发机制等方面非常像，后端开发则更加的套路化，无论用那种语言，最基本的分布式服务原理、缓存、队列、数据库等基础组件原理，都万变不离其宗。<br>　　如果我们更宏观的看每个领域，甚至于都能发现领域之间的知识体系划分也很类似。作为表现层的前端和客户端，知识体系都可以分为语言、API、工程化、框架和设计模式。比如前端的语言包括 HTML、CSS、Javascript 和一些稍小众的 TypeScript、CoffeeScript 等，API 就是各种标准、接口的使用、能够实现的效果、平台限制等，工程化就是各种打包工具、代码转化工具、辅助开发工具等，框架就是像 Vue、React 等，设计模式就是像 PWA、redux 等。<br>　　相应的，刚刚说的这些知识都能找到在 iOS 或 Android 里几乎对应的知识，无非换了一些细节，这里我就不继续展开了。服务端也是这样，知识体系最顶层的部分也很少，具体到细节，只是要了解每一个实现背后的优劣。<br>　　总结一下，技术选型依赖于经验，经验又来源于知识索引的建设，这依赖于平时的总结和不断的新知识输入，技术是一辈子的事，必须得投入大量时间维持状态。学无止尽，大家一起共勉。</p>
]]></content>
      <categories>
        <category>好文</category>
      </categories>
      <tags>
        <tag>技术选型</tag>
      </tags>
  </entry>
  <entry>
    <title>【Redis学习2】redis持久化，主从，哨兵架构</title>
    <url>/2022/06/29/redis/redis_core_2/</url>
    <content><![CDATA[<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="RDB快照（snapshot"><a href="#RDB快照（snapshot" class="headerlink" title="RDB快照（snapshot)"></a>RDB快照（snapshot)</h3><p>在默认情况下， Redis 将内存数据库快照保存在名字为 dump.rdb 的二进制文件中。 你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”<br>这一条件被满足时， 自动保存一次 数据集。 比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次 数据<br>集： # save 60 1000 //关闭RDB只需要将所有的save保存策略注释掉即可</p>
<p>还可以手动执行命令生成RDB快照，进入redis客户端执行命令save或bgsave可以生成dump.rdb文件， 每次命令执行都会将所有redis内存快照到一个新的rdb<br>文件里，并覆盖原有rdb快照文件。</p>
<p><strong>bgsave的写时复制(COW)机制</strong><br>Redis 借助操作系统提供的写时复制技术（Copy-On-Write, COW），在生成快照的同时，依然可以正常 处理写命令。简单来说，bgsave 子进程是由主线程<br>fork 生成的，可以共享主线程的所有内存数据。 bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些 数<br>据也都是读操作，那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据，那 么，这块数据就会被复制一份，生成该数据的副本。然后，<br>bgsave 子进程会把这个副本数据写入 RDB 文 件，而在这个过程中，主线程仍然可以直接修改原来的数据。</p>
<p><strong>save与bgsave对比</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>save</th>
<th>bgsave</th>
</tr>
</thead>
<tbody>
<tr>
<td>IO类型</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>是否阻塞redis其他命令</td>
<td>是</td>
<td>否（在生成子进程执行调用fork函数时会有短期阻塞）</td>
</tr>
<tr>
<td>复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>有点</td>
<td>不会消耗额外内存</td>
<td>不阻塞客户端命令</td>
</tr>
<tr>
<td>缺点</td>
<td>阻塞客户端命令</td>
<td>需要fork子进程，消耗内存</td>
</tr>
</tbody>
</table>
<p>配置自动生成rdb文件后台使用的是bgsave方式。</p>
<ul>
<li>AOF (append-only file)</li>
</ul>
<p>快照功能并不是非常耐久(durable)：如果redis因为某些原因造成故障停机，那么服务器将丢失最近写入、且未保存到快照的那些数据。从1.1版开始<br>Redis增加了一种完全耐久的持久化方式：AOF持久化，将修改的每一条指令记录进文件appendonly.aof中（先写入os cache,每隔一段时间fsync到<br>磁盘）<br>比如执行命令 “set littlehui 666” ，aof记录如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*3</span><br><span class="line"><span class="meta">$</span><span class="bash">3 </span></span><br><span class="line">set </span><br><span class="line"><span class="meta">$</span><span class="bash">5 </span></span><br><span class="line">littlehui</span><br><span class="line"><span class="meta">$</span><span class="bash">3 </span></span><br><span class="line">666</span><br></pre></td></tr></table></figure>
<p>这种是resp协议格式数据，星号后面的数字代表命令有多少个参数。$号后面的数字代表这个参数有几个字符。<br>PS:如果执行带过期的set命令，aof文件记录的并不是原始命令。而是记录这个key的过期时间戳。</p>
<p>比如执行 “set littlehui 888 ex 1000” aof记录如下<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*3 </span><br><span class="line"><span class="meta">$</span><span class="bash">3</span></span><br><span class="line">set</span><br><span class="line"><span class="meta">$</span><span class="bash">6</span></span><br><span class="line">littlehui</span><br><span class="line"><span class="meta">$</span><span class="bash">3</span></span><br><span class="line">888</span><br><span class="line">*3</span><br><span class="line"><span class="meta">$</span><span class="bash">9</span></span><br><span class="line">PEXPIREAT </span><br><span class="line"><span class="meta">$</span><span class="bash">6</span></span><br><span class="line">tuling</span><br><span class="line"><span class="meta">$</span><span class="bash">13</span></span><br><span class="line">1604249786301</span><br></pre></td></tr></table></figure></p>
<p>AOF功能开启：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure></p>
<p>redis重启时，程序通过执行AOF的命令来进行重加数据集。<br>通过配置修改fsync到磁盘的频次。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">appendfsync always：每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全。</span><br><span class="line">appendfsync everysec：每秒 fsync 一次，足够快，并且在故障时只会丢失 1 秒钟的数据。</span><br><span class="line">appendfsync no：从不 fsync ，将数据交给操作系统来处理。更快，也更不安全的选择。</span><br></pre></td></tr></table></figure></p>
<p>以上配置为推荐值，可以兼顾速度和安全性。</p>
<ul>
<li>AOF重写<br>AOF文件里可能有太多没用指令，所以AOF会定期根据内存的新数据生成aof文件。<br>例如：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt;incr readcount</span><br><span class="line">（Integer）1</span><br><span class="line">127.0.0.1:6379&gt;incr readcount</span><br><span class="line">（Integer）2</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>重写后AOF变成<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*3</span><br><span class="line"><span class="meta">$</span><span class="bash">3</span></span><br><span class="line">set</span><br><span class="line"><span class="meta">$</span><span class="bash">2</span></span><br><span class="line">readcount</span><br><span class="line"><span class="meta">$</span><span class="bash">1</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p><strong>自动重写频率</strong><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> auto‐aof‐rewrite‐min‐size 64mb //aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就 很快，重写的意义不大 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> auto‐aof‐rewrite‐percentage 100 //aof文件自上一次重写后文件大小增长了100%则再次触发重写</span></span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>容易丢数据</td>
<td>根据策略决定</td>
</tr>
</tbody>
</table>
<p>生产环境可以都启用，redis启动时如果既有rdb文件又有aof文件则优先选择aof文件恢复数据，因为aof 一般来说数据更全一点。</p>
<h3 id="Redis-4-0混合持久化"><a href="#Redis-4-0混合持久化" class="headerlink" title="Redis 4.0混合持久化"></a>Redis 4.0混合持久化</h3><p>重启 Redis 时，我们很少使用 RDB来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重 放，但是重放 AOF 日志性能相对 RDB来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很 长的时间。 Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。 通过如下配置可以开启混合持久化(必须先开启aof)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>
<p>如果开启了混合持久化，AOF在重写时，不再是单纯将内存数据转换为RESP命令写入AOF文件，而是将 重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容和增量的AOF修改内存数据的命令存在一 起，都写入新的AOF文件，新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改 名，覆盖原有的AOF文件，完成新旧两个AOF文件的替换。 于是在 Redis 重启的时候，可以先加载 RDB 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，因此重启效率大幅得到提升。</p>
<p>混合持久化AOF文件结构</p>
<p><img src="https://images.lilhui.com/0042927170653d7df11736fd7cbdad67" alt="图片"></p>
<ul>
<li>Redis数据备份策略</li>
</ul>
<ol>
<li>写crontab定时调度脚本，每小时都copy一份rdb或aof备份到一个目录中去，仅仅保留最近48小时的备份。</li>
<li>每天都保留一份当日的数据备份到一个目录中去，可以保留最近1个月的备份。</li>
<li>每次copy留备份的时候，都把太旧的备份给删了。</li>
<li>每天晚上将当前机器上的备份复制一份到其他机器上，以防机器损坏。</li>
</ol>
<h3 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h3><p><img src="https://images.lilhui.com/bbc61a741bf58968a1eb3d42ae25f2d1" alt="图片"></p>
<p><strong> redis主从架构搭建，配置从节点步骤 </strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1、复制一份redis.conf文件</span><br><span class="line">2、将相关配置修改为：</span><br><span class="line">port 6380</span><br><span class="line">pidfile /var/run/redis_6380.pid #把pid进程号写入pidfile配置的文件</span><br><span class="line">logfile "6380.log"</span><br><span class="line">dif /usr/local/redis-5.0.3/data/6380 #指定数据存放目录</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要注释掉<span class="built_in">bind</span> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">bind</span> 127.0.0.1（<span class="built_in">bind</span>绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip，代表允许客户端通 过机器的哪些网卡ip去访问，内网一般可以不配置<span class="built_in">bind</span>，注释掉即可） </span></span><br><span class="line">3、配置主从复制</span><br><span class="line">replicaof 192.168.0.60 6379 # 从本机6379的redis实例复制数据，Redis 5.0之前使用slaveof</span><br><span class="line">replica‐read‐only yes # 配置从节点只读 </span><br><span class="line">4、启动从节点 16 redis‐server redis.conf 1718 5、连接从节点  </span><br><span class="line">redis‐cli ‐p 6380 2021 6、测试在6379实例上写数据，6380实例是否能及时同步新修改数据 </span><br><span class="line">7、可以自己再配置一个6381的从节点</span><br></pre></td></tr></table></figure>
<h2 id="Redis主从工作原理"><a href="#Redis主从工作原理" class="headerlink" title="Redis主从工作原理"></a>Redis主从工作原理</h2><p>如果你为master配置了一个slave,不管这个slave是否是第一次连上Master，都会发送一个PSYNC命令给master请求复制数据。<br>master收到PSYNC命令后，会再后台进行数据持久化通过bgsave生成最新的rdb快照文件，持久化期间，master会继续接收客户端<br>的请求，它会把这些可能修改数据集的请求缓存在内存中。当持久化进行完毕后，master会把这份rdb文件数据集发送给slave,slave<br>会把接收到的数据进行持久化生成rdb,然后加载到内存中。最后master再将之前缓存在内存中的命令发送给slave.</p>
<p>当master与slave之间的链接由于某些原因而断开时，slave能够自动重连Master,如果master收到了多个slave并发链接请求，它<br>只会进行一次持久化，而不是一个连接一次，然后再把这一份持久化的数据发送给多个并发连接的slave.</p>
<ul>
<li>主从复制（全量复制）流程图</li>
</ul>
<p><img src="https://images.lilhui.com/ff66d9de5d9dc974140a149f433647f4" alt="图片"></p>
<ul>
<li>数据部分复制</li>
</ul>
<p>当master和slave断开重连后，一般会对整个数据进行复制。但从redis2.8版开始，redis改用可以支持部分数据复制的命令PSYNC<br>去master同步数据，slave和master能够在网络连接断开重连后进行部分数据复制（断点续传）</p>
<p>master会再其内存中创建一个复制数据用的缓存队列，缓存最近一段时间的数据，master和它所有的slave都维护了复制数据下表offset<br>和master的进程ID,因此，当网络连接断开后，slave会请求master offset太久，已经补在master的缓存队列里了。那么将会进行一次<br>全量数据的复制。</p>
<ul>
<li>主从断点续传流程图</li>
</ul>
<p><img src="https://images.lilhui.com/af577bd4dd5d5aaffcc48b4ad76d3dd7" alt="图片"></p>
<p>如果有很多从节点，为了环节主从复制风暴（多个节点同时复制主节点导致主节点压力过大可以做一下架构，让部分从节点与从节点同步数据。</p>
<p><img src="https://images.lilhui.com/84e0a901a219fdb01f0d6172d46f80d4" alt="图片"></p>
<h2 id="Redis管道与Lua脚本"><a href="#Redis管道与Lua脚本" class="headerlink" title="Redis管道与Lua脚本"></a>Redis管道与Lua脚本</h2><h3 id="管道（pipeline"><a href="#管道（pipeline" class="headerlink" title="管道（pipeline)"></a>管道（pipeline)</h3><p>客户端可以一次性发送多个请求而不用等待服务器的响应，待所有命令都发送完后再一次性读取服务的响应，这样可以极大的降低多条命令执行的网络传输开销，管道执行多条命令的网络开销实际上只相当于一次命令执行的网络开销。需要注意到是用pipeline方式打包命令发送，redis必须在处理完所有命令前先缓存起所有命令的处理结果。打包的命令越多，缓存消耗内存也越多。所以并不是打包的命令越多越好。<br>pipeline中发送的每个command都会被server立即执行，如果执行失败，将会在此后的响应中得到信<br>息；也就是pipeline并不是表达“所有command都一起成功”的语义，管道中前面命令失败，后面命令不会有影响，继续执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Pipeline pl = jedis.pipelined();</span><br><span class="line">for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line">  pl.incr("pipelineKey");</span><br><span class="line">  pl.set("littlehui" + i, "666")</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Object&gt; results = pl.syncAndReturnAll();</span><br><span class="line">System.out.println(results)</span><br></pre></td></tr></table></figure>
<h3 id="Redis-Lua脚本"><a href="#Redis-Lua脚本" class="headerlink" title="Redis Lua脚本"></a>Redis Lua脚本</h3><hr>
<p>Redis在2.6推出了脚本功能，允许开发者使用Lua语言编写脚本传到Redis中执行。使用脚本的好处如下:<br>1、<strong>减少网络开销</strong>：本来5次网络请求的操作，可以用一个请求完成，原先5次请求的逻辑放在redis服务器上完成。使用脚本，减少了网络往返时延。这点跟管道类似。<br>2、<strong>原子操作</strong>：Redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。管道不是原子的，不过redis的批量操作命令(类似mset)是原子的。<br>3、<strong>替代redis的事务功能</strong>：redis自带的事务功能很鸡肋，而redis的lua脚本几乎实现了常规的事务功能，官方推荐如果要使用redis的事务功能可以用redis lua替代。</p>
<p>官网文档上有这样一段话：</p>
<hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">A Redis script is transactional by definition, so everything you can do with a Redis t ransaction, you can also do with a script,</span><br><span class="line">and usually the script will be both simpler and faster.</span><br></pre></td></tr></table></figure>
<p>从Redis2.6.0版本开始，通过内置的Lua解释器，可以使用EVAL命令对Lua脚本进行求值。EVAL命令的格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EVAL script numkeys key [key ...] arg [arg ...]</span><br></pre></td></tr></table></figure>
<p>script参数是一段Lua脚本程序，它会被运行在Redis服务器上下文中，这段脚本不必(也不应该)定义为一个Lua函数。numkeys参数用于指定键名参数的个数。键名参数 key [key …] 从EVAL的第三个参数开始算起，表示在脚本中所用到的那些Redis键(key)，这些键名参数可以在 Lua中通过全局变量KEYS数组，用1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。<br>在命令的最后，那些不是键名参数的附加参数 arg [arg …] ，可以在Lua中通过全局变量ARGV数组访问，访问的形式和KEYS变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; eval "return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;" 2 key1 key2 first seco nd</span><br><span class="line">1) "key1"</span><br><span class="line">2) "key2"</span><br><span class="line">3) "key3"</span><br><span class="line">4) "key4"</span><br></pre></td></tr></table></figure>
<p>其中 “return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}” 是被求值的Lua脚本，数字2指定了键名参数的数量， key1和key2是键名参数，分别使用 KEYS[1] 和 KEYS[2] 访问，而最后的 first 和 second 则是附加参数，可以通过 ARGV[1] 和 ARGV[2] 访问它们。<br>在 Lua 脚本中，可以使用redis.call()函数来执行Redis命令<br>Jedis调用示例详见上面jedis连接示例：</p>
<p><img src="https://images.lilhui.com/559aa96f28fdd3cb8e1371f9974d69f6" alt="图片"></p>
<p><strong>注意，不要在Lua脚本中出现死循环和耗时的运算，否则redis会阻塞，将不接受其他的命令， 所以使用时要注意不能出现死循环、耗时的运算。redis是单进程、单线程执行脚本。管道不会阻塞redis。</strong></p>
<h2 id="Redis哨兵高可用架构"><a href="#Redis哨兵高可用架构" class="headerlink" title="Redis哨兵高可用架构"></a>Redis哨兵高可用架构</h2><p><img src="https://images.lilhui.com/8d7487de106d52e9bdb8f25e9bb9862b" alt="图片"></p>
<p>sentinel哨兵是特殊的redis服务，不提供读写服务，主要用来监控redis实例节点。<br>哨兵架构下client端第一次从哨兵找出redis的主节点，后续就直接访问redis的主节点，不会每次都通过<br>sentinel代理访问redis的主节点，当redis的主节点发生变化，哨兵会第一时间感知到，并且将新的redis 主节点通知给client端(这里面redis的client端一般都实现了订阅功能，订阅sentinel发布的节点变动消息)</p>
<h3 id="Redis-哨兵搭建步骤"><a href="#Redis-哨兵搭建步骤" class="headerlink" title="Redis 哨兵搭建步骤"></a>Redis 哨兵搭建步骤</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1、复制一份sentinel.conf文件</span><br><span class="line">cp sentinel.conf sentinel‐26379.conf  </span><br><span class="line">2、将相关配置修改为如下值： </span><br><span class="line">port 26379 </span><br><span class="line">daemonize yes </span><br><span class="line">pidfile "/var/run/redis‐sentinel‐26379.pid" </span><br><span class="line">logfile "26379.log" </span><br><span class="line">dir "/usr/local/redis‐5.0.3/data" </span><br><span class="line"><span class="meta">#</span><span class="bash"> sentinel monitor &lt;master‐redis‐name&gt; &lt;master‐redis‐ip&gt; &lt;master‐redis‐port&gt; &lt;quorum&gt; </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> quorum是一个数字，指明当有多少个sentinel认为一个master失效时(值一般为：sentinel总数/2 + 1)，master才算真正失效</span></span><br><span class="line"></span><br><span class="line">sentinel monitor mymaster 192.168.0.60 6379 2 # mymaster这个名字随便取，客户端访问时会用 到</span><br><span class="line">3、启动sentinel哨兵实例 </span><br><span class="line">src/redis‐sentinel sentinel‐26379.conf </span><br><span class="line">4、查看sentinel的info信息 </span><br><span class="line">src/redis‐cli ‐p 26379 19 127.0.0.1:26379&gt;info </span><br><span class="line">可以看到Sentinel的info里已经识别出了redis的主从 </span><br><span class="line">5、可以自己再配置两个sentinel，端口26380和26381，注意上述配置文件里的对应数字都要修改</span><br></pre></td></tr></table></figure>
<p>sentinel集群都启动完毕后，会将哨兵集群的元数据信息写入所有sentinel的配置文件里去(追加在文件的 最下面)，我们查看下如下配置文件sentinel-26379.conf，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sentinel known‐replica mymaster 192.168.0.60 6380 #代表redis主节点的从节点信息 </span><br><span class="line">sentinel known‐replica mymaster 192.168.0.60 6381 #代表redis主节点的从节点信息 </span><br><span class="line">sentinel known‐sentinel mymaster 192.168.0.60 26380 52d0a5d70c1f90475b4fc03b6ce7c3c569 35760f #代表感知到的其它哨兵节点 </span><br><span class="line">sentinel known‐sentinel mymaster 192.168.0.60 26381 e9f530d3882f8043f76ebb8e1686438ba8 bd5ca6 #代表感知到的其它哨兵节点</span><br></pre></td></tr></table></figure>
<p>当redis主节点如果挂了，哨兵集群会重新选举出新的redis主节点，同时会修改所有sentinel节点配置文件 的集群元数据信息，比如6379的redis如果挂了，假设选举出的新主节点是6380，则sentinel文件里的集 群元数据信息会变成如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sentinel known‐replica mymaster 192.168.0.60 6379 #代表主节点的从节点信息 </span><br><span class="line">sentinel known‐replica mymaster 192.168.0.60 6381 #代表主节点的从节点信息 </span><br><span class="line">sentinel known‐sentinel mymaster 192.168.0.60 26380 52d0a5d70c1f90475b4fc03b6ce7c3c569 35760f #代表感知到的其它哨兵节点 </span><br><span class="line">sentinel known‐sentinel mymaster 192.168.0.60 26381 e9f530d3882f8043f76ebb8e1686438ba8 bd5ca6 #代表感知到的其它哨兵节点</span><br></pre></td></tr></table></figure>
<p>同时还会修改sentinel文件里之前配置的mymaster对应的6379端口，改为6380<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sentinel monitor mymaster 192.168.0.60 6380 2</span><br></pre></td></tr></table></figure></p>
<p>当6379的redis实例再次启动时，哨兵集群根据集群元数据信息就可以将6379端口的redis节点作为从节点 加入集群。</p>
<p>哨兵的Jedis连接代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisSentinelTest</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig(); </span><br><span class="line">        config.setMaxTotal(<span class="number">20</span>); </span><br><span class="line">        config.setMaxIdle(<span class="number">10</span>); </span><br><span class="line">        config.setMinIdle(<span class="number">5</span>); </span><br><span class="line">        String masterName = <span class="string">"mymaster"</span>; </span><br><span class="line">        Set&lt;String&gt; sentinels = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        sentinels.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.0.60"</span>,<span class="number">26379</span>).toString()); </span><br><span class="line">        sentinels.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.0.60"</span>,<span class="number">26380</span>).toString()); </span><br><span class="line">        sentinels.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.0.60"</span>,<span class="number">26381</span>).toString());</span><br><span class="line">        <span class="comment">//JedisSentinelPool其实本质跟JedisPool类似，都是与redis主节点建立的连接池 </span></span><br><span class="line">        <span class="comment">// JedisSentinelPool并不是说与sentinel建立的连接池，而是通过sentinel发现redis主节点并与其 建立连接</span></span><br><span class="line">        JedisSentinelPool jedisSentinelPool = <span class="keyword">new</span> JedisSentinelPool(masterName, sentinels, co nfig, <span class="number">3000</span>, <span class="keyword">null</span>); </span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            jedis = jedisSentinelPool.getResource(); </span><br><span class="line">            System.out.println(jedis.set(<span class="string">"sentinel"</span>, <span class="string">"littlehui"</span>)); </span><br><span class="line">            System.out.println(jedis.get(<span class="string">"sentinel"</span>)); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">            <span class="comment">//注意这里不是关闭连接，在JedisPool模式下，Jedis会被归还给资源池。 </span></span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) </span><br><span class="line">                jedis.close(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>哨兵的Spring Boot整合Redis连接代码见示例项目：redis-sentinel-cluster</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;spring‐boot‐starter‐data‐redis&lt;/artifactId&gt; </span><br><span class="line">&lt;/dependency&gt; </span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.apache.commons&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;commons‐pool2&lt;/artifactId&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>springboot项目核心配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server: </span><br><span class="line">        port: 8080 </span><br><span class="line">        spring: </span><br><span class="line">            redis: </span><br><span class="line">                database: 0</span><br><span class="line">                timeout: 3000 </span><br><span class="line">                sentinel: #哨兵模式 </span><br><span class="line">                    master: mymaster #主服务器所在集群名称 </span><br><span class="line">                    nodes: 192.168.0.60:26379,192.168.0.60:26380,192.168.0.60:26381 </span><br><span class="line">            lettuce:</span><br><span class="line">                pool: </span><br><span class="line">                  max‐idle: 50 </span><br><span class="line">                  min‐idle: 10 </span><br><span class="line">                  max‐active: 100 </span><br><span class="line">                  max‐wait: 1000</span><br></pre></td></tr></table></figure>
<h3 id="StringRedisTemplate与RedisTemplate详解"><a href="#StringRedisTemplate与RedisTemplate详解" class="headerlink" title="StringRedisTemplate与RedisTemplate详解"></a>StringRedisTemplate与RedisTemplate详解</h3><p>spring 封装了 RedisTemplate 对象来进行对redis的各种操作，它支持所有的 redis 原生的 api。在 RedisTemplate中提供了几个常用的接口方法的使用，分别是:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">private ValueOperations&lt;K, V&gt; valueOps; </span><br><span class="line">private HashOperations&lt;K, V&gt; hashOps; </span><br><span class="line">private ListOperations&lt;K, V&gt; listOps; </span><br><span class="line">private SetOperations&lt;K, V&gt; setOps;</span><br><span class="line">private ZSetOperations&lt;K, V&gt; zSetOps;</span><br></pre></td></tr></table></figure>
<p>RedisTemplate中定义了对5种数据结构操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redisTemplate.opsForValue();//操作字符串 </span><br><span class="line">redisTemplate.opsForHash();//操作hash </span><br><span class="line">redisTemplate.opsForList();//操作list </span><br><span class="line">redisTemplate.opsForSet();//操作set </span><br><span class="line">redisTemplate.opsForZSet();//操作有序set</span><br></pre></td></tr></table></figure>
<p>StringRedisTemplate继承自RedisTemplate，也一样拥有上面这些操作。 StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存 的。RedisTemplate默认采用的是JDK的序列化策略，保存的key和value都是采用此策略序列化保存的。</p>
<p>Redis客户端命令对应的RedisTemplate中的方法列表：</p>
<p><img src="https://images.lilhui.com/701b9d3fc1a6eacf37468e93d36f10e0" alt="图片"></p>
<p><img src="https://images.lilhui.com/74100f8edf5b02b2f9bc229dd567da87" alt="图片"></p>
<p><img src="https://images.lilhui.com/1ec7a56abb3e06364c49830ce29a8988" alt="图片"></p>
<p><img src="https://images.lilhui.com/d14be88c07fe271ca86af964e71ca178" alt="图片"></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis，哨兵</tag>
      </tags>
  </entry>
  <entry>
    <title>【Redis学习3】redis集群和高可用</title>
    <url>/2022/07/02/redis/redis_core_3/</url>
    <content><![CDATA[<h2 id="Redis集群方案"><a href="#Redis集群方案" class="headerlink" title="Redis集群方案"></a>Redis集群方案</h2><p><strong>哨兵模式</strong></p>
<p><img src="https://images.lilhui.com/8b76471ec50ed03137bfb7b2ee9dfc17" alt="图片"></p>
<p>在redis3.0以前的版本需要实现集群一般是借助于哨兵sentinel工具来监控master节点的状态，如果master异常，则会做主从切换，将某一台slave作为master,<br>哨兵的配置略微复杂，并且性能和高可用等方面表现一般，特别在主从切换的瞬间存在访问瞬断的情况，而且哨兵模式只有一个主节点对外进行服务，没法支持很高的<br>并发，而且单个节点内存也不宜设置的过大，否则会导致持久化文件过大，影响数据恢复或主从同步的效率。</p>
<p><strong>高可用集群</strong></p>
<p><img src="https://images.lilhui.com/525b5676ac10f2dc5ed4be83bfb45a23" alt="图片"></p>
<p>redis集群是一个由<strong>多个主从节点群组组成的分布式服务器群</strong>，它具有<strong>复制、高可用和分片</strong>特性。redis集群不需要sentinel哨兵也能完成节点移除和故障<br>转移工鞥呢。需要将每个节点设置成集群模式，这种集群模式没有中心节点，可水平扩展，根据官方文档称：可以线性扩展到上万个节点（官方推荐不超过1000）。<br>redis集群的性能和高可用性均优于之前版本的哨兵模式，且集群配置非常简单。</p>
<h2 id="Redis高可用集群搭建"><a href="#Redis高可用集群搭建" class="headerlink" title="Redis高可用集群搭建"></a>Redis高可用集群搭建</h2><p>redis集群至少三个master节点，我们这里搭建三个master节点，并且给每个master再搭建一个slave节点，总共6个redis节点，这里用三台机器部署6个实例。<br>每台机器一主一从，搭建步骤如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第一步：在第一台机器的/usr/local下创建文件夹redis-cluster，然后在其下面分别创建2个文件夾如下</span><br><span class="line">（1）mkdir -p /usr/local/redis-cluster</span><br><span class="line">（2）mkdir 8001 8004</span><br><span class="line"></span><br><span class="line">第一步：把之前的redis.conf配置文件copy到8001下，修改如下内容：</span><br><span class="line">（1）daemonize yes</span><br><span class="line">（2）port 8001（分别对每个机器的端口号进行设置）</span><br><span class="line">（3）pidfile /var/run/redis_8001.pid  # 把pid进程号写入pidfile配置的文件</span><br><span class="line">（4）dir /usr/local/redis-cluster/8001/（指定数据文件存放位置，必须要指定不同的目录位置，不然会丢失数据）</span><br><span class="line">（5）cluster-enabled yes（启动集群模式）</span><br><span class="line">（6）cluster-config-file nodes-8001.conf（集群节点信息文件，这里800x最好和port对应上）</span><br><span class="line">（7）cluster-node-timeout 10000</span><br><span class="line"><span class="meta"> (8)#</span><span class="bash"> <span class="built_in">bind</span> 127.0.0.1（<span class="built_in">bind</span>绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip，代表允许客户端通过机器的哪些网卡ip去访问，内网一般可以不配置<span class="built_in">bind</span>，注释掉即可）</span></span><br><span class="line"> (9)protected-mode  no   （关闭保护模式）</span><br><span class="line"> (10)appendonly yes</span><br><span class="line">如果要设置密码需要增加如下配置：</span><br><span class="line"> (11)requirepass littlehui     (设置redis访问密码)</span><br><span class="line"> (12)masterauth littlehui      (设置集群节点间访问密码，跟上面一致)</span><br><span class="line"></span><br><span class="line">第三步：把修改后的配置文件，copy到8004，修改第2、3、4、6项里的端口号，可以用批量替换：</span><br><span class="line">:%s/源字符串/目的字符串/g </span><br><span class="line"></span><br><span class="line">第四步：另外两台机器也需要做上面几步操作，第二台机器用8002和8005，第三台机器用8003和8006</span><br><span class="line"></span><br><span class="line">第五步：分别启动6个redis实例，然后检查是否启动成功</span><br><span class="line">（1）/usr/local/redis-5.0.3/src/redis-server /usr/local/redis-cluster/800*/redis.conf</span><br><span class="line">（2）ps -ef | grep redis 查看是否启动成功</span><br><span class="line">    </span><br><span class="line">第六步：用redis-cli创建整个redis集群(redis5以前的版本集群是依靠ruby脚本redis-trib.rb实现)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面命令里的1代表为每个创建的主服务器节点创建一个从服务器节点</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行这条命令需要确认三台机器之间的redis实例要能相互访问，可以先简单把所有机器防火墙关掉，如果不关闭防火墙则需要打开redis服务端口和集群节点gossip通信端口16379(默认是在redis端口号上加1W)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭防火墙</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl stop firewalld <span class="comment"># 临时关闭防火墙</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">disable</span> firewalld <span class="comment"># 禁止开机启动</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意：下面这条创建集群的命令大家不要直接复制，里面的空格编码可能有问题导致创建集群不成功</span></span><br><span class="line">（1）/usr/local/redis-5.0.3/src/redis-cli -a littlehui --cluster create --cluster-replicas 1 192.168.0.61:8001 192.168.0.62:8002 192.168.0.63:8003 192.168.0.61:8004 192.168.0.62:8005 192.168.0.63:8006 </span><br><span class="line"></span><br><span class="line">第七步：验证集群：</span><br><span class="line">（1）连接任意一个客户端即可：./redis-cli -c -h -p (-a访问服务端密码，-c表示集群模式，指定ip地址和端口号）</span><br><span class="line">    如：/usr/local/redis-5.0.3/src/redis-cli -a littlehui -c -h 192.168.0.61 -p 800*</span><br><span class="line">（2）进行验证： cluster info（查看集群信息）、cluster nodes（查看节点列表）</span><br><span class="line">（3）进行数据操作验证</span><br><span class="line">（4）关闭集群则需要逐个进行关闭，使用命令：</span><br><span class="line">/usr/local/redis-5.0.3/src/redis-cli -a littlehui -c -h 192.168.0.60 -p 800* shutdown</span><br></pre></td></tr></table></figure>
<h2 id="Java操作redis集群"><a href="#Java操作redis集群" class="headerlink" title="Java操作redis集群"></a>Java操作redis集群</h2><p>借助redis的java客户端jedis可以操作以上集群，引用jedis坐标</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>Java编写访问redis集群代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisClusterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        config.setMaxTotal(<span class="number">20</span>);</span><br><span class="line">        config.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">        config.setMinIdle(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;HostAndPort&gt; jedisClusterNode = <span class="keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line">        jedisClusterNode.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.0.61"</span>, <span class="number">8001</span>));</span><br><span class="line">        jedisClusterNode.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.0.62"</span>, <span class="number">8002</span>));</span><br><span class="line">        jedisClusterNode.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.0.63"</span>, <span class="number">8003</span>));</span><br><span class="line">        jedisClusterNode.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.0.61"</span>, <span class="number">8004</span>));</span><br><span class="line">        jedisClusterNode.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.0.62"</span>, <span class="number">8005</span>));</span><br><span class="line">        jedisClusterNode.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.0.63"</span>, <span class="number">8006</span>));</span><br><span class="line"></span><br><span class="line">        JedisCluster jedisCluster = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//connectionTimeout：指的是连接一个url的连接等待时间</span></span><br><span class="line">            <span class="comment">//soTimeout：指的是连接上一个url，获取response的返回等待时间</span></span><br><span class="line">            jedisCluster = <span class="keyword">new</span> JedisCluster(jedisClusterNode, <span class="number">6000</span>, <span class="number">5000</span>, <span class="number">10</span>, <span class="string">"littlehui"</span>, config);</span><br><span class="line">            System.out.println(jedisCluster.set(<span class="string">"cluster"</span>, <span class="string">"littlehui"</span>));</span><br><span class="line">            System.out.println(jedisCluster.get(<span class="string">"cluster"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedisCluster != <span class="keyword">null</span>)</span><br><span class="line">                jedisCluster.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行效果如下：</span><br><span class="line">OK</span><br><span class="line">littlehui</span><br></pre></td></tr></table></figure>
<p>集群Spring boot整合redis连接代码示例：redis-sentinel-cluster</p>
<ol>
<li>引入依赖：</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>springboot项目核心配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8080</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    database: <span class="number">0</span></span><br><span class="line">    timeout: <span class="number">3000</span></span><br><span class="line">    password: littlehui</span><br><span class="line">    cluster:</span><br><span class="line">      nodes: <span class="number">192.168</span><span class="number">.0</span><span class="number">.61</span>:<span class="number">8001</span>,<span class="number">192.168</span><span class="number">.0</span><span class="number">.62</span>:<span class="number">8002</span>,<span class="number">192.168</span><span class="number">.0</span><span class="number">.63</span>:<span class="number">8003</span>,<span class="number">192.168</span><span class="number">.0</span><span class="number">.61</span>:<span class="number">8004</span>,<span class="number">192.168</span><span class="number">.0</span><span class="number">.62</span>:<span class="number">8005</span>,<span class="number">192.168</span><span class="number">.0</span><span class="number">.63</span>:<span class="number">8006</span></span><br><span class="line">   lettuce:</span><br><span class="line">      pool:</span><br><span class="line">        max-idle: <span class="number">50</span></span><br><span class="line">        min-idle: <span class="number">10</span></span><br><span class="line">        max-active: <span class="number">100</span></span><br><span class="line">        max-wait: <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>访问代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(IndexController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test_cluster"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCluster</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       stringRedisTemplate.opsForValue().set(<span class="string">"littlehui"</span>, <span class="string">"666"</span>);</span><br><span class="line">       System.out.println(stringRedisTemplate.opsForValue().get(<span class="string">"littlehui"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Redis集群原理分析"><a href="#Redis集群原理分析" class="headerlink" title="Redis集群原理分析"></a>Redis集群原理分析</h2><p>Redis Cluster将所有数据划分为16384个slot(槽位)，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中。</p>
<p>当Redis Cluster的客户端来连接集群时，它会得到一份集群的槽位配置信息，并将其缓存在客户端本地。这样当客户端要查找某个key时，可以直接定位到目标<br>节点。同时因为槽位的信息可能会存在客户端与服务器不一致的情况。还需要纠正机制来实现槽位信息的校验调整。</p>
<h3 id="槽位定位"><a href="#槽位定位" class="headerlink" title="槽位定位"></a>槽位定位</h3><p>Cluster默认会对key值使用crc16算法进行hash得到一个整数值，然后用这个整数值对16384进行取摸到具体槽位。</p>
<p>HASH_SLOT = CRC16(key) mod 16384</p>
<h3 id="跳转重定位"><a href="#跳转重定位" class="headerlink" title="跳转重定位"></a>跳转重定位</h3><p>当客户端向一个错误的节点发出了指令，该节点会发现指令的key所在的槽位并不归自己管理，这时它会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，<br>告诉客户端去链接这个节点去获取数据。客户端接收到指令后除了跳转到正确的节点上去操作，还会同步更新纠正本地的槽位映射表缓存，后续所有key将使用新的<br>槽位映射表。</p>
<p><img src="https://images.lilhui.com/1dc5c7bb99d6ffcc06c834ee4ae9ebf6" alt="图片"></p>
<h3 id="Redis集群节点间的通信机制"><a href="#Redis集群节点间的通信机制" class="headerlink" title="Redis集群节点间的通信机制"></a>Redis集群节点间的通信机制</h3><p>redis cluster 节点间采用gossip协议进行通信</p>
<p>维护集群的元数据（集群节点信息，主从节点，节点数量，各节点共享的数据等）有两种方式:几种式和gossip</p>
<h4 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h4><p>优点在于元数据的更新和读取，时效性非常好，一单元数据出现变更立即更新到集中式的存储中，其他节点读取的时候立即感知到；不足在于所有的元数据更新压力<br>集中在一个地方，可能导致元数据的存储压力。很多中间件都会借助zookeeper集中式存储元数据。</p>
<h4 id="gossip"><a href="#gossip" class="headerlink" title="gossip"></a>gossip</h4><p><img src="https://images.lilhui.com/be3e04e29fca2d867970bc9caced10c7" alt="图片"></p>
<p>gossip协议包含多种消息，包括ping，pong，meet，fail等等。<br>meet：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信；</p>
<p><strong>meet</strong>:某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信；<br><strong>ping</strong>:每个节点都会频繁给其他节点发送ping,其中包含自己的状态还有自己维护的集群元数据，互相通过ping交换元数据（类似自己感知到的集群节点增加<br>和移除hash slot信息等）；<br><strong>pong</strong>:对ping和meet消息的返回，包含自己的状态和其他信息，也可以用于信息广播和更新；<br><strong>fail</strong>:某个节点判断另一个节点fail之后，就发送fail给其他节点，通知其他节点，指定的节点宕机了。</p>
<h4 id="gossip通信的1000端口"><a href="#gossip通信的1000端口" class="headerlink" title="gossip通信的1000端口"></a>gossip通信的1000端口</h4><p>每个节点都有一个专门用于节点间gossip通信的端口，就是自己提供的服务端口+10000，比如7001，那么用于节点通信的就是17001端口。每个节点间隔一段时间<br>就会往另外几个节点发送ping消息，同时其他节点接收到ping消息之后返回pong信息。</p>
<h4 id="网络抖动"><a href="#网络抖动" class="headerlink" title="网络抖动"></a>网络抖动</h4><p>真实世界的机房网络往往并不是风平浪静的，他们经常会发生各种各样的小问题。比如网络抖动。突然之间部分链接变得不可访问，然后很快又恢复正常。</p>
<p>为解决这种问题，Redis cluster提供了一种选项cluster-node-timeout,表示当某个节点持续timeout的时间失联时，才可以认定该节点出现故障，需要进行<br>主从切换。如果没有这个选项，网络抖动会导致主从频繁切换（数据的重新复制）。</p>
<h3 id="Redis集群选举原理分析"><a href="#Redis集群选举原理分析" class="headerlink" title="Redis集群选举原理分析"></a>Redis集群选举原理分析</h3><p>当slave发现自己的master变为FAIL状态时，进行failover,以期成为新的master。由于挂掉的master可能会有多个slave,从而存在多个slave竞争成为master<br>节点的过程，过程如下：</p>
<ol>
<li>slave发现自己的master变成fail</li>
<li>将自己记录的集群currentEpoch加1， 并广播failover_auth_request信息</li>
<li>其他节点接收到该信息，只有master响应，判断请求的合法性，并发送failover_auth_ack，对每一个epoch只发送一次ack.</li>
<li>尝试failover的slave搜集master返回的failover_auth_ack</li>
<li>slave收到过半数master的ack后变成新的master(所以为什么至少要三个主节点，如果只有2个其中一个挂了，只剩一个节点是不能选举成功的)</li>
<li>slave广播pong消息通知其他集群节点</li>
</ol>
<p>从节点并不是在主节点已进入fail状态就马上尝试发生选举，而是有一定延迟，一定的延迟保证我们等待fail状态在集群中传播，slave如果立即选举，其他master<br>获取尚未意识到fail状态，可能会拒绝投票。</p>
<ul>
<li>延迟计算公式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> DELAY = <span class="number">500</span>ms + random(<span class="number">0</span> ~ <span class="number">500</span>ms) + SLAVE_RANK * <span class="number">1000</span>ms</span><br></pre></td></tr></table></figure>
<p>SLAVE_RANK表示此slave已经从master复制数据的总量的rank。Rank越小代表已复制的数据越新。这种方式下，持有最新数据的slave将会首先发起选举（理论上）。</p>
<h2 id="集群的一些问题"><a href="#集群的一些问题" class="headerlink" title="集群的一些问题"></a>集群的一些问题</h2><h3 id="集群脑裂数据丢失问题"><a href="#集群脑裂数据丢失问题" class="headerlink" title="集群脑裂数据丢失问题"></a>集群脑裂数据丢失问题</h3><p>redis集群没有过半机制会有脑裂问题，网络分区导致脑裂后。多个主节点对外提供写服务，一旦网络分区恢复，会将其中一个主节点变为从节点，这时会有大量数据丢失。</p>
<p>规避方法可以在redis配置里加上参数（这种方法不可能百分百避免数据丢失，参考集群leader选举机制）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">min-replicas-to-write <span class="number">1</span>  <span class="comment">//写数据成功最少同步的slave数量，这个数量可以模仿大于半数机制配置，比如集群总共三个节点可以配置1，加上leader就是2，超过了半数</span></span><br><span class="line">注意：这个配置在一定程度上会影响集群的可用性，比如slave要是少于<span class="number">1</span>个，这个集群就算leader正常也不能提供服务了，需要具体场景权衡选择。</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：这个配置在一定程度上可能影响集群的可用性，比如slave少于1个，这个集群就算leader正常也不能提供服务，需要具体场景权衡。</p>
<h3 id="集群是否完整才能对外提供服务"><a href="#集群是否完整才能对外提供服务" class="headerlink" title="集群是否完整才能对外提供服务"></a>集群是否完整才能对外提供服务</h3><p>当redis.conf的配置cluster-require-full-coverage为no时，表示当负责一个插槽的主库下线且没有响应的从库进行故障恢复时，集群仍然可用，如果yes则集群不可用。</p>
<h3 id="Redis集群为什么至少需要三个master节点，并且推荐节点数量为奇数"><a href="#Redis集群为什么至少需要三个master节点，并且推荐节点数量为奇数" class="headerlink" title="Redis集群为什么至少需要三个master节点，并且推荐节点数量为奇数"></a>Redis集群为什么至少需要三个master节点，并且推荐节点数量为奇数</h3><p>因为新master的选举需要大于半数的集群master节点同意才能选举成功。如果只有2个master节点，其中一个挂了，是达不到选举新master的条件的。</p>
<p>奇数个master节点可以在满足选举该条件的基础上节省一个节点，比如三个master节点和四个master节点的集群相比，大家如果都挂了一个master节点都能选举新的<br>master节点，如果都挂了2个master节点都没法选举新的master节点，所以奇数的master节点更多的是从节省机器资源角度考虑的。</p>
<h2 id="Redis集群对批量操作命令的支持"><a href="#Redis集群对批量操作命令的支持" class="headerlink" title="Redis集群对批量操作命令的支持"></a>Redis集群对批量操作命令的支持</h2><p>对于类似mset,mget这样的多个key原生批量操作命令，redis集群只支持所有key落在同一个slot的情况，如果有多个key一定要用mset命令在redis集群上操作，<br>则可以在key的前面加上{xx},这样参数数据分片hash计算的只会是大括号里的值，遮掩功能确保不同的key能落到同一个slot里。示例如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mset &#123;user1&#125;:<span class="number">1</span>:name littlehui &#123;user1&#125;:<span class="number">1</span>:age <span class="number">18</span></span><br></pre></td></tr></table></figure></p>
<p>假设name和age计算的hash slot值不一样，但是这条命令在集群下执行，redis只会用大括号里的 user1 做hash slot计算，所以算出来的slot值肯定相同，最后都能落在同一slot。</p>
<h2 id="哨兵leader选举流程"><a href="#哨兵leader选举流程" class="headerlink" title="哨兵leader选举流程"></a>哨兵leader选举流程</h2><p>当一个master服务器被某sentinel视为下线状态后，该sentinel会与其他sentinel协商选出sentinel的leader进行故障转移工作。每个发现master服务器进入下线的sentinel都可以要求其他sentinel选自己为sentinel的leader，选举是先到先得。同时每个sentinel每次选举都会自增配置纪元(选举周期)，每个纪元中只会选择一个sentinel的leader。如果所有超过一半的sentinel选举某sentinel作为leader。之后该sentinel进行故障转移操作，从存活的slave中选举出新的master，这个选举过程跟集群的master选举很类似。<br>哨兵集群只有一个哨兵节点，redis的主从也能正常运行以及选举master，如果master挂了，那唯一的那个哨兵节点就是哨兵leader了，可以正常选举新master。</p>
<p>哨兵集群只有一个哨兵节点，redis的主从也能正常运行以及选举master，如果master挂了，那唯一的那个哨兵节点就是哨兵leader了，可以正常选举新master。<br>不过为了高可用一般都推荐至少部署三个哨兵节点。为什么推荐奇数个哨兵节点原理跟集群奇数个master节点类似。</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="分布式锁实现场景"><a href="#分布式锁实现场景" class="headerlink" title="分布式锁实现场景"></a>分布式锁实现场景</h3><p>互联网秒杀，抢优惠券，接口幂等性校验</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul>
<li>setnx</li>
<li>原子加</li>
</ul>
<p><img src="https://images.lilhui.com/390ed2a0d1575105c79a366ecd64e6f6" alt="图片"></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>sentinel</tag>
        <tag>cluster</tag>
      </tags>
  </entry>
  <entry>
    <title>【Redis学习5】redis缓存设计和性能优化</title>
    <url>/2022/07/06/redis/redis_core_6/</url>
    <content><![CDATA[<h2 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h2><p><img src="https://images.lilhui.com/de63da81ef636030b90e77bf4d25c9d7" alt="图片"></p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指查询一个根本不存在的数据， 缓存层和存储层都不会命中， 通常出于容错的考虑， 如果从存储层查不到数据则不写入缓存层。<br>缓存穿透将导致不存在的数据每次请求都要到存储层去查询， 失去了缓存保护后端存储的意义。</p>
<p>造成缓存穿透的基本原因有两个：<br>第一， 自身业务代码或者数据出现问题。<br>第二， 一些恶意攻击、 爬虫等造成大量空命中。<br><strong>缓存穿透问题解决方案：</strong></p>
<h3 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    String cacheValue = cache.get(key);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123;</span><br><span class="line">        <span class="comment">// 从存储中获取</span></span><br><span class="line">        String storageValue = storage.get(key);</span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空， 需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存非空</span></span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>对于恶意攻击，向服务器请求大量不存在的数据造成的缓存穿透，还可以用布隆过滤器先做一次过滤，对于不存在的数据布隆过滤器一般都能够过滤掉，不让请求再往后端发送。当布隆过滤器说某个值存在时，这个值可能不存在；当它说不存在时，那就肯定不存在。</p>
<p><img src="https://images.lilhui.com/2316311cd8e0ce72dcf850ddb6520014" alt="图片"></p>
<p>布隆过滤器就是一个大型的位数组和几个不一样的无偏 hash 函数。所谓无偏就是能够把元素的 hash 值算得比较均匀。<br>向布隆过滤器中添加 key 时，会使用多个 hash 函数对 key 进行 hash 算得一个整数索引值然后对位数组长度进行取模运算得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就完成了 add 操作。</p>
<p>向布隆过滤器询问 key 是否存在时，跟 add 一样，也会把 hash 的几个位置都算出来，看看位数组中这几个位置是否都为 1，只要有一个位为 0，那么说明布隆过滤器中这个key 不存在。如果都是 1，这并不能说明这个 key 就一定存在，只是极有可能存在，因为这些位被置为 1 可能是因为其它的 key 存在所致。如果这个位数组长度比较大，存在概率就会很大，如果这个位数组长度比较小，存在概率就会降低。</p>
<p>这种方法适用于数据命中不高、 数据相对固定、 实时性低（通常是数据集较大） 的应用场景， 代码维护较为复杂， 但是缓存空间占用很少。<br>可以用redisson实现布隆过滤器，引入依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.6.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>示例伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.redisson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RBloomFilter;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonBloomFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">"redis://localhost:6379"</span>);</span><br><span class="line">        <span class="comment">//构造Redisson</span></span><br><span class="line">        RedissonClient redisson = Redisson.create(config);</span><br><span class="line"></span><br><span class="line">        RBloomFilter&lt;String&gt; bloomFilter = redisson.getBloomFilter(<span class="string">"nameList"</span>);</span><br><span class="line">        <span class="comment">//初始化布隆过滤器：预计元素为100000000L,误差率为3%,根据这两个参数会计算出底层的bit数组大小</span></span><br><span class="line">        bloomFilter.tryInit(<span class="number">100000000L</span>,<span class="number">0.03</span>);</span><br><span class="line">        <span class="comment">//将zhuge插入到布隆过滤器中</span></span><br><span class="line">        bloomFilter.add(<span class="string">"zhuge"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断下面号码是否在布隆过滤器中</span></span><br><span class="line">        System.out.println(bloomFilter.contains(<span class="string">"guojia"</span>));<span class="comment">//false</span></span><br><span class="line">        System.out.println(bloomFilter.contains(<span class="string">"baiqi"</span>));<span class="comment">//false</span></span><br><span class="line">        System.out.println(bloomFilter.contains(<span class="string">"zhuge"</span>));<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用布隆过滤器需要把所有数据提前放入布隆过滤器，并且在增加数据时也要往布隆过滤器里放，布隆过滤器缓存过滤伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化布隆过滤器</span></span><br><span class="line">RBloomFilter&lt;String&gt; bloomFilter = redisson.getBloomFilter(<span class="string">"nameList"</span>);</span><br><span class="line"><span class="comment">//初始化布隆过滤器：预计元素为100000000L,误差率为3%</span></span><br><span class="line">        bloomFilter.tryInit(<span class="number">100000000L</span>,<span class="number">0.03</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把所有数据存入布隆过滤器</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (String key: keys) &#123;</span><br><span class="line">                bloomFilter.put(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 从布隆过滤器这一级缓存判断下key是否存在</span></span><br><span class="line">            Boolean exist = bloomFilter.contains(key);</span><br><span class="line">            <span class="keyword">if</span>(!exist)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">            String cacheValue = cache.get(key);</span><br><span class="line">            <span class="comment">// 缓存为空</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123;</span><br><span class="line">                <span class="comment">// 从存储中获取</span></span><br><span class="line">                String storageValue = storage.get(key);</span><br><span class="line">                cache.set(key, storageValue);</span><br><span class="line">                <span class="comment">// 如果存储数据为空， 需要设置一个过期时间(300秒)</span></span><br><span class="line">                <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> storageValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 缓存非空</span></span><br><span class="line">                <span class="keyword">return</span> cacheValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>注意：布隆过滤器不能删除数据，如果要删除得重新初始化数据。</p>
<h2 id="缓存失效（击穿）"><a href="#缓存失效（击穿）" class="headerlink" title="缓存失效（击穿）"></a>缓存失效（击穿）</h2><p>由于大批量缓存在同一时间失效可能导致大量请求同时穿透缓存直达数据库，可能会造成数据库瞬间压力过大甚至挂掉，对于这种情况我们在批量增加缓存时最好将这一批数据的缓存过期时间设置为一个时间段内的不同时间。<br>示例伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    String cacheValue = cache.get(key);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123;</span><br><span class="line">        <span class="comment">// 从存储中获取</span></span><br><span class="line">        String storageValue = storage.get(key);</span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">//设置一个过期时间(300到600之间的一个随机数)</span></span><br><span class="line">        <span class="keyword">int</span> expireTime = <span class="keyword">new</span> Random().nextInt(<span class="number">300</span>)  + <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cache.expire(key, expireTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存非空</span></span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩指的是缓存层支撑不住或宕掉后， 流量会像奔逃的野牛一样， 打向后端存储层。<br>由于缓存层承载着大量请求， 有效地保护了存储层， 但是如果缓存层由于某些原因不能提供服务(比如超大并发过来，缓存层支撑不住，或者由于缓存设计不好，类似大量请求访问bigkey，导致缓存能支撑的并发急剧下降)， 于是大量请求都会打到存储层， 存储层的调用量会暴增， 造成存储层也会级联宕机的情况。<br>预防和解决缓存雪崩问题， 可以从以下三个方面进行着手。<br>1） 保证缓存层服务高可用性，比如使用Redis Sentinel或Redis Cluster。<br>2） 依赖隔离组件为后端限流熔断并降级。比如使用Sentinel或Hystrix限流降级组件。<br>比如服务降级，我们可以针对不同的数据采取不同的处理方式。当业务应用访问的是非核心数据（例如电商商品属性，用户信息等）时，暂时停止从缓存中查询这些数据，而是直接返回预定义的默认降级信息、空值或是错误提示信息；当业务应用访问的是核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存缺失，也可以继续通过数据库读取。<br>3） 提前演练。 在项目上线前， 演练缓存层宕掉后， 应用以及后端的负载情况以及可能出现的问题， 在此基础上做一些预案设定。</p>
<h3 id="热点缓存key重建优化"><a href="#热点缓存key重建优化" class="headerlink" title="热点缓存key重建优化"></a>热点缓存key重建优化</h3><p>开发人员使用“缓存+过期时间”的策略既可以加速数据读写， 又保证数据的定期更新， 这种模式基本能够满足绝大部分需求。 但是有两个问题如果同时出现， 可能就会对应用造成致命的危害：<br>当前key是一个热点key（例如一个热门的娱乐新闻），并发量非常大。<br>重建缓存不能在短时间完成， 可能是一个复杂计算， 例如复杂的SQL、 多次IO、 多个依赖等。<br>在缓存失效的瞬间， 有大量线程来重建缓存， 造成后端负载加大， 甚至可能会让应用崩溃。<br>要解决这个问题主要就是要避免大量线程同时重建缓存。<br>我们可以利用互斥锁来解决，此方法只允许一个线程重建缓存， 其他线程等待重建缓存的线程执行完， 重新从缓存获取数据即可。<br>示例伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从Redis中获取数据</span></span><br><span class="line">    String value = redis.get(key);</span><br><span class="line">    <span class="comment">// 如果value为空， 则开始重构缓存</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 只允许一个线程重建缓存， 使用nx， 并设置过期时间ex</span></span><br><span class="line">        String mutexKey = <span class="string">"mutext:key:"</span> + key;</span><br><span class="line">        <span class="keyword">if</span> (redis.set(mutexKey, <span class="string">"1"</span>, <span class="string">"ex 180"</span>, <span class="string">"nx"</span>)) &#123;</span><br><span class="line">             <span class="comment">// 从数据源获取数据</span></span><br><span class="line">            value = db.get(key);</span><br><span class="line">            <span class="comment">// 回写Redis， 并设置过期时间</span></span><br><span class="line">            redis.setex(key, timeout, value);</span><br><span class="line">            <span class="comment">// 删除key_mutex</span></span><br><span class="line">            redis.delete(mutexKey);</span><br><span class="line">        &#125;<span class="comment">// 其他线程休息50毫秒后重试</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="缓存与数据库双写不一致"><a href="#缓存与数据库双写不一致" class="headerlink" title="缓存与数据库双写不一致"></a>缓存与数据库双写不一致</h2><p>在大并发下，同时操作数据库与缓存会存在数据不一致性问题<br>1、双写不一致情况<br><img src="https://images.lilhui.com/12a83025928c7558cd7aa2eb80cd414f" alt="图片"></p>
<ol start="2">
<li>读写不一致<br><img src="https://images.lilhui.com/448141939bf5b6a53088e0332c577d0b" alt="图片"></li>
</ol>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>1、对于并发几率很小的数据(如个人维度的订单数据、用户数据等)，这种几乎不用考虑这个问题，很少会发生缓存不一致，可以给缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。<br>2、就算并发很高，如果业务上能容忍短时间的缓存数据不一致(如商品名称，商品分类菜单等)，缓存加上过期时间依然可以解决大部分业务对于缓存的要求。<br>3、如果不能容忍缓存数据不一致，可以通过加分布式读写锁保证并发读写或写写的时候按顺序排好队，读读的时候相当于无锁。<br>4、也可以用阿里开源的canal通过监听数据库的binlog日志及时的去修改缓存，但是引入了新的中间件，增加了系统的复杂度。</p>
<p><img src="https://images.lilhui.com/f101e7c0009f26cadfcb012a0b6ab022" alt="图片"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上我们针对的都是读多写少的情况加入缓存提高性能，如果写多读多的情况又不能容忍缓存数据不一致，那就没必要加缓存了，可以直接操作数据库。当然，如果数据库抗不住压力，还可以把缓存作为数据读写的主存储，异步将数据同步到数据库，数据库只是作为数据的备份。<br>放入缓存的数据应该是对实时性、一致性要求不是很高的数据。切记不要为了用缓存，同时又要保证绝对的一致性做大量的过度设计和控制，增加系统复杂性！</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>redis</tag>
        <tag>缓存设计</tag>
      </tags>
  </entry>
  <entry>
    <title>【Redis学习7】开发规范和性能优化</title>
    <url>/2022/07/06/redis/redis_core_7/</url>
    <content><![CDATA[<h2 id="键值设计"><a href="#键值设计" class="headerlink" title="键值设计"></a>键值设计</h2><h3 id="key名设计"><a href="#key名设计" class="headerlink" title="key名设计"></a>key名设计</h3><p>(1)【建议】: 可读性和可管理性<br>以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">trade:order:<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>(2)【建议】：简洁性<br>保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">user:&#123;uid&#125;:friends:messages:&#123;mid&#125; 简化为 u:&#123;uid&#125;:fr:m:&#123;mid&#125;</span><br></pre></td></tr></table></figure>
<p>(3)【强制】：不要包含特殊字符<br>反例：包含空格、换行、单双引号以及其他转义字符</p>
<h3 id="value设计"><a href="#value设计" class="headerlink" title="value设计"></a>value设计</h3><p>(1)【强制】：拒绝bigkey(防止网卡流量、慢查询)<br>在Redis中，一个字符串最大512MB，一个二级数据结构（例如hash、list、set、zset）可以存储大约40亿个(2^32-1)个元素，但实际中如果下面两种情况，我就会认为它是bigkey。</p>
<ul>
<li>字符串类型：它的big体现在单个value值很大，一般认为超过10KB就是bigkey。</li>
<li>非字符串类型：哈希、列表、集合、有序集合，它们的big体现在元素个数太多。</li>
</ul>
<p>一般来说，string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。<br>反例：一个包含200万个元素的list。</p>
<p>非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞）</p>
<h3 id="bigkey的危害"><a href="#bigkey的危害" class="headerlink" title="bigkey的危害"></a>bigkey的危害</h3><ol>
<li>导致网络堵塞</li>
<li>导致redis阻塞<br>bigkey也就意味着每次获取要产生的网络流量较大，假设一个bigkey为1MB，客户端每秒访问量为1000，那么每秒产生1000MB的流量，对于普通的千兆网卡(按照字节算是128MB/s)的服务器来说简直是灭顶之灾，而且一般服务器会采用单机多实例的方式来部署，也就是说一个bigkey可能会对其他实例也造成影响，其后果不堪设想。</li>
<li>过期删除<br>有个bigkey，它安分守己（只执行简单的命令，例如hget、lpop、zscore等），但它设置了过期时间，当它过期后，会被删除，如果没有使用Redis 4.0的过期异步删除(lazyfree-lazy-expire yes)，就会存在阻塞Redis的可能性。</li>
</ol>
<h3 id="bigkey的产生"><a href="#bigkey的产生" class="headerlink" title="bigkey的产生"></a>bigkey的产生</h3><p>一般来说，bigkey的产生都是由于程序设计不当，或者对于数据规模预料不清楚造成的，来看几个例子：<br>(1) 社交类：粉丝列表，如果某些明星或者大v不精心设计下，必是bigkey。<br>(2) 统计类：例如按天存储某项功能或者网站的用户集合，除非没几个人用，否则必是bigkey。<br>(3) 缓存类：将数据从数据库load出来序列化放到Redis里，这个方式非常常用，但有两个地方需要注意，第一，是不是有必要把所有字段都缓存；第二，有没有相关关联的数据，有的同学为了图方便把相关数据都存一个key下，产生bigkey。</p>
<h3 id="如何优化bigkey"><a href="#如何优化bigkey" class="headerlink" title="如何优化bigkey"></a>如何优化bigkey</h3><ol>
<li>拆<br>big list： list1、list2、…listN<br>big hash：可以讲数据分段存储，比如一个大的key，假设存了1百万的用户数据，可以拆分成200个key，每个key下面存放5000个用户数据</li>
<li>如果bigkey不可避免，也要思考一下要不要每次把所有元素都取出来(例如有时候仅仅需要hmget，而不是hgetall)，删除也是一样，尽量使用优雅的方式来处理。</li>
</ol>
<p>(2)【推荐】：选择适合的数据类型。<br>例如：实体类型(要合理控制和使用数据结构，但也要注意节省内存和性能之间的平衡)<br>反例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">set user:<span class="number">1</span>:name tom</span><br><span class="line">set user:<span class="number">1</span>:age <span class="number">19</span></span><br><span class="line">set user:<span class="number">1</span>:favor football</span><br></pre></td></tr></table></figure></p>
<p>正例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hmset user:<span class="number">1</span> name tom age <span class="number">19</span> favor football</span><br></pre></td></tr></table></figure>
<p>3.【推荐】：控制key的生命周期，redis不是垃圾桶。<br>建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)。</p>
<h2 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h2><p>1.【推荐】 O(N)命令关注N的数量<br>例如hgetall、lrange、smembers、zrange、sinter等并非不能使用，但是需要明确N的值。有遍历的需求可以使用hscan、sscan、zscan代替。</p>
<p>2.【推荐】：禁用命令<br>禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。</p>
<p>3.【推荐】合理使用select<br>redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。</p>
<p>4.【推荐】使用批量操作提高效率<br>原生命令：例如mget、mset。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">原生命令：例如mget、mset。</span><br><span class="line">非原生命令：可以使用pipeline提高效率。</span><br></pre></td></tr></table></figure>
<p>但要注意控制一次批量操作的元素个数(例如500以内，实际也和元素字节数有关)。<br>注意两者不同：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 原生命令是原子操作，pipeline是非原子操作。</span><br><span class="line">2. pipeline可以打包不同的命令，原生命令做不到</span><br><span class="line">3. pipeline需要客户端和服务端同时支持。</span><br></pre></td></tr></table></figure>
<p>5.【建议】Redis事务功能较弱，不建议过多使用，可以用lua替代</p>
<h2 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h2><p>1.【推荐】<br>避免多个应用使用一个Redis实例<br>正例：不相干的业务拆分，公共数据做服务化。</p>
<p>2.【推荐】<br>使用带有连接池的数据库，可以有效控制连接，同时提高效率，标准使用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">jedisPoolConfig.setMaxTotal(<span class="number">5</span>);</span><br><span class="line">jedisPoolConfig.setMaxIdle(<span class="number">2</span>);</span><br><span class="line">jedisPoolConfig.setTestOnBorrow(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">JedisPool jedisPool = <span class="keyword">new</span> JedisPool(jedisPoolConfig, <span class="string">"192.168.0.60"</span>, <span class="number">6379</span>, <span class="number">3000</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    jedis = jedisPool.getResource();</span><br><span class="line">    <span class="comment">//具体的命令</span></span><br><span class="line">    jedis.executeCommand()</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.error(<span class="string">"op key &#123;&#125; error: "</span> + e.getMessage(), key, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//注意这里不是关闭连接，在JedisPool模式下，Jedis会被归还给资源池。</span></span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) </span><br><span class="line">        jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连接池参数含义：</p>
<p><img src="https://images.lilhui.com/b944f308e024d4748649b8989b92e793" alt="图片"></p>
<h2 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h2><p>1）maxTotal：最大连接数，早期的版本叫maxActive<br>实际上这个是一个很难回答的问题，考虑的因素比较多：</p>
<p>业务希望Redis并发量<br>客户端执行命令时间<br>Redis资源：例如 nodes(例如应用个数) * maxTotal 是不能超过redis的最大连接数maxclients。<br>资源开销：例如虽然希望控制空闲连接(连接池此刻可马上使用的连接)，但是不希望因为连接池的频繁释放创建连接造成不必靠开销。</p>
<p>以一个例子说明，假设:<br>一次命令时间（borrow|return resource + Jedis执行命令(含网络) ）的平均耗时约为1ms，一个连接的QPS大约是1000<br>业务期望的QPS是50000<br>那么理论上需要的资源池大小是50000 / 1000 = 50个。但事实上这是个理论值，还要考虑到要比理论值预留一些资源，通常来讲maxTotal可以比理论值大一些。</p>
<p>但这个值不是越大越好，一方面连接太多占用客户端和服务端资源，另一方面对于Redis这种高QPS的服务器，一个大命令的阻塞即使设置再大资源池仍然会无济于事。</p>
<p>2）maxIdle和minIdle</p>
<p>maxIdle实际上才是业务需要的最大连接数，maxTotal是为了给出余量，所以maxIdle不要设置过小，否则会有new Jedis(新连接)开销。<br>连接池的最佳性能是maxTotal = maxIdle，这样就避免连接池伸缩带来的性能干扰。但是如果并发量不大或者maxTotal设置过高，会导致不必要的连接资源浪费。一般推荐maxIdle可以设置为按上面的业务期望QPS计算出来的理论连接数，maxTotal可以再放大一倍。</p>
<p>minIdle（最小空闲连接数），与其说是最小空闲连接数，不如说是”至少需要保持的空闲连接数”，在使用连接的过程中，如果连接数超过了minIdle，那么继续建立连接，如果超过了maxIdle，当超过的连接执行完业务后会慢慢被移出连接池释放掉。<br>如果系统启动完马上就会有很多的请求过来，那么可以给redis连接池做预热，比如快速的创建一些redis连接，执行简单命令，类似ping()，快速的将连接池里的空闲连接提升到minIdle的数量。</p>
<p>连接池预热示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Jedis&gt; minIdleJedisList = <span class="keyword">new</span> ArrayList&lt;Jedis&gt;(jedisPoolConfig.getMinIdle());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jedisPoolConfig.getMinIdle(); i++) &#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        jedis = pool.getResource();</span><br><span class="line">        minIdleJedisList.add(jedis);</span><br><span class="line">        jedis.ping();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//注意，这里不能马上close将连接还回连接池，否则最后连接池里只会建立1个连接。。</span></span><br><span class="line">        <span class="comment">//jedis.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//统一将预热的连接还回连接池</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jedisPoolConfig.getMinIdle(); i++) &#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        jedis = minIdleJedisList.get(i);</span><br><span class="line">        <span class="comment">//将连接归还回连接池</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之，要根据实际系统的QPS和调用redis客户端的规模整体评估每个节点所使用的连接池大小。</p>
<p>3.【建议】<br>高并发下建议客户端添加熔断功能(例如sentinel、hystrix)</p>
<p>4.【推荐】<br>设置合理的密码，如有必要可以使用SSL加密访问</p>
<p>5.【建议】<br>Redis对于过期键有三种清除策略：</p>
<ol>
<li>被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key</li>
<li>主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期(默认每100ms)主动淘汰一批已过期的key，这里的一批只是部分过期key，所以可能会出现部分key已经过期但还没有被清理掉的情况，导致内存并没有被释放</li>
<li>当前已用内存超过maxmemory限定时，触发主动清理策略</li>
</ol>
<p>主动清理策略在Redis 4.0 之前一共实现了 6 种内存淘汰策略，在 4.0 之后，又增加了 2 种策略，总共8种：<br>a) 针对设置了过期时间的key做处理：</p>
<ol>
<li>volatile-ttl：在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。</li>
<li>volatile-random：就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。</li>
<li>volatile-lru：会使用 LRU 算法筛选设置了过期时间的键值对删除。</li>
<li>volatile-lfu：会使用 LFU 算法筛选设置了过期时间的键值对删除。</li>
</ol>
<p>b) 针对所有的key做处理：</p>
<ol>
<li>allkeys-random：从所有键值对中随机选择并删除数据。</li>
<li>allkeys-lru：使用 LRU 算法在所有数据中进行筛选删除。</li>
<li>allkeys-lfu：使用 LFU 算法在所有数据中进行筛选删除。</li>
</ol>
<p>c) 不处理：<br>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。</p>
<p><strong>LRU 算法（Least Recently Used，最近最少使用）</strong><br>淘汰很久没被访问过的数据，以最近一次访问时间作为参考。</p>
<p><strong>LFU 算法（Least Frequently Used，最不经常使用）</strong><br>淘汰最近一段时间被访问次数最少的数据，以次数作为参考。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>redis</tag>
        <tag>开发规范</tag>
      </tags>
  </entry>
  <entry>
    <title>solr高级查询edismax函数详解</title>
    <url>/2017/09/11/search/solr%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2edismax%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>最近遇到solr查询中加入字段权重的需求，自然而然地想到了edismax这个功能。通过系统的学习和文档阅读，大概了解solr 对于函数式查询的支持方式。为了便于记忆，这里对常用公式进行整理说明。  </p>
</blockquote>
<p>使用方式详细见<a href="https://cwiki.apache.org/confluence/display/solr/The+DisMax+Query+Parser" target="_blank" rel="noopener">官方文档介绍</a><br>，这里不做说明，我们重点讲solr edismax所涉及到的函数。   </p>
<h2 id="bf函数列表"><a href="#bf函数列表" class="headerlink" title="bf函数列表"></a>bf函数列表</h2><ol>
<li><p>constant<br> 支持小数点的常量<br>例如，1.5，查询表达式就是：_val_:1.5</p>
</li>
<li><p>fieldvalue<br> 返回numberic field的名字.<br>域必须是index的，非multivalue。格式为该域的名字。如果这个域没值，就返回0</p>
</li>
<li><p>ord<br> ord，返回你要查询的那个特定的值在这个顺序中的排名。<br> 非multiValued的，当没有值存在的时候，将返回0<br> 例如：某个特定的域只能去三个值，“apple”、“banana”、“pear”，那么ord（“apple”）=1，ord（“banana”）=2，ord（“pear”）=3<br> 需要注意的是，ord（）这个函数，依赖于值在索引中的位置，所以当有文档被删除、或者添加的时候，ord（）的值就会发生变化。当你使用MultiSearcher的时候，这个值也就是不定的了。</p>
</li>
<li>rord<br> 函数将会返回与ord相对应的倒排序的排名。<br> 格式: rord(myIndexedField).</li>
<li>sum<br> 就是表示多个数值的“和”。  <pre><code>格式：  
sum(x,1)  
sum(x,y)  
sum(sqrt(x),log(y),z,0.5)
</code></pre></li>
<li><p>product<br> 多个参数的乘积，参数可以是数值，也可以是函数，当为函数时，表示为此函数的计算值乘积。<br> 格式：<br> product(x,2)<br> product(x,y)</p>
</li>
<li><p>div<br> 两个参数做除法。支持函数参数<br> 格式：<br> div(x,y)<br> div(sum(x,100),max(y,1))</p>
</li>
<li>pow<br> 幂值计算，pow(x,y)=x^y 。支持函数参数。<br> 格式：<br> pow(x,0.5) 标识开方<br> pow(x, log(y))</li>
<li>abs<br> 返回表达式的绝对值，支持函数参数。<br> 格式：<br> abx(-5)<br> abc(x)  </li>
<li><p>log<br>返回对数操作，支持函数参数。<br>格式：<br>log(x)<br>log(sum(x,100))  </p>
</li>
<li><p>sqrt<br>返回平方根。与pow(x，0.5)一样。<br>格式：<br>sqrt(2)<br>sqrt(sum(x,100))</p>
</li>
<li><p>map<br>区间检测<br>如果 min&lt;=x&lt;=max，那么map(x,min,max,target)=target，如果x不在[min,max]这个区间内，那么map(x,min,max,target)=x.</p>
</li>
<li>scala<br>限制参数区间<br>例如：<br>scale(x,minTarget,maxTarget) 这个函数将会把x的值限制在[minTarget,maxTarget]范围内。</li>
<li>query<br>计算subquery查询分数<br>例如：<br>query(subquery,default)表示返回给定的subquery的分数，如果subquery与文档不匹配，那么将会返回默认值。任何的查询类型都是受支持的。可以通过引用的方式，也可以直接指定查询串。<br>q=product(popularity, query({!dismax v=’solr rocks’})) 将会返回popularity和通过dismax 查询得到的分数的乘积<br>q=product(popularity, query($qq)&amp;qq={!dismax}solr rocks) 跟上一个例子的效果是一样的。不过这里使用的是引用的方式<br>q=product(popularity, query($qq,0.1)&amp;qq={!dismax}solr rocks) 在前一个例子的基础上又加了一个默认值。</li>
<li>linear<br>线性函数计算<br>例如：<br>liner(x,m,c)其中 x为变量或者函数，m,c为常量。整个函数取值为： x<em>m+c的值。<br>liner(x,2,4)=2</em>x+4</li>
<li>recip<br>recip(x,m,a,b) 函数表达式 a/(m*x+b)<br>其中，m、a、b是常量，x是变量或者一个函数。当a=b，并且x&gt;=0的时候，这个函数的最大值是1，值的大小随着x的增大而减小。</li>
<li>max<br>比较大小<br>例如：max(x,c) x可以为变量或者函数，c为常数，返回两个之间最大值。</li>
</ol>
<h2 id="场景应用"><a href="#场景应用" class="headerlink" title="场景应用"></a>场景应用</h2><ol>
<li><p>某地的新闻网页库中原本的逻辑是对仓库里的数据字段 subject，message进行搜索。默认是通过score检索字段匹配得分进行排序输出。随着时间的推移，大量的搜索可能会展示两年前，三年前匹配度更高的数据，这些搜索结果明显不合适的。那么我们需要对其进行改造，加入发布时间权重排序。</p>
<p> 原本的参数：  </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subject:武则天 OR message:武则天</span><br></pre></td></tr></table></figure>
<p> 搜索得出结果：  </p>
<p> <img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1505143414801.png?imageView2/2/w/1225/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"><br> 文档得分：<br> <img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1505143508131.png?imageView2/2/w/913/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<p> 上面我们可以看到，tid为666811的文档排在第一位，得分27.811375 它的dateline时间是：1239781944明显早于第二位 tid：10364925的 1503334472，得分：26.519054。第三位是 tid:9759987 得分：26.511488。这样的搜索结果显然不是很令人满意的。<br> 开启edismax 加入</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bf=sqrt(log(dateline))^100</span><br></pre></td></tr></table></figure>
<p> 搜索得出结果：  </p>
<p> <img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1505143118475.png?imageView2/2/w/1222/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<p> 文档得分： </p>
<p> <img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1505143152722.png?imageView2/2/w/922/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"><br> 经过调整，我们得出的结果中排在第一位的是 tid:9759987 其时间dateline是1473820016 得分：330.85 是原本的第三位。原来的排第一的 tid:666811排在了第三位，得分 329.40 原来的第二tid:10364925 得分：329.50</p>
<p> 调整后的排序大致满足我们的需求。那么为什么调整后会变成这样的排序呢？</p>
<p> 首先我们要清楚solr的打分机制默认是通过匹配度计算文档相似度得来的。也就是第一次搜索的默认得分，引入edismax的bf函数后我们来分析下最终的结果是怎样，以第一次搜索排名前三的数据为例子：  </p>
<p> tid  | dateline | 初始得分 | 引入bf重新计算<br> —|—|—|—<br> 666811 | 1239781944 | 27.811382 | 329.40198<br> 10364925 | 1503334472  | 26.519054 |329.50174<br> 9759987 | 1473820016 | 26.511488 | 330.85834 </p>
</li>
</ol>
<blockquote>
<p>根据bf=sqrt(log(dateline))^100 分别计算上面三个的新得分  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqrt(log(1239781944)) = 3.0155174194591075  </span><br><span class="line">权重乘100 得:  </span><br><span class="line">301.55174194591075</span><br><span class="line">再加 27.811382  </span><br><span class="line">=329.36312394591073</span><br><span class="line"></span><br><span class="line">sqrt(log(1503334472)) = 3.029365546794402</span><br><span class="line">权重乘100 得:</span><br><span class="line">302.9365546794402</span><br><span class="line">再加 26.519054</span><br><span class="line">=329.45560867944016</span><br><span class="line"></span><br><span class="line">sqrt(log(1473820016)) = 3.0279439311841663</span><br><span class="line">权重乘100 得:</span><br><span class="line">302.79439311841663</span><br><span class="line">再加 26.511488</span><br><span class="line">=329.3058811184166</span><br></pre></td></tr></table></figure>
<pre><code>纳尼。很奇怪为什么 9759987 计算最小 不对劲
</code></pre><p>于是翻看原来前面查询的debug列表分析仔细看原来是<br>原图：</p>
<p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1505186205866.png?imageView2/2/w/898/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<p>添加edismax后：<br><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1505186154351.png?imageView2/2/w/916/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<p>对比以上靓图，原来是我们的Qparser不一样。在普通查询的时候我么使用的是定制化的 SWMCLuceneQparser 查询解析器。而 用edimax后，解析器变成了 ExtendDismaxQparser 这两个差别在于 定制化的 SWMCLuceneQparser会将查询字段通过IK分词转换后进行查询。其parsedquery_tostring 变成<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;parsedquery&quot;:&quot;PhraseQuery(subject:\&quot;武 则 天\&quot;) PhraseQuery(message:\&quot;武 则 天\&quot;)&quot;,</span><br></pre></td></tr></table></figure></p>
<p>ExtendDismaxQparser的 parsedquery_tostringshi :<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;parsedquery_toString&quot;:&quot;+((subject:武 subject:则 subject:天) (message:武 message:则 message:天)) (sqrt(log(long(dateline))))^10.0&quot;,</span><br></pre></td></tr></table></figure></p>
<p>两者稍有不同，所以在计算最终权重的时候有些差异。</p>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>solr</tag>
        <tag>edismax</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch 启动步骤</title>
    <url>/2018/10/31/search/es_0/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>ES的版本迭代较快每个版本启动和运行方式有所差异，本文以6.4.2版本说明。<br>6.4.2版本下载地址：<a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/downloads/elasticsearch</a></p>
<h2 id="启动步骤"><a href="#启动步骤" class="headerlink" title="启动步骤"></a>启动步骤</h2><p>ES启动是通过下载包的 ./bin/elasticsearch叫本进行启动的。脚本定义了一些es和java的默认参数。可以通过修改脚本参数内容方式启动，控制台运行，比如修改esJVM大小等等。</p>
<p>Elasticsearch启动后 Elasticsearch类解析</p>
<p>Elasticsearch类启动时候运行main()函数，如下:</p>
<p>Elasticsearch初始化各种Option</p>
<h3 id="Elasticsearch内部"><a href="#Elasticsearch内部" class="headerlink" title="Elasticsearch内部"></a>Elasticsearch内部</h3><p>解释：</p>
<ol>
<li>运行System.setSecurityManager 配置默认管理器，默认使用的是 $JAVA_HOME/jre/lib/security/java.policy</li>
<li>注册Errorlistener,LogConfigurator.registerErrorListener();用于在失败的时候报错。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main entry point for starting elasticsearch</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// we want the JVM to think there is a security manager installed so that if internal policy decisions that would be based on the</span></span><br><span class="line">    <span class="comment">// presence of a security manager or lack thereof act as if there is a security manager present (e.g., DNS cache policy)</span></span><br><span class="line">    System.setSecurityManager(<span class="keyword">new</span> SecurityManager() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(Permission perm)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// grant all permissions so that we can later set the security manager to the one that we want</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    LogConfigurator.registerErrorListener();</span><br><span class="line">    <span class="keyword">final</span> Elasticsearch elasticsearch = <span class="keyword">new</span> Elasticsearch();</span><br><span class="line">    <span class="keyword">int</span> status = main(args, elasticsearch, Terminal.DEFAULT);</span><br><span class="line">    <span class="keyword">if</span> (status != ExitCodes.OK) &#123;</span><br><span class="line">        exit(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>启动Elasticsearch命令行客户端EnvironmentAwareCommand和对应用来输入Terminal</li>
</ol>
<p>Elasticsearch</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args, <span class="keyword">final</span> Elasticsearch elasticsearch, <span class="keyword">final</span> Terminal terminal)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elasticsearch.main(args, terminal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EnvironmentAwareCommand</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Terminal terminal, OptionSet options)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, String&gt; settings = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> KeyValuePair kvp : settingOption.values(options)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (kvp.value.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UserException(ExitCodes.USAGE, <span class="string">"setting ["</span> + kvp.key + <span class="string">"] must not be empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (settings.containsKey(kvp.key)) &#123;</span><br><span class="line">            <span class="keyword">final</span> String message = String.format(</span><br><span class="line">                    Locale.ROOT,</span><br><span class="line">                    <span class="string">"setting [%s] already set, saw [%s] and [%s]"</span>,</span><br><span class="line">                    kvp.key,</span><br><span class="line">                    settings.get(kvp.key),</span><br><span class="line">                    kvp.value);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UserException(ExitCodes.USAGE, message);</span><br><span class="line">        &#125;</span><br><span class="line">        settings.put(kvp.key, kvp.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    putSystemPropertyIfSettingIsMissing(settings, <span class="string">"path.data"</span>, <span class="string">"es.path.data"</span>);</span><br><span class="line">    putSystemPropertyIfSettingIsMissing(settings, <span class="string">"path.home"</span>, <span class="string">"es.path.home"</span>);</span><br><span class="line">    putSystemPropertyIfSettingIsMissing(settings, <span class="string">"path.logs"</span>, <span class="string">"es.path.logs"</span>);</span><br><span class="line"></span><br><span class="line">    execute(terminal, options, createEnv(terminal, settings));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Elasticsearch</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Elasticsearch() &#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"starts elasticsearch"</span>, () -&gt; &#123;&#125;); <span class="comment">// we configure logging later so we override the base class from configuring logging</span></span><br><span class="line">    versionOption = parser.acceptsAll(Arrays.asList(<span class="string">"V"</span>, <span class="string">"version"</span>),</span><br><span class="line">        <span class="string">"Prints elasticsearch version information and exits"</span>);</span><br><span class="line">    daemonizeOption = parser.acceptsAll(Arrays.asList(<span class="string">"d"</span>, <span class="string">"daemonize"</span>),</span><br><span class="line">        <span class="string">"Starts Elasticsearch in the background"</span>)</span><br><span class="line">        .availableUnless(versionOption);</span><br><span class="line">    pidfileOption = parser.acceptsAll(Arrays.asList(<span class="string">"p"</span>, <span class="string">"pidfile"</span>),</span><br><span class="line">        <span class="string">"Creates a pid file in the specified path on start"</span>)</span><br><span class="line">        .availableUnless(versionOption)</span><br><span class="line">        .withRequiredArg()</span><br><span class="line">        .withValuesConvertedBy(<span class="keyword">new</span> PathConverter());</span><br><span class="line">    quietOption = parser.acceptsAll(Arrays.asList(<span class="string">"q"</span>, <span class="string">"quiet"</span>),</span><br><span class="line">        <span class="string">"Turns off standard output/error streams logging in console"</span>)</span><br><span class="line">        .availableUnless(versionOption)</span><br><span class="line">        .availableUnless(daemonizeOption);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><p>创建Setting（HashMap)设置Elasticsearch配置</p>
</li>
<li><p>进行命令行相关的设置，初始化之后，跳转到Bootstrap中进行操作 init</p>
</li>
</ol>
<p>Elasticsearch</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Terminal terminal, OptionSet options, Environment env)</span> <span class="keyword">throws</span> UserException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (options.nonOptionArguments().isEmpty() == <span class="keyword">false</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UserException(ExitCodes.USAGE, <span class="string">"Positional arguments not allowed, found "</span> + options.nonOptionArguments());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (options.has(versionOption)) &#123;</span><br><span class="line">        <span class="keyword">final</span> String versionOutput = String.format(</span><br><span class="line">                Locale.ROOT,</span><br><span class="line">                <span class="string">"Version: %s, Build: %s/%s/%s/%s, JVM: %s"</span>,</span><br><span class="line">                Version.displayVersion(Version.CURRENT, Build.CURRENT.isSnapshot()),</span><br><span class="line">                Build.CURRENT.flavor().displayName(),</span><br><span class="line">                Build.CURRENT.type().displayName(),</span><br><span class="line">                Build.CURRENT.shortHash(),</span><br><span class="line">                Build.CURRENT.date(),</span><br><span class="line">                JvmInfo.jvmInfo().version());</span><br><span class="line">        terminal.println(versionOutput);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> daemonize = options.has(daemonizeOption);</span><br><span class="line">    <span class="keyword">final</span> Path pidFile = pidfileOption.value(options);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> quiet = options.has(quietOption);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a misconfigured java.io.tmpdir can cause hard-to-diagnose problems later, so reject it immediately</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        env.validateTmpFile();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UserException(ExitCodes.CONFIG, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        init(daemonize, pidFile, quiet, env);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NodeValidationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UserException(ExitCodes.CONFIG, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> daemonize, <span class="keyword">final</span> Path pidFile, <span class="keyword">final</span> <span class="keyword">boolean</span> quiet, Environment initialEnv)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> NodeValidationException, UserException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Bootstrap.init(!daemonize, pidFile, quiet, initialEnv);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BootstrapException | RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// format exceptions to the console in a special way</span></span><br><span class="line">        <span class="comment">// to avoid 2MB stacktraces from guice, etc.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StartupException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Bootstrap内部"><a href="#Bootstrap内部" class="headerlink" title="Bootstrap内部"></a>Bootstrap内部</h3><ol>
<li>初始化一个KeepAlive线程，内部的countDownLatch用于启动之后的心跳。保证节点运行期间Bootstrap一直存在。可以接受相关的命令退出</li>
<li>做了一些检查，SSL加密customConfFile</li>
<li>创建PID文件</li>
<li>checkLucene版本</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * This method is invoked by &#123;<span class="doctag">@link</span> Elasticsearch#main(String[])&#125; to startup elasticsearch.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">final</span> <span class="keyword">boolean</span> foreground,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">final</span> Path pidFile,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">final</span> <span class="keyword">boolean</span> quiet,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">final</span> Environment initialEnv)</span> <span class="keyword">throws</span> BootstrapException, NodeValidationException, UserException </span>&#123;</span><br><span class="line">      <span class="comment">// force the class initializer for BootstrapInfo to run before</span></span><br><span class="line">      <span class="comment">// the security manager is installed</span></span><br><span class="line">      BootstrapInfo.init();</span><br><span class="line"></span><br><span class="line">      INSTANCE = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> SecureSettings keystore = loadSecureSettings(initialEnv);</span><br><span class="line">      <span class="keyword">final</span> Environment environment = createEnvironment(foreground, pidFile, keystore, initialEnv.settings(), initialEnv.configFile());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          LogConfigurator.configure(environment);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BootstrapException(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (environment.pidFile() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              PidFile.create(environment.pidFile(), <span class="keyword">true</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> BootstrapException(e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">boolean</span> closeStandardStreams = (foreground == <span class="keyword">false</span>) || quiet;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (closeStandardStreams) &#123;</span><br><span class="line">              <span class="keyword">final</span> Logger rootLogger = ESLoggerFactory.getRootLogger();</span><br><span class="line">              <span class="keyword">final</span> Appender maybeConsoleAppender = Loggers.findAppender(rootLogger, ConsoleAppender<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">              <span class="keyword">if</span> (maybeConsoleAppender != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  Loggers.removeAppender(rootLogger, maybeConsoleAppender);</span><br><span class="line">              &#125;</span><br><span class="line">              closeSystOut();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// fail if somebody replaced the lucene jars</span></span><br><span class="line">          checkLucene();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// install the default uncaught exception handler; must be done before security is</span></span><br><span class="line">          <span class="comment">// initialized as we do not want to grant the runtime permission</span></span><br><span class="line">          <span class="comment">// setDefaultUncaughtExceptionHandler</span></span><br><span class="line">          Thread.setDefaultUncaughtExceptionHandler(</span><br><span class="line">              <span class="keyword">new</span> ElasticsearchUncaughtExceptionHandler(() -&gt; Node.NODE_NAME_SETTING.get(environment.settings())));</span><br><span class="line"></span><br><span class="line">          INSTANCE.setup(<span class="keyword">true</span>, environment);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// any secure settings must be read during node construction</span></span><br><span class="line">              IOUtils.close(keystore);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> BootstrapException(e);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          INSTANCE.start();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (closeStandardStreams) &#123;</span><br><span class="line">              closeSysError();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (NodeValidationException | RuntimeException e) &#123;</span><br><span class="line">          <span class="comment">// disable console logging, so user does not see the exception twice (jvm will show it already)</span></span><br><span class="line">          <span class="keyword">final</span> Logger rootLogger = ESLoggerFactory.getRootLogger();</span><br><span class="line">          <span class="keyword">final</span> Appender maybeConsoleAppender = Loggers.findAppender(rootLogger, ConsoleAppender<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">          <span class="keyword">if</span> (foreground &amp;&amp; maybeConsoleAppender != <span class="keyword">null</span>) &#123;</span><br><span class="line">              Loggers.removeAppender(rootLogger, maybeConsoleAppender);</span><br><span class="line">          &#125;</span><br><span class="line">          Logger logger = Loggers.getLogger(Bootstrap<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">          <span class="keyword">if</span> (INSTANCE.node != <span class="keyword">null</span>) &#123;</span><br><span class="line">              logger = Loggers.getLogger(Bootstrap<span class="class">.<span class="keyword">class</span>, <span class="title">Node</span>.<span class="title">NODE_NAME_SETTING</span>.<span class="title">get</span>(<span class="title">INSTANCE</span>.<span class="title">node</span>.<span class="title">settings</span>()))</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// HACK, it sucks to do this, but we will run users out of disk space otherwise</span></span><br><span class="line">          <span class="keyword">if</span> (e <span class="keyword">instanceof</span> CreationException) &#123;</span><br><span class="line">              <span class="comment">// guice: log the shortened exc to the log file</span></span><br><span class="line">              ByteArrayOutputStream os = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">              PrintStream ps = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  ps = <span class="keyword">new</span> PrintStream(os, <span class="keyword">false</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (UnsupportedEncodingException uee) &#123;</span><br><span class="line">                  <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">                  e.addSuppressed(uee);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">new</span> StartupException(e).printStackTrace(ps);</span><br><span class="line">              ps.flush();</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  logger.error(<span class="string">"Guice Exception: &#123;&#125;"</span>, os.toString(<span class="string">"UTF-8"</span>));</span><br><span class="line">              &#125; <span class="keyword">catch</span> (UnsupportedEncodingException uee) &#123;</span><br><span class="line">                  <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">                  e.addSuppressed(uee);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> NodeValidationException) &#123;</span><br><span class="line">              logger.error(<span class="string">"node validation exception\n&#123;&#125;"</span>, e.getMessage());</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// full exception</span></span><br><span class="line">              logger.error(<span class="string">"Exception"</span>, e);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// re-enable it if appropriate, so they can see any logging during the shutdown process</span></span><br><span class="line">          <span class="keyword">if</span> (foreground &amp;&amp; maybeConsoleAppender != <span class="keyword">null</span>) &#123;</span><br><span class="line">              Loggers.addAppender(rootLogger, maybeConsoleAppender);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h3><ol>
<li>根据Pid和是否守护进程等信息和之前是setting，创建运行时环境environment和pid文件。</li>
<li>检查所需的Lucene jar包</li>
<li>根据之前的environment,为每个plugin创建本地插件控制器：spawner</li>
<li>初始化本地资源（native方法进行一些OS调用和JVM信息，比如mlock/系统最大资源之类的）</li>
<li>初始化两种probes（探测），将提供给ES start时所需的一些进程信息和OS层面信息。</li>
<li>检查重复的jar包，并打印在日志中（JarHell.checkJarHell())</li>
</ol>
<h3 id="初始化Node节点（本地节点）"><a href="#初始化Node节点（本地节点）" class="headerlink" title="初始化Node节点（本地节点）"></a>初始化Node节点（本地节点）</h3><ol>
<li>配置一个检查非回路的IP监测点</li>
<li>初始化nodeId和nodeName(new NodeEnvironment)</li>
<li>促使华ES各个功能模块的Service和module，并将service和module绑定</li>
</ol>
<h3 id="核心：真正启动Node和keeplive线程"><a href="#核心：真正启动Node和keeplive线程" class="headerlink" title="核心：真正启动Node和keeplive线程"></a>核心：真正启动Node和keeplive线程</h3><p>node启动是在node中各个模块的胡同，通过guice获取各个module的service接口并启动<br>内部包括了master选举机制等。</p>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>【tomcat调优系列4】Tomcat 类加载机制，和热部署</title>
    <url>/2022/11/23/tomcat/tomcat_4/</url>
    <content><![CDATA[<h2 id="Tomcat类加载机制"><a href="#Tomcat类加载机制" class="headerlink" title="Tomcat类加载机制"></a>Tomcat类加载机制</h2><h3 id="JVM类加载器"><a href="#JVM类加载器" class="headerlink" title="JVM类加载器"></a>JVM类加载器</h3><p>Java中有3个类加载器，并且你可以自定义加载器。</p>
<ul>
<li>BoostrapClassLoader 是启动类加载器，由C预演实现，用来加载JVM启动时所需的核心类，比如rt.jar。</li>
<li>ExtClassLoader是扩展类加载器，用来加载\jre\lib\ext 目录下Jar包。扩展加载器的 #getParent()返回null,实际上扩展类加载器的<br>父类加载器就是启动类加载器。</li>
<li>AppClassLoader是系统类加载器，用来加载ClassPath下的类。应用程序默认用它来加载类。程序可以通过#getSystemClassLoader()来获取系统类加载器。</li>
<li>自定义加载器，用来加载自定义路径下的类。</li>
</ul>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>加载某个类时会先委派父类加载器寻找目标类，找不到再委托上层父加载器，如果所有父加载器都找不到目标类，则在自己的类加载器路径中查找，并载入目标类。</p>
<p><img src="https://images.lilhui.com/c9cdb1fc55bcbd323b25aa274b6f2916" alt="图片"></p>
<p><img src="https://images.lilhui.com/23455a00f586de4dcebe1e4dd8453b05" alt="图片"></p>
<p>上图：ClassLoader#loadClass加载过程</p>
<p>问题： 为什么要设计双亲委派机制？</p>
<ul>
<li><strong>沙箱安全机制</strong>：自己写的java.lang.String.class类不会被夹在，防止API库被篡改。</li>
<li><strong>避免类的重复加载</strong>：当父亲已经加载了该类，就没有必要子ClassLoader再加载一次，保证加载类的唯一性。</li>
</ul>
<h3 id="Tomcat类加载机制-1"><a href="#Tomcat类加载机制-1" class="headerlink" title="Tomcat类加载机制"></a>Tomcat类加载机制</h3><p>Tomcat作为Servlet容器，它负责加载我们的Servlet类，此外还负责加载Servlet所依赖的Jar包。并且Tomcat本身也是一个Java程序。<br>因此它需要加载自己的类和依赖的Jar包。</p>
<p>问题：Tomcat如何隔离Web应用的？</p>
<p>Tomcat 自定义了一个类加载器WebAppClassLoader，并且给每个Web应用创建一个类加载器实例，每个Context容器负责创建和维护一个<br>WebAppClassLoader加载器实例。其实现的原理就是<strong>不同的类加载器实例加载的类被认为是不同的类，即使它们的类名相同（不同类加载器<br>实例加载的类是相互隔离的）</strong>。</p>
<p>Tomcat的自定义类加载器WebAppClassLoader打破了双亲委派机制。它首先自己尝试加载某个类，如果找不到再代理给父类加载器，其目的是<br>优先加载Web应用自己定义的类。具体实现就是重写ClassLoader的2个方法：findClass和loadClass.</p>
<p>findClass步骤：</p>
<ol>
<li>在Web应用本地目录下查找要加载的类。</li>
<li>如果没有找到，交给父加载器去查找，它的付加载器就是上面提到的系统类加载器。AppClassLoader.</li>
<li>如果父加载器也没找到这个类，抛出ClassNotFound异常。</li>
</ol>
<p>loadClass有6个步骤：</p>
<ol>
<li>现在本地Cache查找该类是否加载过，也就是说Tomcat的类加载器是否已经加载过这个类。</li>
<li>如果Tomcat加载器没加载过这个类，再看系统类加载器是否加载过。</li>
<li>如果都没有，就让ExtClassLoader去加载，这一步比较关键，目的防止 Web 应用自己的类覆盖 JRE 的核心类。因为 Tomcat 需要打破双<br>亲委托机制，假如 Web 应用里自定义了一个叫 Object 的类，如果先加载这个 Object 类，就会覆盖 JRE 里面的那个 Object 类，这就<br>是为什么 Tomcat 的类加载器会优先尝试用 ExtClassLoader 去加载，因为 ExtClassLoader 会委托给 BootstrapClassLoader 去加载，BootstrapClassLoader 发现自己已经加载了 Object 类，直接返回给 Tomcat 的类加载器，这样 Tomcat 的类加载器就不会去加载 Web 应用下的 Object 类了，也就避免了覆盖 JRE 核心类的问题。</li>
<li>如果 ExtClassLoader 加载器加载失败，也就是说 JRE 核心类中没有这类，那么就在本地 Web 应用目录下查找并加载。</li>
<li>如果本地目录下没有这个类，说明不是 Web 应用自己定义的类，那么由系统类加载器去加载。这里请你注意，Web 应用是通过Class.forName调用交给系统类加载器的，因为Class.forName的默认加载器就是系统类加载器。</li>
<li>如果上述加载过程全部失败，抛出 ClassNotFound 异常。</li>
</ol>
<p>本地cache -&gt; ExtendClassLoader -&gt; WebAppClassLoader -&gt; AppClassLoader</p>
<p>所以本地可以覆盖jar包里的实现。</p>
<h3 id="Tomcat类加载器的层次结构"><a href="#Tomcat类加载器的层次结构" class="headerlink" title="Tomcat类加载器的层次结构"></a>Tomcat类加载器的层次结构</h3><p>Tomcat 拥有不同的自定义类加载器，以实现对各种资源库的控制。 Tomcat 主要用类加载器解决以下 4 个问题：<br>同一个 Web 服务器里，各个 Web 项目之间各自使用的 Java 类库要互相隔离。</p>
<ul>
<li>同一个 Web 服务器里，各个 Web 项目之间各自使用的 Java 类库要互相隔离。</li>
<li>同一个 Web 服务器里，各个 Web 项目之间可以提供共享的 Java 类库 。</li>
<li>为了使服务器不受 Web 项目的影响，应该使服务器的类库与应用程序的类库互相独立。</li>
<li>对于支持 JSP 的 Web 服务器，应该支持热插拔（ HotSwap ）功能 。  </li>
</ul>
<p>Tomcat提供了四组目录供用户存放第三方类库：</p>
<ul>
<li>放置在/common目录中：类库可被Tomcat和所有的 Web应用程序共同使用。</li>
<li>放置在/server目录中：类库可被Tomcat使用，对所有的Web应用程序都不可见。</li>
<li>放置在/shared目录中：类库可被所有的Web应用程序共同使用，但对 Tomcat自己不可见。</li>
<li>放置在/WebApp/WEB-INF目录中：类库仅仅可以被此Web应用程序使用，对 Tomcat和其他Web应用程序都不可见。</li>
</ul>
<p>Tomcat自定义了多个类加载器</p>
<ol>
<li>CommonClassLoader   加载 /common</li>
<li>CatalinaClassLoader 加载 /server/</li>
<li>SharedClassLoader  加载 /shared/</li>
<li>WebappClassLoader  加载 /WebApp/WEB-INF/</li>
</ol>
<p><img src="https://images.lilhui.com/a4bfcb6f0ae2ddbd691e12746461c7cc" alt="图片"></p>
<h3 id="线程上下文加载器"><a href="#线程上下文加载器" class="headerlink" title="线程上下文加载器"></a>线程上下文加载器</h3><p>在 JVM 的实现中有一条隐含的规则，默认情况下，如果一个类由类加载器 A 加载，那么这个类的依赖类也是由相同的类加载器加载。比如 Spring 作为一个 Bean 工厂，它需要创建业务类的实例，并且在创建业务类实例之前需要加载这些类。<br>思考：如果spring作为共享第三方jar包，交给SharedClassLoader加载，但是业务类在web目录下，不在SharedClassLoader的加载路径下，那spring如何加载web应用目录下的业务bean呢？</p>
<p>问题： 如果spring作为共享第三方jar包，交给SharedClassLoader加载，但是业务类在web目录下，不在SharedClassLoader的加载路径下，那spring如何加载web应用目录下的业务bean呢？</p>
<p>Tomcat为每个Web应用创建一个WebAppClassLoader加载器，并在启动Web应用的线程设置上下文加载器。这样Spring在启动时就将现成上下文加载器取出来，用来加载Bean。</p>
<p>线程上下文加载器是一种类加载器传递机制，因为这个类加载器保存在线程私有数据里，只要是同一个线程，一旦设置了线程上下文加载器，在线程后续执行过程中就能把这个类加载器取出来用。<br>Thread.currentThread().getContextClassLoader()</p>
<p>线程上下文加载器不仅仅可以用在 Tomcat 和 Spring 类加载的场景里，核心框架类需要加载具体实现类时都可以用到它，比如我们熟悉的 JDBC 就是通过上下文类加载器来加载不同的数据库驱动的</p>
<p>线程上下文加载器，在SPI实现上用的比较多。</p>
<h2 id="Tomcat热加载和热部署"><a href="#Tomcat热加载和热部署" class="headerlink" title="Tomcat热加载和热部署"></a>Tomcat热加载和热部署</h2><p>在项目开发过程中，经常要改动Java/JSP 文件，但是又不想重新启动Tomcat，有两种方式:热加载和热部署。热部署表示重新部署应⽤，它的执⾏主体是Host。 热加载表示重新加载class，它的执⾏主体是Context。<br>热加载：在server.xml -&gt; context 标签中 设置 reloadable=”true”</p>
<ul>
<li>热加载：在server.xml -&gt; context 标签中 设置 reloadable=”true”</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">"D:\mvc"</span> <span class="attr">path</span>=<span class="string">"/mvc"</span>  <span class="attr">reloadable</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">热部署：在server.xml -&gt; Host标签中 设置  autoDeploy="true"</span><br></pre></td></tr></table></figure>
<ul>
<li>热部署：在server.xml -&gt; Host标签中 设置  autoDeploy=”true”</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>他们的区别</strong></p>
<ul>
<li>热加载的实现方式是 Web 容器启动一个后台线程，定期检测类文件的变化，如果有变化，就重新加载类，在这个过程中不会清空 Session ，一般用在开发环境。</li>
<li>热部署原理类似，也是由后台线程定时检测 Web 应用的变化，但它会重新加载整个 Web 应用。这种方式会清空 Session，比热加载更加干净、彻底，一般用在生产环境。</li>
</ul>
<p>问题： Tomcat是如何用后台线程来实现热加载和热部署的</p>
<h3 id="Tomcat开启后台线程执行周期性任务"><a href="#Tomcat开启后台线程执行周期性任务" class="headerlink" title="Tomcat开启后台线程执行周期性任务"></a>Tomcat开启后台线程执行周期性任务</h3><p>Tomcat 通过开启后台线程ContainerBase.ContainerBackgroundProcessor，使得各个层次的容器组件都有机会完成一些周期性任务。我们在实际工作中，往往也需要执行一些周期性的任务，比如监控程序周期性拉取系统的健康状态，就可以借鉴这种设计。<br>Tomcat9 是通过ScheduledThreadPoolExecutor来开启后台线程的，它除了具有线程池的功能，还能够执行周期性的任务。</p>
<p><img src="https://images.lilhui.com/0121b5252cd38720749f046807893124" alt="图片"></p>
<p>此后台线程会调用当前容器的 backgroundProcess 方法，以及递归调用子孙的 backgroundProcess 方法，backgroundProcess 方法会触发容器的周期性任务。</p>
<p><img src="https://images.lilhui.com/5c90f19905daff7d323025a58de15ebd" alt="图片"></p>
<p>有了 ContainerBase 中的后台线程和 backgroundProcess 方法，各种子容器和通用 组件不需要各自弄一个后台线程来处理周期性任务，这样的设计显得优雅和整洁。</p>
<h3 id="热加载实现原理"><a href="#热加载实现原理" class="headerlink" title="热加载实现原理"></a>热加载实现原理</h3><p>有了 ContainerBase 的周期性任务处理“框架”，作为具体容器子类，只需要实现自 己的周期性任务就行。而 Tomcat 的热加载，就是在 Context 容器中实现的。Context 容 器的 backgroundProcess 方法是这样实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  StandardContext#backgroundProcess</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WebappLoader 周期性的检查 WEB-INF/classes 和 WEB-INF/lib 目录下的类文件</span></span><br><span class="line"><span class="comment">// 热加载</span></span><br><span class="line">Loader loader = getLoader();</span><br><span class="line"><span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">    loader.backgroundProcess();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WebappLoader 实现热加载的逻辑：它主要是调用了 Context 容器的 reload 方法，先stop Context容器，再start Context容器。具体的实现：<br>停止和销毁 Context 容器及其所有子容器，子容器其实就是 Wrapper，也就是说 Wrapper 里面 Servlet 实例也被销毁了。</p>
<ol>
<li>停止和销毁 Context 容器及其所有子容器，子容器其实就是 Wrapper，也就是说 Wrapper 里面 Servlet 实例也被销毁了。</li>
<li>停止和销毁 Context 容器关联的 Listener 和 Filter。</li>
<li>停止和销毁 Context 下的 Pipeline 和各种 Valve。</li>
<li>停止和销毁 Context 的类加载器，以及类加载器加载的类文件资源。</li>
<li>启动 Context 容器，在这个过程中会重新创建前面四步被销毁的资源。</li>
</ol>
<p>在这个过程中，类加载器发挥着关键作用。一个 Context 容器对应一个类加载器，类加载器在销毁的过程中会把它加载的所有类也全部销毁。Context 容器在启动过程中，会创建一个新的类加载器来加载新的类文件。</p>
<h3 id="Tomcat热部署原理"><a href="#Tomcat热部署原理" class="headerlink" title="Tomcat热部署原理"></a>Tomcat热部署原理</h3><p>热部署跟热加载的本质区别是，热部署会重新部署 Web 应用，原来的 Context 对象会整个被销毁掉，因此这个 Context 所关联的一切资源都会被销毁，包括 Session。<br>Host 容器并没有在 backgroundProcess 方法中实现周期性检测的任务，而是通过监听器 HostConfig 来实现的</p>
<p>Host 容器并没有在 backgroundProcess 方法中实现周期性检测的任务，而是通过监听器 HostConfig 来实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HostConfig#lifecycleEvent</span></span><br><span class="line"><span class="comment">// 周期性任务</span></span><br><span class="line"><span class="keyword">if</span> (event.getType().equals(Lifecycle.PERIODIC_EVENT)) &#123;</span><br><span class="line">    check();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (host.getAutoDeploy()) &#123;</span><br><span class="line">        <span class="comment">// Check for resources modification to trigger redeployment</span></span><br><span class="line">        DeployedApplication[] apps = deployed.values().toArray(<span class="keyword">new</span> DeployedApplication[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (DeployedApplication app : apps) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tryAddServiced(app.name)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 检查 Web 应用目录是否有变化</span></span><br><span class="line">                    checkResources(app, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    removeServiced(app.name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check for old versions of applications that can now be undeployed</span></span><br><span class="line">        <span class="keyword">if</span> (host.getUndeployOldVersions()) &#123;</span><br><span class="line">            checkUndeploy();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hotdeploy applications</span></span><br><span class="line">        <span class="comment">//热部署</span></span><br><span class="line">        deployApps();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>HostConfig 会检查 webapps 目录下的所有 Web 应用：</p>
<ul>
<li>如果原来 Web 应用目录被删掉了，就把相应 Context 容器整个销毁掉。</li>
<li>是否有新的 Web 应用目录放进来了，或者有新的 WAR 包放进来了，就部署相应的 Web 应用。</li>
</ul>
<p>因此 HostConfig 做的事情都是比较“宏观”的，它不会去检查具体类文件或者资源文件是否有变化，而是检查 Web 应用目录级别的变化。</p>
]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>类加载，热部署</tag>
      </tags>
  </entry>
  <entry>
    <title>【代码审查系列4】CODE REVIEW 代码审查清单</title>
    <url>/2019/06/04/article/codereview/article_4/</url>
    <content><![CDATA[<h2 id="整洁的代码"><a href="#整洁的代码" class="headerlink" title="整洁的代码"></a>整洁的代码</h2><table>
<thead>
<tr>
<th>清单项</th>
<th>分类</th>
</tr>
</thead>
<tbody>
<tr>
<td>使用可以表达实际意图的名称</td>
<td>有意义的名称</td>
</tr>
<tr>
<td>每一个概念只用一个词</td>
<td>有意义的名称</td>
</tr>
<tr>
<td>使用方案/问题领域名称</td>
<td>有意义的名称</td>
</tr>
<tr>
<td>类应该是比较小的</td>
<td>类</td>
</tr>
<tr>
<td>函数应该是比较小的</td>
<td>函数</td>
</tr>
<tr>
<td>只做一件事</td>
<td>函数</td>
</tr>
<tr>
<td>DRY(拒绝重复)</td>
<td>函数</td>
</tr>
<tr>
<td>用代码来注释自己的做法</td>
<td>注释</td>
</tr>
<tr>
<td>确定应用了代码格式化</td>
<td>格式</td>
</tr>
<tr>
<td>使用异常而不是返回码</td>
<td>异常</td>
</tr>
<tr>
<td>不要返回NULL</td>
<td>异常</td>
</tr>
</tbody>
</table>
<h2 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h2><table>
<thead>
<tr>
<th>清单项</th>
<th>分类</th>
</tr>
</thead>
<tbody>
<tr>
<td>如果不用继承，使用final类</td>
<td>基础</td>
</tr>
<tr>
<td>避免重复代码</td>
<td>基础</td>
</tr>
<tr>
<td>权限限制：程序应该运行在保证功能正常的最小权限模式下</td>
<td>基础</td>
</tr>
<tr>
<td>最小化类和成员的可访问性</td>
<td>基础</td>
</tr>
<tr>
<td>注释安全相关的信息</td>
<td>基础</td>
</tr>
<tr>
<td>系统的输入必须检查是否有效和在允许范围内</td>
<td>拒绝服务</td>
</tr>
<tr>
<td>避免对于一些不寻常行为的过分日志</td>
<td>拒绝服务</td>
</tr>
<tr>
<td>在任何情况下都释放资源（流，连接等）</td>
<td>拒绝服务</td>
</tr>
<tr>
<td>从异常中清楚敏感信息（暴露文件路径，系统内部相关，配置，IP等）</td>
<td>秘密信息</td>
</tr>
<tr>
<td>不把高敏感度的信息写到日志</td>
<td>秘密信息</td>
</tr>
<tr>
<td>考虑把高度敏感的信息在使用后从内存中删除</td>
<td>密码信息</td>
</tr>
<tr>
<td>限制包，类，接口，方法和域的可访问性</td>
<td>可访问性的扩展</td>
</tr>
<tr>
<td>限制类和方法的可扩展性</td>
<td>可访问性的扩展</td>
</tr>
<tr>
<td>检验输入（有效数据，大小，范围，边界）</td>
<td>输入检验</td>
</tr>
<tr>
<td>把从不可信对象得到的输出作为输入来检验</td>
<td>输入检验</td>
</tr>
<tr>
<td>为native方法定义包装类（而不是定义native方法为public）</td>
<td>输入检验</td>
</tr>
<tr>
<td>把从不可信对象得到的输出作为输入来对待</td>
<td>可变性</td>
</tr>
<tr>
<td>使public static域为final（避免调用方法（caller）修改它的值）</td>
<td>可变性</td>
</tr>
<tr>
<td>避免暴露敏感类的构造函数</td>
<td>对象构造</td>
</tr>
<tr>
<td>避免安全敏感类的序列化</td>
<td>序列化反序列化（Serialization Deserialization)</td>
</tr>
<tr>
<td>通过序列化来保护敏感数据</td>
<td>序列化反序列化</td>
</tr>
<tr>
<td>小心地缓存潜在的特权操作结果</td>
<td>序列化反序列化</td>
</tr>
</tbody>
</table>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><table>
<thead>
<tr>
<th>清单项目</th>
<th>分类</th>
</tr>
</thead>
<tbody>
<tr>
<td>避免过分的同步</td>
<td>并发</td>
</tr>
<tr>
<td>保持同步于去比较小</td>
<td>并发</td>
</tr>
<tr>
<td>知道String连接的性能情况</td>
<td>综合编程</td>
</tr>
<tr>
<td>避免创建不需要的对象</td>
<td>创建和销毁对象</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>技术之外</category>
      </categories>
      <tags>
        <tag>代码审查</tag>
        <tag>CODEREVIEW</tag>
      </tags>
  </entry>
  <entry>
    <title>【代码审查系列3】CODE REVIEW代码审查执行方法</title>
    <url>/2019/06/04/article/codereview/article_3/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>建立完善的代码审查机制有助于提升开发团队的协作能力，和提升代码质量。并不是件简单的事情。不同团队所处的公司，项目客观环境不同，所采用的审查流程也不尽相同。本文根据目前公司项目状态和团队人员状况指定简单的可执行方案。希望对开展代码审查机制有帮助。</p>
</blockquote>
<h2 id="默认约定"><a href="#默认约定" class="headerlink" title="默认约定"></a>默认约定</h2><h3 id="review方法约定"><a href="#review方法约定" class="headerlink" title="review方法约定"></a>review方法约定</h3><p>这里暂时用两种方式  </p>
<ol>
<li><p>结对review</p>
<ul>
<li>在项目或者需求计划完成时由reviewer或者项目负责人对关键功能点进行评估是否进行结对review</li>
<li>当需要进行结对review的功能点开发完成后，由codeowner通知review约定一个具体时间对关键代码的解说，reviewer跟着coderowner的流程进行review提出可能隐藏的逻辑错误。</li>
</ul>
</li>
<li><p>异步review</p>
<ul>
<li>codeowner每天提交完整的可编译的代码。</li>
<li>codeviewer每天拉取完整的代码。<ul>
<li>项目实际开发天数&gt;7人日（含）：<br>在项目阶段的每个周四固定一个时间段进行已提交的完整代码review。再另外在提测前两天进行review一遍。如果两者时间有冲突，那么以提测前 两天为主。</li>
<li>如果项目或者需求实际时间小于7人日，在提测前两天进行review一遍。</li>
</ul>
</li>
<li>codeowner在接收到review comment时。最迟第二天进行答复。和codereview协商完成comment处理。</li>
<li>codereview在提测前一天下午前，进行完整审查。寻找未处理的reviewcomment灭掉。</li>
</ul>
</li>
</ol>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><ol>
<li>代码上传到Gitlab  </li>
<li>配置好upsource代码库</li>
<li>安装upsource idea插件</li>
</ol>
<h3 id="划分角色"><a href="#划分角色" class="headerlink" title="划分角色"></a>划分角色</h3><p>CODEROWNER: 代码作者  </p>
<p>REVIEWER: 代码审查者  </p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">开始 --&gt; 开发计划</span><br><span class="line">开发计划 --&gt; 划分角色</span><br><span class="line">开发计划 --&gt; review计划</span><br><span class="line">划分角色 --&gt; 开发提交代码</span><br><span class="line">review计划 --&gt; 开发提交代码</span><br><span class="line">开发提交代码 --&gt; 进行review</span><br><span class="line">进行review --&gt; 开发提交代码</span><br><span class="line">进行review --&gt; 提测</span><br></pre></td></tr></table></figure>
<h3 id="核心流程详解"><a href="#核心流程详解" class="headerlink" title="核心流程详解"></a>核心流程详解</h3><ol>
<li>划分角色和review计划制定<ul>
<li>开发计划制定后进行角色划分。code reviewer一般是项目负责人。同时也可以是coder</li>
<li>rewiver将要进行的项目上传到gitlab和<a href="http://10.5.117.151:8080/" target="_blank" rel="noopener">upsource</a>。并配置好项目在upsource上的配置。</li>
<li>coder 配置好idea插件</li>
<li>根据功能划分制定review方式。</li>
</ul>
</li>
<li><p>按照功能进行开发</p>
</li>
<li><p>在功能开发过程中按照指定好的review计划进行codereview</p>
</li>
</ol>
<h2 id="CODE-REVIEW的方法"><a href="#CODE-REVIEW的方法" class="headerlink" title="CODE REVIEW的方法"></a>CODE REVIEW的方法</h2><h3 id="代码审查方式"><a href="#代码审查方式" class="headerlink" title="代码审查方式"></a>代码审查方式</h3><ul>
<li>关注点<br>  代码审查清单列表</li>
<li><p>代码的设计是否符合要求</p>
</li>
<li><p>逻辑是否正确</p>
</li>
</ul>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><ul>
<li>角色：<ul>
<li>Reviewer<br>reviewer为各个项目负责人可以同时是CodeOwner</li>
<li>CodeOwner<br>CoderOwner为这个代码的作者,</li>
</ul>
</li>
</ul>
<p>每天由Codeowner提交代码。Reviewer通过idea插件或者 upsource的hub页面筛查自己需要 审查的代码进行审查。并提交相关建议。</p>
<h3 id="结果反馈"><a href="#结果反馈" class="headerlink" title="结果反馈"></a>结果反馈</h3><p>略</p>
<h2 id="审查工具和附件"><a href="#审查工具和附件" class="headerlink" title="审查工具和附件"></a>审查工具和附件</h2><ul>
<li><a href="http://10.5.117.151:8080" target="_blank" rel="noopener">upsource</a></li>
<li><p><a href="http://note.youdao.com/noteshare?id=767a7fea1df64b72d5e06ffe9f3da103" target="_blank" rel="noopener">注释模板设置方式</a></p>
</li>
<li><p><a href="http://note.youdao.com/noteshare?id=79263de59433b0f710641c1966ca8785" target="_blank" rel="noopener">代码审查清单</a></p>
</li>
<li><a href="http://note.youdao.com/noteshare?id=767a7fea1df64b72d5e06ffe9f3da103" target="_blank" rel="noopener">git注释模板</a></li>
</ul>
]]></content>
      <categories>
        <category>技术之外</category>
      </categories>
      <tags>
        <tag>代码审查</tag>
        <tag>CODEREVIEW</tag>
      </tags>
  </entry>
  <entry>
    <title>【代码审查系列5】upsource使用简介</title>
    <url>/2019/06/04/article/codereview/article_5/</url>
    <content><![CDATA[<blockquote>
<p>upsource使用简介</p>
</blockquote>
]]></content>
      <categories>
        <category>技术之外</category>
      </categories>
      <tags>
        <tag>代码审查</tag>
        <tag>CODEREVIEW</tag>
      </tags>
  </entry>
  <entry>
    <title>【代码审查系列6】GIT修改注释模板方式</title>
    <url>/2019/06/04/article/codereview/article_6/</url>
    <content><![CDATA[<blockquote>
<p>在使用Git做版本控制工具的团队协助开发中，保证团队成员在提交代码后能够更详尽的追溯源头下。规范代码注释的必要性就得以体现。通过制定这种规范约束，可以显著提高代码提交的目的可追溯性。这里介绍Git修改注释模板方式。</p>
</blockquote>
<h2 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h2><ol>
<li><strong>git命令下创建注释模板</strong></li>
</ol>
<p>创建 XX_template文件，内容为团队制定的git提交规范例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Desgraption: </span><br><span class="line">Date: </span><br><span class="line">Author:</span><br></pre></td></tr></table></figure>
<p>通过git config配置commit_template,如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config –-global commit.template /d/develop/Git/Git_Home/commit_template</span><br></pre></td></tr></table></figure>
<p>设置git commit时填写注释所用的编辑器，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global core.editor vim</span><br></pre></td></tr></table></figure>
<p>设置后，提交试用git commit</p>
]]></content>
      <categories>
        <category>技术之外</category>
      </categories>
      <tags>
        <tag>代码审查</tag>
        <tag>CODEREVIEW</tag>
      </tags>
  </entry>
  <entry>
    <title>【代码审查系列7】如何做人性化的代码审查</title>
    <url>/2019/06/04/article/codereview/article_7/</url>
    <content><![CDATA[<ul>
<li><a href="https://note.youdao.com/ynoteshare1/index.html?id=ce984049ed01f2c177de0e3d6d0dfbfb&amp;type=note" target="_blank" rel="noopener">如何做人性化的代码审查详情</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>【代码审查系列2】CODE REVIEW 代码审查分类-以及选取方式</title>
    <url>/2019/06/04/article/codereview/article_2/</url>
    <content><![CDATA[<p>代码审查主要可以划分4种类型。每一种代码审查类型都有它特有的优缺点。<br>在高层面，代码审查归为两大类：正式的审查，轻量级的审查。以下详细说明：</p>
<h2 id="正式的审查"><a href="#正式的审查" class="headerlink" title="正式的审查"></a>正式的审查</h2><p>正式的审查与开发流程绑定作为流程中不可或缺的一部分。实践方式有很多种，其中最流行的实践方式是 范根检查法（Faganinspection）。它为视图寻找代码缺陷提供了一种非常结构化的流程，并且，还可以用于发现规范中的或者设计中的缺陷。</p>
<h3 id="范根检查法步骤"><a href="#范根检查法步骤" class="headerlink" title="范根检查法步骤"></a>范根检查法步骤</h3><ol>
<li>计划</li>
<li>概述</li>
<li>准备</li>
<li>召开检查会议</li>
<li>重做</li>
<li>追查</li>
</ol>
<p>其基本思想为：预先制定好每一个步骤所需要达到的输出要求。当进行到某个过程时，检查现在的输出，并与之前指定的理想输出要求做比较。然后，由此决定是否进入下一个步骤。或者仍需在当前步骤继续工作。这种结构化的流程比较繁琐，用的不多。成本较高。一般团队很少使用。然而，如果开发的软件生死攸关，会因为有缺陷而让人丧命，那么以这种结构化的方式查找软件缺陷就显得很合理。比如动车调度，飞机自动驾驶等等。</p>
<h2 id="轻量级审查"><a href="#轻量级审查" class="headerlink" title="轻量级审查"></a>轻量级审查</h2><p>相比于正式的代码审查，轻量级代码审查正在被更多的开发团队所使用。<br>其子分类有：</p>
<ol>
<li><strong>瞬时代码审查，也称为结对编程</strong>。 </li>
</ol>
<ul>
<li><p><strong>一般情况</strong>：<br>  当一个开发者在敲代码的同时，另一个开发盯着代码，注意着代码中潜在的问题，并在此过程中给出提升代码质量的建议。</p>
</li>
<li><p><strong>解决复杂问题的情况</strong>：  </p>
<p>  此种方法比较适用于，仔细找解决方案的时候两个大脑汇集起来增加成功的概率。让两个头脑思考同一个问题，并且互相讨论可行的方案，这样你更可能覆盖到问题的一些边界情况。在遇到需要很多复杂业务逻辑的任务时候，可以用结对编程。</p>
</li>
<li><p><strong>需要学习新技术时候的情况</strong>：  </p>
</li>
</ul>
<p>例如：在使用一个新的框架，或者在探索之前没用过的新技术。最好还是单独行动，因为这时可以根据自己的情况作出快速调整。为了弄清楚技术是如何工作的，需要网络上搜索大量资料。或者阅读文档。这时，结对编程帮助就不大，因为不同的人可能获取知识的方式不同。另一方面，当你被问题卡主之后，与同事之间交流一下解决方案，往往会有意想不到的收获。</p>
<ul>
<li><p><strong>开发者水平差距问题的影响</strong>：  </p>
<p>  当一个初级开发者和高级开发者进行结对编程，效果并不好。在初级代码开发者负责写代码时，坐在旁边的高级程序员可能因为他写的太慢而感到烦恼。如此设定，这个高级程序员的能力就被限制住了，从而浪费时间。当键盘在高级程序员手上时，又敲得太快，初级程序员跟不上高级程序员的思路。几分钟后，初级程序员就迷失在代码上下文了，或者需要更多的时间解释代码的含义。徒增时间成本。</p>
</li>
<li><p><strong>总结</strong><br>  结对编程适用于两个有相似经验水平的开发者处理复杂的业务问题的情况。</p>
</li>
</ul>
<ol start="2">
<li><strong>同步代码审查，既时代码审查</strong>。</li>
</ol>
<ul>
<li><p><strong>运行方式</strong>：</p>
<p>  一个开发者独自编写代码，当她写完代码后，立即找代码审查者进行审查。审查者来到开发者的桌前，看着同一个屏幕，一起审查、讨论和改进代码。</p>
</li>
<li><p><strong>审查者不清楚这个任务的目标时</strong>：    </p>
<p>  这种代码审查类型会很有效果。它会在这种情况下发生：团队里没有优化会议，或者sprint计划会议，来预先讨论每一项任务。此种做法会导致一种结果：只有特定的开发人员才能知道某项任务的需求。这种情况下，在代码审查之前，向审查者介绍下任务的目标是很有帮助的。</p>
</li>
<li><p><strong>期待大量的代码改进时</strong>：如果代码编写者缺乏经验，写出的代码需要很大的改进，那么同步代码审查也很有效。<br>  如果一个经验丰富的高级开发者将要对一个很初级的程序员写出的一段代码进行审查，那么，当初级程序员写完代码后和高级开发者一起改进这块代码，效率是远远高于初级程序员一个人看的。<br>  缺点：它强行切换了审查者的思路，不仅让审查者感到沮丧，也拖慢了整个团队的效率。</p>
</li>
</ul>
<ol start="3">
<li><strong>异步的代码审查，工具支持的代码审查</strong>。  </li>
</ol>
<ul>
<li><p><strong>运行方式</strong>：<br>  开发者在写完代码后，让这些代码对审查者课件，让后开始他的下一个任务。当审查者有时间了，他会在自己的桌子上按自己的时间表进行审查。他不需要和开发者进行沟通，而是通过工具写一些评论。在完成审查后，那些工具会把评论和需要改动的通知给开发者。开发者就会根据评论改进代码，同样的，以自己的时间进行这些事情。这种循环，会以代码改动再次提交到审查者这里又重新开始。开发者修改代码，知道没有评论需要改进。最后改动完成，并且同意，合并到主分支。同步和异步的代码审查有较大的不同。</p>
</li>
<li><p><strong>好处</strong>：<br>  没有直接的依赖，异步发生。开发者不需要直接依赖于审查者，并且时间安排相对自由。</p>
</li>
<li><p><strong>缺点</strong>：<br>  可能有许多次循环的审查，可能持续好几天，最终被接受。可能发生的详情如下：当开发者完成代码后，需要几个小时候审查者才开始做代码审查。很多事会后，审查者给出的建议在第二天才能被开发者修复。这样，第一次审查周期就用了一天，如果有多次循环，审查的时间久延续了一整周，还不算代码和测试的时间。</p>
</li>
<li><strong>解决方案</strong>：<br>  在团队里，我们规定，每天上午，每个开发者在开始做其他工作之前，都需要处理挤压的代码审查任务，同样的，在中午午休结束后也类似的工作安排。在较长的休息时间后，开发者已经不出在他的代码思路里了。这时进行代码审查，冰没有强制他们进行不自然的思路切换，并且能够让代码在合适的时间内得到审查。</li>
<li><strong>总结</strong>：异步的代码审查应该作为每一个专业开发团队的默认选项。但是在为什么这么做之前，要想清楚这些代码审查分类原则。</li>
</ul>
<ol start="4">
<li><strong>偶尔的代码审查，基于回忆的代码审查</strong>。</li>
</ol>
<ul>
<li><p><strong>执行方式</strong>：</p>
<p>  坐在会议室，一个开发者展示并解释他最近写的一段困难的代码。其他开发者尝试寻找潜在的缺陷，发表评论，给出如何改进代码的建议。  </p>
</li>
<li><p><strong>适用场景</strong>：  </p>
<p>  当整个团队都没有代码审查的经验时，把每个人都聚集起来，一起做代码审查，这样弄几次后，可能帮助每个人理解代码审查的目标和意义。长远看来，此种方式并不是一个合适的技术，因为让劝阻审核一段代码是很低效的。</p>
</li>
</ul>
<h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><ol>
<li>正式的代码审查，不流行，较难实现较难用于实践。</li>
<li>轻量级的代码审查选择<ol>
<li>瞬时代码审查用于结对编程，在解决复杂业务时候使用。</li>
<li>同步代码审查，用于审查者不知道大量改进时。</li>
<li>异步审查，避免了强行切换思路带来的问题，对大多数用例都工作的很好。</li>
<li>偶尔的代码审查，对于专业团队来说不是长期的选择。</li>
</ol>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主要用轻量级代码审查。在轻量级代码审查中按照不同情况进行选择审查方式。</p>
<ol>
<li>默认使用异步审查。</li>
<li>在开发一个新系统新业务时候，评估业务复杂度如果复杂度高，进行结对编程。</li>
</ol>
]]></content>
      <categories>
        <category>技术之外</category>
      </categories>
      <tags>
        <tag>代码审查</tag>
        <tag>CODEREVIEW</tag>
      </tags>
  </entry>
  <entry>
    <title>团队管理中的三个时期</title>
    <url>/2019/06/04/article/teammanager/teammanager_0/</url>
    <content><![CDATA[<blockquote>
<p>团队建设</p>
</blockquote>
<h2 id="前期重教育"><a href="#前期重教育" class="headerlink" title="前期重教育"></a>前期重教育</h2><blockquote>
<p>完成团队前期的人员了解和结构梳理</p>
</blockquote>
<h2 id="中期重规范"><a href="#中期重规范" class="headerlink" title="中期重规范"></a>中期重规范</h2><blockquote>
<p>建立团队运作规范，技术规范，技术外的流程规范</p>
</blockquote>
<h2 id="后期重辅导"><a href="#后期重辅导" class="headerlink" title="后期重辅导"></a>后期重辅导</h2><blockquote>
<p>具体协助过程的配合</p>
</blockquote>
]]></content>
      <categories>
        <category>技术之外</category>
      </categories>
      <tags>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title>角色转变</title>
    <url>/2019/10/08/article/teammanager/teammanager_2/</url>
    <content><![CDATA[<h1 id="什么是角色转变"><a href="#什么是角色转变" class="headerlink" title="什么是角色转变"></a>什么是角色转变</h1><blockquote>
<p>角色转变，使你不仅仅是自然人的你。</p>
</blockquote>
<h1 id="角色转变转变了什么"><a href="#角色转变转变了什么" class="headerlink" title="角色转变转变了什么"></a>角色转变转变了什么</h1><p>不同的角色转变，转变的形式不同。之于部门，你代表的是部门。之于具体项目，这个角色可能是项目组。<br>那么多不同的角色转变之下，实际上都保持着转变的共性。归根结底两个：思维转变，做事风格转变。</p>
<h2 id="思维转变"><a href="#思维转变" class="headerlink" title="思维转变"></a>思维转变</h2><p>思维转变在于，考虑的问题角度发生变化。</p>
<h2 id="做事风格"><a href="#做事风格" class="headerlink" title="做事风格"></a>做事风格</h2><p>做事风格，是由于考虑角度的风格发生了变化。自然而然影响到了具体做事的风格。</p>
<h1 id="如何适应角色的转变"><a href="#如何适应角色的转变" class="headerlink" title="如何适应角色的转变"></a>如何适应角色的转变</h1><p>在角色转变过程中，迅速切换，抓住处于不同角色时候需要做到的关键决策尤为重要。</p>
]]></content>
      <categories>
        <category>技术之外</category>
      </categories>
      <tags>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title>【代码审查系列8】阿里巴巴编码规范</title>
    <url>/2019/06/04/article/codereview/article_8/</url>
    <content><![CDATA[<ul>
<li><a href="http://note.youdao.com/noteshare?id=96f4bf961d3ded69d6af43bc183361fb" target="_blank" rel="noopener">阿里巴巴编码规范详情</a></li>
</ul>
]]></content>
      <categories>
        <category>技术之外</category>
      </categories>
      <tags>
        <tag>代码审查</tag>
        <tag>CODEREVIEW</tag>
      </tags>
  </entry>
  <entry>
    <title>结果导向</title>
    <url>/2019/06/13/article/teammanager/teammanager_1/</url>
    <content><![CDATA[<h1 id="什么是结果导向"><a href="#什么是结果导向" class="headerlink" title="什么是结果导向"></a>什么是结果导向</h1><blockquote>
<p>结果导向是质量管理体系、绩效管理理论中的基本概念核心思想之一。强调工作的结果。<br>这里记录另外一种思考。称之为结果导向在过程中的作用和价值。</p>
</blockquote>
<h1 id="结果导向在过程中的作用和价值"><a href="#结果导向在过程中的作用和价值" class="headerlink" title="结果导向在过程中的作用和价值"></a>结果导向在过程中的作用和价值</h1><p>结果导向，字面上意思是注重结果。实际在执行工作过程中体现的是恰恰是过程中的重要性。<br>在过程中强调结果导向，其目的是强调在工作过程中朝着最终的结果靠拢。随着工作过程的推进，<br>这个路径慢慢向结果收敛靠近。它可以作为纠正工作中偏离最终设定结果的工具。</p>
]]></content>
      <categories>
        <category>技术之外</category>
      </categories>
      <tags>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title>【更好工作的 tips1】临时工作的安排</title>
    <url>/2019/06/11/article/worker/worker_0/</url>
    <content><![CDATA[<ul>
<li>临时工作的安排</li>
</ul>
<p>口头，或者会议结论提出的临时工作任务。在安排好手上的工作后，立即着手对临时达成<br>协议内容进行安排，花五分钟时间进行记录和规划，上报。</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>文档编写的过程</title>
    <url>/2019/06/11/article/word/word_0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>一个好的软件工程师在工作的过程中，不仅仅要求编写计算机高效运行的代码，更需要<br>能够将自己所做工作完美呈现出来的文档能力。</p>
</blockquote>
<h1 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h1><h1 id="思维过程"><a href="#思维过程" class="headerlink" title="思维过程"></a>思维过程</h1><p>零碎的思维碎片-&gt;初始文档-&gt;汇报文件(ppt等)<br>以上，从0开始的文档整理过程都是这样过来。首先开始思考有了零碎的思维碎片，此时可<br>能还不能完整的串联起来，但是不要紧，思维碎片完成后。从中提取完整的脉络简单的<br>可以从时间维度、业务发展维度等进行提取。在大概一天的提取后可以大概完成一个具象化<br>的初始文档，初始文档比较粗糙，需要进行润色，加素材。这个过程一般经过一到两天<br>润色或者素材完成后，已经是一份对自己来说完成度较高的文档了。此时如果不需要进行<br>汇报或者演讲，可以直接封板。如果需要汇报或者培训演讲，就需要在此基础上进行提炼<br>提炼更精炼的数据汇总成PPT。</p>
]]></content>
      <categories>
        <category>技术之外</category>
      </categories>
      <tags>
        <tag>文档能力</tag>
      </tags>
  </entry>
  <entry>
    <title>【工具】IDEA配置注释</title>
    <url>/2021/11/15/article/util/util_1/</url>
    <content><![CDATA[<h2 id="File-and-Code-Templates"><a href="#File-and-Code-Templates" class="headerlink" title="File and Code Templates"></a>File and Code Templates</h2><ul>
<li>Class</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != &quot;&quot;)package $&#123;PACKAGE_NAME&#125;;#end</span><br><span class="line">#parse(&quot;File Header.java&quot;)</span><br><span class="line">/*</span><br><span class="line"> * @className $&#123;NAME&#125;</span><br><span class="line"> * @description TODO </span><br><span class="line"> * @author littlehui</span><br><span class="line"> * @date $&#123;DATE&#125; $&#123;TIME&#125;</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line">public class $&#123;NAME&#125; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Live-Templates"><a href="#Live-Templates" class="headerlink" title="Live Templates"></a>Live Templates</h2><ol>
<li>新建 Templates Group</li>
<li>新建 * Template</li>
<li>新建 ** Template</li>
</ol>
<ul>
<li>*<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">** </span><br><span class="line"> * @description $description$</span><br><span class="line">$params$</span><br><span class="line"> * @author littlehui</span><br><span class="line"> * @date $date$ $time$</span><br><span class="line"> * @return $returns$</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>params 参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groovyScript(&quot;def result=&apos;&apos;;def fourspace=&apos;&apos;; def params=\&quot;$&#123;_1&#125;\&quot;.replaceAll(&apos;[\\\\[|\\\\]|\\\\s]&apos;, &apos;&apos;).split(&apos;,&apos;).toList(); for(i = 0; i &lt; params.size(); i++) &#123;if (i&gt;0)fourspace=&apos;    &apos;;result+=fourspace+&apos; * @param &apos; + params[i] + ((i &lt; params.size() - 1) ? &apos;\\n&apos; : &apos;&apos;)&#125;; return result&quot;, methodParameters())</span><br></pre></td></tr></table></figure>
<ul>
<li>**</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line"> * @description: TODO</span><br><span class="line"> * @author littlehui</span><br><span class="line"> * @date $date$ $time$</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>注释</tag>
      </tags>
  </entry>
  <entry>
    <title>谈判的四大金刚</title>
    <url>/2020/08/25/article/teammanager/teammanager_3/</url>
    <content><![CDATA[<blockquote>
<p>一个单体的个人对外界信息的反馈可以分为</p>
</blockquote>
<ul>
<li>梦想型</li>
<li>计划型</li>
<li>恋人型</li>
<li>勇士型</li>
</ul>
<p>梦想型，主导方向（激励）。计划型，做逻辑预算（基于自我表达）。恋人型，拉近距离（共情）。勇士型，坚毅行动（直接的怼）。</p>
<blockquote>
<p>不同的场景应用以上不同的组合兵来将挡，水来土掩。一切的故事从针锋相对开始，到化干戈为玉帛结束。</p>
</blockquote>
<p>运用好，表现在在个人社交上，是魅力。在工作上是领导力。表现在家庭生活上是责任担当。</p>
<p>逻辑是可以从不便的事物中推理出改变的轨迹。然而人与人之间不讲逻辑的时候居多。</p>
<p>与死物讲逻辑，与活物打太极。绕进自己框架，将意识移植。改变不了对方的想法，就改变自己的想法。<br>这是个非零和博弈。  </p>
<blockquote>
<p>谈判三断式  </p>
</blockquote>
<ul>
<li>赞同  A</li>
<li>中立  B</li>
<li>共情  C</li>
<li>反对  D</li>
</ul>
<blockquote>
<p>有不同意见时候，采取比较适合的方式：</p>
</blockquote>
<p>ABDC</p>
<p>A开场，B阐述事实，D抛出观点，C安慰。</p>
]]></content>
      <categories>
        <category>技术之外</category>
      </categories>
      <tags>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title>【更好的工作 tips3】敏捷开发原则</title>
    <url>/2019/06/12/article/worker/worker_2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>敏捷开发的核心目的是利用有限技术资源，实现软件开发的效能的最大化。一些原则或者方法贯穿<br>着敏捷开发的整个过程。</p>
</blockquote>
<p>#原则</p>
<ul>
<li><p>简单</p>
</li>
<li><p>拥抱变化</p>
</li>
<li><p>可持续性</p>
</li>
<li><p>递增</p>
</li>
<li><p>资源最大化</p>
</li>
<li><p>有目的地建模</p>
</li>
<li><p>多种模型</p>
</li>
<li><p>高质量的工作</p>
</li>
<li><p>快速反馈</p>
</li>
<li><p>主要目标-软件</p>
</li>
<li><p>轻量前行</p>
</li>
</ul>
<h1 id="成功的结果"><a href="#成功的结果" class="headerlink" title="成功的结果"></a>成功的结果</h1><ul>
<li><p>随机应变</p>
</li>
<li><p>自主权</p>
</li>
<li><p>分享经验</p>
</li>
</ul>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>敏捷开发</tag>
      </tags>
  </entry>
  <entry>
    <title>【更好工作的 tips2】会议的要点</title>
    <url>/2019/06/11/article/worker/worker_1/</url>
    <content><![CDATA[<ul>
<li>会议的要点</li>
</ul>
<p>会议或大，或小，或长或短，目的要明确。要明确要解决的问题、确认的问题、达成的共<br>识等。当会议快结束时候确认会议达成的共识或者解决问题的方案，分配相应的任务。<br>特别是技术类、需求类会议。最终都需要达成一个超目标迈进的可执行方案。</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>【更好的工作 tips4】理解事物的脉络</title>
    <url>/2019/10/09/article/worker/worker_3/</url>
    <content><![CDATA[<h2 id="脉络是什么"><a href="#脉络是什么" class="headerlink" title="脉络是什么"></a>脉络是什么</h2><blockquote>
<p>各种事，各种情况，各种状态，都有一定的内在规律可循。称之为事物的脉络。掌握到事物的脉络<br>就会很清楚的理解事物为什么这样发展，他的轨迹为什么是这样的。能为后面预测事物发展作为依据<br>让人自然而然地会理解到后面可能会面对的挑战，并且为迎接挑战而做准备。</p>
</blockquote>
<h2 id="怎么把握到脉络"><a href="#怎么把握到脉络" class="headerlink" title="怎么把握到脉络"></a>怎么把握到脉络</h2><p>事物的脉络是依托于原始轨迹。需要深度思考原来的轨迹模式为什么是这样的。从表象开始思考<br>剥离无关的因素，就会得到一张完整的发展骨架。从骨架出发，结合因果律，整体的事物脉络就会很清晰<br>地展现在你面前。</p>
<h2 id="实际工作怎么用到"><a href="#实际工作怎么用到" class="headerlink" title="实际工作怎么用到"></a>实际工作怎么用到</h2><p>把握事物的脉络，小到技术上的选型，大道公司运转层面的方向把握，都有用处。比如在学习Sentinel<br>流量控制技术时，代码是技术上的表象，从表象上可以看到Sentinel用到的几种模式。比如责任链，比如<br>工厂等等，算法如：漏铜，漏斗等。基于这些算法那和模式，构建了他的核心功能-对流量的控制管理。<br>从这里就找到一副完整的技术骨架：基于漏桶算法和责任链模式。围绕着这个骨架的因果，周边构建出了<br>规则配置，流量整形，监控等等非核心业务功能。这样，Sentinel的脉络就很清晰了。</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>事物的脉络</tag>
      </tags>
  </entry>
  <entry>
    <title>【深入理解并发编程系列2】JVM内存模型</title>
    <url>/2021/03/24/java/concurrent/concurrent_2/</url>
    <content><![CDATA[<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>Java原生支持多线程，这种模型是为了适配不同操作系统架构。屏蔽掉系统和底层硬件的差异。工作模型如下：</p>
<p><img src="https://images.lilhui.com/8a91c87d87bba98b171931924db362a9" alt="图片"></p>
<p>JVM的内存模型是JVM定义抽象的定义。<br>工作内存对应的JVM哪一个模块不重要因为，不同的JVM实现，实现的也不一样。</p>
<h2 id="数据八大原子操作"><a href="#数据八大原子操作" class="headerlink" title="数据八大原子操作"></a>数据八大原子操作</h2><ol>
<li>lock: 作用于主内存的变量，把一个变量标记为一条线程独占状态。</li>
<li>unlock：与loc相反的操作。</li>
<li>read： 作用于主内存的变量，把一个变量从主内存传输到线程的工作内存中，以便后续的load动作。</li>
<li>load: 作用于工作内存的操作，把read操作从主内存中得到的变量放入工作内存的变量副本中。</li>
<li>use： 作用于工作内存的操作，把工作内存中的一个变量值传给执行引擎。</li>
<li>assign： 作用于工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量。</li>
<li>store： 作用于工作内存，把工作内存中的一个变量的值传送到主内存中，以便随后的write。</li>
<li>write：作用于工作内存，把store操作从工作内存中的一个变量的值传送到主内存变量中。</li>
</ol>
<p>来：lock-&gt;read-&gt;load-&gt;use<br>去：assign-&gt;store-&gt;write-&gt;unlock</p>
<p><img src="https://images.lilhui.com/82069c69691038f6e42241e677c5f027" alt="图片"></p>
<h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><p>关键词：MESI 协议</p>
<p>volatile 用于保证有序性 解决可见性问题<br>syncronized用于保证原子性   </p>
<p><strong><em>volatile</em></strong> 解决可见性问题  保证及时看到。不加的话，也有可能看到。只是不及时。<br>如何理解：<br>JVM定义的这些模型语义，不会去描述多线程程序如何执行，而是描述多线程程序于许表现出来的行为。任何执行策略，只要产生的是允许的行为，那他就是一个可以接受的策略。</p>
<p><img src="https://images.lilhui.com/888b6e0ac95b919baf7304e8b2778c21" alt="图片"></p>
<p>空循环优先级超高。</p>
<p><strong>synronized</strong>可以保证内存块操作的原子性。</p>
<h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><p><img src="https://images.lilhui.com/ff219959971893780f14c82af5225f9c" alt="图片"></p>
<ul>
<li><p>as-if-serial</p>
</li>
<li><p>happen-before</p>
</li>
</ul>
<h3 id="volatile指令重排优化"><a href="#volatile指令重排优化" class="headerlink" title="volatile指令重排优化"></a>volatile指令重排优化</h3><p>内存屏障是cpu指令，作用两个：</p>
<ol>
<li>保证特定操作的执行顺序。</li>
<li>保证某些变量的可见性。（volatile的可见性）</li>
</ol>
<p><img src="https://images.lilhui.com/9dba804c353b8adf0c3c9cefd06fce08" alt="图片"></p>
<p>原理：内存屏障技术<br>ifence：  一种Load barrier读屏障。<br>sfence：   一种Store Barrier写屏障<br>mfence ： 全能型屏障，具备ifence和sfence能力。<br>Lock前缀  Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为PUC指令的一种锁。它后面可以跟 ADD，ADC,AND，BTC，BTR,BTS，CMPXCHG,CMPXCH8B,DEC,INC,NEG,NOT,OR,SBB,SUB,XOR,XADD,and XCHG指令。</p>
<h3 id="手动加内存屏障"><a href="#手动加内存屏障" class="headerlink" title="手动加内存屏障"></a>手动加内存屏障</h3><p>Unsafe.fullFence<br>java中的可见性如何保证：<br>归类有两种：</p>
<ol>
<li>OrderAccess::storeLoad<br> lock; addl xxxx X86架构 lock替代mfence<br> java: volatile,final,syncronized,sleep</li>
<li>上下文切换 Thread.yield</li>
</ol>
<p>CPU 等待唤醒。所有切换都是 park,unpark。操作系统库函数：<br>Linux： pthread_cond_timewait<br>spl.park</p>
]]></content>
      <categories>
        <category>java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【深入理解并发编程系列1】操作系统与虚拟机</title>
    <url>/2021/03/21/java/concurrent/concurrent_1/</url>
    <content><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><ol>
<li>冯诺依曼计算机模型</li>
<li>cpu缓存结构剖析。</li>
<li>操作系统内存管理与线程模型。</li>
<li>虚拟机指令集架构详解。</li>
</ol>
<h2 id="冯诺依曼计算机体系"><a href="#冯诺依曼计算机体系" class="headerlink" title="冯诺依曼计算机体系"></a>冯诺依曼计算机体系</h2><p><img src="https://images.lilhui.com/cf75937f11435b5ff7fc6a55c000c72b" alt="图片"></p>
<h3 id="CPU缓存架构"><a href="#CPU缓存架构" class="headerlink" title="CPU缓存架构"></a>CPU缓存架构</h3><p><img src="https://images.lilhui.com/85288ff26f1f5c0a69cf28336ef02a31" alt="图片"></p>
<p>多级缓存：</p>
<ol>
<li>L1 cache 数据缓存和指令缓存，逻辑独占。一般 256K</li>
<li>L2 cache 物理核独占，逻辑核共享。 一般1M左右</li>
<li>L3 cache， 所有物理核共享 一般8M</li>
</ol>
<p>缓存由缓存行构成（cacheline)64byte大小</p>
<p>CPU读取内存数据的过程：  </p>
<ol>
<li>L1-&gt;l2-&gt;L3 一次判断，如果有，直接读取到寄存器。</li>
<li>如果L1,2,3都没有，从内存，读到L3，从L3复制到L2,从L2复制到L1。L1读到寄存器。</li>
</ol>
<ul>
<li>CPU读取数据的特性</li>
</ul>
<ol>
<li>空间局部性<br> CPU从内存拿数据，不仅是拿目标数据，紧邻的一片一次性加载到L3缓存里。</li>
<li>时间局部性<br> 如果一个信息正在被访问那么近期它还可能被访问，比如循环，递归方法的反复调用。</li>
</ol>
<h2 id="操作系统内存管理"><a href="#操作系统内存管理" class="headerlink" title="操作系统内存管理"></a>操作系统内存管理</h2><p>操作系统内存空间分为  </p>
<ol>
<li>用户空间  </li>
<li>内核空间  </li>
</ol>
<p>为什么进行内存空间的划分？  </p>
<pre><code>目的是为了做到程序运行的安全隔离与稳定。32G 4G大小内存为例。内核空间 1G用户空间3G
</code></pre><p><img src="https://images.lilhui.com/6d5b5c00e9c8e4966c517817f50393a1" alt="图片"></p>
<h2 id="CPU运行的安全等级"><a href="#CPU运行的安全等级" class="headerlink" title="CPU运行的安全等级"></a>CPU运行的安全等级</h2><p>ring0：<br>    内核态，权限最高。各种操作都可以做。</p>
<p>ring1<br>ring2<br>ring3<br>权限一次降低。</p>
<p>运用运行的级别一般在用户态。JVM,app等等。</p>
<p><img src="https://images.lilhui.com/dbefca81e04794cb7181cc34444004c5" alt="图片"></p>
<h3 id="内核线程模型"><a href="#内核线程模型" class="headerlink" title="内核线程模型"></a>内核线程模型</h3><p>内核线程（KLT) ，系统内核管理线程内核保存线程额上下文信息，线程阻塞不会引起进程阻塞。在多处理器系统上，多线程在多处理器上并行执行。线程的创建调度和管理由内核完成。效率比ULT要慢，比进程操作快。</p>
<h3 id="用户线程模型"><a href="#用户线程模型" class="headerlink" title="用户线程模型"></a>用户线程模型</h3><p><img src="https://images.lilhui.com/9120839a4ae5a71190ec251f91d3bce8" alt="图片"></p>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>现代操作系统在运行一个程序时，会为其创建一个进程，例如：启动一个java<br>程序，操作系统就会创建一个java进程。进程是OS操作系统资源分配的最小单位</p>
<p>线程是OS操作系统调度CPU的最小单元。也叫轻量级进程（Light Weight Process)，<br>在一个进程里可以创建多个线程。这些线程拥有各自的计数器，堆栈，局部变量<br>等属性。并且能够访问共享的内存变量，CPU在这些线程上高速切换。让使用者感觉到这些<br>线程在同时执行，既并发的感觉。相似的还有并行</p>
<p>线程上下文切换过程：<br><img src="https://images.lilhui.com/57daf7d4695424cce11032ad6e029672" alt="图片"></p>
<h1 id="虚拟机指令集架构"><a href="#虚拟机指令集架构" class="headerlink" title="虚拟机指令集架构"></a>虚拟机指令集架构</h1><p>CPU执行架构分两种，指令集架构和，寄存器指令集架构。</p>
<h2 id="指令集架构"><a href="#指令集架构" class="headerlink" title="指令集架构"></a>指令集架构</h2><ol>
<li>设计和实现更简单，适用于资源受限的系统。</li>
<li>避开了寄存器分配难题，使用零地址指令方式分配。</li>
<li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈，指令集更小，编译器容易实现。</li>
<li>不需要硬件支持，可移植性更好，更容易实现跨平台。</li>
</ol>
<h2 id="寄存器指令集架构"><a href="#寄存器指令集架构" class="headerlink" title="寄存器指令集架构"></a>寄存器指令集架构</h2><ol>
<li>典型的应用如二进制指令集。传统的PC一级Android的Davilk虚拟机。</li>
<li>指令集架构则完全依赖硬件，可移植性差。</li>
<li>性能优秀和执行更高效。</li>
<li>花费更少的指令去完成一项操作。</li>
<li>在大部分情况下，基于寄存器架构的指令集往往都以一地址，二地址指令和三地址指令为主。而基于栈架构的指令集涉及出栈入栈等操作。<br>Java，Python，GO</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【深入理解并发编程系列4】JVM内置锁 synchronized关键字详解</title>
    <url>/2021/03/29/java/concurrent/concurrent_4/</url>
    <content><![CDATA[<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>历史：李二狗看到Synchronized效率太低，自己实现了一套基于AQS的锁。支持可重入，公平，非公平等特性。</p>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p>历史：1.6之前效率低下，重量锁。<br>1.6之后进行了升级，追加了锁的升级过程。</p>
<p>偏向锁-&gt;轻量级锁-&gt;重量级锁。</p>
<p>效率和ReentrantLock差不多</p>
<p>一个图：</p>
<h3 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h3><p><img src="https://images.lilhui.com/396c23c6c4ebbe1a5d1f4c8af2c8f33d" alt="图片"></p>
<h3 id="JVM锁膨胀过程"><a href="#JVM锁膨胀过程" class="headerlink" title="JVM锁膨胀过程"></a>JVM锁膨胀过程</h3><p><img src="https://images.lilhui.com/91400ffa709aeb66905363f9634550e2" alt="图片"></p>
<p><img src="https://images.lilhui.com/fc76a51fb07d27428139cb33d207ae6b" alt="图片"></p>
<p>膨胀过程：</p>
<ol>
<li>新建实例： 匿名偏向锁。</li>
<li>第一个线程过来加锁，变成偏向锁。（高23位记录了对象的线程ID)</li>
<li>第二个线程来后，触发 偏向锁升级，轻量级锁。</li>
</ol>
<p>重量锁膨胀：</p>
<ol>
<li>新建实例，匿名偏向锁</li>
<li>第一个线程过来，变成偏向锁。</li>
<li>第二个线程过来，触发轻量级锁。（高30位，指向线程，栈中锁记录的指针-比偏向锁要精确）</li>
<li>轻量级锁一直被占用，第二个线程自旋无法获取。此时升级成重量级锁。 （高30位存互斥量指针）。</li>
</ol>
<p>加锁hashcode，会变成轻量级锁的原因：</p>
<p>偏向锁没有hashcode,轻量级锁有个叫replace lock record。在栈帧里。</p>
<p>轻量级锁升级的时候 高30位记录了线程栈上锁的块，lockrecord .hashcode存在这个lockrecord。并且初始的mark word也存在了线程栈上。</p>
<p>hashcode存的位置</p>
<p><img src="https://images.lilhui.com/c2a3567c7fa13ba332cb369db9212652" alt="图片"></p>
<p>什么是Monitor?</p>
<p>一种同步工具，是java的一个对象。所有的java对象天生就是monitor。所有对象在新建的时候都会有一把看不见的锁。叫做内部锁，或者Monitor锁。就是Synchronized锁。MarkWord锁标记为10.其中指针指向 的地址就是Monitor对象的起始地址。在java虚拟机中（hotspot)Monitor是由ObjectMonitor实现的。源码在C++的ObjectMonitor.http文件中。</p>
<p><img src="https://images.lilhui.com/6503f5eb91ced216a674c4cb4ccb57d4" alt="图片"></p>
]]></content>
      <categories>
        <category>java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【深入理解并发编程系列3】JMM-CPU缓存一致性协议MESI</title>
    <url>/2021/03/26/java/concurrent/concurrent_3/</url>
    <content><![CDATA[<h2 id="volatile可见性实现的原理"><a href="#volatile可见性实现的原理" class="headerlink" title="volatile可见性实现的原理"></a>volatile可见性实现的原理</h2><p>编译后的汇编会增加一个lock前缀</p>
<p>CPU指令</p>
<p>lock前缀是总线锁</p>
<p><img src="https://images.lilhui.com/838fe54717d996b8cd7a0c720fcfbfb7" alt="图片"></p>
<p>CPU访问内存必须通过总线桥访问。lock前缀加了总线锁，其他CPU就无法通过总线桥获取内存数据。</p>
<p>这个是古老的CPU用的。这种方式会降低多核性能。</p>
<h2 id="MESI"><a href="#MESI" class="headerlink" title="MESI"></a>MESI</h2><p><img src="https://images.lilhui.com/9e3a302bce699c54dfa4a3265be70744" alt="图片"></p>
<p>M:modify<br>E:独占<br>S:share<br>I:已失效</p>
<p>总线嗅探：</p>
<p>CPU会嗅探Bus总线的通知状态。</p>
<p>当CPU都要进行对某个缓存行进行加锁的时候（64byte)会发一个消息出来。我要加锁了。让总线来判断，是否加锁成功。总线裁决。</p>
<p>LOCK的时候告诉CPU采用缓存一致性协议来处理这个被修饰的变量。</p>
<p>缓存行是最大64byte有时候变量大于64byte，这时候会升级总线锁。</p>
<p>缓存一致性协议无法对寄存器生效。所以如果已经被加载到了寄存器里面进行操作的话</p>
<p>CPU中有一个 StoreBufer。cpu修改变量后，会发送一个I信号给其他cpu，其他cpu信息收到后确认后会回复一个已经失效消息。这时后才进行storo操作。所以会先把操作后的数据存在storeBuffer.（内部CPU的ACK机制）</p>
<p>接收后 storeBuffer放回缓存行，在写到内存。</p>
<h2 id="Happens-before"><a href="#Happens-before" class="headerlink" title="Happens-before"></a>Happens-before</h2><p>指令重排需要遵循的规则。</p>
<p>Thread().start<br>Thread().interupt<br>这种是不会被重排的</p>
<p>八大规则：<br><img src="https://images.lilhui.com/0a2bc52ca5a013f7a2d53739a740761e" alt="图片"></p>
]]></content>
      <categories>
        <category>java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【深入理解并发编程系列5】抽象队列同步器AQS Lock详解</title>
    <url>/2021/04/01/java/concurrent/concurrent_5/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>为了提升锁性能引入了 锁粗化技术。</p>
<p><strong>锁粗化：</strong><br>多个同步都加统一个对象。反复不停进出一个对象。JVM会对这样的代码进行逃逸分析。对整个代码块进行扫描。如果符合这种特征代码的话，会将多个同步块合并成一个大的同步快,变粗了。</p>
<p><strong>锁消除：</strong><br>如果对象不可能被多个对象访问到。通过逃逸分析，会对锁进行消除。比如只加在对象上的锁。对象的生命周期是线程调用周期，对象只被一个线程访问。此时会对锁进行消除。</p>
<p>还有一个典型的就是栈上分配的对象，符合逃逸分析的对象，分配在栈上。并且对这个对象进行了加锁。此时，也只有这个线程能对对象进行访问，就会进行锁消除。</p>
<p>PS:逃逸分析后会做的优化:锁消除，锁粗化，标量替换等。<br>标量:八大基本类型。  </p>
<h2 id="AQS-LOCK详解"><a href="#AQS-LOCK详解" class="headerlink" title="AQS LOCK详解"></a>AQS LOCK详解</h2><ol>
<li>AQS还没出现之前，如果需要规定一个线程占用CPU使用时间的话，可能用到while循环。</li>
</ol>
<p>或者用：lock.pack(); lock.Unpack(THread) 停止，阻塞方法。</p>
<p>unpack</p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>Lock三大核心：自旋，LockSupport,CAS,队列</p>
<p>队列的FIFO用来实现公平，非公平锁。</p>
<p>CAS依赖硬件元语：cmpxchg()</p>
<p>LockSupport:线程阻塞工具。底层是native的方法 UNSAFE.xx</p>
<p><strong><em>AQS具备特性：</em></strong></p>
<ul>
<li>阻塞等待队列</li>
<li>共享/独占</li>
<li>公平/非公平</li>
<li>可重入</li>
<li>允许中断</li>
</ul>
<p>除了Lock外，Java.concurrent.util当中同步器的实现如Latch,Barrier,BlockingQueue等， 都是基于AQS框架实现</p>
<p>AQS内部维护属性volatile int state (32位)</p>
<p><strong><em>state表示资源可用状态。</em></strong></p>
<ul>
<li>state三种访问方式：</li>
</ul>
<ol>
<li>getState()</li>
<li>setState(int)</li>
<li>compareAndSetState()</li>
</ol>
<ul>
<li>AQS定义两种资源共享方式</li>
</ul>
<ol>
<li>Exclusive-独占，只有一个线程能执行，如ReentrantLock。</li>
<li>Share-共享，多个线程可以同时执行，如Semaphore/CountDownLatch。</li>
<li>同步等待队列</li>
<li>同步等待队列</li>
</ol>
<ul>
<li>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共 享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/ 唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</li>
</ul>
<ol>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去 实现它。</li>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回 false。</li>
<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回 false。</li>
<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成 功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>海量数据查询和存储</title>
    <url>/2022/12/02/java/distributed/big_data/</url>
    <content><![CDATA[<h2 id="存储选型"><a href="#存储选型" class="headerlink" title="存储选型"></a>存储选型</h2><p>存储系统的选择，决定了系统的性能上限。</p>
<p>Mysql: 1000W以内</p>
<h2 id="如何技术选型"><a href="#如何技术选型" class="headerlink" title="如何技术选型"></a>如何技术选型</h2><p>技术选型不能脱离业务，业务决定技术选型。</p>
<ul>
<li>业务系统类型<br>在线业务系统OLTP,分析系统OLAP</li>
</ul>
<h3 id="选型步骤"><a href="#选型步骤" class="headerlink" title="选型步骤"></a>选型步骤</h3><ol>
<li><p>评估规模<br>评估规模，一般估两年以后的量。实际的量，跟老板的期望会有折扣。</p>
</li>
<li><p>数据库选择<br>如果数据数量在千万（1GB)：mysql首选。 </p>
</li>
</ol>
<p>数量亿级（1TB): 数据进行分库分表，分片等。<br>只能事先对数据进行聚合计算，然后再聚合后的数据进行查询，这种情况放在HDFS。</p>
<h3 id="成本考虑"><a href="#成本考虑" class="headerlink" title="成本考虑"></a>成本考虑</h3><p>比如购买Oracle服务。市场MySQL人更容易找到，成本就会更低。尽量选择普遍的技术。学习成本高低,是否有坑。</p>
<h2 id="如何存储埋点之类的海量数据"><a href="#如何存储埋点之类的海量数据" class="headerlink" title="如何存储埋点之类的海量数据"></a>如何存储埋点之类的海量数据</h2><p>这种数据写的量巨大，先进入队列。kafka,rocketMq。</p>
<h2 id="分析类系统如何选择存储"><a href="#分析类系统如何选择存储" class="headerlink" title="分析类系统如何选择存储"></a>分析类系统如何选择存储</h2><p>分析类存储的需求有四点</p>
<ol>
<li>分析的数据量，会比业务数据量高几个数量级。需要存储系统能够保存海量数据。</li>
<li>还要能在海量数据上进行聚合，如果要快速请求返回，分析和查询操作。GB,TB,PB级别的海量数据，这种业务在毫秒级响应是不可能的。</li>
<li>大多数情况下数据都是异步写入</li>
</ol>
<p>关键点，还是根据业务决定技术。查询- 选择存储系统和数据结构。</p>
<h3 id="京东的仓库"><a href="#京东的仓库" class="headerlink" title="京东的仓库"></a>京东的仓库</h3><p>运营过程产生的物流数据。智能补货系统要用，运力调度的系统要用。每个系统使用的方式不同。<br>京东智能补货，需求仓库间补货的最短路径。</p>
<p><strong>分析</strong>  </p>
<p>补货系统:地域性，通过地域分片数据，先查询距离近的分片在汇总成区域物流数据。得到最优的发货点。</p>
<h2 id="商品系统需要保存哪些数据"><a href="#商品系统需要保存哪些数据" class="headerlink" title="商品系统需要保存哪些数据"></a>商品系统需要保存哪些数据</h2><p>商品详情页保存哪些信息？<br>基本信息：标题，副标题，原价，价格，促销价<br>详细信息：商品参数，商品介绍，图片视频<br>其他信息：促销信息，推荐商品，评论，评价，配送信息，店铺信息</p>
<p>商品详情页：静态化。</p>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>bigdata</tag>
      </tags>
  </entry>
  <entry>
    <title>【微服务电商平台关键技术1】分布式事务</title>
    <url>/2021/12/02/java/distributed/distributed_1/</url>
    <content><![CDATA[<h2 id="常见的分布式事务方案"><a href="#常见的分布式事务方案" class="headerlink" title="常见的分布式事务方案"></a>常见的分布式事务方案</h2><p><img src="https://images.lilhui.com/aff38186038103177cb12abc59492773" alt="图片"></p>
<h3 id="2PC-两阶段提交"><a href="#2PC-两阶段提交" class="headerlink" title="2PC 两阶段提交"></a>2PC 两阶段提交</h3><p><strong>角色定义：</strong></p>
<p>TM：TransactionManager协调者<br>RM：RresourceManager参与者</p>
<p>从字面上理解两阶段提交分两个阶段提交的事务。</p>
<p><strong>阶段一：</strong><br>TM通知RM准备提交他们的事务分支，如果RM判断自己进行的工作可以被提交，就对工作内容进行持久化<br>再回复TM,否则异常。<br>Mysql是这样做的：事务管理器向所有涉及到的数据库发出prepare 准备提交请求，数据库收到请求后<br>执行修改和日志记录处理，处理完后把事务的状态标记成 可以提交，然后返回结果。</p>
<p><strong>阶段二：</strong><br>TM根据阶段一各个RM prepare的结果，决定提交还是回滚操作。所有的prepare都成功，就提交。如果有prepare失败的<br>则TM通知所有RM回滚自己的事务。<br>Mysql是这样做的：第一阶段提交的prepare成功，那么事务管理器向数据库服务器发出 确认提交 请求，数据库服务器把事务<br>的状态改成 提交完成 状态，然后返回。如果第一阶段内有任何一个数据库操作发生了错误，或者事务管理器收不到某个数据库的<br>响应，则认为事务失败，回滚所有的事务，数据库服务器收不到第二阶段的确认提交，也会把  可以提交的事务 回滚。</p>
<p><img src="https://images.lilhui.com/926fc561b6ea8c0c8e5304b7281c5596" alt="图片"></p>
<p><strong>二阶段提交存在的问题：</strong></p>
<ul>
<li>同步阻塞</li>
</ul>
<p>各个事务的ACID保证了全局的ACID所以需要用到串行化,<br>SERIALZABLE隔离级别。效率低。可重复度隔离级别无法保障分布式事务一致性。</p>
<ul>
<li>单点故障</li>
</ul>
<p>协调者TM有单点故障问题。</p>
<ul>
<li>数据不一致</li>
</ul>
<p>发送commit的时候有的参与者没接收到！</p>
<h3 id="JTA-XA-规范实现"><a href="#JTA-XA-规范实现" class="headerlink" title="JTA/XA 规范实现"></a>JTA/XA 规范实现</h3><p>java对于事务的规范实现。管理多个connection事务的封装。有阻塞。</p>
<h2 id="补偿机制"><a href="#补偿机制" class="headerlink" title="补偿机制"></a>补偿机制</h2><p>为了解决阻塞的问题，引入了补偿机制。</p>
<h3 id="Seata-AT模式实现"><a href="#Seata-AT模式实现" class="headerlink" title="Seata AT模式实现"></a>Seata AT模式实现</h3><p>补偿机制实现的 应用层面的分布式事务框架。</p>
<p><img src="https://images.lilhui.com/9b81d334f266e632772648638da6e6c6" alt="图片"></p>
<p>TC，事务协调，独立出来。存储全局事务和分支事务信息。</p>
<p>开启事务的时候通过RPC向TC发送一个请求生成XID 全局事务ID。</p>
<p>RM:资源管理器</p>
<ul>
<li>第一阶段  </li>
</ul>
<ol start="0">
<li>解析SQL</li>
<li>现场记录（查原始数据，并记录。）行锁，级别。</li>
<li>执行sql语句。</li>
<li>查下执行完成的日志存到 UndoLog</li>
<li>Befor commit</li>
<li>commit</li>
<li>After local TX</li>
</ol>
<p><img src="https://images.lilhui.com/bd850c07c83c6ec78265a4bc15af9786" alt="图片"></p>
<ul>
<li>第二阶段<br>如果成功：  </li>
</ul>
<ol>
<li>Find undo Log</li>
<li>Delete Undo log</li>
<li>commit</li>
</ol>
<p><img src="https://images.lilhui.com/33ae92e7385a402bd7be89fd1b5d0022" alt="图片"></p>
<p>如果失败：  </p>
<ol>
<li>Find Undo log</li>
<li>确认后置镜像是否可以回滚。</li>
<li>执行Undo SQL</li>
<li>删除 Undo SQL</li>
<li>Commit</li>
<li>After Local TX</li>
</ol>
<p><img src="https://images.lilhui.com/ba2d7021ccb83903ed03b390b2524301" alt="图片"></p>
<ul>
<li>设计优点  </li>
</ul>
<ol>
<li>应用成实现，给予SQL解析和补偿。</li>
<li>TC可以独立部署，避免单点故障。</li>
<li>通过全局（TC管理）锁实现了隔离与读隔离</li>
</ol>
<ul>
<li>存在的问题  </li>
</ul>
<ol>
<li>数据局交互太多，效率低。性能损耗严重。</li>
<li>全局锁，力度也高</li>
<li>性价比不高</li>
</ol>
<h4 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h4><ol>
<li><p>注册，授权   </p>
</li>
<li><p>订单服务，扣减库存，扣除余额。订单状态。</p>
</li>
</ol>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>微服务为例：</p>
<ol>
<li>引入Seata包，nacos注册中心  </li>
<li>添加Undo_log表</li>
<li>配置seata DataSourceProxy代理数据源  </li>
<li>启动类排除DataSourceAutoCinfiguration，以免造成循环依赖。</li>
<li>添加seata配置 在nacos配置中心。存TC的配置。</li>
<li>使用 @GlobalTransactionnal</li>
</ol>
<h3 id="柔性事务-TCC-Try-Confirm-Cancel"><a href="#柔性事务-TCC-Try-Confirm-Cancel" class="headerlink" title="柔性事务 TCC (Try-Confirm-Cancel)"></a>柔性事务 TCC (Try-Confirm-Cancel)</h3><p>TCC和XA都是2阶段提交</p>
<p>实现有：</p>
<ul>
<li>TCC-Transaction</li>
<li>Hmily</li>
<li>ByteTCC</li>
<li>EasyTransaction</li>
<li>SeataTCC</li>
</ul>
<p><img src="https://images.lilhui.com/df9e0ab532d5b31a27ee48a608359442" alt="图片"></p>
<p>XA是资源层面的分布式事务，强一致性，在两阶段提交的过程中，一直会持有资源的锁。<br>TCC是业务层的分布式事务，最终一致性，不会一直持有资源的锁。  </p>
<p><strong>优点:</strong> XA两阶段提交是资源层面的，而TCC是提升到了应用层面，避免了XA两阶段提交占用<br>资源锁时间过长导致的性能低下问题。<br><strong>缺点:</strong> 主业务和从业务服务都需要改造，从业务改造成本更高，原来只需要提供一个接口，现在需要改造try,confirm,cancel三<br>个接口。开发成本高。</p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>TCC需要把事务在应用层面切成两个阶段。</p>
<p><img src="https://images.lilhui.com/b151157caa0e6674a218c4a78d825dbd" alt="图片"></p>
<p>三种方法设计不好有很大bug，一般用以下方式：</p>
<p><img src="https://images.lilhui.com/611c9e22f3a2a606410887f5d30cf71f" alt="图片"></p>
<h4 id="TCC设计"><a href="#TCC设计" class="headerlink" title="TCC设计"></a>TCC设计</h4><ul>
<li>TCC异常控制<br>网络问题，重发，机器宕机等一系列问题。出现空回滚，幂等，悬挂问题。</li>
</ul>
<p>TCC允许空回滚。</p>
<ul>
<li>TCC 防悬挂控制<br>要运行空回滚，必须拒绝空回滚之后的try操作。<br>案例：<br>try方法超时，这时候触发了cancel后try才到达。try是减少数据操作。这时候数据就出错了。</li>
</ul>
<p>此时try方法不能被执行。</p>
<p><img src="https://images.lilhui.com/257ca2a2ead452ea870ef8a3324dc6d0" alt="图片"></p>
<ul>
<li>TCC 幂等</li>
</ul>
<p>网络故障情况下，分支事务可能多次被执行，需要支持幂等性。</p>
<h4 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h4><ol>
<li>引入依赖</li>
<li>添加配置 Hmily配置</li>
<li>建Hmily的表</li>
<li>实现接口，添加 @Hmily注解，制定confirm方法，cancel方法</li>
</ol>
<h3 id="柔性事务，可靠消息最终一致性方案"><a href="#柔性事务，可靠消息最终一致性方案" class="headerlink" title="柔性事务，可靠消息最终一致性方案"></a>柔性事务，可靠消息最终一致性方案</h3><p>可靠性消息最终一致性的方案是指当事务发起执行完成本地食物后并发出一条消息，事务参与方（消息消费者）一定能接受消息并处理事务成功，<br>此方案强调的是只要消息发给事务参与方最终事务要达成一致。</p>
<p>TCC比较难，业务侵入比较大。控制力比较强，适合金融类产品。<br>可靠新消息方案是从架构上避免分布式事务！</p>
<h4 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h4><p>本地消息表，这个方案是ebay提出。核心是通过保证本地事务操作和消息的一致性。</p>
<p><img src="https://images.lilhui.com/197864dc504ab51310d5111de069170f" alt="图片"></p>
<ul>
<li>RockMq事务消息的方案<br><img src="https://images.lilhui.com/42887bcf2282a910d82a046444b1f94d" alt="图片"></li>
</ul>
<p>事务消息也有2PC,存在MqProducer RocketMq 4.3开始支持。</p>
<p>关键点，事务回查。</p>
<h3 id="柔性事务，最大努力通知"><a href="#柔性事务，最大努力通知" class="headerlink" title="柔性事务，最大努力通知"></a>柔性事务，最大努力通知</h3><ol>
<li>消息重复通知机制</li>
<li>消息校对机制<br> 可查消息最终状态</li>
</ol>
<p>场景：比如公司内部实现了短信平台，所有的业务都接入这个短信平台，来实现发送短信的功能。<br><img src="https://images.lilhui.com/bb6a1ee6f9abcfe697ebcb3a57604af0" alt="图片"></p>
<p>场景2：充值</p>
<p><img src="https://images.lilhui.com/c72ea521f4efbadc03c2c31bc6a03888" alt="图片"></p>
<p>最大通知与可靠新消息最终一致性的区别？</p>
<ul>
<li>思想不同<br>  可靠消息最终一致性，发起通知方需要保证消息发出去，并且将消息发送到接收方，消息的<br>可靠性关键由发起通知放来保证。</li>
<li>业务场景不同<br>  可靠消息最终一致性关注的是交易过程的事务一致性，以异步的方式完成交易。<br>  最大努力通知关注的是交易后的通知事务，即将交易结果可靠的通知出去。</li>
<li>技术解决方向不同<br>  可靠消息最终一致性要解决消息从发出到接收的一致性，既消息发出并且被接收到。<br>  最大努力通知无法保证消息从发出到接收的一致性，只提供消息接收的可靠性机制。可靠性机制是，最大努力的将消息通知给<br>接收方，当消息无法被接收方接收时，由接收方主动查询消息。</li>
</ul>
]]></content>
      <categories>
        <category>电商</category>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>分布式事务</tag>
        <tag>亿级流量</tag>
      </tags>
  </entry>
  <entry>
    <title>大型网站的高并发读写总结</title>
    <url>/2022/12/01/java/distributed/concurrent_read_write/</url>
    <content><![CDATA[<h2 id="高并发的读写场景解析"><a href="#高并发的读写场景解析" class="headerlink" title="高并发的读写场景解析"></a>高并发的读写场景解析</h2><p>不管什么系统，都是做读和写。</p>
<h3 id="侧重”高并发读”的系统"><a href="#侧重”高并发读”的系统" class="headerlink" title="侧重”高并发读”的系统"></a>侧重”高并发读”的系统</h3><p>存储引擎 ES,solr等<br>终端用户-搜索（读）-&gt; 搜索引擎 &lt;-发布（写）- 内容生产者</p>
<ol>
<li>数量级的差别：终端用户成千上百万个。生产者是公司内部产生，数量级不会太高。</li>
<li>响应时间。读的响应时间要求在毫秒级。</li>
</ol>
<h3 id="侧重”高并发写”的系统"><a href="#侧重”高并发写”的系统" class="headerlink" title="侧重”高并发写”的系统"></a>侧重”高并发写”的系统</h3><p>广告位竞拍，扣费类的。如baidu的业务模式，抖音的广告投放扣费等。</p>
<ol>
<li>按照浏览次数，点击收费。需要写的实时性。C端每次浏览点击都要进行主账号上的扣减。</li>
</ol>
<h3 id="同时有-“高并发读”-和-“高并发写”"><a href="#同时有-“高并发读”-和-“高并发写”" class="headerlink" title="同时有 “高并发读” 和 “高并发写”"></a>同时有 “高并发读” 和 “高并发写”</h3><ol>
<li>电商的库存系统和秒杀系统</li>
<li>支付系统，微信红包</li>
<li>IM,微博朋友圈</li>
</ol>
<p>不同场景面面对的高并发压力不同，应对高并发读和高并发写的策略是不同的。</p>
<h2 id="高并发读常见解决策略"><a href="#高并发读常见解决策略" class="headerlink" title="高并发读常见解决策略"></a>高并发读常见解决策略</h2><h3 id="本地缓存或集中式缓存"><a href="#本地缓存或集中式缓存" class="headerlink" title="本地缓存或集中式缓存"></a>本地缓存或集中式缓存</h3><p>本地Map缓存<br>Redis缓存</p>
<ul>
<li>集中式缓存需要避免的问题</li>
</ul>
<ol>
<li>缓存高可用</li>
<li>缓存穿透</li>
<li>缓存击穿</li>
<li>大量热key过期</li>
</ol>
<h3 id="读副本"><a href="#读副本" class="headerlink" title="读副本"></a>读副本</h3><p>Mysql Master/Slave 增加一堆Slave（网易的Mysql用法）几百台Mysql slave树。</p>
<h3 id="CND-静态文件加速，动静分离"><a href="#CND-静态文件加速，动静分离" class="headerlink" title="CND/静态文件加速，动静分离"></a>CND/静态文件加速，动静分离</h3><ol>
<li>静态内容，数据不变。html,js,css,图片等，是静态，分发到CDN</li>
<li>动态内容，用户的信息，实时查询的数据，这些放在服务器进行处理。</li>
</ol>
<h3 id="并发读"><a href="#并发读" class="headerlink" title="并发读"></a>并发读</h3><h3 id="异步RPC"><a href="#异步RPC" class="headerlink" title="异步RPC"></a>异步RPC</h3><p>串行读 -&gt; 并发读</p>
<ol>
<li>在链路上的请求 并发执行。</li>
<li>冗余请求 Jeaf Dean 写的 The Tail at scale。肠胃耗时优化的经验。<br>案例：一个用户的请求需要100台服务器联合处理，每个服务器有1%的概率发生调用延迟（1秒延迟)。那么C端用户来说，响应时间<br>大于1秒的概率是63%<br>怎么算出来的呢？如果用户请求响应时间小于1s那么 100台服务器响应时间都小于1s。这个概念是100个99%相乘。<br>所以是 1- 0.99 100次方。 问题就很严重。</li>
</ol>
<p>此问题的解决方法：冗余请求。客户端同时向多台服务器发送请求，哪个返回快就用哪个，其他的丢弃。这种方法系统的调用量会翻倍。<br>调整一下：如果客户端在一定时间内没有收到服务端的响应，则马上给另一台或者多台发送同样的请求。客户端等待第一个响应到达之后，立即终止其他请求的处理<br>“一定时间” 定义为 ： 内部服务95%请求的响应时间。这种方法称之为 “对冲请求”。</p>
<p>测试数据：采用这种方法，可以仅用2%的额外请求将系统99.9%的请求响应时间从1800ms降低到74ms.</p>
<p>牛逼的 The Tail at Scale</p>
<p>另一个方法：<br>捆绑请求。 上游对下游服务器进行探测，找负载低的。在请求的时候顺便探测。</p>
<p>核心：用更多的机器来减少延迟，扛起高并发读</p>
<h3 id="重写轻读"><a href="#重写轻读" class="headerlink" title="重写轻读"></a>重写轻读</h3><h4 id="微博-feeds流的实现"><a href="#微博-feeds流的实现" class="headerlink" title="微博 feeds流的实现"></a>微博 feeds流的实现</h4><p>Feeds流 关注的n个人的微博进行排序成一个列表。有变更，冗余保存起来。<br>为每个人增加一个Feeds流，叫做收件箱。</p>
<p>将复杂的读逻辑，通过重写的方式，进行了简化。  </p>
<p>实现的方案：<br>Redis list 缓存。并对list大小进行限制。并且持久化，分库分表。根据业务进行设置分片键。</p>
<p>以上解决了读的高并发，又引来一个问题：假设一个用户的粉丝很多，每个粉丝的邮箱都复制一份，计算<br>和延迟会很大。比如某个明星有粉丝8000万，如果复制8000万份，对系统来说是个沉重的负担。</p>
<p>解决方法：回到最初的思路，在读的时候进行实时聚合。用’拉’的方式进行获取。</p>
<p>将粉丝用户分组，份成在线和不在线。只推送在线的粉丝。系统维护一个全局的，在线列表</p>
<p>对于读的一端一个用户关注的人当中。有的人是推给他的。有的人需要他去拉的，需要把两者聚合起来，再按时间排序，然后分页显示，这就是’推拉结合’。</p>
<h3 id="多表的关联查询：宽表于搜索引擎"><a href="#多表的关联查询：宽表于搜索引擎" class="headerlink" title="多表的关联查询：宽表于搜索引擎"></a>多表的关联查询：宽表于搜索引擎</h3><p>多表关联到情况下，通过加Slave解决。这种方法在没有分库的情况下可以实现。</p>
<p>如果已经分库了，那需要多个查询进行聚合，无法使用原声的Join功能。只能从程序中分别从两个库读取，再做聚合。</p>
<p>存在一个问题：如果需要把聚合出来的数据按某个维度进行排序分页，这个维度是临时计算出来的维度，而不是数据库本来就有的维度。</p>
<p>由于无法使用数据库的排序和分页功能，也无法再内存中通过实时计算来实现排序、分页此时如何处理？</p>
<p>采用类似微博重写轻读的思路：提前把关联数据计算好，存在一个地方，读的时候直接去读聚合好的数据，而不是读的时候去做join.</p>
<p>具体的操作：准备一张宽表，把关联表的数据算好后保存在宽表里。依据实际情况，定时计算，也可能任何一张原始表发生变化时进行宽表数据的计算。</p>
<p>也可以使用ES类的搜索引擎来实现：把多个表的join结果做成一个个的文档，放在搜索引擎里。可以林火实现排序和分页查询。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>读写分离Command Query Responsiblility Spareation<br>分别为读和写设计不同的数据结构。在C端，当同时面临读和写的高并发压力时，把系统分成读和写两个视角来设计，各自设计适合搞并发和读写的数据结构或模型。</p>
<p>缓存其实是读写分离的一个简化，或者是说特例，写业务DB和读缓存用了基本一样的数据结构。</p>
<h2 id="高并发写常见解决策略"><a href="#高并发写常见解决策略" class="headerlink" title="高并发写常见解决策略"></a>高并发写常见解决策略</h2><h3 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h3><p>数据分片后利用多台机器的资源进行分发写操作。</p>
<p>MySQL: 分库分表<br>Redis: Redis Cluster集群<br>ES: 分布式索引 sharder<br>10亿个网页或商品分成n份，建成n个小的索引。一个查询请求来了，并行地在n各索引上查询。</p>
<h3 id="异步化"><a href="#异步化" class="headerlink" title="异步化"></a>异步化</h3><p>异步化，无处不在。  </p>
<p>发送请求立即响应返回。客户端轮询或者其他方式进行获取结果。<br>客户端发起一个Http请求，不等结果，立即发送2，3个。数据库的事务提交Write-aheadLog 。</p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ul>
<li>电商系统的拆单功能  </li>
<li>短信验证码或者登录</li>
<li>写内存 + Write-Ahead 日志。</li>
</ul>
<p>MySQL为了提高磁盘IO性能，使用了 Write-Ahead日志。也就是RedoLog。<br>高并发扣减MySQL中的账户余额，或者电商系统中扣减库存，直接在数据库中口，数据库可能扛不住。<br>可以在Redis中先扣，然后同时落地一条日志（日志可以在一个高可靠的消息中间件或数据库中插入一条条日志）。<br>当Redis宕机，把所有的日志重放完毕，再用数据库中的数据初始化Redis的数据。</p>
<h3 id="批量写"><a href="#批量写" class="headerlink" title="批量写"></a>批量写</h3><blockquote>
<p>广告计费的合并扣费</p>
</blockquote>
<p>假设有10个用户，对于1个广澳，每个用户点了1次，就意味着同1个广告的主账号要扣10次钱，每次扣1块（假设点击1次扣1次）如果改成<br>合并扣费，就是1次扣10块钱。</p>
<p>扣费模块一次性从持久化消息队列中取多条消息，对多条消息按照广告的主账号进行分类然后进行扣费。</p>
<blockquote>
<p>MySQL的小事务合并机制</p>
</blockquote>
<p>MySQL内核会自动合并小事务进行批量的事务操作。<br>Canal里 进行更新的时候，进行合并事务执行。</p>
<h3 id="侧重-‘高并发写’-的系统"><a href="#侧重-‘高并发写’-的系统" class="headerlink" title="侧重 ‘高并发写’ 的系统"></a>侧重 ‘高并发写’ 的系统</h3><blockquote>
<p>扣费系统:</p>
</blockquote>
<h2 id="商城秒杀中RocketDB数据详解"><a href="#商城秒杀中RocketDB数据详解" class="headerlink" title="商城秒杀中RocketDB数据详解"></a>商城秒杀中RocketDB数据详解</h2><p>异步下单 Redis挂了，但是单没有正常发出去。这时候哪里去找单呢？<br>引入写内存+ write ahead日志。将日志写到RocketDB</p>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>【分库分表1】分布式主键1</title>
    <url>/2022/01/15/java/distributed/distributed_3/</url>
    <content><![CDATA[<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>ShardingSphere</p>
]]></content>
      <categories>
        <category>电商</category>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>亿级流量</tag>
        <tag>分库分表</tag>
      </tags>
  </entry>
  <entry>
    <title>RocksDB详解</title>
    <url>/2022/12/02/java/distributed/rocksDB/</url>
    <content><![CDATA[<h2 id="RocksDB-详解"><a href="#RocksDB-详解" class="headerlink" title="RocksDB 详解"></a>RocksDB 详解</h2><blockquote>
<p>性能好，支持事务。</p>
</blockquote>
<p>秒杀库存扣减中使用了缓存 + Write-Ahead Logging 技术。</p>
<p>事务随机读写。Redo日志是追加文件顺序读写，性能差异有30-40倍。</p>
<p>事务的实现上，MySQL使用的是WAL机制来的。所有的修改都先被写到日志中，然后再被应用到系统重。包括<br>redo,undo.</p>
<p>RocksDB是Facebook开源的高性能，持久化的KV存储引擎，最初是Facebook数据库工程师团队基于 Google LevelDB开发。<br>一般很少使用到RocksDB保存数据。</p>
<p>越来越多的新生代数据库都选择RocksDB作为他们的存储引擎。比如：CockroachDB(蟑螂)一个开源，可伸缩，跨地域复制且<br>兼容事务的ACID特性的分布式数据库，思路来源于Google的全球性分布式数据库Spanner，其理念是将数据分布在多数据中心的<br>多台服务上。</p>
<p>YugabyteDB，Tidb 作为CockroachDB的竞争产品，底层也是RocksDB.</p>
<p>MyRocks使用RocksDB给MySQL做引擎，目的是取代现有的InnoDB存储引擎。MySQL的请兄弟MariaDB已经接纳了MyRocks作为<br>它的存储引擎。</p>
<p>实时计算引擎Flink,其State就是一个KV存储，它用的也是RocksDB</p>
<p>MongoDB，Cassandra,Hbase都在开发基于RocksDB的引擎。</p>
<p>原因是 RocksDB性能高，并且支持事务。</p>
<blockquote>
<p>随机读写能达到: 18w-19w qps<br>覆盖操作能达到：9w tps<br>多读单鞋：10w qps</p>
</blockquote>
<p>所以用RocksDB实现 Write-Ahead Logging</p>
<h3 id="RocksDB为什么这么快呢"><a href="#RocksDB为什么这么快呢" class="headerlink" title="RocksDB为什么这么快呢"></a>RocksDB为什么这么快呢</h3><p>内存+磁盘IO,读写性能主要取决于他的存储结构。MySql B+树,Oracle B*,RocksDB LSM-tree</p>
<h4 id="LSM-Tree"><a href="#LSM-Tree" class="headerlink" title="LSM-Tree"></a>LSM-Tree</h4><p>保证顺序写入的前提下，还能保证很好的查询性能。<br>WAL,跳表和一个分层的有序表（sorted String table,SSTable).LSM-Tree专门为key-value设计的<br>存储系统，以牺牲部分读性能为代价提高写入性能。通常适合于写多读上的场景。</p>
<p>LSM-Tree 描述图如下 </p>
<p><img src="https://images.lilhui.com/28ee3b34af9b86ce6288179da1edd623" alt="图片"></p>
<p>在SSD搞并行下，扩展LevelDB以显示利用SSD的多通道，优化并发I/O请求的调度和调度策略，将常规SSD<br>上运行LevelDB的吞吐量再提高4倍。</p>
<p>Log写入是使用的WAL机制，顺序写。</p>
<p>MemTable，跳表（类似红黑树)</p>
<p>c端过来写MemTable和log后就可以返回了。MemTable 32M,写满后会Dump成ImultableMemTable（不可变）<br>如果write继续，会重新创建一个MemTable.</p>
<blockquote>
<p>问题：写入磁盘，部分有序全局无序。</p>
</blockquote>
<p>解决方案：Level0,Level1，会进行合并。</p>
<p>SSTable分层，越热的数据越靠上。对热数据比较友好。</p>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>rocksDB</tag>
      </tags>
  </entry>
  <entry>
    <title>【秒杀系统1】设计与实现上</title>
    <url>/2022/11/29/java/distributed/seckill_1/</url>
    <content><![CDATA[<h2 id="业务分析-系统挑战"><a href="#业务分析-系统挑战" class="headerlink" title="业务分析 系统挑战"></a>业务分析 系统挑战</h2><ol>
<li>瞬时流量</li>
<li>库存有限</li>
<li>持续时间短</li>
<li>预约，限购</li>
<li>涉及 商品详情页，订单结算，支付</li>
</ol>
<h2 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h2><ol>
<li>瞬时流量带来的服务端压力，造成单个请求增加。打挂服务器，用户体验不佳。</li>
<li>库存有限。造成多卖，超卖。</li>
<li>刷子流量，黄牛抢单，刷订单。黑产！道高一尺魔高一丈。</li>
</ol>
<h2 id="通用秒杀架构"><a href="#通用秒杀架构" class="headerlink" title="通用秒杀架构"></a>通用秒杀架构</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p><strong><em>解决大流量问题</em></strong></p>
<ul>
<li>Http请求路径</li>
</ul>
<p>用户 -&gt; DNS -&gt; NGINX -&gt; Web服务 -&gt; RPC调用</p>
<p>解决流量问题，就是在链路上的个个节点进行优化。</p>
<p>NGINX：负载均衡，反向代理，静态资源服务器。流量过滤，限流。<br>Web服务：集群，业务聚合。<br>RPC调用：数据库，缓存等基础服务。</p>
<h3 id="NGINX"><a href="#NGINX" class="headerlink" title="NGINX"></a>NGINX</h3><p>流量筛选，缓存接口（openretry)</p>
<p>引入Openrestry 处理商品展示页面相关接口。</p>
<p>Nginx启动后，产生Master进程。Master生成多个Worker进程，处理相关请求。<br>Worker进程数可以配置。一般跟CPU数量保持一致。或者CPU跟Worker进行绑定，减少上下文切换，提升性能。</p>
<p>OpenRestry将LuaJIT的虚拟机嵌入到Nginx的管理进程和Worker进程。性能上OpenRestry接近或者超过C的模块，开发效率高。</p>
<p>Nginx将Http请求分成多个阶段，一个Http请求分给多个模块进行处理。每个模块专注一个独立简单的功能处理。</p>
<p>9个模块：</p>
<p>OpenRestry在Http处理阶段基础上分别在Rewrite/Access阶段、Content阶段、Log阶段注册了自己的Handler，加上系统初始阶段<br>Master的两个阶段，共11 个阶段为Lua脚本提供了介入的能力。</p>
<p>init_by_lua：进程加载Nginx配置文件时运行，一般用于注册全局变量，或者预加载Lua模块。<br>init_worker_by_lua：每个worker进程启动时执行，通常用于定时拉取配置数据或则进行后端服务的健康检查。<br>set_by_lua：变量初始化。<br>rewrite_by_lua：可以实现复杂的转发，重定向逻辑。<br>access_by_lua：准入，接口权限等情况集中处理。<br>content_by_lua：内容处理器，接收请求处理并输出响应。<br>header_filter_by_lua：响应头部或者Cookie处理。<br>body_filter_by_lua： 对响应数据进行过滤，如截断或者替换。<br>log_by_lua:会话完成后，本地异步完成日志记录。  </p>
<h3 id="商城中的OpenRestry"><a href="#商城中的OpenRestry" class="headerlink" title="商城中的OpenRestry"></a>商城中的OpenRestry</h3><ol>
<li>负载均衡</li>
<li>网关</li>
<li>反向代理</li>
</ol>
<h4 id="详情页静态化"><a href="#详情页静态化" class="headerlink" title="详情页静态化"></a>详情页静态化</h4><p><strong>页面</strong>：商品详情页静态化。比商城页面静态化更彻底的静态化。  </p>
<p>秒杀的商品是独立提报的。秒杀商品详情页的模板是类似的。抽出相同部分，通过freemark生成静态页面，缓存到ftp服务器。通过nginx直接访问。<br>具体做法：  </p>
<ol>
<li>准备提报脚本，自动化处理 生成html静态文件。推送到nginx服务端。</li>
<li>秒杀管理后台，开启秒杀开关，选取商品进行商详面静态化。</li>
<li>sftp 上传到nginx服务器。</li>
<li>访问链接和具体页面进行映射。通过RestyTemplate</li>
<li>OpenRestry二次模板化。活动详情的渲染等。通过RestyTemplate</li>
</ol>
<h4 id="库存获取"><a href="#库存获取" class="headerlink" title="库存获取"></a>库存获取</h4><p><strong>库存</strong>：库存直接从redis进行获取。不用通过后端服务。</p>
<ol>
<li>OpenResty直接访问Redis获取库存。resty.redis开源模块。</li>
<li>Nginx 和 Redis从服务器放在一起，避免链路层和传输层的开销。完全避免网络开销需要用到Unix Domain Socket变成进程间通信 IPC！</li>
</ol>
<p>Unix Domain Socket: 进程间通讯。</p>
<h2 id="秒杀隔离设计"><a href="#秒杀隔离设计" class="headerlink" title="秒杀隔离设计"></a>秒杀隔离设计</h2><p>隔离策略,秒杀商品和普通商品隔离。</p>
<h3 id="如何隔离"><a href="#如何隔离" class="headerlink" title="如何隔离"></a>如何隔离</h3><ol>
<li>业务上的隔离</li>
<li>系统隔离。流量大的系统进行隔离（订单，支付,库存)</li>
<li>数据的隔离</li>
</ol>
]]></content>
      <categories>
        <category>seckill</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title>【秒杀系统3】优化订单交易全链路优化</title>
    <url>/2022/11/30/java/distributed/seckill_3/</url>
    <content><![CDATA[<h2 id="下单定时检查的优化"><a href="#下单定时检查的优化" class="headerlink" title="下单定时检查的优化"></a>下单定时检查的优化</h2><p>RocketMq事务消息</p>
<h2 id="Redis扣减库存优化"><a href="#Redis扣减库存优化" class="headerlink" title="Redis扣减库存优化"></a>Redis扣减库存优化</h2><blockquote>
<p>分布式锁，存在锁竞争，一个商品对应一个锁。几百个商品同时秒杀，Redis压力巨大。</p>
</blockquote>
<p><strong>优化方案：</strong> 分布式锁变成本地锁。秒杀服务开始前，由配置中心给每个应用服务实例下发<br>一个库存数胡亮。然后每次下单，每个服务器只管自己的库存数量。与其他应用服务器完全不进行<br>库存同步。在各自的内存里扣减库存，然后定时批量扣减Redis里面的总库存。这样就不会有超卖的问题。减少了网络消耗，性能得到提升。</p>
<p><strong>引入的问题：</strong> 库存扣减不均衡。少卖了。这种情况是可以接受的。解决的方案有：返场。因为有的下单不支付<br>这些也是要加入到库存。</p>
<p>技术都是工具，工具的组合才是解决方法之道！</p>
]]></content>
      <categories>
        <category>seckill</category>
      </categories>
      <tags>
        <tag>全链路</tag>
      </tags>
  </entry>
  <entry>
    <title>【秒杀系统2】设计与实现下</title>
    <url>/2022/11/29/java/distributed/seckill_2/</url>
    <content><![CDATA[<h2 id="秒杀前的流量控制"><a href="#秒杀前的流量控制" class="headerlink" title="秒杀前的流量控制"></a>秒杀前的流量控制</h2><h3 id="预约"><a href="#预约" class="headerlink" title="预约"></a>预约</h3><p>开放预约获得资格后才能参与秒杀。<br>    预约也有高并发所以需要一些设计：</p>
<ol>
<li>预约管理后台。</li>
<li>预约短信和消息提醒。</li>
<li>面向终端的雨夜核心微服务，提供给用户预约和取消资格能力。</li>
<li>详情页在展示时获取预约信息的能力，比如商品是否预约，当前预约人数等等。</li>
<li>秒杀下单时检查预约资格的能力。</li>
<li>核心在两个维度：<ol>
<li>预约活动和用户预约关系。所以需要2张表。预约活动表信息表，记录预约活动本身。预约活动开始和结束时间，<br>预约活动对应的秒杀信息，预约商品信息等。另一张表 用户预约关系表，用户的ID,预约的活动ID，预约商品等。</li>
</ol>
</li>
</ol>
<h3 id="预约系统优化"><a href="#预约系统优化" class="headerlink" title="预约系统优化"></a>预约系统优化</h3><p>用户预约关系表量非常大。方法：</p>
<ol>
<li>分库分表。用户预约关系表，写热点。</li>
<li>前置缓存。预约活动信息，读热点。</li>
</ol>
<p>计算预约量：</p>
<ol>
<li>用redis记录。</li>
<li>本地缓存累加，批量写入redis。</li>
</ol>
<h2 id="秒杀中流量控制-削峰"><a href="#秒杀中流量控制-削峰" class="headerlink" title="秒杀中流量控制-削峰"></a>秒杀中流量控制-削峰</h2><h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>无损削峰：限流技术是有损。<br>有损削峰：验证码，问答题，以及一部消息队列。</p>
<p>加验证码的作用：本来需要0.1秒完成的操作，拉长到10秒或者更长时间。拉长了时间<br>降低的最高的峰值。</p>
<h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><p>异步下单：<br>引入消息队列：kafka,RocketMQ,RabbitMQ</p>
<p>异步支付和订单不一致如何解决？</p>
<p>订单支付页，定时检查秒杀订单是否已经生成！WebSocket 等等。下单查库问题不大，比访问量第很多。</p>
<h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><h2 id="秒杀中的流量控制-限流"><a href="#秒杀中的流量控制-限流" class="headerlink" title="秒杀中的流量控制-限流"></a>秒杀中的流量控制-限流</h2><p>自我保护的直接手段，整个链路都可以进行限流：逐级限流、分层过滤。</p>
<p>常用算法：令牌桶和漏铜。</p>
<p><img src="https://images.lilhui.com/2b1147408ad1ebece871df0d32ae979b" alt="图片"></p>
<h3 id="nginx限流"><a href="#nginx限流" class="headerlink" title="nginx限流"></a>nginx限流</h3><p>HttpLimitZone,HttpLimitRequest<br>HttpLimitZone: 用来限制一个客户端的并发连接数。<br>HttpLimitRequest: 通过漏桶算法进行限制用户的链接频率。</p>
<p><img src="https://images.lilhui.com/b957e25c0046c74e56476b84ba3d032b" alt="图片"></p>
<p>limit_req_zone: 指令名称，关键字，只能在http块中使用。<br>$binary_remote_addr Nginx内置绑定变量，比如$remote_port是指客户端端口号。<br>zone=one：规则名称zai limit_req_zone申明过。<br>burst=2: 制定最大突然请求数，超过这个数目的请求会被延迟。<br>nodelay: 突发请求大于burst时候，立即返回503.不排队了。<br>rate:每秒允许通过的请求，每个IP。<br>zone=one:10m :1M可以支持 16000个链接。 10M就是160000个会话链接。</p>
<h3 id="线程池限流"><a href="#线程池限流" class="headerlink" title="线程池限流"></a>线程池限流</h3><p>Java，Tomcat原生线程池，配置最大连接数，请求处理队列长度以及拒绝策略来达到限流的目的。</p>
<h3 id="API限流"><a href="#API限流" class="headerlink" title="API限流"></a>API限流</h3><p>线程池限流是一种并发限流。并发恒定的情况下，处理速度越快。QPS越高。</p>
<p>大部分情况是根据QPS来限流。可以使用Google的RateLimiter开源包。基于令牌桶的算法实现。</p>
<p>开源的组件Sentinel整合了流量控制、流量整型、流量路由、熔断升级、系统自适应。</p>
<h3 id="自定义限流"><a href="#自定义限流" class="headerlink" title="自定义限流"></a>自定义限流</h3><p>订单的重复下单问题。订单结算也的时候进行判断（生成ID服务）。下单的时候用这个订单来校验下单是否重复。<br>如果高并发回拖慢秒杀的速度，所以需要进行改造：</p>
<ol>
<li>OrderId预生成，放在队列里。缓存在本地。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OrderIdList = <span class="keyword">new</span> ConcurrentLinkedQueue();</span><br><span class="line">OrderItemList = <span class="keyword">new</span> ConcurrentLinkedQueue();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>100毫秒产生200个订单号。所以1秒内只能有2000个订单过来。类似令牌桶限流。更精细的可以控制某个商品的发放速度。</p>
<ol start="2">
<li>商品库存分发到本地。</li>
</ol>
<h2 id="限购、秒杀的库存与降级、热点"><a href="#限购、秒杀的库存与降级、热点" class="headerlink" title="限购、秒杀的库存与降级、热点"></a>限购、秒杀的库存与降级、热点</h2><p>重点问题：</p>
<ol>
<li>库存超卖，库存扣减的热点。</li>
</ol>
<p>在库存服务里解决。</p>
<h3 id="限购"><a href="#限购" class="headerlink" title="限购"></a>限购</h3><p>全部流量不能直接打到库存服务。需要有个系统来承接大流量没并且脂肪商品库存和匹配的请求到库存服务。限购就是这样的角色。<br>限购之于库存，就像秒杀之于下单。欠着都是后者的滤网和保护伞。</p>
<p>限购： 做商品的限制购买。因为参加秒杀活动的商品都是爆品、稀缺品，所以为了让更多的用户参与进来，并让有限的投放量汇集<br>更多的人，所以往往会对商品的售卖做限制，一般限制的维度包括两个方面。</p>
<p><strong>商品维度限购</strong>：每次参加秒杀的活动商品投放量。针对不同地区投放。</p>
<p><strong>个人维度限购</strong>：校验个人是否能购买数量。</p>
<h3 id="库存扣减"><a href="#库存扣减" class="headerlink" title="库存扣减"></a>库存扣减</h3><p>如何不超卖 -&gt; 查询用户库存。</p>
<p>库存扣减必须实现原子性和一致性，如何实现呢？<br>两个操作</p>
<h4 id="利用乐观锁"><a href="#利用乐观锁" class="headerlink" title="利用乐观锁"></a>利用乐观锁</h4><ol>
<li><p>查询库存。<br>乐观锁 version 每次扣减的时候带上这个版本号比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> stock,<span class="keyword">version</span> <span class="keyword">from</span> product <span class="keyword">where</span> <span class="keyword">id</span> = ? ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>扣减库存</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> product <span class="keyword">set</span> stock = stock - ?,<span class="keyword">version</span> = <span class="keyword">version</span> + <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> = ? <span class="keyword">and</span> <span class="keyword">version</span> = ?</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="利用数据库特性"><a href="#利用数据库特性" class="headerlink" title="利用数据库特性"></a>利用数据库特性</h4><p><strong>数据库方案：</strong> 行锁。查询和扣减放在一个事务，for update。事务结束后进行释放锁。<br><strong>通过SQL语句</strong>: where条件，保证库存不会被溅到0以下。</p>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>redis分布式锁可以实现。<br>弊端：需要超时机制。但是有超时机制，又占用时间，与高并发的秒杀系统是相悖的。不建议使用。</p>
<h4 id="高并发扣减"><a href="#高并发扣减" class="headerlink" title="高并发扣减"></a>高并发扣减</h4><p>流量洪峰来临时，TP99指标变差，CPU升高，IO等待边长。系统变得不稳定。需要对非核心服务进行降级，减轻<br>系统负担，这种降级一般是有损的。属于 ‘弃卒保帅’</p>
<p>秒杀的核心问题是解决单个商品搞并发读和写的问题。是典型的热点数据问题。我们需要响应的机制，避免热点数据打垮<br>系统。</p>
<p>Redis库存扣减。宁可少卖，不可超卖。</p>
<p>如何实现：</p>
<ol>
<li>对缓存进行扣减。<br>redis lua eval原子脚本：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local c_s = redis.call(&apos;get&apos;, KEYS[1])</span><br><span class="line">if (not c_s or  tonumber(c_s) &lt; tonumber(KEYS[2]) then</span><br><span class="line">    return 0</span><br><span class="line">end</span><br><span class="line">redis.call(&apos;decrby&apos;,KEYS[1],KEYS[2])</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>下单失败需要还原数量。</p>
<p>问题：Redis挂了怎么办?<br>快速持久化扣减记录，采用WAL机制实现。保存到本地RockDB数据库。</p>
<h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h4><ul>
<li>写服务降级</li>
</ul>
<p>Redis高并发扣减就是一种写降级</p>
<ul>
<li>读服务降级</li>
</ul>
<p>在不影响正常购买的流程中。将一些无关紧要的信息隐藏。完成读降级。<br>例子：</p>
<p>问题：双11时登录后，切换几分钟后需要重新登陆。平时并不用重新登陆。</p>
<p>登录信息缓存失效时间减少。腾出缓存资源。<br><strong>牢记：</strong>微服务资深所依赖的外服中间件或者系统跟本身可用性无关。</p>
<h2 id="秒杀的防刷，风控，容灾"><a href="#秒杀的防刷，风控，容灾" class="headerlink" title="秒杀的防刷，风控，容灾"></a>秒杀的防刷，风控，容灾</h2><h3 id="防刷"><a href="#防刷" class="headerlink" title="防刷"></a>防刷</h3><p>秒杀商品有限，防止黄牛<br>有效流量： 6：1：3</p>
<p>6： 黄牛用户<br>1： 错误用户<br>3： 正常请求  </p>
<p>防刷方法有：</p>
<ol>
<li>Nginx限流机制。限制IP高频访问。</li>
<li>Token机制，用来做鉴权。防止直接访问下单接口。在订单详情页时候获取Token，在下单时候带上原Token并再产生一个Token,每个环节进行校验。保证用户的操作是连续的。<br> 例子：在header_filter_by_lua_block 返回 的header里增加流程Token</li>
</ol>
<h3 id="风控"><a href="#风控" class="headerlink" title="风控"></a>风控</h3><p>如果已经有风控系统，可以拿到黑名单列表。进行封闭。</p>
<h3 id="容灾"><a href="#容灾" class="headerlink" title="容灾"></a>容灾</h3><p>防天灾，机房容灾。</p>
<p>异地双活：跨城市备份。有物理时延比较难实现。（招行实现）<br>同城双活：同城双活，物理距离比价近，延迟低。同城机房，同事承担部分流量。主机房承担写，部分读，备份机房部分读。</p>
]]></content>
      <categories>
        <category>seckill</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title>【秒杀系统4】订单链路兜底方案，限流和熔断降级</title>
    <url>/2022/11/30/java/distributed/seckill_4/</url>
    <content><![CDATA[<h2 id="高并发场景下实现系统稳定运行"><a href="#高并发场景下实现系统稳定运行" class="headerlink" title="高并发场景下实现系统稳定运行"></a>高并发场景下实现系统稳定运行</h2><h2 id="微服务网关常见限流方案"><a href="#微服务网关常见限流方案" class="headerlink" title="微服务网关常见限流方案"></a>微服务网关常见限流方案</h2><p>客户端限流</p>
<p>服务端限流</p>
<p>网关限流</p>
<p>应用层限流</p>
<h3 id="微服务网关限流"><a href="#微服务网关限流" class="headerlink" title="微服务网关限流"></a>微服务网关限流</h3><p>详情页入口流量保护，黑订单，限制一个IP访问频率。</p>
<h4 id="基于Redis-Lua的脚本限流"><a href="#基于Redis-Lua的脚本限流" class="headerlink" title="基于Redis + Lua的脚本限流"></a>基于Redis + Lua的脚本限流</h4><p>RequestRateLimiter过滤工厂。算法：令牌桶。</p>
<p>初始化令牌数量。每次请求过来获取一个令牌，请求完成后，令牌返回桶。</p>
<h4 id="网关整合-Sentinel-Route-amp-API维度限流"><a href="#网关整合-Sentinel-Route-amp-API维度限流" class="headerlink" title="网关整合 Sentinel Route &amp; API维度限流"></a>网关整合 Sentinel Route &amp; API维度限流</h4><p>主要功能：<br>根据API流控，根据热点参数进行流控。</p>
<p>流控规则配置在Sentinel后台，分发到网关各节点。网关加入Sentinel jar包。<br>在接受请求时候，通过SlotChain记录并计算流控的结果。</p>
<h2 id="Sentinel-生产环境引入"><a href="#Sentinel-生产环境引入" class="headerlink" title="Sentinel 生产环境引入"></a>Sentinel 生产环境引入</h2><ul>
<li>2个维度</li>
</ul>
<ol>
<li>API维度。api流控。</li>
<li>Route维度。整个为服务进行流控</li>
</ol>
<ul>
<li>持久化<br>改造Senitnel支持Nacos持久化。规则从nacos分发到微服务网关。</li>
</ul>
<h2 id="下单引入Sentinel熔断"><a href="#下单引入Sentinel熔断" class="headerlink" title="下单引入Sentinel熔断"></a>下单引入Sentinel熔断</h2><ol>
<li>秒杀确认页，配置排队等待。匀速器设置。</li>
<li>热点参数限流。进行流控。<ol>
<li>商品ID进行流控。</li>
<li>用户ID为参数，针对一段时间频繁访问的用户ID进行限制。</li>
</ol>
</li>
</ol>
<p>PS:<br>热点参数规则需要使用@SentinalResource(“resourceName”)进行注解。<br>参数必须是7中基本数据类型才行。</p>
<h2 id="电商系统自适应保护方案"><a href="#电商系统自适应保护方案" class="headerlink" title="电商系统自适应保护方案"></a>电商系统自适应保护方案</h2><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>系统容量达到一定程度时，限制或者关闭系统的某些非核心功能。把有限的资源保留给核心业务。<br>降级方案例子：</p>
<ol>
<li>当秒杀流量达到5w/s时，把成交记录的获取从展示20条降级到只展示5条。从20 到5，通过开关来配置实现。<br>降级的核心目标是，牺牲次要的功能和用户体验来保证核心业务流程的稳定。不得已为之的举措。例如：在双11时如果优惠券<br>系统扛不住，可能会临时降级商品详情的优惠券信息展示。把有限的资源用在保障交易系统正确展示优惠信息上。既保证用户<br>整整下单时的价格是正确的。</li>
</ol>
<h4 id="服务降级的策略"><a href="#服务降级的策略" class="headerlink" title="服务降级的策略"></a>服务降级的策略</h4><p><img src="https://images.lilhui.com/b2c1ecaebba2d0509d9f167867db4b98" alt="图片"></p>
<h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3><p>对返回失败的借口，或者借口请求返回慢的。进行降级熔断。直接返回。不请求到后端服务。降低服务端的压力。</p>
]]></content>
      <categories>
        <category>seckill</category>
      </categories>
      <tags>
        <tag>限流，熔断</tag>
      </tags>
  </entry>
  <entry>
    <title>【Dubbo源码系列2】基础应用和高级应用</title>
    <url>/2022/02/10/java/dubbo/dubbo_2/</url>
    <content><![CDATA[<h3 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h3><p>提供诸如：<br><a href="http://ip:port/servicerName+group+version" target="_blank" rel="noopener">http://ip:port/servicerName+group+version</a><br>dubbo://ip:port/serviceName+group+version  </p>
<p>作为唯一识别码的不同服务。<br>Dubbo使用可以指定 协议，IP，端口</p>
<ul>
<li>负载均衡，集群容错，服务降级</li>
<li>本地存根，本地伪装，参数回调</li>
<li>异步调用，泛化调用，动态配置</li>
<li>管理台，动态配置，服务路由</li>
</ul>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><ul>
<li>Random LoadBalance<br>随机</li>
<li>RoundRobin LoadBalance<br>轮询</li>
<li>LastActiveLoadBalance<br>最少活跃</li>
<li>ConsistentHash LoadBalance<br>一致性hash</li>
</ul>
]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>泛化调用</tag>
      </tags>
  </entry>
  <entry>
    <title>【Dubbo源码系列1】框架介绍</title>
    <url>/2022/01/14/java/dubbo/dubbo_1/</url>
    <content><![CDATA[<h2 id="Dubbo框架介绍"><a href="#Dubbo框架介绍" class="headerlink" title="Dubbo框架介绍"></a>Dubbo框架介绍</h2><ol>
<li>方法名</li>
<li>参数类型列表</li>
<li>入参</li>
<li>类</li>
<li>version</li>
</ol>
<p>RPC：通信协议，数据传输上层的一种协议。用于完成远程方法调用。</p>
<p>RPC over http协议传输<br>RPC over tcp传输</p>
<ul>
<li>消费端：</li>
</ul>
<ol>
<li>组织协议</li>
<li>序列化</li>
<li>调用netty传输</li>
</ol>
<ul>
<li>服务端：</li>
</ul>
<ol>
<li>接收并反序列化</li>
<li>invoke调用实现方法</li>
<li>获取结果，组织协议，序列化</li>
<li>调用netty传输</li>
</ol>
<p><img src="https://images.lilhui.com/b1834ce26273be087e101a81b7d5ec4d" alt="图片"></p>
]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>SPI</tag>
      </tags>
  </entry>
  <entry>
    <title>【Dubbo源码系列5】Duboo 服务引入</title>
    <url>/2022/02/18/java/dubbo/dubbo_5/</url>
    <content><![CDATA[<h2 id="Dubbo服务引入源码分析"><a href="#Dubbo服务引入源码分析" class="headerlink" title="Dubbo服务引入源码分析"></a>Dubbo服务引入源码分析</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol>
<li>服务引入原理解析</li>
<li>路由链源码解析</li>
<li>服务静态目录与动态目录源码解析</li>
<li>服务引入源码解析</li>
</ol>
<h3 id="服务引入原理"><a href="#服务引入原理" class="headerlink" title="服务引入原理"></a>服务引入原理</h3><p>当Spring启动过程中，会去给@Reference注解标注了的属性去进行赋值，赋值的对象为ReferenceBean中get()方法所返回的对象，这个对象是一个代理对象。<br>对于ReferenceBean，它表示应用想要引入的服务的信息，在执行get()时会做如下几步：</p>
<ol>
<li>调用checkAndUpdateSubConfigs()，检查和更新参数，和服务提供者类似，把ReferenceBean里的属性的值更新为优先级最高的参数值</li>
<li>调用init()去生成代理对象ref，get()方法会返回这个ref</li>
<li>在生成代理对象ref之前，先把消费者所引入服务设置的参数添加到一个map中，等会根据这个map中的参数去从注册中心查找服务</li>
<li>把消费者配置的所有注册中心获取出来<br>a. 如果只有一个注册中心，那么直接调用Protocol的refer(interfaceClass, urls.get(0));得到一个Invoker对象<br>b. 如果有多个注册中心，则遍历每个注册中心，分别调用Protocol的refer(interfaceClass, url);得到一个Invoker对象添加到invokers中，然后把invokers调用CLUSTER.join(new StaticDirectory(u, invokers));封装所有invokers得到一个invoker，</li>
<li>把最终得到的invoker对象调用PROXY_FACTORY.getProxy(invoker);得到一个代理对象，并返回，这个代理对象就是ref</li>
<li>总结：上文的Invoker对象，表示服务执行者，从注册中心refer下来的是一个服务执行者，合并invokers后得到的invoker也是一个服务执行者（抽象范围更大了）</li>
</ol>
<p>接下来，来看Protorol.refer(interfaceClass, url)方法是怎么生成一个Invoker的</p>
<ol>
<li>首先interfaceClass表示要引入的服务接口，url是注册中心的url（registry://），该url中有一个refer参数，参数值为当前所要引入服务的参数</li>
<li>调用doRefer(cluster, registry, type, url)</li>
<li>在doRefer方法中会生成一个RegistryDirectory</li>
<li>然后获取新版本中的路由器链，并添加到RegistryDirectory中去</li>
<li>RegistryDirectory监听几个目录（注意，完成监听器的订阅绑定后，会自动触发一次去获取这些目录上的当前数据）<br>a. 当前所引入的服务的动态配置目录：/dubbo/config/dubbo/org.apache.dubbo.demo.DemoService:1.1.1:g1.configurators<br>b. 当前所引入的服务的提供者目录：/dubbo/org.apache.dubbo.demo.DemoService/providers<br>c. 当前所引入的服务的老版本动态配置目录：/dubbo/org.apache.dubbo.demo.DemoService/configurators<br>d. 当前所引入的服务的老版本路由器目录：/dubbo/org.apache.dubbo.demo.DemoService/routers</li>
<li>调用cluster.join(directory)得到一个invoker</li>
<li>返回invoker（如果消费者引入了多个group中的服务，那么这里返回的是new MergeableClusterInvoker<t>(directory);，否则返回的是new FailoverClusterInvoker<t>(directory);）</t></t></li>
<li>但是，上面返回的两个Invoker都会被MockClusterInvoker包装，所以最终返回的是MockClusterInvoker。</li>
</ol>
<ol>
<li>获取服务提供者列表</li>
<li>Mock</li>
<li>路由 M–&gt;N</li>
<li>负载均衡 N—&gt;1</li>
<li>集群容错</li>
<li>构造NettyClient</li>
<li>发送数据</li>
</ol>
<h2 id="服务引入"><a href="#服务引入" class="headerlink" title="服务引入"></a>服务引入</h2><ol>
<li>构造Invoker</li>
<li>DemoService 服务目录。当前服务的提供者列表 List<invoker> 实际上是 List<dubboinvoker><ol>
<li>构造一个服务目录的时候要到注册中心查看</li>
<li>多少个提供者 List<invoker>就多少个 List<dubboinvoker></dubboinvoker></invoker></li>
<li>监听 当前服务对应的节点</li>
<li>路由 TagRouter–&gt;AppRouter–&gt;ServiceRouter<br>本质上是构造一个代理对象。代理对象最重要的是Invoker</li>
</ol>
</dubboinvoker></invoker></li>
</ol>
<p>代理对象逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代理对象.a() &#123;</span><br><span class="line">    invoker.invoke(Invocation)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代理对象<br>  Invoker invoker 有这个就行了。</li>
<li>Invoker<br>MockClusterInvoker.invoke()<br>  FailoverClusterInvoker.invoke()<pre><code>DubboInvoker.invoke()
</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>服务引入</tag>
      </tags>
  </entry>
  <entry>
    <title>【流量控制系列1】引言和索引</title>
    <url>/2019/07/29/java/flowcontroller/flowcontroller_1/</url>
    <content><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ol>
<li>自底向上构建流量控制知识体系。在后面遇到流量控制相关问题，可以举一反三快速得到解决方案。</li>
<li>对sentinel流控产品有一定的了解，在使用的时候能够快速入手，并且根据具体业务场景开发和扩展。</li>
</ol>
<h2 id="流量控制背景"><a href="#流量控制背景" class="headerlink" title="流量控制背景"></a>流量控制背景</h2><p>在平时的正常的访问流量下，系统可以正常运行，但是当遇到热点事件，流量突然间增大的情况下。但是预估值和真实的访问量可能会有很大的出入，流量是不能准确估算的，所以要对我们的系统制定应急预案，防范流量突然暴涨的情况下我们的系统被压垮。</p>
<h3 id="应用的场景"><a href="#应用的场景" class="headerlink" title="应用的场景"></a>应用的场景</h3><ol>
<li>秒杀活动。</li>
<li>高并发流量控制。</li>
<li>一些需要提高服务稳定性的场景。</li>
</ol>
<h2 id="文档索引"><a href="#文档索引" class="headerlink" title="文档索引"></a>文档索引</h2><p><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_1/">【流量控制系列1】引言和索引</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_2/">【流量控制系列2】流量控制的基础方法和算法</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_3/">【流量控制系列3】Semaphore信号量介绍</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_4/">【流量控制系列4】Sentinel和Hystrix对比</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_5/">【流量控制系列5】Sentinel 详细介绍</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_6/">【流量控制系列6】Sentinel 详细介绍-SlotChain源码解析</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_7/">【流量控制系列7】Sentinel实践</a>  </p>
]]></content>
      <categories>
        <category>java</category>
        <category>流量控制</category>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>限流</tag>
        <tag>Sentinel</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>【Dubbo源码系列6】Duboo 服务调用源码解析</title>
    <url>/2022/03/03/java/dubbo/dubbo_6/</url>
    <content><![CDATA[<h2 id="服务消费端执行逻辑"><a href="#服务消费端执行逻辑" class="headerlink" title="服务消费端执行逻辑"></a>服务消费端执行逻辑</h2><ol>
<li>nvoker.invoke(new RpcInvocation(method, args))：Mock逻辑</li>
<li>AbstractClusterInvoker.invoke(invocation)：把RpcContext中设置的Attachments添加到invocation对象上，调用路由链从服务目录上筛选出适合的服务Invoker，获得服务均衡策略loadbalance</li>
<li>FailoverClusterInvoker.doInvoke(invocation, invokers, loadbalance)：根据负载均衡策略选出一个invoker，然后执行</li>
<li>InvokerWrapper.invoke(invocation)：没做什么事情</li>
<li>CallbackRegistrationInvoker.invoke(invocation)：开始执行Filter链，执行完得到结果后，会获取ListenableFilter中的listener，执行listener的onResponse方法</li>
<li>ConsumerContextFilter.invoke(invocation)：设置RpcContext中LocalAddress、RemoteAddress、RemoteApplicationName参数</li>
<li>FutureFilter.invoke(invocation)：</li>
<li>MonitorFilter.invoke(invocation)：方法的执行次数+1</li>
<li>ListenerInvokerWrapper.invoke(invocation)：没做什么事情</li>
<li>AsyncToSyncInvoker.invoke(invocation)：异步转同步，会先用下层Invoker去异步执行，然后阻塞Integer.MAX_VALUE时间，直到拿到了结果</li>
<li>AbstractInvoker.invoke(invocation)：主要调用DubboInvoker的doInvoke方法，如果doInvoker方法出现了异常，会进行包装，包装成AsyncRpcResult</li>
<li>DubboInvoker.doInvoke(invocation)：从clients轮询出一个client进行数据发送，如果配置了不关心结果，则调用ReferenceCountExchangeClient的send方法，否则调用ReferenceCountExchangeClient的request方法</li>
<li>ReferenceCountExchangeClient.request(Object request, int timeout)：没做什么事情</li>
<li>HeaderExchangeClient.request(Object request, int timeout)：没做什么事情</li>
<li>HeaderExchangeChannel.request(Object request, int timeout)：构造一个Request对象，并且会构造一个DefaultFuture对象来阻塞timeout的时间来等待结果，在构造DefaultFuture对象时，会把DefaultFuture对象和req的id存入FUTURES中，FUTURES是一个Map，当HeaderExchangeHandler接收到结果时，会从这个Map中根据id获取到DefaultFuture对象，然后返回Response。</li>
<li>AbstractPeer.send(Object message)：从url中获取send参数，默认为false</li>
<li>AbstractClient.send(Object message, boolean sent)：没做什么</li>
<li>NettyChannel.send(Object message, boolean sent)：调用NioSocketChannel的writeAndFlush发送数据，然后判断send如果是true，那么则阻塞url中指定的timeout时间，因为如果send是false，在HeaderExchangeChannel中会阻塞timeout时间</li>
<li>NioSocketChannel.writeAndFlush(Object msg)：最底层的Netty非阻塞式的发送数据</li>
</ol>
<h2 id="总结流程"><a href="#总结流程" class="headerlink" title="总结流程"></a>总结流程</h2><ol>
<li>最外层是Mock逻辑，调用前，调用后进行Mock</li>
<li>从服务目录中，根据当前调用的方法和路由链，筛选出部分服务Invoker（DubboInvoker）</li>
<li>对服务Invoker进行负载均衡，选出一个服务Invoker</li>
<li>执行Filter链</li>
<li>AsyncToSyncInvoker完成异步转同步，因为DubboInvoker的执行是异步非阻塞的，所以如果是同步调用，则会在此处阻塞，知道拿到响应结果</li>
<li>DubboInvoker开始异步非阻塞的调用</li>
<li>HeaderExchangeChannel中会阻塞timeout的时间来等待结果，该timeout就是用户在消费端所配置的timeout</li>
</ol>
<h2 id="服务提供端执行逻辑"><a href="#服务提供端执行逻辑" class="headerlink" title="服务提供端执行逻辑"></a>服务提供端执行逻辑</h2><ol>
<li>NettyServerHandler：接收数据</li>
<li>MultiMessageHandler：判断接收到的数据是否是MultiMessage，如果是则获取MultiMessage中的单个Message，传递给HeartbeatHandler进行处理</li>
<li>HeartbeatHandler：判断是不是心跳消息，如果是不是则把Message传递给AllChannelHandler</li>
<li>AllChannelHandler：把接收到的Message封装为一个ChannelEventRunnable对象，扔给线程池进行处理</li>
<li>ChannelEventRunnable：在ChannelEventRunnable的run方法中会调用DecodeHandler处理Message</li>
<li>DecodeHandler：按Dubbo协议的数据格式，解析当前请求的path，versio，方法，方法参数等等，然后把解析好了的请求交给HeaderExchangeHandler</li>
<li>HeaderExchangeHandler：处理Request数据，首先构造一个Response对象，然后调用ExchangeHandlerAdapter得到一个CompletionStage future，然后给future通过whenComplete绑定一个回调函数，当future执行完了之后，就可以从回调函数中得到ExchangeHandlerAdapter的执行结果，并把执行结果设置给Response对象，通过channel发送出去。</li>
<li>ExchangeHandlerAdapter：从本机已经导出的Exporter中根据当前Request所对应的服务key，去寻找Exporter对象，从Exporter中得到Invoker，然后执行invoke方法，此Invoker为ProtocolFilterWrapper$CallbackRegistrationInvoker</li>
<li>ProtocolFilterWrapper$CallbackRegistrationInvoker：负责执行过滤器链，并且在执行完了之后回调每个过滤器的onResponse或onError方法</li>
<li>EchoFilter：判断当前请求是不是一个回升测试，如果是，则不继续执行过滤器链了（服务实现者Invoker也不会调用了）</li>
<li>ClassLoaderFilter：设置当前线程的classloader为当前要执行的服务接口所对应的classloader</li>
<li>GenericFilter：把泛化调用发送过来的信息包装为RpcInvocation对象</li>
<li>ContextFilter：设置RpcContext.getContext()的参数</li>
<li>TraceFilter：先执行下一个invoker的invoke方法，调用成功后录调用信息</li>
<li>TimeoutFilter：调用时没有特别处理，只是记录了一下当前时间，当整个filter链都执行完了之后回调TimeoutFilter的onResponse方法时，会判断本次调用是否超过了timeout</li>
<li>MonitorFilter：记录当前服务的执行次数</li>
<li>ExceptionFilter：调用时没有特别处理，在回调onResponse方法时，对不同的异常进行处理，详解Dubbo的异常处理</li>
<li>DelegateProviderMetaDataInvoker：过滤器链结束，调用下一个Invoker</li>
<li>AbstractProxyInvoker：在服务导出时，根据服务接口，服务实现类对象生成的，它的invoke方法就会执行服务实现类对象的方法，得到结果</li>
</ol>
<h2 id="Dubbo的异常处理"><a href="#Dubbo的异常处理" class="headerlink" title="Dubbo的异常处理"></a>Dubbo的异常处理</h2><p>当服务消费者在调用一个服务时，服务提供者在执行服务逻辑时可能会出现异常，对于Dubbo来说，服务消费者需要在消费端抛出这个异常，那么这个功能是怎么做到的呢？<br>服务提供者在执行服务时，如果出现了异常，那么框架会把异常捕获，捕获异常的逻辑在AbstractProxyInvoker中，捕获到异常后，会把异常信息包装为正常的AppResponse对象，只是AppResponse的value属性没有值，exception属性有值。<br>此后，服务提供者会把这个AppResponse对象发送给服务消费端，服务消费端是在InvokerInvocationHandler中调用AppResponse的recreate方法重新得到一个结果，在recreate方法中会去失败AppResponse对象是否正常，也就是是否存在exception信息，如果存在，则直接throw这个exception，从而做到服务执行时出现的异常，在服务消费端抛出。<br>那么这里存在一个问题，如果服务提供者抛出的异常类，在服务消费者这边不存在，那么服务消费者也就抛不出这个异常了，那么dubbo是怎么处理的呢？<br>这里就涉及到了ExceptionFilter，它是服务提供者端的一个过滤器，它主要是在服务提供者执行完服务后会去识别异常：</p>
<ol>
<li>如果是需要开发人员捕获的异常，那么忽略，直接把这个异常返回给消费者</li>
<li>如果在当前所执行的方法签名上有声明，那么忽略，直接把这个异常返回给消费者</li>
<li>如果抛出的异常不需要开发人员捕获，或者方法上没有申明，那么服务端或记录一个error日志</li>
<li>异常类和接口类在同一jar包里，那么忽略，直接把这个异常返回给消费者</li>
<li>如果异常类是JDK自带的异常，那么忽略，直接把这个异常返回给消费者</li>
<li>如果异常类是Dubbo自带的异常，那么忽略，直接把这个异常返回给消费者</li>
<li>否则，把异常信息包装成RuntimeException，并覆盖AppResponse对象中的exception属性</li>
</ol>
]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>服务调用</tag>
      </tags>
  </entry>
  <entry>
    <title>【流量控制系列2】流量控制的基础方法和算法</title>
    <url>/2019/07/29/java/flowcontroller/flowcontroller_2/</url>
    <content><![CDATA[<h3 id="流量控制的方法"><a href="#流量控制的方法" class="headerlink" title="流量控制的方法"></a>流量控制的方法</h3><h4 id="白名单机制："><a href="#白名单机制：" class="headerlink" title="白名单机制："></a>白名单机制：</h4><blockquote>
<p>可以采用白名单的机制来限制访问，没有加入白名单的用户不让访问系统</p>
</blockquote>
<h4 id="令牌池机制也叫令牌桶"><a href="#令牌池机制也叫令牌桶" class="headerlink" title="令牌池机制也叫令牌桶"></a>令牌池机制也叫令牌桶</h4><blockquote>
<p>用户访问系统必须获得令牌池中的令牌，才能进行访问。令牌池每秒钟，阀门开启一次，所有的请求去令牌池中并发的抢夺令牌，获得令牌的可以访问系统，没有获得的返回“系统正忙”或者让该请求加入队列然后重试（注意：这里是一个坑，不能让请求加入到队列中，因为加入队列后会带来很大的问题，访问的请求底层是一个socket连接，我们不知道要过多长时间才能获得访问，hold住这个socket连接要耗费系统的资源，如果保存的请求量比较大的，系统的load会非常的高，会带来很大的系统负载压力。最好的方法是让直接拒绝掉访问的请求，返回给用户，让用户重试，重新访问）。<br>可以通过控制令牌池中令牌的数量来控制访问，当一个请求访问获得令牌时令牌池中的令牌数量减一，当访问结束后要把令牌还回到令牌池中，令牌数量加一。</p>
</blockquote>
<ul>
<li>限QPS</li>
</ul>
<p>阀门每秒开启一次，开启后重新初始化令牌池根据初始化的令牌数量限制每秒能够进行的请求数量，取了令牌后不用归还。</p>
<p><img src="https://images.lilhui.com/b438e96ee0339527c3e28317433bb6bc" alt="图片"></p>
<ul>
<li>限并发</li>
</ul>
<p>限制同一时间的请求只能敷在多少。他的令牌池是固定的，直接限制并发，取令牌进行访问，访问结束后归还令牌。</p>
<p><img src="https://images.lilhui.com/222da3c295fd9995acc4867ac2b4f293" alt="图片"></p>
<h4 id="简单的实现实例：java信号量实现方式"><a href="#简单的实现实例：java信号量实现方式" class="headerlink" title="简单的实现实例：java信号量实现方式"></a>简单的实现实例：java信号量实现方式</h4><p><img src="https://images.lilhui.com/7ae0a1644c6f97baf66c46f9d01b81af" alt="图片"></p>
<h4 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h4><p>每个接口限定一个固定的处理请求能力，相当于一个固定的桶能承载的最大的水的容量，而这个桶的大小就是最多能处理的请求并发数能力，然后每处理完一个请求，那么漏桶里面的水就会漏出去一些，如果请求来的时候，漏桶已达到承载极限（水装满了），这时就是请求速度大于处理速度并且堆积的请求太多了的情况。最终漏桶的水将会溢出，就相当于拒绝了请求。</p>
<p><img src="https://images.lilhui.com/15dad5774f62c8859971d923dc663eda" alt="图片"></p>
<p>漏斗有一个进水口 和 一个出水口，出水口以一定速率出水，并且有一个最大出水速率：</p>
<p>在漏斗中没有水的时候，</p>
<ul>
<li>如果进水速率小于等于最大出水速率，那么，出水速率等于进水速率，此时，不会积水</li>
<li>如果进水速率大于最大出水速率，那么，漏斗以最大速率出水，此时，多余的水会积在漏斗中</li>
</ul>
<p>在漏斗中有水的时候</p>
<ul>
<li>出水口以最大速率出水</li>
<li>如果漏斗未满，且有进水的话，那么这些水会积在漏斗中</li>
<li>如果漏斗已满，且有进水的话，那么这些水会溢出到漏斗之外</li>
</ul>
<h4 id="漏桶与令牌桶的比较"><a href="#漏桶与令牌桶的比较" class="headerlink" title="漏桶与令牌桶的比较"></a>漏桶与令牌桶的比较</h4><p>漏桶的出水速度是恒定的，那么意味着如果瞬时大流量的话，将有大部分请求被丢弃掉（也就是所谓的溢出）。</p>
<p>令牌桶来说，<br>生成令牌的速度是恒定的，而请求去拿令牌是没有速度限制的。这意味，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌，而且拿令牌的过程并不是消耗很大的事情。</p>
<h2 id="文档索引"><a href="#文档索引" class="headerlink" title="文档索引"></a>文档索引</h2><p><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_1/">【流量控制系列1】引言和索引</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_2/">【流量控制系列2】流量控制的基础方法和算法</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_3/">【流量控制系列3】Semaphore信号量介绍</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_4/">【流量控制系列4】Sentinel和Hystrix对比</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_5/">【流量控制系列5】Sentinel 详细介绍</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_6/">【流量控制系列6】Sentinel 详细介绍-SlotChain源码解析</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_7/">【流量控制系列7】Sentinel实践</a>  </p>
]]></content>
      <categories>
        <category>java</category>
        <category>流量控制</category>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>限流</tag>
        <tag>Sentinel</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>【流量控制系列3】Semaphore信号量介绍</title>
    <url>/2019/07/29/java/flowcontroller/flowcontroller_3/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Semaphore当前在多线程环境下被扩放使用，操作系统的信号量是个很重要的概念，在进程控制方面都有应用。Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。比如在Windows下可以设置共享文件的最大客户端访问个数。 </p>
<h2 id="实现原理和规则"><a href="#实现原理和规则" class="headerlink" title="实现原理和规则"></a>实现原理和规则</h2><p>Semaphore实现的功能就类似厕所有5个坑，假如有10个人要上厕所，那么同时只能有多少个人去上厕所呢？同时只能有5个人能够占用，当5个人中 的任何一个人让开后，其中等待的另外5个人中又有一个人可以占用了。另外等待的5个人中可以是随机获得优先机会，也可以是按照先来后到的顺序获得机会，这取决于构造Semaphore对象时传入的参数选项。单个信号量的Semaphore对象可以实现互斥锁的功能，并且可以是由一个线程获得了“锁”，再由另一个线程释放“锁”，这可应用于死锁恢复的一些场合。</p>
<p>Semaphore维护了当前访问的个数，提供同步机制，控制同时访问的个数。在数据结构中链表可以保存“无限”的节点，用Semaphore可以实现有限大小的链表。另外重入锁 ReentrantLock 也可以实现该功能，但实现上要复杂些。 </p>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>下面的Demo中申明了一个只有5个许可的Semaphore，而有20个线程要访问这个资源，通过acquire()和release()获取和释放访问许可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphore</span> </span>&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 线程池</span></span><br><span class="line">                ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">                <span class="comment">//只能5个线程同时访问</span></span><br><span class="line">                <span class="keyword">final</span> Semaphore semp = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">                <span class="comment">//模拟20个客户端访问</span></span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">20</span>; index++) &#123;</span><br><span class="line">                              <span class="keyword">final</span> <span class="keyword">int</span> NO = index;</span><br><span class="line">                              Runnable run = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                                                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                                                    <span class="comment">// 获取许可</span></span><br><span class="line">                                                                    semp.acquire();</span><br><span class="line">                                                                    System.out.println(<span class="string">"Accessing: "</span> + NO);</span><br><span class="line">                                                                    Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">                                                                    <span class="comment">// 访问完后，释放</span></span><br><span class="line">                                                                    semp.release();</span><br><span class="line">                                                                    System.out.println(<span class="string">"-----------------"</span>+semp.availablePermits());</span><br><span class="line"></span><br><span class="line">                                                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                                                  e.printStackTrace();</span><br><span class="line">                                                            &#125;</span><br><span class="line"></span><br><span class="line">                                                  &#125;</span><br><span class="line">                                      &#125;;</span><br><span class="line">                      exec.execute(run);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 退出线程池</span></span><br><span class="line">             exec.shutdown();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文档索引"><a href="#文档索引" class="headerlink" title="文档索引"></a>文档索引</h2><p><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_1/">【流量控制系列1】引言和索引</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_2/">【流量控制系列2】流量控制的基础方法和算法</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_3/">【流量控制系列3】Semaphore信号量介绍</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_4/">【流量控制系列4】Sentinel和Hystrix对比</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_5/">【流量控制系列5】Sentinel 详细介绍</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_6/">【流量控制系列6】Sentinel 详细介绍-SlotChain源码解析</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_7/">【流量控制系列7】Sentinel实践</a>  </p>
]]></content>
      <categories>
        <category>java</category>
        <category>流量控制</category>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>限流</tag>
        <tag>Sentinel</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>【流量控制系列4】Sentinel和Hystrix对比</title>
    <url>/2019/07/29/java/flowcontroller/flowcontroller_4/</url>
    <content><![CDATA[<h2 id="Sentinel和hystrix对比"><a href="#Sentinel和hystrix对比" class="headerlink" title="Sentinel和hystrix对比"></a>Sentinel和hystrix对比</h2><ul>
<li><p>Hystrix侧重点</p>
<ul>
<li>隔离熔断为主的容错机制</li>
</ul>
</li>
<li><p>sentinel侧重点S</p>
<ul>
<li>多样化的流量控制</li>
<li>熔断降级</li>
<li>系统负载保护</li>
<li>实时监控和控制台</li>
</ul>
</li>
<li><p>共同特征</p>
<ul>
<li>资源类型和执行模型</li>
</ul>
</li>
</ul>
<h2 id="sentinel的特色"><a href="#sentinel的特色" class="headerlink" title="sentinel的特色"></a>sentinel的特色</h2><pre><code>1. 轻量，高性能
2. 流量控制
3. 负载保护
4. 实时监控和控制面板
5. 生态
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>对比项</th>
<th>Sentinel</th>
<th>Hystrix</th>
</tr>
</thead>
<tbody>
<tr>
<td>隔离策略</td>
<td>信号量隔离</td>
<td>线程池隔离/信号量隔离</td>
</tr>
<tr>
<td>熔断降级策略</td>
<td>基于响应实践活动失败比率</td>
<td>基于失败比率</td>
</tr>
<tr>
<td>实时指标实现</td>
<td>滑动窗口</td>
<td>滑动窗口（基于RxJava)</td>
</tr>
<tr>
<td>规则配置</td>
<td>支持多种数据源</td>
<td>支持多种数据源</td>
</tr>
<tr>
<td>扩展性</td>
<td>多个扩展点</td>
<td>插件的形式</td>
</tr>
<tr>
<td>基于注解的支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>限流</td>
<td>基于QPS,支持基于调用关系的限流</td>
<td>有限的支持</td>
</tr>
<tr>
<td>流量整型</td>
<td>支持慢启动、匀速器模式</td>
<td>不支持</td>
</tr>
<tr>
<td>负载均衡保护</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>控制台</td>
<td>开箱即用，可配置规则、查看秒级监控、机器发现等</td>
<td>不完善</td>
</tr>
<tr>
<td>常见的框架适配</td>
<td>Servlet,Spring Cloud,Dubbo,gRPC等</td>
<td>Servlet,Spring Cloud Netflix</td>
</tr>
<tr>
<td>开源否</td>
<td>开源</td>
<td>半开源</td>
</tr>
</tbody>
</table>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>从产品层面来看，sentinel提供了更为丰富的功能和控制入口。更容易实现项目级的扩展。Hystrix的功能更偏向线程、信号量的隔离，作为插件的方式集成在服务中会比较适合，更偏向包级扩展。<br>  所以在这里建议：</p>
<ul>
<li>在单纯的流量控制需求下，建议使用sentinel  </li>
<li>在需求到线程池隔离的功能下使用Hystrix </li>
</ul>
<h2 id="文档索引"><a href="#文档索引" class="headerlink" title="文档索引"></a>文档索引</h2><p><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_1/">【流量控制系列1】引言和索引</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_2/">【流量控制系列2】流量控制的基础方法和算法</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_3/">【流量控制系列3】Semaphore信号量介绍</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_4/">【流量控制系列4】Sentinel和Hystrix对比</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_5/">【流量控制系列5】Sentinel 详细介绍</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_6/">【流量控制系列6】Sentinel 详细介绍-SlotChain源码解析</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_7/">【流量控制系列7】Sentinel实践</a>  </p>
]]></content>
      <categories>
        <category>java</category>
        <category>流量控制</category>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>限流</tag>
        <tag>Sentinel</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>【Dubbo源码系列4】Duboo 服务导出</title>
    <url>/2022/02/18/java/dubbo/dubbo_4/</url>
    <content><![CDATA[<h2 id="Dubbo服务导出源码解析"><a href="#Dubbo服务导出源码解析" class="headerlink" title="Dubbo服务导出源码解析"></a>Dubbo服务导出源码解析</h2><p>服务导出流程 </p>
<ol>
<li>读取配置(端口，协议，loadbalance，注册中心)</li>
<li>启动netty,tomcat</li>
<li>服务注册 -&gt; 服务信息 -&gt; 注册中心</li>
<li>服务提供者，监听动态配置</li>
</ol>
<ol start="2">
<li>服务注册<br>围绕URL + SPI</li>
</ol>
<p>export -&gt; doRegister<br>构造URL剔除冗余 信息，调用注册中心的接口保存到注册中心。</p>
<p>注册中心URL-&gt;服务URL-&gt;简化-&gt;注册</p>
]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>服务导出</tag>
      </tags>
  </entry>
  <entry>
    <title>【流量控制系列5】Sentinal 详细介绍</title>
    <url>/2019/07/29/java/flowcontroller/flowcontroller_5/</url>
    <content><![CDATA[<h2 id="Sentinal-详细介绍"><a href="#Sentinal-详细介绍" class="headerlink" title="Sentinal 详细介绍"></a>Sentinal 详细介绍</h2><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>2012 年，Sentinel 诞生，主要功能为入口流量控制。<br>2013-2017 年，Sentinel 在阿里巴巴集团内部迅速发展，成为基础技术模块，覆盖了所有的核心场景。Sentinel 也因此积累了大量的流量归整场景以及生产实践。<br>2018 年，Sentinel 开源。</p>
<p>现在的版本1.6.1</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>功能组成:</p>
<p><img src="https://images.lilhui.com/9ca7d8666de1c1396010d6922965d61c" alt="图片"></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>资源  </li>
</ul>
<p>资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。在接下来的文档中，我们都会用资源来描述代码块。</p>
<p>只要通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。大部分情况下，可以使用方法签名，URL，甚至服务名称作为资源名来标示资源。</p>
<ul>
<li>规则  </li>
</ul>
<p>围绕资源的实时状态设定的规则，可以包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整。</p>
<h2 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h2><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p><img src="https://images.lilhui.com/1fa76486ed2514ef49369c490b3cb83b" alt="图片"></p>
<h3 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h3><p>除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。由于调用关系的复杂性，如果调用链路中的某个资源不稳定，最终会导致请求发生堆积。Sentinel 熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 DegradeException）。</p>
<h4 id="降级策略"><a href="#降级策略" class="headerlink" title="降级策略"></a>降级策略</h4><p>我们通常用以下几种方式来衡量资源是否处于稳定的状态：</p>
<ul>
<li>平均响应时间 (DEGRADE_GRADE_RT)：当 1s 内持续进入 5 个请求，对应时刻的平均响应时间（秒级）均超过阈值（count，以 ms 为单位），那么在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 DegradeException）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt=xxx 来配置。</li>
<li>异常比例 (DEGRADE_GRADE_EXCEPTION_RATIO)：当资源的每秒请求量 &gt;= 5，并且每秒异常总数占通过量的比值超过阈值（DegradeRule 中的 count）之后，资源进入降级状态，即在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。</li>
<li>异常数 (DEGRADE_GRADE_EXCEPTION_COUNT)：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 timeWindow 小于 60s，则结束熔断状态后仍可能再进入熔断状态。</li>
</ul>
<p>注意：异常降级仅针对业务异常，对 Sentinel 限流降级本身的异常（BlockException）不生效。为了统计异常比例或异常数，需要通过 Tracer.trace(ex) 记录业务异常。示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entry entry = null;</span><br><span class="line">try &#123;</span><br><span class="line">  entry = SphU.entry(key, EntryType.IN, key);</span><br><span class="line"></span><br><span class="line">  // Write your biz code here.</span><br><span class="line">  // &lt;&lt;BIZ CODE&gt;&gt;</span><br><span class="line">&#125; catch (Throwable t) &#123;</span><br><span class="line">  if (!BlockException.isBlockException(t)) &#123;</span><br><span class="line">    Tracer.trace(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  if (entry != null) &#123;</span><br><span class="line">    entry.exit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h2><p><img src="https://images.lilhui.com/475d519f2749add285155ba9f2832cae" alt="图片"></p>
<p>基于nacos配置中心：</p>
<ol>
<li>在 Sentinel 控制台配置项中需要指定 nacos 的地址，启动时即创建nacos链接。</li>
<li>针对每个应用（appName），每种规则设置不同的 path（可随时修改）；或者约定大于配置（如 path 的模式统一为 /sentinel_rules/{appName}/{ruleType}，e.g. sentinel_rules/appA/flowRule）</li>
<li>规则配置页需要进行相应的改造，直接针对应用维度进行规则配置；修改同个应用多个资源的规则时可以批量进行推送，也可以分别推送。Sentinel 控制台将规则缓存在内存中（如 InMemFlowRuleStore），可以对其进行改造使其支持应用维度的规则缓存（key 为 appName），每次添加/修改/删除规则都先更新内存中的规则缓存，然后需要推送的时候从规则缓存中获取全量规则，然后通过上面实现的 Client 将规则推送到 nacos。</li>
<li>应用客户端需要注册对应的读数据源以监听变更。</li>
</ol>
<h2 id="文档索引"><a href="#文档索引" class="headerlink" title="文档索引"></a>文档索引</h2><p><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_1/">【流量控制系列1】引言和索引</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_2/">【流量控制系列2】流量控制的基础方法和算法</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_3/">【流量控制系列3】Semaphore信号量介绍</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_4/">【流量控制系列4】Sentinel和Hystrix对比</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_5/">【流量控制系列5】Sentinel 详细介绍</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_6/">【流量控制系列6】Sentinel 详细介绍-SlotChain源码解析</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_7/">【流量控制系列7】Sentinel实践</a>  </p>
]]></content>
      <categories>
        <category>java</category>
        <category>流量控制</category>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>限流</tag>
        <tag>Sentinel</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java IO详解1】基础知识</title>
    <url>/2022/02/10/java/io/netty_1/</url>
    <content><![CDATA[<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>TCP/IP</p>
<h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP UDP"></a>TCP UDP</h2><p>协议簇。</p>
<p>应用层，传输层，网络层，网络访问层。</p>
<p>TCP：面向连接的，需要两个端互相识别后才发送数据。</p>
<ul>
<li>TCP 在发送之前要先进行三次握手，建立链接。并把链接信息放在头部。<br>建立链接：<img src="https://images.lilhui.com/5d15d8dd5cf3f3fe6653910c30bf12ec" alt="图片"></li>
</ul>
<p>UDP：面向非链接的，单端发送。发送目的在UDP协议包里描述。</p>
<ul>
<li>UDP不理会接收端是否接收到，一股脑的发送。是不可靠的</li>
<li><p>报文头很小，比较高效</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3></li>
<li><p>建立链接的三次握手</p>
<p>A:你好  能通吗<br>B:收到  可以建立链接<br>A:建立连接成功</p>
</li>
<li><p>消除链接的四次握手</p>
<p>A:你好我要关闭了<br>B:确认可以关闭<br>B:我先关闭<br>A:我也关闭</p>
</li>
</ul>
<p>应用程序获取数据</p>
<ul>
<li><p>用户空间</p>
<p>socket</p>
</li>
<li><p>内核空间</p>
<p>网卡，驱动等</p>
</li>
</ul>
<p>文件描述<br>数据准备，数据拷贝</p>
<ul>
<li>阻塞IO</li>
</ul>
<p><img src="https://images.lilhui.com/3e005c673a86f5b7983a62a7562c90cc" alt="图片"></p>
<ul>
<li>非阻塞IO</li>
</ul>
<p><img src="https://images.lilhui.com/85667f9f740e4bdb67a050039ad1875b" alt="图片"></p>
<ul>
<li>IO多路复用</li>
</ul>
<p><img src="https://images.lilhui.com/d79874a36ba820681cf04084b6dc6c97" alt="图片"></p>
<p>· 零拷贝<br>epoll使用了 零拷贝<br>内核-用户epoll  共享部分空间。</p>
<ul>
<li>信号驱动</li>
</ul>
<p><img src="https://images.lilhui.com/b9bb1fee4aff4ff95e680bd598318c88" alt="图片"></p>
<h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p><img src="https://images.lilhui.com/e9d187264391cc2d1c212e8955808376" alt="图片"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://images.lilhui.com/55b9ca8e0a7b629d86135ae0822a0e6f" alt="图片"></p>
<h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><p><img src="https://images.lilhui.com/dfbb129b19e3287b76360cb3174aaddd" alt="图片"></p>
<p>Buffer</p>
<p>flip</p>
<p>position</p>
<p>capacity</p>
<p>limit</p>
<p><img src="https://images.lilhui.com/59fd0c402c8bf0778ecdc89ab5e81bc1" alt="图片"></p>
<p>为什么要用读写翻转 flip<br>sc.read(buffer)<br>buffer.flip<br>socket从内核空间拷贝到用户空间，其实是对用户空间的写。</p>
<ul>
<li>AIO</li>
</ul>
<p>Linux 上多路复用实现的AIO。</p>
<p>所以netty 是基于NIO实现的</p>
<p>用户空间还是需要同步阻塞以获取内核的发送的消息。<br>在内核到用户控件的时候通过事件的方式进行通知，达到异步状态。</p>
<h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><ol>
<li>api复杂</li>
<li>多线程开发复杂</li>
<li>半包 粘包</li>
<li>心跳，网络中断，网络堵塞</li>
<li>nio bug空轮询<br>epoll 水平 触发  一次IO中没有读完，等到下次信号来时候才能读。信号驱动<br>边缘 触发  尽可能多的读取IO</li>
</ol>
]]></content>
      <categories>
        <category>io</category>
      </categories>
      <tags>
        <tag>tcp</tag>
        <tag>udp</tag>
      </tags>
  </entry>
  <entry>
    <title>【流量控制系列7】Sentinel实践</title>
    <url>/2019/07/29/java/flowcontroller/flowcontroller_7/</url>
    <content><![CDATA[<h2 id="sentinel的使用"><a href="#sentinel的使用" class="headerlink" title="sentinel的使用"></a>sentinel的使用</h2><h2 id="架构方式"><a href="#架构方式" class="headerlink" title="架构方式"></a>架构方式</h2><p><img src="https://images.lilhui.com/48aaae65471cb1e9c45876ae2ddfe901" alt="图片"></p>
<h2 id="Sentinel-dashboard改造"><a href="#Sentinel-dashboard改造" class="headerlink" title="Sentinel dashboard改造"></a>Sentinel dashboard改造</h2><p>默认是支持单机，现在需要改造成集群配置方式。</p>
<h3 id="页面controller改造"><a href="#页面controller改造" class="headerlink" title="页面controller改造"></a>页面controller改造</h3><p>将test下的nacos文件夹复制到包rule下<br>启用类：FlowControllerV2<br>provider注入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;flowRuleNacosProvider&quot;)</span><br><span class="line">private DynamicRuleProvider&lt;List&lt;FlowRuleEntity&gt;&gt; ruleProvider;</span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;flowRuleNacosPublisher&quot;)</span><br><span class="line">private DynamicRulePublisher&lt;List&lt;FlowRuleEntity&gt;&gt; rulePublisher;</span><br></pre></td></tr></table></figure></p>
<p>前端页面sidebar替换<br>app.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.state(&apos;dashboard.flow&apos;, &#123;</span><br><span class="line">    templateUrl: &apos;app/views/flow_v2.html&apos;,</span><br><span class="line">    url: &apos;/v2/flow/:app&apos;,</span><br><span class="line">    controller: &apos;FlowControllerV2&apos;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        loadMyFiles: [&apos;$ocLazyLoad&apos;, function ($ocLazyLoad) &#123;</span><br><span class="line">            return $ocLazyLoad.load(&#123;</span><br><span class="line">                name: &apos;sentinelDashboardApp&apos;,</span><br><span class="line">                files: [</span><br><span class="line">                    &apos;app/scripts/controllers/flow_v2.js&apos;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="配置改造"><a href="#配置改造" class="headerlink" title="配置改造"></a>配置改造</h3><p>追加nacos配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.port=8091</span><br><span class="line">#spring settings</span><br><span class="line">spring.http.encoding.force=true</span><br><span class="line">spring.http.encoding.charset=UTF-8</span><br><span class="line">spring.http.encoding.enabled=true</span><br><span class="line"></span><br><span class="line">#logging settings</span><br><span class="line">logging.level.org.springframework.web=INFO</span><br><span class="line">logging.file=$&#123;user.home&#125;/logs/csp/sentinel-dashboard.log</span><br><span class="line">logging.pattern.file= %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n</span><br><span class="line">#logging.pattern.console= %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n</span><br><span class="line"></span><br><span class="line">#auth settings</span><br><span class="line">auth.filter.exclude-urls=/,/auth/login,/auth/logout,/registry/machine</span><br><span class="line">auth.filter.exclude-url-suffixes=htm,html,js,css,map,ico,ttf,woff,png</span><br><span class="line">auth.username=sentinel</span><br><span class="line">auth.password=sentinel</span><br><span class="line"></span><br><span class="line">nacos.server=10.5.117.217</span><br></pre></td></tr></table></figure>
<h2 id="nacos集群部署"><a href="#nacos集群部署" class="headerlink" title="nacos集群部署"></a>nacos集群部署</h2><ul>
<li>追加配置</li>
</ul>
<p>distribution 下的resource配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.num=1</span><br><span class="line">db.url.0=jdbc:mysql://10.59.118.120:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span><br><span class="line">db.user=prog_admin</span><br><span class="line">db.password=prog_nacos</span><br></pre></td></tr></table></figure></p>
<p>cluster.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.59.118.126:8848</span><br><span class="line">10.59.118.127:8848</span><br><span class="line">10.59.118.121:8848</span><br></pre></td></tr></table></figure>
<ul>
<li><p>编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mvn -Prelease-nacos -DskipTests clean install -</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$NACOS_HOME/bin/startup.sh</span><br></pre></td></tr></table></figure>
<h2 id="支付平台配置改造"><a href="#支付平台配置改造" class="headerlink" title="支付平台配置改造"></a>支付平台配置改造</h2><h3 id="Web项目"><a href="#Web项目" class="headerlink" title="Web项目"></a>Web项目</h3><p>引入包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;sentinel-transport-simple-http&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;$&#123;sentinel-version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;sentinel-cluster-client-default&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;$&#123;sentinel-version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;$&#123;sentinel-version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;sentinel-web-servlet&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>追加nacos配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###限流配置###</span><br><span class="line">nexos.host=@filter.nexos.host@</span><br></pre></td></tr></table></figure>
<ul>
<li>追加拦截器<br>SentinelFilter<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</span><br><span class="line">        throws IOException, ServletException &#123;</span><br><span class="line">    HttpServletRequest sRequest = (HttpServletRequest)request;</span><br><span class="line">    Entry entry = null;</span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line">        // 根据请求生成的资源</span><br><span class="line">        String target = FilterUtil.filterTarget(sRequest);</span><br><span class="line">        if (!target.startsWith(&quot;/admin&quot;)) &#123;</span><br><span class="line">            target = WebCallbackManager.getUrlCleaner().clean(target);</span><br><span class="line">            entry = SphU.entry(target, EntryType.IN, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果能成功“申请”到资源，则说明未被限流</span><br><span class="line">        // 则将请求放行</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125; catch (BlockException e) &#123;</span><br><span class="line">        // 否则如果捕获了BlockException异常，说明请求被限流了</span><br><span class="line">        // 则将请求重定向到一个默认的页面</span><br><span class="line">        //System.out.println(&quot;触发限流规则&quot;);</span><br><span class="line">        throw new RuntimeException(&quot;触发限流规则&quot;);</span><br><span class="line">    &#125; catch (IOException e2) &#123;</span><br><span class="line">        // 省略部分代码</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (entry != null) &#123;</span><br><span class="line">            entry.exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>监听 nacos配置变更</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void initSentinalClusterClientConfig() &#123;</span><br><span class="line">    String REMOTE_ADDRESS = propertyPlaceholderConfigurer.getCtxProp(&quot;nexos.host&quot;);</span><br><span class="line">    //初始化一个配置ClusterClientConfig的 Nacos 数据源</span><br><span class="line">    ReadableDataSource&lt;String, ClusterClientAssignConfig&gt; ds =</span><br><span class="line">            new NacosDataSource&lt;&gt;(REMOTE_ADDRESS, GROUP_ID, CLIENT_CONFIG_DATA,</span><br><span class="line">                    source -&gt; JSON.parseObject(source, new TypeReference&lt;ClusterClientAssignConfig&gt;() &#123;&#125;));</span><br><span class="line">    ClusterClientConfigManager.registerServerAssignProperty(ds.getProperty());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void initClientFlow() &#123;</span><br><span class="line">    String REMOTE_ADDRESS = propertyPlaceholderConfigurer.getCtxProp(&quot;nexos.host&quot;);</span><br><span class="line">    //使用 Nacos 数据源作为配置中心，需要在 REMOTE_ADDRESS 上启动一个 Nacos 的服务</span><br><span class="line">    ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; ds =</span><br><span class="line">            new NacosDataSource&lt;&gt;(REMOTE_ADDRESS, GROUP_ID, APP_NAME + FLOW_POSTFIX,</span><br><span class="line">                    source -&gt; JSON.parseObject(source, new TypeReference&lt;List&lt;FlowRule&gt;&gt;() &#123;&#125;));</span><br><span class="line">    //为集群客户端注册动态规则源</span><br><span class="line">    FlowRuleManager.register2Property(ds.getProperty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>启动加入：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Dcsp.sentinel.dashboard.server=10.5.32.97:8091 -Dproject.name=littlehui-17pay</span><br></pre></td></tr></table></figure></p>
<h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><ol>
<li><p>sentinel配置的限流规则。来源app字段limitApp指的是请求来源，常用default，如果指定app那么非app来源的请求获取不到rule列表。</p>
</li>
<li><p>sentinel客户端不支持nacos的命名空间配置，所以用的是默认的public空间。</p>
</li>
</ol>
<h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><a href="http://ued.local.17173.com/gitlab/xiaohuichen_17173/nacos" target="_blank" rel="noopener">nacos-1.0.0-RC3源码</a><br><a href="http://ued.local.17173.com/gitlab/xiaohuichen_17173/sentinel" target="_blank" rel="noopener">sentinel-1.6.0源码</a></p>
<h2 id="文档索引"><a href="#文档索引" class="headerlink" title="文档索引"></a>文档索引</h2><p><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_1/">【流量控制系列1】引言和索引</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_2/">【流量控制系列2】流量控制的基础方法和算法</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_3/">【流量控制系列3】Semaphore信号量介绍</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_4/">【流量控制系列4】Sentinel和Hystrix对比</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_5/">【流量控制系列5】Sentinel 详细介绍</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_6/">【流量控制系列6】Sentinel 详细介绍-SlotChain源码解析</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_7/">【流量控制系列7】Sentinel实践</a>  </p>
]]></content>
      <categories>
        <category>java</category>
        <category>流量控制</category>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>限流</tag>
        <tag>Sentinel</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>【流量控制系列6】Sentinal 详细介绍-SlotChain源码解析</title>
    <url>/2019/07/29/java/flowcontroller/flowcontroller_6/</url>
    <content><![CDATA[<h2 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h2><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p><a href="http://www.lilhui.com/2019/07/28/java/patterndesign/patterndesign_17/">责任链模式介绍-扩展链接</a></p>
<h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><ul>
<li>限流功能-基于FlowSlot</li>
</ul>
<p><img src="https://images.lilhui.com/bc36844adc0e4f4116eb8898ed2d6028" alt="图片"></p>
<h2 id="SoltChain源码解析"><a href="#SoltChain源码解析" class="headerlink" title="SoltChain源码解析"></a>SoltChain源码解析</h2><ul>
<li>类图</li>
</ul>
<p><img src="https://images.lilhui.com/6f298cb9a9a2652c40b6bb5b3bbab5d5" alt="图片"></p>
<ul>
<li>SoltChain内部</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProcessorSlot</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, T param, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized,</span></span></span><br><span class="line"><span class="function"><span class="params">               Object... args)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fireEntry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, Object obj, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized,</span></span></span><br><span class="line"><span class="function"><span class="params">                   Object... args)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(Context context, ResourceWrapper resourceWrapper, <span class="keyword">int</span> count, Object... args)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fireExit</span><span class="params">(Context context, ResourceWrapper resourceWrapper, <span class="keyword">int</span> count, Object... args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLinkedProcessorSlot</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ProcessorSlot</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AbstractLinkedProcessorSlot&lt;?&gt; next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fireEntry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, Object obj, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized, Object... args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next.transformEntry(context, resourceWrapper, obj, count, prioritized, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transformEntry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, Object o, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized, Object... args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        T t = (T)o;</span><br><span class="line">        entry(context, resourceWrapper, t, count, prioritized, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fireExit</span><span class="params">(Context context, ResourceWrapper resourceWrapper, <span class="keyword">int</span> count, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next.exit(context, resourceWrapper, count, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> AbstractLinkedProcessorSlot&lt;?&gt; getNext() &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(AbstractLinkedProcessorSlot&lt;?&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractLinkedProcessorSlot为一个Slot节点，通过setNext指定下一个Slot节点,通过 fireEntry()方法，调用下一个节点的transformEntry()最终调用到下一个Slot节点的entry方法,本身的结构类似于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">clsss Slot &#123;</span><br><span class="line">  Slot next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ProcessorSlotChain和DefaultProcessorSlotChain</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessorSlotChain</span> <span class="keyword">extends</span> <span class="title">AbstractLinkedProcessorSlot</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//添加头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(AbstractLinkedProcessorSlot&lt;?&gt; protocolProcessor)</span></span>;</span><br><span class="line">    <span class="comment">//添加下一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(AbstractLinkedProcessorSlot&lt;?&gt; protocolProcessor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultProcessorSlotChain</span> <span class="keyword">extends</span> <span class="title">ProcessorSlotChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AbstractLinkedProcessorSlot&lt;?&gt; first = <span class="keyword">new</span> AbstractLinkedProcessorSlot&lt;Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, Object t, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized, Object... args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.fireEntry(context, resourceWrapper, t, count, prioritized, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(Context context, ResourceWrapper resourceWrapper, <span class="keyword">int</span> count, Object... args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.fireExit(context, resourceWrapper, count, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    AbstractLinkedProcessorSlot&lt;?&gt; end = first;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(AbstractLinkedProcessorSlot&lt;?&gt; protocolProcessor)</span> </span>&#123;</span><br><span class="line">        protocolProcessor.setNext(first.getNext());</span><br><span class="line">        first.setNext(protocolProcessor);</span><br><span class="line">        <span class="keyword">if</span> (end == first) &#123;</span><br><span class="line">            end = protocolProcessor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(AbstractLinkedProcessorSlot&lt;?&gt; protocolProcessor)</span> </span>&#123;</span><br><span class="line">        end.setNext(protocolProcessor);</span><br><span class="line">        end = protocolProcessor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(AbstractLinkedProcessorSlot&lt;?&gt; next)</span> </span>&#123;</span><br><span class="line">        addLast(next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AbstractLinkedProcessorSlot&lt;?&gt; getNext() &#123;</span><br><span class="line">        <span class="keyword">return</span> first.getNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, Object t, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized, Object... args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        first.transformEntry(context, resourceWrapper, t, count, prioritized, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(Context context, ResourceWrapper resourceWrapper, <span class="keyword">int</span> count, Object... args)</span> </span>&#123;</span><br><span class="line">        first.exit(context, resourceWrapper, count, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultProcessorSlotChain实质是指定头节点FirstSlot和endSnot的链表。就如下面结构 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class Chain&#123;</span><br><span class="line">  Slot first;</span><br><span class="line">  Slot end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>com.alibaba.csp.sentinel.slots.DefaultSlotChainBuilde</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ProcessorSlotChain <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ProcessorSlotChain chain = <span class="keyword">new</span> DefaultProcessorSlotChain();</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> NodeSelectorSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> ClusterBuilderSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> LogSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> StatisticSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> SystemSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> AuthoritySlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> FlowSlot());</span><br><span class="line">    chain.addLast(<span class="keyword">new</span> DegradeSlot());</span><br><span class="line">    <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构图</p>
<p><img src="https://images.lilhui.com/7b10af885444473060a03c428e32c0ea" alt="图片"></p>
<p>各个slot职责</p>
<ul>
<li><p>NodeSelectorSlot 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；</p>
</li>
<li><p>ClusterBuilderSlot则用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；</p>
</li>
<li><p>StatistcSlot  则用于记录，统计不同纬度的 runtime 信息；</p>
</li>
<li><p>SystemSlot 则通过系统的状态，例如 load1 等，来控制总的入口流量；</p>
</li>
<li><p>AuthorizationSlot 则根据黑白名单，来做黑白名单控制；</p>
</li>
<li><p>FlowSlot则用于根据预设的限流规则，以及前面 slot 统计的状态，来进行限流；</p>
</li>
<li><p>DegradeSlot则通过统计信息，以及预设的规则，来做熔断降级；</p>
</li>
</ul>
<p>可以看到，我需要的熔断，限流，白名单控制都可以通过配置AuthorizationSlot，FlowSlot，DegradeSlot实现。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>基于SPI与责任链模式的实现扩展。</p>
<ol>
<li>新增自己的Slot。继承AbstractLinkedProcessorSlot。实现自己的流控业务。</li>
<li>sentinel-core下的SPI配置：<br>com.alibaba.csp.sentinel.soltchain.SoltChainBuilder初始化追加扩展的Solt</li>
</ol>
<p>参考：<br><a href="https://www.jianshu.com/p/a7a405de3a12" target="_blank" rel="noopener">【sentinel】深入浅出之原理篇SlotChain</a></p>
<h2 id="文档索引"><a href="#文档索引" class="headerlink" title="文档索引"></a>文档索引</h2><p><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_1/">【流量控制系列1】引言和索引</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_2/">【流量控制系列2】流量控制的基础方法和算法</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_3/">【流量控制系列3】Semaphore信号量介绍</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_4/">【流量控制系列4】Sentinel和Hystrix对比</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_5/">【流量控制系列5】Sentinel 详细介绍</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_6/">【流量控制系列6】Sentinel 详细介绍-SlotChain源码解析</a><br><a href="http://www.lilhui.com/2019/07/29/java/flowcontroller/flowcontroller_7/">【流量控制系列7】Sentinel实践</a>  </p>
]]></content>
      <categories>
        <category>java</category>
        <category>流量控制</category>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>限流</tag>
        <tag>Sentinel</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java IO详解2】Netty初识</title>
    <url>/2022/02/10/java/io/netty_2/</url>
    <content><![CDATA[<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>BIO, NIO, AIO<br>其中：  AIO中 linux在 内核绑定 CompleteChandle</p>
<h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><p>Reactor 模式，事件驱动实现方式</p>
<h3 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h3><ul>
<li>多线程<br>在selector加入了多线程支持。<br><img src="https://images.lilhui.com/5633cd5e1b23d8493684fe91229938dc" alt="图片"></li>
</ul>
<ul>
<li>主从</li>
</ul>
<p>selector加入到线程池</p>
<p><img src="https://images.lilhui.com/1a7d3c04ed76989cb06257a1e7424f8d" alt="图片"></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ul>
<li>Bootstrap</li>
</ul>
<p>EventLoop   selector保持器<br>EventLoopGroup  Reactor主反应</p>
<p>结合实现多个selector</p>
<p><img src="https://images.lilhui.com/db1eea4b563ad1eab4a6df70ef9e9e58" alt="图片"></p>
<ul>
<li>Channel</li>
</ul>
<p>管道，充当用户空间与内核间的沟通</p>
<p><img src="https://images.lilhui.com/99f24ec74332fa18d9db568f50476f6a" alt="图片"></p>
<p>ChannelHandler</p>
<p><img src="https://images.lilhui.com/c21f2895d82cd0015a2eb35e4c129a37" alt="图片"></p>
<p>协作处理</p>
<p><img src="https://images.lilhui.com/f47ef15cbbeb00d3a7e12a79ca237363" alt="图片"></p>
<ul>
<li>ChannelHandlerContext</li>
</ul>
<p><img src="https://images.lilhui.com/3be250bdb608d37702227d534f4b0509" alt="图片"></p>
]]></content>
      <categories>
        <category>io</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java IO详解5】Netty实践2</title>
    <url>/2022/02/10/java/io/netty_5/</url>
    <content><![CDATA[<h2 id="RPC实践"><a href="#RPC实践" class="headerlink" title="RPC实践"></a>RPC实践</h2><ul>
<li>http服务</li>
</ul>
<p>Netty实现了完整的http协议 HttpHandler只要在channelHandler初始化的时候设置就行。FullHttpServerHandler</p>
<ul>
<li>服务推送技术</li>
</ul>
<p>WebSocket</p>
<p><img src="https://images.lilhui.com/2e200872f8eac314980765e2adba30c0" alt="图片"></p>
<p>1：建立http请求<br>2：建立WebSocket握手</p>
<p>协议升级</p>
<p>子协议：STOMP<br>文本定向消息协议<br>生产者，消息代理，消费者。</p>
]]></content>
      <categories>
        <category>io</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java IO详解4】Netty实践</title>
    <url>/2022/02/10/java/io/netty_4/</url>
    <content><![CDATA[<h2 id="ByteBuf回顾"><a href="#ByteBuf回顾" class="headerlink" title="ByteBuf回顾"></a>ByteBuf回顾</h2><p>ByteBuf</p>
<p>协议 nagle合并包<br>应用层  包大于套接字缓冲区<br>网络层 tcp分片 帧<br>路由器，硬件设备等等</p>
<ul>
<li><p>编码器</p>
</li>
<li><p>解码器</p>
</li>
</ul>
<p>netty基于ChannelInboudHandlerAdater和ChannelOutboudHanlderAdapter实现了一些编解码抽象类，我们在使用的过程中就只要关注编解码的业务实现。<br>MessageToMessageDecoder<i>：把某种对象解码成另外一种对象。泛型I对应的是第一个Message类型。<br>ByteToMessageDecoder：把ByteBuf解码成某一种对象。<br>MessageToMessageEncoder<i>：把某种对象编码成另一种对象。泛型I对应的是第一个Message类型。<br>MessageToByteEncoder<i>:把某对象编码成另一种对象。泛型I对应的是第一个Message类型。</i></i></i></p>
<h2 id="RPC框架实现"><a href="#RPC框架实现" class="headerlink" title="RPC框架实现"></a>RPC框架实现</h2><p><img src="https://images.lilhui.com/1c673683597bcd34f4636c8d569ca45b" alt="图片"></p>
<p>需要使用到的技术：<br>1、动态代理<br>通过java Proxy技术拿到代理对象，invocationHandler实现数据协议包装和通讯。<br>2、序列化、反序列化<br>3、网络通讯<br>基于netty的客户端和服务端进行通讯可以获得很好的IO性能<br>4、反射<br>根据客户端请求参数通过反射技术实现服务端对应实例的方法调用</p>
<p>使用netty实现客户端发送需要注意的点<br>通过Netty的channel调用写数据writeAndFlush 写的事件以及收到响应之后的channelRead事件都是会异步执行，所以需要注意线程协作的问题。可以使用countdowlacth来实现主线程等待channelread执行完之后才去获取收到的响应对象。</p>
<p><img src="https://images.lilhui.com/b6572ded990e4a9459d844d8d16bc69b" alt="图片"></p>
<p><img src="https://images.lilhui.com/4c692c1d48f22b4f25fe19af825c8702" alt="图片"></p>
]]></content>
      <categories>
        <category>io</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java IO详解3】Netty进阶</title>
    <url>/2022/02/10/java/io/netty_3/</url>
    <content><![CDATA[<h2 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h2><ul>
<li>管件类和概念<br>Channel, ChannelHandler，ChannelHandlerContext<br>ChannelHandler的执行规则  INBound,OutBound<br>Pipline里的ChannelHandlerContext<br>OutBoundHandler也有read，是为了校验，因为OutBound是在前面。</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>outChannelHandler.write触发fireChannelRead的时候<br>inHandler会writeAndFlash,会触发outChannelHandler的 write形成死循环。<br>所以在OutHandler的write里不能fireChannelRead<br>会OverStackFlow</p>
<h2 id="Bytebuf"><a href="#Bytebuf" class="headerlink" title="Bytebuf"></a>Bytebuf</h2><p>Unpooled.xxx</p>
<ul>
<li>申请方式</li>
</ul>
<p>ByteBufAllocator heapBuffer() directBuffer()<br>compositeBuffer()</p>
<ul>
<li>两套索引</li>
</ul>
<p>readIndex和writeIndex</p>
<p>调用get<em> set</em>不会移动索引。调用read<em>, write</em>会移动相应的索引。<br>forEachByte 查找。</p>
<ul>
<li>派生缓冲区</li>
</ul>
<p>为Bytebuf提供了专门的方式来呈现其内容的试图。通过以下方法被创建：</p>
<p>dumplicate(), slice(), slice(int, int);</p>
<p>Unpooled.unmodifiableBuffer(…);<br>order(ByteOrder);<br>readSlice()</p>
<p>每个方法都返回一个新的ByteBuf实例，它具有自己的读索引、写索引和标记索引。<br>派生的缓冲区和原缓冲区的数据是共享的。</p>
<ul>
<li>引用计数</li>
</ul>
<p>release 计数减一。减到0后会进行回收。<br>减少GC。</p>
<p>池化的对象如果不释放，可能会引起内存溢出。</p>
<p>writeAndFlush会释放资源</p>
<p>SimpleChannelInboundHandler实现了 release。</p>
<ul>
<li>粘包，半包</li>
</ul>
<p><img src="https://images.lilhui.com/f6c05cc6032dad053d0a41f8811dc4c8" alt="图片"></p>
<p>假设客户端分别发送了两个数据包D1和D2给服务器，由于服务器一次读取的字节数是不确定的。所以可能会有以下4种情况。<br>从用户空间到内存空间。累计几个包后进行flash一起发送。</p>
<p>1：服务端分两次读取到两个独立的数据包，分别是D1和D2，没有粘包和拆包。<br>2：服务端一次接收到了两个数据包，D1和D2粘在一起，被称为TCP粘包。<br>3：服务端分两次读取到了两个数据包，第一次读取到了完整的D1和D2部分内容，第二次读取到了D2的剩余内容。这个叫做TCP拆包。<br>4：服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包剩余内容和D2包的完整包。<br>如果此时服务端TCP接收滑窗非常小，而数据D1和D2比较大，很有可能会发生第五种可能，既服务端分多次才能将D1和D2包接收完成。期间发生多次拆包。</p>
<ul>
<li>TCP粘包/半包发生的原因</li>
</ul>
<p><img src="https://images.lilhui.com/3487c1c6c200dbd7c746550f82911bbe" alt="图片"></p>
<p>TCP的Nagle算法，会合并小包，统一发送。如此，服务端无法区分哪些数据包是需要分开的，这就产生了粘包。</p>
<p>UDP：作为连接不可靠的传输协议。不会对数据包进行合并发送。没有Nogle算法。<br>UDP的包是 数据+UDP头+IP头一次封装，没有粘包。<br>分包产生的原因：</p>
<p>IP分片传输导致。传输过程丢失部分包。或者一个包被分成了多个，接收端顺序打乱了。<br>整理有几种情况：<br>1：数据大于套接字发送缓冲区。<br>2：进行MSS大小的TCP分段，MSS最大报文段长度的缩写。MSS是TCP报文段中数据段的最大长度。数据字段加上TCP首部才等于整个TCP报文段。所以MSS并不是TCP报文长度的最大长度。而是：MSS=TCP报文头长度-TCP首部长度。</p>
<p>1、两次请求，每个请求一个包<br>2、两次请求和成了一个包<br>3、第二个包被分成了两个包D2-2、D2-1 ，被分割的包D2-1的包有可能会跟D1合成一个包<br>4、第一个包分成了两个包，第二部分的包D1-2跟D2合成了一个包</p>
<ul>
<li>如何解决粘包半包问题</li>
</ul>
<p>1：包尾巴追加分隔符。 LineBasedFrameDecoder和DelimiterBasedFrameDecoder<br>2：消息定长。不够的补空格FixedLengthFrameDecoder<br>3：消息协议氛围消息头和消息体，消息头中包含标识消息总长度。通常设计思路为消息头的第一个字段使用int32来表示消息的总长度，LengthFieldBasedFrameDecoder。</p>
<ul>
<li>编解码<br>加密解密\序列化 反序列化</li>
</ul>
]]></content>
      <categories>
        <category>io</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列：JVM内存优化实例</title>
    <url>/2017/10/11/java/jvm/jvm_3/</url>
    <content><![CDATA[<h3 id="优化实例"><a href="#优化实例" class="headerlink" title="优化实例"></a>优化实例</h3><p>java application项目（非web项目）</p>
<p>改进前：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xms128m</span><br><span class="line">-Xmx128m</span><br><span class="line">-XX:NewSize=64m</span><br><span class="line">-XX:PermSize=64m</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=78</span><br><span class="line">-XX:ThreadStackSize=128</span><br><span class="line">-Xloggc:logs/gc.log</span><br><span class="line">-Dsun.rmi.dgc.server.gcInterval=3600000</span><br><span class="line">-Dsun.rmi.dgc.client.gcInterval=3600000</span><br><span class="line">-Dsun.rmi.server.exceptionTrace=true</span><br></pre></td></tr></table></figure></p>
<p>问题:<br>permsize 设置较小,很容易达到报警范围(0.8)<br>没有设置MaxPermSize，堆增长会带来额外压力。<br>NewSize较大，old gen 剩余空间64m，一方面可能会带来old区容易增长到报警范围（监控数据显示oldgenused长期在50m左右，接近78%，容易出现full gc）,另一方面也存在promontion fail风险<br>改进后：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xms128m</span><br><span class="line">-Xmx128m</span><br><span class="line">-Xmn24m</span><br><span class="line">-XX:PermSize=80m</span><br><span class="line">-XX:MaxPermSize=80m</span><br><span class="line">-Xss256k</span><br><span class="line">-XX:SurvivorRatio=1</span><br><span class="line">-XX:MaxTenuringThreshold=20</span><br><span class="line">-XX:+UseParNewGC</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=75</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection</span><br><span class="line">-XX:+CMSParallelRemarkEnabled</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction=2</span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB=0</span><br><span class="line">-XX:+PrintClassHistogram</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">-XX:+PrintHeapAtGC</span><br><span class="line">-Xloggc:logs/gc.log</span><br><span class="line">-Dsun.rmi.dgc.server.gcInterval=3600000</span><br><span class="line">-Dsun.rmi.dgc.client.gcInterval=3600000</span><br><span class="line">-Dsun.rmi.server.exceptionTrace=true</span><br></pre></td></tr></table></figure></p>
<p>修改点：<br>PermSize与MaxPermSize都设置为80，一方面避免non heap warn(报警阀值0.8 非对内存一般占用到60M以内），一方面避免堆伸缩带来的压力<br>通过设置Xmn=24M及SurvivorRatio=1 使得Eden区=from space=to  space=8M,降低了Eden区大小，降低YGC的时间(降低到3-4ms左右),同时通过设MaxTenuringThreshold=20，使得old gen的增长很缓慢。带来的问题是YGC的次数明显提高了很多。<br>其他参数优化 修改后带来的好处见JVM参数设置<br>再次改进后<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xms128m</span><br><span class="line">-Xmx128m</span><br><span class="line">-Xmn36m</span><br><span class="line">-XX:PermSize=80m</span><br><span class="line">-XX:MaxPermSize=80m</span><br><span class="line">-Xss256k</span><br><span class="line">-XX:SurvivorRatio=1</span><br><span class="line">-XX:MaxTenuringThreshold=20</span><br><span class="line">-XX:+UseParNewGC</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=73</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection</span><br><span class="line">-XX:+CMSParallelRemarkEnabled</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction=2</span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB=0</span><br><span class="line">-XX:+PrintClassHistogram</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">-XX:+PrintHeapAtGC</span><br><span class="line">-Xloggc:logs/gc.log</span><br><span class="line">-Dsun.rmi.dgc.server.gcInterval=3600000</span><br><span class="line">-Dsun.rmi.dgc.client.gcInterval=3600000</span><br><span class="line">-Dsun.rmi.server.exceptionTrace=true</span><br></pre></td></tr></table></figure></p>
<p>修改点：<br>      在上面的基础上调整Xmn大小到36M，设置CMSInitiatingOccupancyFraction=73。</p>
<pre><code>Dden区与Survivor区大小都增加到12M，通过CMSInitiatingOccupancyFraction计算公式,计算得出value为73是，可以避免promotion faild问题，同时满足堆内存监控报警值在80%：内存大小128M*80%=102.4M 102.4M-36M=66.4M(老生代达到此值报警） 老生代达到67.15M（92M*0.73）将发生Full GC，所以在老生代大小达到66.4M时也就是WARN报警时将很有可能出现Full GC。
 增大了Eden和Survivor区的值，会减小YGC的次数，但由于空间变大理论上也会相应的增加YGC的时间，不过由于新生代本身就很小（才36M）这点儿变化可以忽略掉。实际的监控值显示YGC的时间在4-5ms之间。是可以接受范围。
SurvivorRatio 这个值还得在仔细考虑下,有待优化中
</code></pre><p>网上某个牛人的配置 :每天几百万pv一点问题都没有，网站没有停顿<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$JAVA_ARGS</span><br><span class="line">.=</span><br><span class="line">&quot;</span><br><span class="line">-Dresin.home=$SERVER_ROOT</span><br><span class="line">-server</span><br><span class="line">-Xms6000M</span><br><span class="line">-Xmx6000M</span><br><span class="line">-Xmn500M</span><br><span class="line">-XX:PermSize=500M</span><br><span class="line">-XX:MaxPermSize=500M</span><br><span class="line">-XX:SurvivorRatio=65536</span><br><span class="line">-XX:MaxTenuringThreshold=0</span><br><span class="line">-Xnoclassgc</span><br><span class="line">-XX:+DisableExplicitGC</span><br><span class="line">-XX:+UseParNewGC</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction=0</span><br><span class="line">-XX:+CMSClassUnloadingEnabled</span><br><span class="line">-XX:-CMSParallelRemarkEnabled</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=90</span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB=0</span><br><span class="line">-XX:+PrintClassHistogram</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">-XX:+PrintHeapAtGC</span><br><span class="line">-Xloggc:log/gc.log</span><br><span class="line">&quot;;</span><br></pre></td></tr></table></figure></p>
<p>说明一下， -XX:SurvivorRatio=65536 -XX:MaxTenuringThreshold=0就是去掉了救助空间；<br>-Xnoclassgc禁用类垃圾回收，性能会高一点；<br>-XX:+DisableExplicitGC禁止System.gc()，免得程序员误调用gc方法影响性能；<br>-XX:+UseParNewGC，对年轻代采用多线程并行回收，这样收得快；<br>带CMS参数的都是和并发回收相关的，不明白的可以上网搜索；<br>CMSInitiatingOccupancyFraction，这个参数设置有很大技巧，基本上满足(Xmx-Xmn)<em>(100-CMSInitiatingOccupancyFraction)/100&gt;=Xmn就不会出现promotion failed。在我的应用中Xmx是6000，Xmn是500，那么Xmx-Xmn是5500兆，也就是年老代有5500兆，CMSInitiatingOccupancyFraction=90说明年老代到90%满的时候开始执行对年老代的并发垃圾回收（CMS），这时还剩10%的空间是5500</em>10%=550兆，所以即使Xmn（也就是年轻代共500兆）里所有对象都搬到年老代里，550兆的空间也足够了，所以只要满足上面的公式，就不会出现垃圾回收时的promotion failed；<br>SoftRefLRUPolicyMSPerMB这个参数我认为可能有点用，官方解释是softly reachable objects will remain alive for some amount of time after the last time they were referenced. The default value is one second of lifetime per free megabyte in the heap，我觉得没必要等1秒；<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xmx4000M</span><br><span class="line">-Xms4000M</span><br><span class="line">-Xmn600M</span><br><span class="line">-XX:PermSize=500M</span><br><span class="line">-XX:MaxPermSize=500M</span><br><span class="line">-Xss256K</span><br><span class="line">-XX:+DisableExplicitGC</span><br><span class="line">-XX:SurvivorRatio=1</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:+UseParNewGC</span><br><span class="line">-XX:+CMSParallelRemarkEnabled</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction=0</span><br><span class="line">-XX:+CMSClassUnloadingEnabled</span><br><span class="line">-XX:LargePageSizeInBytes=128M</span><br><span class="line">-XX:+UseFastAccessorMethods</span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=80</span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB=0</span><br><span class="line">-XX:+PrintClassHistogram</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">-XX:+PrintHeapAtGC</span><br><span class="line">-Xloggc:log/gc.log</span><br></pre></td></tr></table></figure></p>
<p>改进方案：<br>上面方法不太好，因为没有用到救助空间，所以年老代容易满，CMS执行会比较频繁。我改善了一下，还是用救助空间，但是把救助空间加大，这样也不会有promotion failed。<br>具体操作上，32位Linux和64位Linux好像不一样，64位系统似乎只要配置MaxTenuringThreshold参数，CMS还是有暂停。为了解决暂停问题和promotion failed问题，最后我设置-XX:SurvivorRatio=1 ，并把MaxTenuringThreshold去掉，这样即没有暂停又不会有promotoin failed，而且更重要的是，年老代和永久代上升非常慢（因为好多对象到不了年老代就被回收了），所以CMS执行频率非常低，好几个小时才执行一次，这样，服务器都不用重启了。<br>某网友:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$JAVA_ARGS</span><br><span class="line">.=</span><br><span class="line">&quot;</span><br><span class="line">-Dresin.home=$SERVER_ROOT</span><br><span class="line">-server</span><br><span class="line">-Xmx3000M</span><br><span class="line">-Xms3000M</span><br><span class="line">-Xmn600M</span><br><span class="line">-XX:PermSize=500M</span><br><span class="line">-XX:MaxPermSize=500M</span><br><span class="line">-Xss256K</span><br><span class="line">-XX:+DisableExplicitGC</span><br><span class="line">-XX:SurvivorRatio=1</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:+UseParNewGC</span><br><span class="line">-XX:+CMSParallelRemarkEnabled</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction=0</span><br><span class="line">-XX:+CMSClassUnloadingEnabled</span><br><span class="line">-XX:LargePageSizeInBytes=128M</span><br><span class="line">-XX:+UseFastAccessorMethods</span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=70</span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB=0</span><br><span class="line">-XX:+PrintClassHistogram</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">-XX:+PrintHeapAtGC</span><br><span class="line">-Xloggc:log/gc.log</span><br><span class="line">&quot;;</span><br></pre></td></tr></table></figure></p>
<pre><code>64位jdk参考设置，年老代涨得很慢，CMS执行频率变小，CMS没有停滞，也不会有promotion failed问题，内存回收得很干净
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>打印并分析进行垃圾回收的时间，内容，具体数值。如果有OOM导出OOM时内存使用情况。</li>
<li>分析垃圾回收时候的数据信息，（年轻区，年老区，方法区）查看OOM时内存使用情况。 </li>
<li>优化的权重顺序可以按照，FullGc&gt;频繁YGC</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm调优</tag>
      </tags>
  </entry>
  <entry>
    <title>【JVM深入理解系列2】执行引擎</title>
    <url>/2021/05/10/java/jvm/jvm_deep_2/</url>
    <content><![CDATA[<h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><p>JVM运行Java程序的一套子系统</p>
<pre><code>两种解释器

字节码解释器
    Java字节码-&gt; C++代码-&gt;硬件编码

模板解释器
    Java字节码-&gt;硬件编码

    底层实现过程

    1. 申请一块内存：可读可写可执行。2. 将处理new字节码的硬编码拿过来
    3. 将处理new字节码的硬编码写入申请的内存。
    4. 申请一个函数指针，用这个函数指针执行这块内存。
    5. 调用的时候，直接通过这个指针调用。
</code></pre><h2 id="三种运行模式"><a href="#三种运行模式" class="headerlink" title="三种运行模式"></a>三种运行模式</h2><ol>
<li>-Xint</li>
<li>-Xcomp</li>
<li>-Xmixed</li>
</ol>
<h2 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h2><p>正常的C++函数生成的硬编码都有堆栈操作。</p>
<ul>
<li><p>字节码解释器<br>解释执行的<br>和编译器没关系</p>
</li>
<li><p>模板解释器<br>执行的因编码是即时编译器编译的。</p>
</li>
</ul>
<h3 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h3><p>即时编译器</p>
<pre><code>C1
    c1编译器在client模式下的即时编译器
    1. 比C2搜集的数据少。触发宽松。
    2. 编译优化比较浅。
    3. C1编译器生成的代码执行效率低。
C2
    C2编译器是server模式下的即时编译器

    1. 触发条件比较严格，程序运行一段时间后才执行。
    2. 优化比较深。
    3. 编译生成的代码比C1效率高
混合编译器
</code></pre><hr>
<pre><code>GraalVM
</code></pre><ul>
<li><p>即时编译触发条件</p>
<p>硬编码<br>热点代码</p>
</li>
</ul>
<p>注意：即时编译的最小单位是代码块。</p>
<ul>
<li>N热度：</li>
</ul>
<p>生成热点代码<br>client，N默认是1500<br>server，N默认是10000</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -client -XX:+PrintFlagsFinal -version</span><br></pre></td></tr></table></figure>
<ul>
<li><p>热度衰减：<br>new 7000<br>一段时间么执行后会2倍速递减 -&gt; 3500</p>
</li>
<li><p>经典故障</p>
<p>  业务增长，加节点。热机切冷机</p>
</li>
</ul>
<p>冷机：刚运行不久<br>热机：运行了一段时间</p>
<ul>
<li>节点。相同配置节点加入。负载均衡平摊压力。</li>
</ul>
<p>热机有热点代码缓存了，并发更大。</p>
<ol>
<li>热机能承受的并发大于冷机。</li>
<li>冷机一边在增加流量一遍在即时编译。性能就降低。</li>
</ol>
<p>问题：热点代码缓存在哪里？<br>方法区：<br>CodeCache（调优方向之一）<br>server 2496 2M，<br>client模式下160k</p>
<h2 id="即时编译是如何运行的"><a href="#即时编译是如何运行的" class="headerlink" title="即时编译是如何运行的"></a>即时编译是如何运行的</h2><p>VM_THREAD<br>GC</p>
<p>队列存放及时编译任务。当触发即时编译时会将编译任务放到及时编译队列里。</p>
<p>1、 触发及时编译任务入队列。<br>2、 VM_THREAD执行队列任务。</p>
<p>异步。</p>
<p>即时编译的线程有多少，如何调优？</p>
<p>硬编码，热点代码<br>热点代码存在哪里？热点代码缓冲区在哪里？</p>
<p>热点代码缓冲区，在方法区。</p>
<ul>
<li>逃逸分析</li>
</ul>
<p>逃逸<br>是一种现象</p>
<pre><code>对象作用域
    局部变量，非逃逸
    非局部变量，逃逸。方法外，线程外。
</code></pre><p>基于逃逸技术，JVM开发了三种优化技术。</p>
<pre><code>1. 栈上分配
2. 标量替换
    标量： 不可再分，java中的基本类型就是标量。
3. 锁消除
    没竞争的锁，会消除掉。
</code></pre><ul>
<li>栈上分配</li>
</ul>
<p>如何通过代码测试？</p>
<pre><code>对象在兑取分配
对象在虚拟机栈上分配。
HSDB
JDK8的栈上分配存在吗？
生成一个对象100W次，在栈上是不是又100W个。如果没有，就存在栈上分配，不发生GC的情况下。
</code></pre>]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm调优</tag>
      </tags>
  </entry>
  <entry>
    <title>【JVM深入理解系列3】底层优化</title>
    <url>/2021/05/10/java/jvm/jvm_deep_3/</url>
    <content><![CDATA[<p>对象布局</p>
<pre><code>对象头
    Mark Word
        32bit   4B
        64bit   8B
    类型指针    Klass pointer
        对象所属类的元信息的实例指针
            instanceKlass

        指针压缩
            开启后  4B
            关闭    8B
    数组长度
        如果这个对象不是数组 占 0B
        如果这个对象是数组 占4B 表示这个对象数组的元素个数

实例数据
    类的非静态属性，生成对象就是实例数据。

    对象属性

    boolean 2B
    byte 1B
    char 2B
    int 4B
    float 4B
    double 8B
    引用类型：4B(指针压缩) 8B(不压缩)
    long 8B

对齐填充
    8B字节对齐，java中所有的对象都是8B字节对齐。
    如果一个对象占3个字节，JVM会补2个字节凑成32B达到8字节对齐。

    为什么要做填充？
        1. 效率提高
</code></pre><p>计算类大小</p>
<p>指针压缩<br>开启后指针压缩<br>16B = 8B（markword)+ 4B(klass point) + 0B + 0B = 12<br>需要补到16<br>关闭指针压缩<br>16B = 8 + 8 + 0 + 0</p>
<p>数组对象<br>开启指针压缩</p>
<p>数组对象在关闭指针压缩的情况下，会出现两端填充。<br>不止这一种情况。</p>
<p>一个OOP能标识最大堆空间</p>
<p>32bit内存最大 4G</p>
<p>一个OOP,存储的时候是3B,32bit<br>使用的时候胃部补了3个0， 35bit</p>
<p>OOP32G瓶颈</p>
<p>32G不够用了，需要扩容怎么办？<br>解决方法：8字节对齐 改成16字节对齐。</p>
<p>8 自己对齐，内存地址会补3个0.16字节对齐会补4个0<br>32G*2 = 64G<br>改源码。</p>
<p>JDK为什么没用16字节对齐</p>
<pre><code>1. 没必要

32G已经极限了。GC耗费CPU资源。太大，暂停时间太长。

2. 非空间
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>对象的两种内存结构 kclass,oop</li>
<li>计算三种类型的对象大小。</li>
<li>指针压缩</li>
</ol>
<h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><ol>
<li>项目上线前的预估调优。</li>
<li>项目上线初期，基于日志做一些基础调优。</li>
<li>发生oom，频繁full gc，做测地的调优</li>
</ol>
<ul>
<li>调优的点</li>
</ul>
<ol>
<li>jvm内存模型的调优。</li>
<li>热点代码缓冲区的调优。</li>
</ol>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul>
<li>亿级流量项目的调优</li>
</ul>
<p>一个UV会访问20个左右的PV<br>500W用户。</p>
<p>下单转换率 10% = 50W</p>
<p>40%订单在前两小时四完成。<br>每分钟1200笔订单。<br>周边流量都加起来，大概</p>
<p>没妙产生200M对象<br>总共2700M</p>
<p>每个操作要3秒 200 * 3 = 600<br>每秒钟 600M对象进入Eden区</p>
<p>14秒发生一次young gc</p>
<p>600M对象还存活，无法被回收</p>
<p>触发空间担保。</p>
<p>老年代6400M<br>多长时间触发一次fullgc</p>
<p>9 * 14 = 126秒一次full gc</p>
<p>本质：<br>有对象在young gc时未被清理干净。<br>触发空间担保，动态年龄判断，15次<br>进入了老年代。</p>
<ul>
<li>解决之道：</li>
</ul>
<p>对象尽量在 young gc阶段回收掉。</p>
<p>堆最小是物理内存的64份之一，最大是物理内存的4分之一。</p>
<p>oop<br>java对象在JVM中的存在形式</p>
<pre><code>opp-klass模型
</code></pre><p>两种对象内存结构<br>条虫</p>
<p>计算三种类型的对象<br>开启指针压缩<br>关闭指针压缩<br>指针压缩<br>实现原理<br>32G瓶颈<br>如何扩展<br>JDK源码，OS源码<br>何为JVM调优</p>
<ol>
<li>预估调优</li>
<li>小规模调优</li>
<li>OOM,full gc频繁<br>调什么？</li>
<li>方法区</li>
<li>虚拟机栈</li>
<li>堆区</li>
<li>热点代码缓冲区</li>
</ol>
<p>亿级流量预估调试实战</p>
<p>GC日志</p>
<p>减少fullgc stw时间太长。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm调优</tag>
      </tags>
  </entry>
  <entry>
    <title>【JVM深入理解系列1】JVM底层加载</title>
    <url>/2021/05/10/java/jvm/jvm_deep_1/</url>
    <content><![CDATA[<h2 id="klass模型"><a href="#klass模型" class="headerlink" title="klass模型"></a>klass模型</h2><p>java的每个类在JVM中都有一个对应的klass类实例与之对应，存储类的元信息：常量池、属性信息、方法信息</p>
<p>MetaspaceObj</p>
<pre><code>Metadata
    klass
        instanceKlass
            instanceMirrorKlass买奥数java.lang.Class实例
            instanceRefKlass描述java.lang.Reference的子类
            instanceClassLoaderKlass

        ArrayKlass
            TypeArrayKlass描述java基本类型数组的数据结构
            ObjectArrayKlass描述java中引用类型数组的数据结构。
</code></pre><p>类的元信息是存储在元空间的。</p>
<p>普通的Java类在JVM对应的是instanceKlass的实例。三个类：</p>
<ol>
<li>InstanceMirrorKlass:用于表示java.lang.class, Java代码中获取到的class对象，实际上是这个C++类的实例。存储在堆区，学名镜像类。</li>
<li>InstanceRefClass：用于表示Java.lang.ref.Referece的子类。</li>
<li>InstanceClassLoader:用于遍历某个加载器加载的类。</li>
</ol>
<p>Java中的数组不是静态数组类型，是动态数据类型，既是运行时期生成的，Java数组的元信息用ArrayKlass的子类来表示</p>
<ol>
<li>TypeArrayKlass:表示基本类型的数组。</li>
<li>ObjectArrayKlass:表示引用类型的数组。</li>
</ol>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>七个过程：</p>
<p>loading -&gt; verification -preparation -&gt; resolution<br>-&gt; initialization -&gt; Using -&gt; Unloading</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ol>
<li>通过类的全限定名获取存储该类的class文件。</li>
<li>解析成运行时数据，InstanceKlasss实例。存放在方法区。</li>
<li>在堆区生成该类的class对象，InstanceMirrorKlass实例。</li>
</ol>
<p>程序怎么写都可以。只要满足上面三个效果就OK。改写OpenJdk源码，满足上面三个条件就Ok</p>
<ul>
<li>何时加载</li>
</ul>
<p>主动使用时</p>
<ol>
<li>new, getstatic, putstatic, invokestatic</li>
<li>反射</li>
<li>初始化一个类的子类去加载其父类。</li>
<li>启动类（main函数所在类）</li>
<li>当使用JDK1.7动态语言时，如果一个java.lang.invoke.MethodHandler实例最后的解析结果。REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先触发其初始化。</li>
</ol>
<ul>
<li>预加载：包装类，String, Thread</li>
</ul>
<p>因为没有指明必须从哪里获取class文件，脑洞大开的工程师开发了这些：</p>
<ol>
<li>从压缩包中读取，jar，war</li>
<li>从网络中读取，web applet</li>
<li>动态生成，如 动态代理，CGLIB</li>
<li>由其他文件生成，如JSP</li>
<li>从数据库读取。</li>
<li>从加密文件中读取</li>
</ol>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><ol>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ol>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为静态变量分配内存，赋初值。<br>实例变量是在创建对象的时候完成赋值的，没有赋初值一说。</p>
<p>int,long,short,char,byte,boolean,float,double,reference</p>
<p>如果被final修饰，在编译的时候会给属性添加ConstantValue属性，准备阶段直接完成赋值，既没有赋初值这一说。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>将常量池中的符号引用转为直接引用</p>
<p>解析后的信息存储在ConstantPoolCache类实例中</p>
<ol>
<li>类或接口的解析。</li>
<li>字段解析</li>
<li>方法解析</li>
<li>接口方法解析</li>
</ol>
<ul>
<li>何时解析</li>
</ul>
<p>思路：</p>
<ol>
<li>加载阶段解析常量池时</li>
<li>用的时候</li>
</ol>
<p>openjdk是第二种思路，在执行特定的字节码指令之前进行解析：</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>执行静态代码块，完成静态变量的赋值。<br>静态字段，静态代码段，字节码层面会生成clinit方法。<br>方法中语句的先手顺序与代码的编写顺序相关。</p>
<h2 id="类加载细节"><a href="#类加载细节" class="headerlink" title="类加载细节"></a>类加载细节</h2><p>有空了再补`</p>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm调优</tag>
      </tags>
  </entry>
  <entry>
    <title>【JVM深入理解系列5】精通垃圾回收</title>
    <url>/2021/05/11/java/jvm/jvm_deep_5/</url>
    <content><![CDATA[<h2 id="分代复制算法指针移动原理"><a href="#分代复制算法指针移动原理" class="headerlink" title="分代复制算法指针移动原理"></a>分代复制算法指针移动原理</h2><p>数据发生了移动，为什么依然能够访问到。</p>
<p>JVM四大层面</p>
<p>java语法<br>java字节码<br>openjdk原理</p>
<p>openJdk源码</p>
<h2 id="强软弱虚引用"><a href="#强软弱虚引用" class="headerlink" title="强软弱虚引用"></a>强软弱虚引用</h2><p>前提：<br>未发生GC 所有的对象都是白色。<br>发生GC时新建的对象都是hi黑色。</p>
<ul>
<li>标记阶段做的事情</li>
</ul>
<ol>
<li><p>初始化标记<br>只标记 GC Roots直接关联的对象</p>
<p>对象直接充当GC Root</p>
<p>只标记A,E 标记成灰色</p>
<p>会STW，耗时很少。</p>
</li>
<li><p>并发标记阶段 （三色标记）<br>不需要STW<br>耗时很久<br>将GC Roots直接关联的对象所有引用链全部跑一遍<br>一层一层遍历，正常所有被标记的都会变成黑色。</p>
</li>
</ol>
<ul>
<li>三色标记</li>
</ul>
<p>GC:<br>串行<br>用户线程会STW<br>一个Thread执行gc<br>并行<br>用户线程STW,多个GC线程运行<br>并发<br>不需要STW,用户线程，GC线程并发。（需要三色标记）</p>
<ol start="3">
<li>最终标记</li>
</ol>
<p>并发标记会带来三个问题</p>
<ol>
<li>多标<br>A-&gt;B-C  A是黑色，B是灰色，C是白色，此时 A不引用B了。B还是灰色，没有变成黑色。 不会被回收。</li>
<li><p>少标<br>标记程序在运行的过程中，用户线程依然创建对象。</p>
<p>由于是新创建的所以是黑色的。<br>创建的对象会躲过这次GC,但是下次GC有可能会被回收。</p>
</li>
<li><p>漏标<br>GC标记程序运行过程中，引用链发生改变。</p>
<p>B（灰）对D引用取消了。<br>A（黑）引用了D.<br>这个会导致D被回收，执行就会报错。</p>
</li>
</ol>
<p>解决方法：增量更新，原始快照。</p>
<p>多标和少标在下轮GC会被回收掉。</p>
<p>如何解决漏标：</p>
<ol>
<li><p>当黑色对象直接引用了一个白色对象后，我们就将这个黑色对象记录下来（加入 oopMap)，在扫描完成后，重新对这个黑色对象扫描,这个就是<strong>增量更新</strong>（Incremental Update）</p>
</li>
<li><p>当删除了灰色对象到白色对象的直接或间接引用后，就将这个灰色对象记录下来，再以此灰色对象为根，重新扫描一次。这个就是<strong>原始快照</strong>（Snapshot At TheBeginning，SATB）</p>
</li>
</ol>
<ul>
<li>读写屏障</li>
</ul>
<p>原方法write</p>
<p>在执行前加上 pre_write,在执行之后执行 post_write。</p>
<h2 id="核心垃圾回收期"><a href="#核心垃圾回收期" class="headerlink" title="核心垃圾回收期"></a>核心垃圾回收期</h2><p>现在的垃圾回收期发展趋势：模块化，支持并发。<br>默认 Parallel Scvenge，Parallel Old</p>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>分代<br>写屏障 + 增量更新</p>
<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>基于region 默认2M，4M,8M,16,32M</p>
<p>2048个Regin<br>每个 region都可以是e,f,to老年代，但是一个region只能有一个角色。</p>
<p>控制耗时</p>
<p>Garbege First == G1</p>
<p>为什么耗内存？<br>20% - 30% 内存存一些数据结构。<br>优先队列维护一个 Region优先级数据。每次回收10ms。能回收几个region算几个。</p>
<p>空间换时间。</p>
<ul>
<li>记忆集与卡表</li>
</ul>
<p>首先跨代引用的问题？</p>
<p>存在跨代引用时，在进行YGC时，如果young generation的Y对象被old generation中O对象引用，那么称O对象存在跨代引用，而且Y对象应该在本次垃圾回收中存活下来，所以old generation的对象在YGC时也是Strong root的一部分，如果每次YGC都去扫描old generation中所有对象的话，肯定会非常耗时。</p>
<p>解决跨代引用<br>老年代引用新生代。<br>YGC时候对象被回收了。老年代会报错<br>新生代引用老年代。<br>YGC时候，也要扫描整个老年代，非常耗时。</p>
<p>记忆集：GenRemSet<br>卡表：CardTable</p>
<p>记忆集是一个理论，卡表是实现。</p>
<ul>
<li><p>卡表的实现原理<br>每个Region 2M.<br>卡表<br>卡页</p>
<p>卡表中有2048个卡页</p>
<p>一个卡页对应一个Region<br>一个卡页是512B</p>
<p>卡页中的一个B标识Region中的4KB(2M/512)<br>00000001<br>标记这个region是否有对年轻代的引用。</p>
</li>
</ul>
<p>如果没有记忆集：<br>需要遍历所有的老年代的region,遍历所有region中的所有对象。</p>
<p>说白了，记忆标记了某个region是否有引用年亲代引用，然后只遍历有年轻代引用的region。减少了遍历的region数量。</p>
<ul>
<li>savePoint</li>
</ul>
<p>安全点：</p>
<p>150 + 90 + 275 - 40 = </p>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm调优</tag>
      </tags>
  </entry>
  <entry>
    <title>【JVM深入理解系列4】精通String</title>
    <url>/2021/05/11/java/jvm/jvm_deep_4/</url>
    <content><![CDATA[<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>String s2 = “dd” + new String(“test”);<br>四个 string<br>3个char</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>UseCompressedoops<br>压缩的是对象指针的长度</p>
<p>UseCompressedClassPointers<br>压缩的是klass对象指针的长度</p>
<p>如果不压缩，则在arrayOopDesc中声明的非静态字段之后分配，如果压缩，它将占用oopDesc中_klass字段的后半部分。</p>
<ul>
<li><p>数组长度怎么算</p>
<p>数组<br>对应的klass是：TypeArrayKlass实例<br>对应的oop：TypeArrayOop</p>
<p>对象的内存布局</p>
<pre><code>对象头
    mark word
    klass pointer

实例数据
填充
</code></pre><p>不开启解压的情况：<br>Mark word 8B<br>klass point<br>metadata._compressed_klass<br>数组长度4B</p>
<pre><code>这种情况下，klass + 数组长度用了多少字节
    12 = 8 + 4

开启压缩的情况下：
_metadata._compressed_klass 数组长度4B
klass + 数组长度= 4 + 4 = 8B
</code></pre></li>
</ul>
<p>=====</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>可重入锁很像 lock + 1 unlock -1 计数==0<br>释放</p>
<p>对象存活依据</p>
<ul>
<li><p>引用计数</p>
<p>例外，无法处理循环依赖。</p>
<p>初始化死锁</p>
</li>
<li><p>可达性分析</p>
<p>GC Roots<br>oop<br>局部变量表<br>字符串常量池</p>
</li>
</ul>
<p>JVM的GC</p>
<p>给存活的对象打标机，回收没有标记的对象。</p>
<h2 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h2><ul>
<li><p>内存分配算法<br>指针碰撞（openJdk, 无限CAS-失败就是已经被使用了 )</p>
<p>空闲列表：维护一个表存放 已用，空闲，已回收 描述。</p>
</li>
</ul>
<ol>
<li><p>Memory Pool内存池<br>管理内存块。<br>list<memorychunk *> m_chunks;<br>是一个列表，存放所有向OS申请的内存块。</memorychunk></p>
<ul>
<li><p>能做的事情<br>向OS要内存<br>mall哦错，calloc<br>释放内存<br>没有垃圾回收器，需要手动释放</p>
<p>其他<br>打印chunk信息</p>
</li>
</ul>
</li>
<li><p>Memory chunk<br>直接持有内存</p>
</li>
<li><p>Memory Cell<br>chunk中的单元。内存块。</p>
</li>
</ol>
<p>Memory Pool</p>
<ol>
<li>根据要的内存对齐后计算出要申请的内存大小。</li>
<li>向操作系统申请内存。</li>
<li><p>根据不同的垃圾回收算法填充不同的list<br>标记清除，标记-整理，回收的是整个chunk.</p>
<pre><code>m_avaliable_table
m_used_table
</code></pre><p> 分代+复制算法，</p>
<pre><code>空闲
可用
已用
待交换
</code></pre></li>
</ol>
<ul>
<li><p>标记-清除算法<br>面向整个堆<br>产生碎片</p>
<p>如果你需要分配大对象，需要连续的空间。但是内存是碎片化的。</p>
</li>
<li><p>标记-整理算法<br>内存碎片合并<br>老年代基本属于这个算法。</p>
<p>合并内存，解决碎片问题。<br>耗CPU</p>
</li>
</ul>
<pre><code>Eden区，对象朝生夕死。碎片很多。
碎片很多，合并碎片的时候需要STW。

合并碎片的时候有两种对象需要处理：
    1. 这个空间已被释放。直接合并
    2. 这个空间的空间未被释放
        对象搬家（合并内存，数据移动，指针移动）
</code></pre><ul>
<li>分代-复制算法<br>JVM使用这个算法，解决标记合并碎片消耗性能过高、GC停止用户线程过长问题。<br>举例<ol>
<li>将内存分段。 一半用（0-10） from，一半闲（11-20）to</li>
<li>发生GC的时候不需要整理，交换空间标记，角色切换。<br>标记<br>角色切换<br>原先from区的内存处理<br>标记的对象清理。存活的对象需要移动到新的内存区域（to 区）<br>数据整理<br>指针整理</li>
</ol>
</li>
</ul>
<p>注意：<br>不管现在的9种垃圾回收器，还是以后出现的垃圾回收器，都是这三种垃圾回收算法。</p>
<p>指针移动，老的指针地址不能变，这个怎么做到？(对象的hashCode不变)<br>指针是动态计算出来的。<br>公式依赖的变量在变。</p>
<p>return (pvoid)((ulong)chunk-&gt;get_data() + get_start()* chunk-&gt;get_align_size() )<br>卡表，记忆集</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>内存池，JVM不需要手动释放内存，由垃圾回收器自动回收。</p>
<p>自动回收算法</p>
<p>标记-清除算法。面向整个堆，会产生碎片，在申请大对象时候，会有问题。</p>
<p>标记-整理算法。老年代常用，会在标记清理后整理内存，但是CPU耗费太大，STW时间会比较长。<br>标记，清理，数据整理，指针整理。</p>
<p>数据块(chunk cell)整理过程<br>从前到后合并一次<br>从后到前合并一次<br>分代-复制<br>解决整理算法性能太低，而且新生代的特点是朝生夕死。</p>
<pre><code>不需要清理，只需要转移数据和指针切换 from,to角色

问题：  
    指针切换了以后为什么可以访问？
    hashcode会一直变。运行时计算出来的，所以没影响。
</code></pre><p>PS:对象模型，为什么要字节对齐。8B<br>CPU提升速率。<br>CPU读是 4</p>
<pre><code>当数据从1字节开始的时候，问题很复杂，首先先将前4个字节读到寄存器，并再次读取4-7字节的数据进寄存器，接着把0字节，4,6,7字节的数据剔除，最后合并1,2,3,4字节的数据进寄存器，对一个内存未对齐的寄存器进行了这么多额外操作，大大降低了CPU的性能。
但是这还属于乐观情况，上文提到内存对齐的作用之一是平台的移植原因，因为只有部分CPU肯干，其他部分CPU遇到未对齐边界就直接罢工了。
</code></pre>]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm调优</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM调优系列1:ZGC详解</title>
    <url>/2022/10/26/java/jvm_tuning/tuning_1/</url>
    <content><![CDATA[<ul>
<li>逃逸分析</li>
<li>标量替换</li>
<li><p>栈上分配</p>
</li>
<li><p>锁消除</p>
</li>
<li>锁粗化</li>
</ul>
<h2 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h2><p>JVM 语言无关性<br>字节码执行</p>
<pre><code>- 解释执行
- 即时编译 JIT
</code></pre><p>JIT是编译成本地字节码。非java字节码，是机器直接运行的本地编码，可能是汇编等。</p>
<p><img src="https://images.lilhui.com/7e6500afac4a1919f2d8d780657aa187" alt="图片"></p>
<h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>C1 class -&gt; 本地编码（不做优化）<br>C2 性能优化</p>
<ul>
<li>热点探测技术<ul>
<li>方法内联<br>热点探测技术<br>方法体大小限制</li>
<li>栈上分配</li>
</ul>
</li>
</ul>
<p>C2比较难维护，Java 10 以后开发了新的Graal（java写的）</p>
<ul>
<li>分层编译</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>调优</tag>
        <tag>jvm</tag>
        <tag>ZGC</tag>
      </tags>
  </entry>
  <entry>
    <title>【JVM深入理解系列6】OOM调优</title>
    <url>/2021/05/11/java/jvm/jvm_deep_6/</url>
    <content><![CDATA[<h2 id="JVM-OOM"><a href="#JVM-OOM" class="headerlink" title="JVM OOM"></a>JVM OOM</h2><ul>
<li>堆区<br>Heap</li>
<li>方法区<br>Per</li>
<li>栈区<br>StackOverFlow</li>
</ul>
<h2 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h2><p>调优参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:MetaspaceSize=10m</span><br><span class="line">-XX:MaxMetaspaceSize=10m</span><br></pre></td></tr></table></figure>
<p>1、最大、最小设置成一样大。<br>2、程序运行起来后，通过visualVM、arthas查看占用了多少内存，向上调优，预留20%以上的空间。</p>
<h2 id="虚拟机堆"><a href="#虚拟机堆" class="headerlink" title="虚拟机堆"></a>虚拟机堆</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 1344K-&gt;320K(2048K)] 7894K-&gt;7118K(9216K), 0.0071516 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </span><br><span class="line"></span><br><span class="line">[GC类型 (GC原因) [新生代垃圾收集器: gc前新生代的内存使用情况-&gt;gc后新生代的内存使用情况(新生代总内存)] gc前堆内存的使用情况-&gt;gc后堆内存的使用情况(堆总内存), gc耗时] [Times: gc阶段用户空间耗时 gc阶段内核空间耗时, gc阶段实际耗时] </span><br><span class="line"></span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 320K-&gt;0K(2048K)] [ParOldGen: 6798K-&gt;5930K(7168K)] 7118K-&gt;5930K(9216K), [Metaspace: 9296K-&gt;9233K(1058816K)], 0.6733958 secs] [Times: user=1.76 sys=0.00, real=0.68 secs] </span><br><span class="line"></span><br><span class="line">[GC类型 (GC原因) [新生代垃圾收集器: gc前新生代的内存使用情况-&gt;gc后新生代的内存使用情况(新生代总内存)] [老年代垃圾收集器: gc前老年代的内存使用情况-&gt;gc后老年代的内存使用情况(新生代总内存)] gc前堆内存的使用情况-&gt;gc后堆内存的使用情况(堆总内存), [Metaspace: gc前元空间的内存使用情况-&gt;gc后元空间的内存使用情况(元空间总内存)], gc耗时] [Times: gc阶段用户空间耗时 gc阶段内核空间耗时, gc阶段实际耗时]</span><br></pre></td></tr></table></figure>
<ul>
<li>调优参数</li>
</ul>
<p>-Xms10m -Xmx10m</p>
<p>1、预留30%以上的空间<br>2、周期性看日志，重点关注full gc频率</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><ul>
<li>调优参数</li>
</ul>
<p>-Xmss200k</p>
<p>栈大小相同，栈深度不同，为什么？<br>因为栈上会分配数据。导致栈帧变大。深度会变浅。</p>
<h2 id="调优工具"><a href="#调优工具" class="headerlink" title="调优工具"></a>调优工具</h2><ol>
<li>jps</li>
</ol>
<p>-q：只显示Java进程的ID</p>
<p>-m：输出Java进程的ID + main函数所在类的名词 + 传递给main函数的参数</p>
<p>-l：输出Java进程的ID + main函数所在类的全限定名（包名 + 类名）</p>
<p>-v：输出Java进程的ID + main函数所在类的名称 + 传递给JVM的参数<br>应用：可通过此方式快速查看JVM参数是否设置成功</p>
<p>-V、hostid基本用不到，这里就不做介绍了，感兴趣的同学可以自行百度学习。</p>
<ul>
<li>如何识别Java进程</li>
</ul>
<p>jps输出的信息全是Java进程的信息，是如何做到的？</p>
<p>Java进程在创建的时候，会生成相应的文件，进程相关的信息会写入该文件中。Windows下默认理解是</p>
<ol start="2">
<li>jstate</li>
</ol>
<p>Hotspot自带的工具，通过该工具可实时了解某个进程的class、compile、gc、memory的相关信息。具体可通过该工具查看哪些信息可通过jstat -options查看.</p>
<p>为什么说是实时呢，因为底层实现是mmap，及内存映射文件</p>
<ul>
<li><p>jstat输出的这些值从哪来的<br>PerfData文件<br>Windows下默认理解是C:\Users\username\AppData\Local\Temp\hsperfdata_username<br>Linux下默认路径是/tmp/hsperfdata_username</p>
</li>
<li><p>PerfData文件</p>
</li>
</ul>
<p>1、文件创建<br>取决于两个参数<br>-XX:-/+UsePerfData<br>默认是开启的<br>关闭方式：-XX:-UsePerfData。如果关闭了，就不会创建PerfData文件<br>-XX:-/+PerfDisableSharedMem（禁用共享内存）<br>默认是关闭的，即支持内存共享。如果禁用了，依赖于PerfData文件的工具就无法正常工作了<br>2、文件删除<br>默认情况下随Java进程的结束而销毁<br>3、文件更新<br>-XX:PerfDataSamplingInterval = 50ms<br>即内存与PerfData文件的数据延迟为50ms</p>
<p>纯Java编写<br>\openjdk\jdk\src\share\classes\sun\tools\jstat\Jstat.java</p>
<p>3、jinfo<br>4、jstack<br>5、jmap<br>6、jconsole<br>7、visualVM<br>8、arthas</p>
<h3 id="Java-agent"><a href="#Java-agent" class="headerlink" title="Java agent"></a>Java agent</h3><p>1、命令行<br>2、attach</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>1、统计线程数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jstack -l 6972 | grep &apos;java.lang.Thread.State&apos; | wc -l</span><br></pre></td></tr></table></figure>
<p>2、检测死锁</p>
<p>可使用jstack、jconsle、visualVM</p>
<p>3、CPU占用过高</p>
<ol>
<li>定位到占用CPU最高的进程</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top -H -p 6290</span><br></pre></td></tr></table></figure>
<p>线程ID由十进制转成十六进制，用Python</p>
<p>jstack 6290（进程ID）|grep 18a1（线程ID，十六进制） -A 30</p>
<p>问题：<br>模拟OOM并思考如何调优<br>死锁、CPU占用过高问题排查<br>Java Agent的两种实现方式自己写DEMO  </p>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm调优</tag>
      </tags>
  </entry>
  <entry>
    <title>Druid连接池 communications link failure问题</title>
    <url>/2022/03/03/java/midware/druid_1/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>项目基于Spring boot 链接数据库用的Druid连接池1.1.16版。通过nginx代理连接数据库。数据库配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show VARIABLES like &apos;%timeout%&apos;</span><br><span class="line">        interactive_timeout 1000</span><br><span class="line">        wait_timeout 1000</span><br></pre></td></tr></table></figure></p>
<p>物理链接空闲1000秒后会进行回收。<br>druid连接池配置:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timeBetweenEvictionRunsMillis: 10000</span><br><span class="line">minEvictableIdleTimeMillis: 30000</span><br><span class="line">maxEvictableIdleTimeMillis: 84000</span><br></pre></td></tr></table></figure></p>
<p>每隔10秒回进行判断空闲时间大于30秒的，或者总存活时间大于84秒的，是否需要回收。按照道理不会有问题，但是执行后会发现druid后台的逻辑链接打开次数<br>大于逻辑链接关闭次数。两者之差，正好等于物理连接打开次数-物理链接关闭次数-1。（-1是因为配置的最小链接数量）。通过后台日志查看到会报</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Communications link failure\n\nThe last packet successfully received from the server was 3 milliseconds ago. The last packet sent successfully to the server was 4 milliseconds ago.; nested exception is com.mysql.cj.jdbc.exceptions.CommunicationsException: Communications link failure\n\nThe last packet successfully received from the server was 3 milliseconds ago. The last packet sent successfully to the server was 4 milliseconds ago.</span><br></pre></td></tr></table></figure>
<p>看着很难受，也影响使用。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>druid通过MySqlValidConnectionChecker类进行链接健康检查。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>   <span class="title">MySqlValidConnectionChecker</span></span>&#123;</span><br><span class="line">    <span class="comment">//其他方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configFromProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        String property = properties.getProperty(<span class="string">"druid.mysql.usePingMethod"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"true"</span>.equals(property)) &#123;</span><br><span class="line">            setUsePingMethod(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"false"</span>.equals(property)) &#123;</span><br><span class="line">            setUsePingMethod(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidConnection</span><span class="params">(Connection conn, String validateQuery, <span class="keyword">int</span> validationQueryTimeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (conn.isClosed()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (usePingMethod) &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn <span class="keyword">instanceof</span> DruidPooledConnection) &#123;</span><br><span class="line">                conn = ((DruidPooledConnection) conn).getConnection();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (conn <span class="keyword">instanceof</span> ConnectionProxy) &#123;</span><br><span class="line">                conn = ((ConnectionProxy) conn).getRawObject();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (clazz.isAssignableFrom(conn.getClass())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (validationQueryTimeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    validationQueryTimeout = DEFAULT_VALIDATION_QUERY_TIMEOUT;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ping.invoke(conn, <span class="keyword">true</span>, validationQueryTimeout * <span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                    Throwable cause = e.getCause();</span><br><span class="line">                    <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> SQLException) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> (SQLException) cause;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String query = validateQuery;</span><br><span class="line">        <span class="keyword">if</span> (validateQuery == <span class="keyword">null</span> || validateQuery.isEmpty()) &#123;</span><br><span class="line">            query = DEFAULT_VALIDATION_QUERY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="keyword">if</span> (validationQueryTimeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                stmt.setQueryTimeout(validationQueryTimeout);</span><br><span class="line">            &#125;</span><br><span class="line">            rs = stmt.executeQuery(query);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtils.close(rs);</span><br><span class="line">            JdbcUtils.close(stmt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查链接是否存活。默认是用的internalPing方法。这个方法会一直返回true 当达到mysql的wait_timeout后。数据库将物理链接关闭，druid端还认为可用。<br>这就有问题了。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>使用validationQuery进行检查。<br>配置方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 增加yml配置</span><br><span class="line">validationQuery: select &apos;x&apos;</span><br><span class="line">2.  启动时参数带上</span><br><span class="line">    -Ddruid.mysql.usePingMethod=false</span><br><span class="line">    或者在druid配置类上加入：</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void setProperties()&#123;</span><br><span class="line">        System.setProperty(&quot;druid.mysql.usePingMethod&quot;,&quot;false&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>druid</category>
      </categories>
      <tags>
        <tag>druid</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程系列：volatile关键字</title>
    <url>/2017/10/25/java/multithread/multithread_1/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生下的Java虚拟机 GraalVM</title>
    <url>/2022/10/27/java/jvm_tuning/tuning_2/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>java 的编译器<br>C1,C2<br>C1不进行优化，C2会进行优化。热点代码缓存,JIT等等。</p>
<p>C2 C++写的，太复杂，不维护，而且有bug<br>java语言一直在进步，C2没有办法维护，需要一种新的编译器来进行支持，所以有了GraalVM</p>
<ul>
<li><p>事实<br>JIT,性能优化、垃圾回收等代表的特性需要一段时间来达到最佳性能。<br>java是面向大规模、长时间的服务应而设计。</p>
</li>
<li><p>矛盾<br>  微服务时代对启动速度、达到高性能的时间提出了新的要求。</p>
</li>
</ul>
<h3 id="问题根源"><a href="#问题根源" class="headerlink" title="问题根源"></a>问题根源</h3><p>Java离不开虚拟机（JVM)</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>革命派：</strong> 直接而干掉Java和Java生态。（Golang的诞生）<br><strong>保守派：</strong> 保留原有主流Java生态和技术资产，朝着微服务、云原生环境靠拢（GraalVM)</p>
<h2 id="GraalVM的技术"><a href="#GraalVM的技术" class="headerlink" title="GraalVM的技术"></a>GraalVM的技术</h2><p><strong>AOT技术：</strong> ahead of time</p>
<p>编译成native代码花费时间太大，这部分时间无法节省，所以引入AOT，减少这部分时间。</p>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul>
<li>C++<br>  微软的Stackless模式单台1000万个链接。<br>  腾讯微信团队：libco</li>
<li>Java<br>  JVM（Loom:fibers轻量级用户线程）<br>  基于JNI<br>  操控字节码</li>
</ul>
<h2 id="GraalVM介绍"><a href="#GraalVM介绍" class="headerlink" title="GraalVM介绍"></a>GraalVM介绍</h2><p>C2编译器比较缓和，GraalVM比较激进</p>
<p><img src="https://images.lilhui.com/a0c5bf2ee63b97dcd762ee4843e6a734" alt="图片"></p>
<p>JVMCI: JVM compile interface</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>GraalVM</tag>
      </tags>
  </entry>
  <entry>
    <title>【代码审查系列1】CODE REVIEW机制目标规划</title>
    <url>/2019/06/04/article/codereview/article_1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>代码审查是软件生产过程中用于把控软件质量的一种方式。通常的目的是查找系统缺陷，保证软件总体质量和提高开发者自身水平。如何建立长远的审核机制，以保证代码的持续健康优化，是个相对复杂的过程。本文对代码审查的规划做一个简单的分析。</p>
</blockquote>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>代码规范化</li>
<li>更好的设计</li>
<li>技术成长</li>
</ul>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>通过制度和规范的手段对代码审核进行合理化推行，在执行的潜移默化中落实到实际操作 最终在团队变更或者其他事物发生变迁的情况下依然能够完整执行并且收效。</p>
<h2 id="目前的状态"><a href="#目前的状态" class="headerlink" title="目前的状态"></a>目前的状态</h2><p>当前项目的状态是：项目小，数量多，项目人员分散。  </p>
<p>外部环境的状态：需求不定期加入，维护性工作不定期进行。  </p>
<p>内部人员状态：<br>对于老员工来讲，习惯旧有的思考方式和做事方式。<br>对社招新员工来讲，带着之前的思维方式做事风格，还在适应新环境中。<br>对于校招员工来讲规则尚未建立，接受新鲜事物规则较快。</p>
<h2 id="推行面临的问题"><a href="#推行面临的问题" class="headerlink" title="推行面临的问题"></a>推行面临的问题</h2><ul>
<li>时间不够<br>  应对措施：在开发计划制定时预留1-2天时间进行review。</li>
<li>需求变化<br>  应对措施：在需求变化后重新进行review.</li>
<li>人员态度<br>  应对措施：局部某个项目开始进行review，养成习惯，各个击破。进而扩展到整体团队review</li>
</ul>
<h2 id="目标分解"><a href="#目标分解" class="headerlink" title="目标分解"></a>目标分解</h2><h3 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h3><ul>
<li>完成代码规范<ul>
<li>CODE REVIEW习惯养成<br>CODE REVIEW机制建立初始化，团队内部养成习惯，作为工作的一部分。</li>
</ul>
</li>
</ul>
<h3 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h3><ul>
<li>更好的设计<ul>
<li>发现隐藏缺陷Bug<br>发现并尽量避免隐藏Bug的发生，对不合理的设计进行重新评审。</li>
</ul>
</li>
</ul>
<h3 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h3><ul>
<li>技术成长<ul>
<li>REVIEWER能力的提升<br>提升代码审查的效率和准确率。</li>
<li>CODER的技术提升<br>提升代码设计的质量</li>
</ul>
</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="http://note.youdao.com/noteshare?id=7c240547861df502ea232411563f2153" target="_blank" rel="noopener">审查类型和选择方式</a></li>
</ul>
<h2 id="代码审查执行方法"><a href="#代码审查执行方法" class="headerlink" title="代码审查执行方法"></a>代码审查执行方法</h2><ul>
<li><a href="http://note.youdao.com/noteshare?id=ca823b51d2e0bf44b5ddbc2ac3f0ec5a" target="_blank" rel="noopener">代码审查执行方法</a></li>
</ul>
<h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><ul>
<li><a href="http://note.youdao.com/noteshare?id=767a7fea1df64b72d5e06ffe9f3da103" target="_blank" rel="noopener">注释模板设置方式</a></li>
</ul>
<ul>
<li><a href="http://note.youdao.com/noteshare?id=79263de59433b0f710641c1966ca8785" target="_blank" rel="noopener">代码审查清单</a></li>
</ul>
]]></content>
      <categories>
        <category>技术之外</category>
      </categories>
      <tags>
        <tag>代码审查</tag>
        <tag>CODEREVIEW</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列：概况</title>
    <url>/2017/10/25/java/patterndesign/parterndesign_0/</url>
    <content><![CDATA[<h3 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h3><blockquote>
<p>设计模式是对于Java变成过程中遇到的特定抽象场景总结出的一套通用方法,常用的用23种几年模式。</p>
</blockquote>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>总体来说设计模式分为三大类：</p>
<ul>
<li>创建型模式，共五种： <ol>
<li>工厂方法模式<br> 定义一个创建对象的接口，让子类决定将哪一个类实例化。使一个类实例化延迟到子类。</li>
<li>抽象工厂模式<br> 提供一个创建一系列产品或相互依赖对象接口无需指定具体的类。 </li>
<li>单例模式<br> 保证一个类仅有一个实例，并提供一个访问它的全局访问。</li>
<li>建造者模式<br> 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</li>
<li>原型模式<br> 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。</li>
</ol>
</li>
<li>结构型模式，共七种：<ol>
<li>适配器模式<br> 将一个类的接口转换成客户希望的另一个接口，Adapter使原本由于接口不兼容而不能正常工作的类可以正常工作。</li>
<li>装饰器模式<br> 动态地给一个对象添加一些额外的职责，就扩展功能而言，它比生成子类方式更加灵活。</li>
<li>代理模式<br> 为其他对象提供一个代理以控制对这个对象的访问。</li>
<li>外观模式<br> 为子系统中的一组接口提供一个一致的界面，Facade模式定义一个高层接口，这个接口使得这一子系统更加容易使用。</li>
<li>桥接模式<br> 将抽象部分与实现部分分离，使它们可以独立变化。</li>
<li>组合模式<br> 将对象组合成树形结构以表示 “部分-整体”的层次结构。它使得客户对单个对象和符合对象的使用具有一致性。</li>
<li>享元模式<br> 运用共享技术有效支持大量细粒度对象。</li>
</ol>
</li>
<li>行为型模式，共十一种：<ol>
<li>策略模式<br> 定义一系列算法，把他们封装起来，并且使它们可以相互替换，本模式使得算法的变化可以独立与使用它的客户端。</li>
<li>模板方法模式<br> 定义一个操作中的算法骨架，而将一些步骤延迟到子类，Template Method使得子类可以不改变一个算法结构即可重新定义该算法某些特定步骤。</li>
<li>观察者模式<br> 定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。</li>
<li>迭代器模式<br> 提供一种方法顺序访问一个聚合对象中各个元素而又不暴露该对象内部表示。</li>
<li>责任链模式<br> 为接触请求的发送者和接受者之间的耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条连传递该请求，知道有一个对象处理。</li>
<li>命令模式<br> 将一个请求封装为一个对象，从而使可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可取消操作。</li>
<li>备忘录模式<br> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象回复到保存的状态。</li>
<li>状态模式<br> 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎属于一个新的类。</li>
<li>访问者模式<br> 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</li>
<li>中介者模式<br>用一个中介对象来封装一系列对象交互，中介者使各对象不需要显示的相互引用，从而使得其耦合松散，而且可以独立的改变他们之间的交互。</li>
<li>解释器模式<br>给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中句子。<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3></li>
</ol>
</li>
</ul>
<ol>
<li>开闭原则（Open Close Principle）<br> 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。</li>
<li>里氏代换原则（Liskov Substitution Principle）   <ol>
<li>子类的能力必须大于等于父类，即父类可以使用的方法，子类都可以使用。</li>
<li>返回值也是同样的道理。假设一个父类方法返回一个List，子类返回一个ArrayList，这当然可以。<br>如果父类方法返回一个ArrayList，子类返回一个List，就说不通了。这里子类返回值的能力是比父类小的。</li>
<li>还有抛出异常的情况。任何子类方法可以声明抛出父类方法声明异常的子类。<br>而不能声明抛出父类没有声明的异常。<br>一句话理解：所有使用父类的地方都可以被子类替换</li>
</ol>
</li>
<li>依赖倒转原则（Dependence Inversion Principle）<br> 面向接口编程，依赖于抽象而不依赖于具体。</li>
<li>接口隔离原则（Interface Segregation Principle）<br> 使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，<br> 从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</li>
<li>迪米特法则（最少知道原则）（Demeter Principle）<br>一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</li>
<li>合成复用原则（Composite Reuse Principle）<br> 当聚合和继成都可以实现时候，应该使用聚合。聚合由于继承。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>上面提到的23种是经典和常用的模式。在实际生产中按照需求总结提取使用。有利于提高代码和程序功能的扩展维护性。然而也不能一味的以使用模式而是用，这就本末倒置了。随着更深入的理解和学习设计模式，会渐渐意识到：设计模式<br>真正的的模式是 “无模式”。看似无招胜似有招。</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列：单例模式</title>
    <url>/2017/10/23/java/patterndesign/parterndesign_1/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>单例模式，顾名思义就是在Java应用中，类的实例保证只有一个在JVM中。他有几个好处</p>
<ul>
<li>减少创建开销</li>
<li>减少内存使用频率，GC压力</li>
<li>保证流程独立</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="第一种-饿汉法"><a href="#第一种-饿汉法" class="headerlink" title="第一种 饿汉法"></a>第一种 饿汉法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSignleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码简单，但是无法延迟加载。</p>
<h4 id="第二种-单线程安全"><a href="#第二种-单线程安全" class="headerlink" title="第二种 单线程安全"></a>第二种 单线程安全</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式可以实现基本要求，但是在多线程情况下就会出现可能New出多个实例的情况。由此引入synchronized关键字，我们有如下实现：</p>
<h4 id="第三种-多线程安全"><a href="#第三种-多线程安全" class="headerlink" title="第三种 多线程安全"></a>第三种 多线程安全</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;  </span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方法引入了syncronized 关键字，在调用getInstance方法的时候进行了并发处理。然而在多线程情况下仍然有问题<br>情况如下：  </p>
<pre><code>a&gt;A、B线程同时进入了第一个if判断
b&gt;A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton();
c&gt;在new对象的过程中，由于JVM的优化，指令进行重排序，JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块。
d&gt;B进入synchronized块，由于instance此时不是null，因此它马上离开了synchronized块并将结果返回给调用该方法的程序。
e&gt;此时B线程打算使用Singleton实例，却发现它没有被初始化，于是错误发生了。
</code></pre><p>这里引入volatile关键字禁止对instance操作的指令重排。</p>
<h4 id="第四种-多线程安全”多重锁检查””"><a href="#第四种-多线程安全”多重锁检查””" class="headerlink" title="第四种 多线程安全”多重锁检查””"></a>第四种 多线程安全”多重锁检查””</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;  </span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法就是有名的DCL的单利模式。基本已经完善多线程下的单例模式。需要提醒的是， volatile屏蔽指令重排的语义在JDK 1.5中才被修复，所以JDK1.5之前的JAVA无法使用这一方式。</p>
<h4 id="第五种-静态内部类方法"><a href="#第五种-静态内部类方法" class="headerlink" title="第五种 静态内部类方法"></a>第五种 静态内部类方法</h4><p>静态类方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">         </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类只加载一次，所以这中方式也是线程安全的。<br>不过以上的方法都存在一些问题：</p>
<ul>
<li>进行序列化时需要额外的工作进行序列化(Serializable,transient,readResolve())等操作。否则每次序列化都是创建一个新的实例。</li>
<li>构造器虽然是私有的，但是还是可以通过反射来强行调用创建实例。一个方法是在构造器里判断已经创建过实例抛异常。<br>如何更优雅地解决以上两个缺陷呢，我们可以使用枚举单例。</li>
</ul>
<h4 id="第六种-枚举方法"><a href="#第六种-枚举方法" class="headerlink" title="第六种 枚举方法"></a>第六种 枚举方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举不仅线程安全，防止反射强行调用构造器外。还提供了自动化序列机制，繁殖序列化的时候创建新对象。<br>更接近与”完美”的单利模式。</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>程序执行时候只需要一个实例执行的时候就可以用单例来：经典的场景有:<br>线程池，驱动管理，通用的计算模块，工具类代码等等</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>单例模式既熟悉，又陌生。看起来简单的功能，算法，要写好，无瑕疵，还是需要很大专研精神。避免遇到快很多坑。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
        <category>单例</category>
      </categories>
      <tags>
        <tag>设计模式，单例</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列：建造者模式</title>
    <url>/2017/10/25/java/patterndesign/parterndesign_4/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>当要创建的对象相对复杂，可以将复杂对象的创建过程分离成若干过程。此时只要改变不同过程中的参数就可以产生不同的实例。</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1510133972021.png?imageView2/2/w/593/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>Builder<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildProductPartA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildProductPartB</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildProductPartC</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">buildProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Director<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">constructProduct</span><span class="params">(Builder productBuilder)</span></span>&#123;</span><br><span class="line">        productBuilder.buildProductPartA();</span><br><span class="line">        productBuilder.buildProductPartB();</span><br><span class="line">        productBuilder.buildProductPartC();</span><br><span class="line">        <span class="keyword">return</span> productBuilder.buildProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProductBuilder<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildProductPartA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildProductPartB</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildProductPartC</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">buildProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Product<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Client<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Director director = <span class="keyword">new</span> Director();</span><br><span class="line">        director.constructProduct(<span class="keyword">new</span> ProductBuilder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>我们看饮料机的工作步骤可以分为 倒入水，倒入饮料剂，制造饮料。定义一个饮料机就可以当做建造饮料的过程。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>建造者模式的核心是把类的创建过程分解成一个个过程。每个过程是一个单独的执行流程，可以通过不同参数指定流程的结果。</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列：工厂方法模式</title>
    <url>/2017/10/25/java/patterndesign/parterndesign_2/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>工厂与一类产品的关系。用于调用端从复杂的构造逻辑中解耦。</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>简单工厂模式<br>产品：<br>Product<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProductA<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"A产品方法1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"A产品方法2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProductB<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"B产品方法1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"B产品方法2"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>工厂：<br>Factory<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(String type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SimpleFactory<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"A"</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"B"</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">            <span class="keyword">default</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>PS：这里用Java7的写法，switch支持String。
</code></pre><p>客户端：<br>Client<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Factory factory = <span class="keyword">new</span> SimpleFactory();</span><br><span class="line">        Product product = factory.createProduct(<span class="string">"A"</span>);</span><br><span class="line">        product.methodOne();</span><br><span class="line">        product.methodTwo();</span><br><span class="line">        <span class="comment">//业务代码 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>A是一个接口，它的实现由 ClassA1,ClassA2,ClassA3。<br>B是一段业务代码，需要new一个A1并且进行操作。这时候就可以用工厂模式。某天业务的修改，需操作到另外一个ClassA2的方法。在工厂类进行修改就可以了。业务端代码就不用修改。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>工厂方法模式有良好的封装性，代码结构清晰。扩展性非常优秀。在增加产品类的情况下，只要适当地修改具体或扩展工厂类即可。调用者它只需要关心产品的接口。 可以对调用端调用复杂的构造逻辑进行解耦。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
        <category>工厂方法</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列：原型模式</title>
    <url>/2017/10/25/java/patterndesign/parterndesign_5/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>原型模式是特殊的创建模式，它创建对象不通过直接new的方式产生，而是通过已有的对象复制。</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><ul>
<li>类图：</li>
</ul>
<p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1516185236989.png?imageView2/2/w/370/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<p>Product<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ProductB productB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductB <span class="title">getProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProductB</span><span class="params">(ProductB productB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productB = productB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"product name:"</span> + <span class="keyword">this</span>.name);</span><br><span class="line">        System.out.println(<span class="string">"product value:"</span> + <span class="keyword">this</span>.value);</span><br><span class="line">        System.out.println(<span class="string">"productB name:"</span> + <span class="keyword">this</span>.productB.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">deepClone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteArrayOutputStream bo = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oo = <span class="keyword">new</span> ObjectOutputStream(bo);</span><br><span class="line">            oo.writeObject(<span class="keyword">this</span>);</span><br><span class="line">            ByteArrayInputStream bi = <span class="keyword">new</span> ByteArrayInputStream(bo.toByteArray());</span><br><span class="line">            ObjectInputStream oi = <span class="keyword">new</span> ObjectInputStream(bi);</span><br><span class="line">            <span class="keyword">return</span> (Product)oi.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProductB<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Client<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> Product();</span><br><span class="line">        ProductB productB = <span class="keyword">new</span> ProductB();</span><br><span class="line">        productB.setName(<span class="string">"B"</span>);</span><br><span class="line">        product.setName(<span class="string">"X"</span>);</span><br><span class="line">        product.setValue(<span class="string">"XX"</span>);</span><br><span class="line">        product.setProductB(productB);</span><br><span class="line">        Product clone = product.deepClone();</span><br><span class="line">        clone.getProductB().setName(<span class="string">"newXX"</span>);</span><br><span class="line">        product.display();</span><br><span class="line">        clone.display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果：<br>Connected to the target VM, address: ‘127.0.0.1:58904’, transport: ‘socket’<br>product name:X<br>product value:XX<br>productB name:B<br>product name:X<br>product value:XX<br>productB name:newXX<br>Disconnected from the target VM, address: ‘127.0.0.1:58904’, transport: ‘socket’</p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><ul>
<li>类图：</li>
</ul>
<p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1516185268976.png?imageView2/2/w/194/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<p>Product<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ProductB productB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductB <span class="title">getProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProductB</span><span class="params">(ProductB productB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productB = productB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"product name:"</span> + <span class="keyword">this</span>.name);</span><br><span class="line">        System.out.println(<span class="string">"product value:"</span> + <span class="keyword">this</span>.value);</span><br><span class="line">        System.out.println(<span class="string">"productB name:"</span> + <span class="keyword">this</span>.productB.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Product)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProductB<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Client<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> Product();</span><br><span class="line">        ProductB productB = <span class="keyword">new</span> ProductB();</span><br><span class="line">        productB.setName(<span class="string">"B"</span>);</span><br><span class="line">        product.setName(<span class="string">"X"</span>);</span><br><span class="line">        product.setValue(<span class="string">"XX"</span>);</span><br><span class="line">        product.setProductB(productB);</span><br><span class="line">        Product clone = product.clone();</span><br><span class="line">        clone.getProductB().setName(<span class="string">"newXX"</span>);</span><br><span class="line">        product.display();</span><br><span class="line">        clone.display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果：<br>Connected to the target VM, address: ‘127.0.0.1:58962’, transport: ‘socket’<br>product name:X<br>product value:XX<br>productB name:newXX<br>product name:X<br>product value:XX<br>productB name:newXX<br>Disconnected from the target VM, address: ‘127.0.0.1:58962’, transport: ‘socket’</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>浅拷贝 拷贝后的对象如果有嵌套的复杂对象，那么改变嵌套对象会跟着改变。只拷贝表层的对象信息。<br>深拷贝，是所有的都拷贝，包括嵌套对象。这里的实现是通过序列化的方式实现。</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列:桥接模式</title>
    <url>/2017/11/09/java/patterndesign/patterndesign_10/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>类的继承是类本身的垂直维度变化。如果需要水平维度上的变化扩展。继承是不好实现的。这时候我们可以引入桥接方式。桥接模式的做法是把变化部分抽象<br>出来，使变化部分与主类分离开来，从而将多个维度的变化彻底分离。最后，提供一个管理类来组合不同维度上的变化，通过这种组合来满足业务的需要。</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1516184529562.png?imageView2/2/w/491/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<p>Fruit:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractFruit:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFruit</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    EatHandler eatHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractFruit</span><span class="params">(EatHandler eatHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.eatHandler = eatHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        eatHandler.handle();</span><br><span class="line">        System.out.println(<span class="string">"开始吃水果。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Apple:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">AbstractFruit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(EatHandler eatHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(eatHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enjoy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>WaterMelon:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaterMelon</span> <span class="keyword">extends</span> <span class="title">AbstractFruit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaterMelon</span><span class="params">(EatHandler eatHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(eatHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.eat();</span><br><span class="line">        System.out.println(<span class="string">"吃西瓜"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>EatHandler:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EatHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃水果前处理。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PeelHandler :<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeelHandler</span> <span class="keyword">extends</span> <span class="title">EatHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handle();</span><br><span class="line">        System.out.println(<span class="string">"削皮"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>EatHandlerDivid:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EatHandlerDivid</span> <span class="keyword">extends</span> <span class="title">EatHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handle();</span><br><span class="line">        System.out.println(<span class="string">"切块。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EatHandler eatHandler = <span class="keyword">new</span> PeelHandler();</span><br><span class="line">        EatHandler eatHandler1 = <span class="keyword">new</span> EatHandlerDivid();</span><br><span class="line">        Fruit apple = <span class="keyword">new</span> Apple(eatHandler);</span><br><span class="line">        Fruit waterMelon = <span class="keyword">new</span> WaterMelon(eatHandler1);</span><br><span class="line">        apple.eat();</span><br><span class="line">        waterMelon.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码解释：</p>
<ul>
<li>抽象部分 1：吃水果接口抽象，2.吃水果前处理抽象。</li>
<li>具体实现部分 : apple里的enjoy</li>
</ul>
<p>这里就分离了水果关于吃水果和水果处理的部分。Apple里的enjoy是具体的实现，可以eat，可以做其他操作。我们可以切换 水果处理 Handle来改变 Apple<br>enjoy具体时动作。</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>略</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>桥接的重点是 将实现解耦，抽象和实现独立开，不影响对方。<br>桥接一般用于跨多个平台的图形和窗口系统上。当需要不同的方式改变借口和实现时，可以用桥接。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列:组合模式</title>
    <url>/2017/11/09/java/patterndesign/patterndesign_11/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>组合模式是把对象堆起来形成集合的一种方式。它组织对象形成集合，结合迭代器模式，可以对客户隐藏具体对象实现。不至于暴露集合内部信息。形式上经<br>常将组合你模式用于对象的树形结构表示。</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>背景</li>
</ul>
<p>村子里面养了 鸡，鸭，本地鸭，外地鸭，猪。这些家畜都会跑。现在要将他们集合起来，进行统一管理。每天数数，防止丢失。</p>
<ul>
<li><p>抽象<br>我们可以用组合模式来进行管理这些家畜。<br>首先家畜的集合进行抽象树形结构。<br>第一层：普通家畜<br>第二层：普通家禽下有   猪，禽类<br>第三层：禽类 下面有 鸡，鸭<br>第四层：鸭子下面有 本地鸭，外地鸭。</p>
</li>
<li><p>类图</p>
</li>
</ul>
<p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1516349065490.png?imageView2/2/w/750/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1516352083222.png?imageView2/2/w/592/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<ul>
<li>对象关联图：</li>
</ul>
<p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1516349180345.png?imageView2/2/w/657/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<p>部分代码：</p>
<p>AnimalType:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.composite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.littlehui.design.iterate.AnimalIterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnimalType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnimalIterator <span class="title">createIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.composite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.littlehui.design.iterate.AnimalIterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">each</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnimalIterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.composite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.littlehui.design.iterate.AnimalIterator;</span><br><span class="line"><span class="keyword">import</span> com.littlehui.design.iterate.HomeAnimalIterator;</span><br><span class="line"><span class="keyword">import</span> com.littlehui.design.iterate.IteratorComposite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">IteratorAnimal</span> <span class="keyword">implements</span> <span class="title">AnimalType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Animal&gt; birds;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birds = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br><span class="line">        birds.add(<span class="keyword">new</span> Chicken());</span><br><span class="line">        birds.add(<span class="keyword">new</span> Duck());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鸟类跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">each</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Animal animal : birds) &#123;</span><br><span class="line">            animal.each();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnimalIterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> HomeAnimalIterator(birds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnimalIterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IteratorComposite(<span class="keyword">this</span>.iterator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.composite;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chicken</span> <span class="keyword">extends</span> <span class="title">IteratorAnimal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小鸡跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">each</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鸡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.composite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.littlehui.design.iterate.AnimalIterator;</span><br><span class="line"><span class="keyword">import</span> com.littlehui.design.iterate.HomeAnimalIterator;</span><br><span class="line"><span class="keyword">import</span> com.littlehui.design.iterate.IteratorComposite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span>  <span class="keyword">extends</span> <span class="title">IteratorAnimal</span> <span class="keyword">implements</span> <span class="title">AnimalType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Animal&gt; ducks;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ducks = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br><span class="line">        ducks.add(<span class="keyword">new</span> LocalDuck());</span><br><span class="line">        ducks.add(<span class="keyword">new</span> ForignDuck());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鸭类跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">each</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鸭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnimalIterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HomeAnimalIterator(ducks);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnimalIterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IteratorComposite(<span class="keyword">this</span>.iterator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.composite;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForignDuck</span> <span class="keyword">extends</span> <span class="title">IteratorAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"外地鸭跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">each</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"外地鸭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.composite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.littlehui.design.iterate.AnimalIterator;</span><br><span class="line"><span class="keyword">import</span> com.littlehui.design.iterate.HomeAnimalIterator;</span><br><span class="line"><span class="keyword">import</span> com.littlehui.design.iterate.IteratorComposite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeAnimal</span>  <span class="keyword">extends</span> <span class="title">IteratorAnimal</span> <span class="keyword">implements</span> <span class="title">AnimalType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Animal&gt; homeAnimals = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HomeAnimal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        homeAnimals.add(<span class="keyword">new</span> Pig());</span><br><span class="line">        homeAnimals.add(<span class="keyword">new</span> Bird());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"家养牲畜跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">each</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"家养牲畜跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnimalIterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HomeAnimalIterator(homeAnimals);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnimalIterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IteratorComposite(<span class="keyword">this</span>.iterator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.composite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.littlehui.design.iterate.AnimalIterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorAnimal</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IteratorAnimal</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">each</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnimalIterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> IteratorAnimal baseAnimal = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnimalIterator() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (baseAnimal != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Animal <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> baseAnimal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.composite;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalDuck</span> <span class="keyword">extends</span> <span class="title">IteratorAnimal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"本地鸭跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">each</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"本地鸭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.composite;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pig</span> <span class="keyword">extends</span> <span class="title">IteratorAnimal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猪在跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">each</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猪"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Client:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.composite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.littlehui.design.iterate.AnimalIterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HomeAnimal homeAnimal = <span class="keyword">new</span> HomeAnimal();</span><br><span class="line"></span><br><span class="line">        AnimalIterator homeAnimalIterator = homeAnimal.createIterator();</span><br><span class="line">        <span class="keyword">while</span> (homeAnimalIterator.hasNext()) &#123;</span><br><span class="line">            Animal animal = homeAnimalIterator.next();</span><br><span class="line">            animal.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>迭代器组合部分</li>
</ul>
<p><a href="https://github.com/littlehui/designpattern" target="_blank" rel="noopener">设计模式-组合模式</a></p>
<ul>
<li>解析<br>实际上，上面的代码分两个部分理解：<br>1：家畜动物们的关联组合<br>2：对动物们遍历的迭代组合(代码略)<br>组合模式经常会应用到迭代模式，这里也都写上了。</li>
</ul>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>HtmlPaser包，解析Html页面。就是典型的组合模式。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>组合模式关注的重点是对对象的结合方式。结合后暴露统一的接口管理。正如上所表达的，动物们集合后通过组合迭代器的方式统一暴露了一个遍历的方法口。<br>屏蔽了内部实现，调用端只需调用迭代方法就可以实现遍历管理了。有了迭代组合还可以个性化的筛选，等等趋向业务逻辑的实现。 </p>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列：抽象工厂模式</title>
    <url>/2017/10/25/java/patterndesign/parterndesign_3/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>抽象工厂模式在原有的工厂方法模式上扩展，在工厂方面进行了抽象。从而增加产品规格的需求，可以更高地抽象成增加工厂类型。降低了耦合。</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1510131441764.png?imageView2/2/w/744/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>Factory<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createSoftProduct</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createHardProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FactoryA<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactoryA</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createSoftProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"工厂A:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SoftProductA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createHardProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"工厂A:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HardProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FactoryB<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactoryB</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createSoftProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"工厂B:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SoftProductB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createHardProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"工厂B:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HardProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Product<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProductB<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我是产品B"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SoftProductB<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftProductB</span> <span class="keyword">extends</span> <span class="title">ProductB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoftProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建 产品B:特性:柔软"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getName() + <span class="string">"柔软"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>HardProductB<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HardProductB</span> <span class="keyword">extends</span> <span class="title">ProductB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HardProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建 产品B:特性:坚硬"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getName() + <span class="string">"坚硬"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProductA<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我是产品A"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SoftProductA<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftProductA</span> <span class="keyword">extends</span> <span class="title">ProductA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoftProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建 产品A:特性:柔软"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getName() + <span class="string">"柔软"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>HardProductA<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HardProductA</span> <span class="keyword">extends</span> <span class="title">ProductA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HardProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建 产品A:特性:坚硬"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getName() + <span class="string">"坚硬"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Client<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Factory factoryA = <span class="keyword">new</span> ProductFactoryA();</span><br><span class="line">        Factory factoryB = <span class="keyword">new</span> ProductFactoryB();</span><br><span class="line">        Product productAHard = factoryA.createHardProduct();</span><br><span class="line">        System.out.println(productAHard.getName());</span><br><span class="line">        Product productBHard = factoryB.createHardProduct();</span><br><span class="line">        System.out.println(productBHard.getName());</span><br><span class="line">        Product productASoft = factoryA.createSoftProduct();</span><br><span class="line">        System.out.println(productASoft.getName());</span><br><span class="line">        Product productBSoft = factoryB.createSoftProduct();</span><br><span class="line">        System.out.println(productBSoft.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>如上产品 族 A B都有两个子类型，或者说特性。Hard or Soft。如果某个时候业务需求添加产品族C。此时扩展就很方便了，只要实现产品C的工厂类，就可以。<br>不用修改原来的代码，耦合度低。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>抽象工厂<br>优点: 扩展产品族（类型）容易<br>缺点: 扩展产品族下的子产品难，需要整体结构调整。  </p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列:享元模式</title>
    <url>/2017/11/09/java/patterndesign/patterndesign_12/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>一个类的实例有多种 “虚拟实例”。 虚拟实例通过共享数据的方式存在。</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>类图：<br><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1516691836360.png?imageView2/2/w/275/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></li>
</ul>
<p>Tree:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.flyweight;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/23.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tree</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"坐标x:"</span> + x + <span class="string">"坐标y:"</span> + y + <span class="string">"年龄age:"</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.flyweight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/23.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Tree&gt; allTrees = <span class="keyword">new</span> HashMap&lt;String, Tree&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Tree <span class="title">createTree</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        String treeHash = <span class="keyword">new</span> StringBuffer().append(x).append(y).append(age).toString();</span><br><span class="line">        <span class="keyword">if</span> (allTrees.get(treeHash) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> allTrees.get(treeHash);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Tree tree = <span class="keyword">new</span> Tree(x, y, age);</span><br><span class="line">            allTrees.put(treeHash, tree);</span><br><span class="line">            <span class="keyword">return</span> allTrees.get(treeHash);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayAllTrees</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String key : allTrees.keySet()) &#123;</span><br><span class="line">            Tree tree = allTrees.get(key);</span><br><span class="line">            tree.display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.flyweight;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/23.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeManager treeManager = <span class="keyword">new</span> TreeManager();</span><br><span class="line">        Tree tree1 = treeManager.createTree(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        Tree tree2 = treeManager.createTree(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        Tree tree3 = treeManager.createTree(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"实例个数："</span> + <span class="string">"tree1, tree2, tree3"</span>);</span><br><span class="line">        System.out.println(<span class="string">"真实实例个数："</span>);</span><br><span class="line">        treeManager.displayAllTrees();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>在java应用中,会出现许多String a=”123”,String b=”123”之类的String类型的变量,如果只是小应用,到还好,假设是一个庞大的系统,有好多处都需要用定义String a=”223”,那开销可想而知,而JDK的开发者自然想到了这点,采用了享元模式解决创建大量相同String变量带来的开销问题</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>享元模式，其功能是在运行时减少实例的个数，节省内存。当一个类有许多的实例，而这些实例能被统一个方法控制到时候，可以用享元模式。</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列:策略模式</title>
    <url>/2018/01/23/java/patterndesign/patterndesign_13/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>策略模式定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>策略模式涉及到三个角色：</p>
<ul>
<li>环境(Context)角色：持有一个Strategy的引用。</li>
<li>抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li>
<li>具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。</li>
</ul>
<p>PriceStrategy:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/2/27.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PriceStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">caculaPrice</span><span class="params">(Double price)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MemberPriceStrategy:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/2/27.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberPriceStrategy</span> <span class="keyword">implements</span> <span class="title">PriceStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">caculaPrice</span><span class="params">(Double price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price * <span class="number">0.9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>VipPriceStrategy:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/2/27.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VipPriceStrategy</span> <span class="keyword">implements</span> <span class="title">PriceStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">caculaPrice</span><span class="params">(Double price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price * <span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Price:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/2/27.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Price</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Double price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Price</span><span class="params">(Double price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">cacularPrice</span><span class="params">(PriceStrategy priceStrategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> priceStrategy.caculaPrice(price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Client:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/2/27.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Price price = <span class="keyword">new</span> Price(<span class="number">5</span>D);</span><br><span class="line">        System.out.println(price.cacularPrice(<span class="keyword">new</span> VipPriceStrategy()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>策略模式的优点<br>　　（1）策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。</p>
<p>　　（2）使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。</p>
<p>策略模式的缺点<br>　　（1）客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。</p>
<p>　　（2）由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列:模板方法模式</title>
    <url>/2018/01/23/java/patterndesign/patterndesign_14/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>模板方法模式 在意个方法中定义一个算法的骨架，而将这些具体步骤实现延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中<br>的某些步骤。</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>类图：</li>
</ul>
<p><img src="https://images.lilhui.com/1c1244dfa6a432afc52fea2020aa8777" alt="图片"></p>
<ul>
<li><p>AbstractProjectDesign:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.templatemethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> AbstractProjectDesign</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/9 11:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProjectDesign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tempateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//需求分析</span></span><br><span class="line">        demandAnalysis();</span><br><span class="line">        <span class="comment">//架构设计</span></span><br><span class="line">        architecturalDesign();</span><br><span class="line">        <span class="comment">//代码编写</span></span><br><span class="line">        coding();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">demandAnalysis</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">architecturalDesign</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>PaymentProjectDesign:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.littlehui.design.templatemethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> PaymentProjectDesign</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/9 11:27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentProjectDesign</span> <span class="keyword">extends</span> <span class="title">AbstractProjectDesign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">demandAnalysis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"支付项目需求分析"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">architecturalDesign</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"支付项目的架构设计"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"支付项目的编码"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SearchProjectDesign:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.littlehui.design.templatemethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> SearchProjectDesign</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/9 11:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchProjectDesign</span> <span class="keyword">extends</span> <span class="title">AbstractProjectDesign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">demandAnalysis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"搜索项目需求分析"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">architecturalDesign</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"搜索项目架构设计"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"搜索项目编码"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Client:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.littlehui.design.templatemethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/9 11:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractProjectDesign paymentProject = <span class="keyword">new</span> PaymentProjectDesign();</span><br><span class="line">        AbstractProjectDesign searchProject = <span class="keyword">new</span> SearchProjectDesign();</span><br><span class="line"></span><br><span class="line">        paymentProject.tempateMethod();</span><br><span class="line">        searchProject.tempateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Connected to the target VM, address: <span class="string">'127.0.0.1:50695'</span>, transport: <span class="string">'socket'</span></span><br><span class="line">支付项目需求分析</span><br><span class="line">支付项目的架构设计</span><br><span class="line">支付项目的编码</span><br><span class="line">搜索项目需求分析</span><br><span class="line">搜索项目架构设计</span><br><span class="line">搜索项目编码</span><br><span class="line">Disconnected from the target VM, address: <span class="string">'127.0.0.1:50695'</span>, transport: <span class="string">'socket'</span></span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure></p>
<p>抽象类里的tempateMethod执行的是具体的业务逻辑。以一个个抽象方法呈现。以上展示的逻辑是顺序执行逻辑。<br>此外还可以加上分支，利用模板钩子的方式实现分支逻辑。在具体实现类里面进行取舍。</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>使用模板方法首先将不同业务场景分解成顺序执行的逻辑。将这些具体的逻辑抽出共性，组成抽象方法。如果有<br>具体的分支的话，利用钩子的方法进行扩展。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>模板方法重点在于定义模板类。<br>注意的点<br>1:模板类由 基本方法，模板方法，钩子方法构成。<br>2：基本方法用final修饰。表明不能修改的。其他的模板方法，钩子等用protected修饰，用于子类的集成修改。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>模板方法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列:责任链模式</title>
    <url>/2019/07/28/java/patterndesign/patterndesign_17/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>责任链模式顾名思义，它是由一连串单一职责的对象构成链式结构。此结构一般为请求接受者做前置业务处理，主要目的是<br>为发送者和接收者进行解耦。其特点是，每个对象都只处理自己成处理的请求，如果处理不了，会把请求传给下一个接收者。以此类推。</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>一个简单的日志记录链</p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="https://images.lilhui.com/6e46ca0831dd35468e408879a66d1e6d" alt="图片"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>AbstractLogger<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.responsebilitychain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> AbstractLogger</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/7/29 15:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> INFO = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> WARN = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ERROR = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">    AbstractLogger nextLogger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextLogger</span><span class="params">(AbstractLogger nextLogger)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextLogger = nextLogger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMessage</span><span class="params">(<span class="keyword">int</span> level, String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.level &lt;= level)&#123;</span><br><span class="line">            write(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nextLogger !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            nextLogger.logMessage(level, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ErrorLogger</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.responsebilitychain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> ErrorLogger</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/7/29 15:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ErrorLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Error Console::Logger: "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InfoLogger</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.responsebilitychain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> InfoLogger</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/7/29 15:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfoLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InfoLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Error Console::Logger: "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WarnLogger</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.responsebilitychain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> WarnLogger</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/7/29 15:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WarnLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WarnLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Error Console::Logger: "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.littlehui.design.responsebilitychain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Demo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/7/29 15:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AbstractLogger <span class="title">getChainOfLoggers</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        AbstractLogger errorLogger = <span class="keyword">new</span> ErrorLogger(AbstractLogger.ERROR);</span><br><span class="line">        AbstractLogger infoLogger = <span class="keyword">new</span> InfoLogger(AbstractLogger.INFO);</span><br><span class="line">        AbstractLogger warnLogger = <span class="keyword">new</span> WarnLogger(AbstractLogger.WARN);</span><br><span class="line"></span><br><span class="line">        errorLogger.setNextLogger(infoLogger);</span><br><span class="line">        infoLogger.setNextLogger(warnLogger);</span><br><span class="line">        <span class="keyword">return</span> errorLogger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractLogger loggerChain = getChainOfLoggers();</span><br><span class="line">        loggerChain.logMessage(AbstractLogger.INFO, <span class="string">"This is an information."</span>);</span><br><span class="line">        loggerChain.logMessage(AbstractLogger.WARN,</span><br><span class="line">                <span class="string">"This is a warn level information."</span>);</span><br><span class="line">        loggerChain.logMessage(AbstractLogger.ERROR,</span><br><span class="line">                <span class="string">"This is an error information."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/bin/java -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:65034,<span class="built_in">suspend</span>=y,server=n -Dfile.encoding=UTF-8 -classpath <span class="string">"/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/lib/tools.jar:/Users/littlehui/WorkSpaces/Home/pattern/out/production/responsbilitychain:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar"</span> com.littlehui.design.responsebilitychain.Demo</span><br><span class="line">Connected to the target VM, address: <span class="string">'127.0.0.1:65034'</span>, transport: <span class="string">'socket'</span></span><br><span class="line">Error Console::Logger: This is an information.</span><br><span class="line">Error Console::Logger: This is a warn level information.</span><br><span class="line">Error Console::Logger: This is a warn level information.</span><br><span class="line">Error Console::Logger: This is an error information.</span><br><span class="line">Error Console::Logger: This is an error information.</span><br><span class="line">Error Console::Logger: This is an error information.</span><br><span class="line">Disconnected from the target VM, address: <span class="string">'127.0.0.1:65034'</span>, transport: <span class="string">'socket'</span></span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure></p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul>
<li>Spring MVC的filter，Interceptor各种Handler等等</li>
<li>日志记录</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>责任链的特点是单一职责，链式结构。前提是统一的输入端。<br>在遇到复杂业务，特别是复杂请求时候。输入端是统一的，这时候就可以考虑将业务处理拆分成单一的<br>职责。再将对象链接起来。这样的好处是，解耦了接收端的处理。并且提升了扩展性能。维护也方便。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>责任链模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列:迭代器模式</title>
    <url>/2019/07/28/java/patterndesign/patterndesign_16/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>迭代器一般用于访问聚合对象内部元素。只暴露该暴露的，隐藏该隐藏的。比如隐藏掉容器内部的实现逻辑，只暴露<br>遍历的接口。</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="https://images.lilhui.com/049b3ca0b694a0b2c2b68a0cca80d180" alt="图片"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li>Iterator</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Iterator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/12 14:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>IteratorCreator</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> IteratorCreator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/12 14:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IteratorCreator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>MenuItem</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.littlehui.design.iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> MenuItem</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/12 14:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuItem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String menuName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MenuItem</span><span class="params">(String code, String menuName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.menuName = menuName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMenuName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> menuName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMenuName</span><span class="params">(String menuName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.menuName = menuName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"编码："</span> + code + <span class="string">"名称："</span> + menuName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>MenuContainer</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.iterator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> MenuContainer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/12 14:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuContainer</span> <span class="keyword">implements</span> <span class="title">IteratorCreator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuItem&gt; menuItems;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MenuContainer</span><span class="params">(List&lt;MenuItem&gt; menuItems)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.menuItems = menuItems;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MenuContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMenuItem</span><span class="params">(MenuItem menuItem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (menuItems == <span class="keyword">null</span>) &#123;</span><br><span class="line">            menuItems = <span class="keyword">new</span> ArrayList&lt;MenuItem&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        menuItems.add(menuItem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MenuContainerIterator(menuItems);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>MenuContainerIterator</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.littlehui.design.iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> MenuContainerIterator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/12 14:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuContainerIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuItem&gt; menuItemList = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentIndex = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lastIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MenuContainerIterator</span><span class="params">(List&lt;MenuItem&gt; menuItemList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.menuItemList = menuItemList;</span><br><span class="line">        lastIndex = menuItemList.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentIndex &lt; lastIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MenuItem currentItem = menuItemList.get(++currentIndex);</span><br><span class="line">        <span class="keyword">return</span> currentItem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        menuItemList.remove(currentIndex);</span><br><span class="line">        --currentIndex;</span><br><span class="line">        lastIndex = menuItemList.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Client</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/12 15:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;MenuItem&gt; menuItemList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        menuItemList.add(<span class="keyword">new</span> MenuItem(<span class="string">"CODE_1"</span>, <span class="string">"第一个菜单"</span>));</span><br><span class="line">        menuItemList.add(<span class="keyword">new</span> MenuItem(<span class="string">"CODE_2"</span>, <span class="string">"第二个菜单"</span>));</span><br><span class="line">        menuItemList.add(<span class="keyword">new</span> MenuItem(<span class="string">"CODE_3"</span>, <span class="string">"第三个菜单"</span>));</span><br><span class="line"></span><br><span class="line">        MenuContainer menuContainer = <span class="keyword">new</span> MenuContainer(menuItemList);</span><br><span class="line">        Iterator iterator = menuContainer.createIterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            MenuItem item = (MenuItem)iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"CODE_2"</span>.equals(item.getCode())) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                item.printMenu();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Connected to the target VM, address: <span class="string">'127.0.0.1:51875'</span>, transport: <span class="string">'socket'</span></span><br><span class="line">编码：CODE_1名称：第一个菜单</span><br><span class="line">编码：CODE_3名称：第三个菜单</span><br><span class="line">Disconnected from the target VM, address: <span class="string">'127.0.0.1:51875'</span>, transport: <span class="string">'socket'</span></span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>如上简单描述了一个菜单面板利用迭代器模式的遍历过程。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>迭代器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列:状态模式</title>
    <url>/2020/01/08/java/patterndesign/patterndesign_20/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>状态模式是将对象的状态接口抽出，从状态的维度出发描述对象。对象千千万，状态<br>就那么几个，所以从状态的维度度量。业务上会清晰很多。  </p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://images.lilhui.com/13cc93043b1f94bb237d668ffba543e8" alt="图片"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li><p>抽象状态 CarState</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> CarState</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/7 17:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doCarAction</span><span class="params">(Car car)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体状态 start,run,stop</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> CarStart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/7 17:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarStart</span> <span class="keyword">implements</span> <span class="title">CarState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doCarAction</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"汽车启动中。"</span>);</span><br><span class="line">        car.setState(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.littlehui.design.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> CarRun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/7 17:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarRun</span> <span class="keyword">implements</span> <span class="title">CarState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doCarAction</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        car.setState(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"汽车在行驶中。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.littlehui.design.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> CarStop</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/7 17:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarStop</span> <span class="keyword">implements</span> <span class="title">CarState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doCarAction</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        car.setState(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">"汽车停止。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上下文 Car</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/7 17:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 0 停止</span></span><br><span class="line"><span class="comment">     * 1 启动中</span></span><br><span class="line"><span class="comment">     * 2 奔跑中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>客户端调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/7 17:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        CarStart carStart = <span class="keyword">new</span> CarStart();</span><br><span class="line">        carStart.doCarAction(car);</span><br><span class="line">        CarRun carRun = <span class="keyword">new</span> CarRun();</span><br><span class="line">        carRun.doCarAction(car);</span><br><span class="line">        CarStop carStop = <span class="keyword">new</span> CarStop();</span><br><span class="line">        carStop.doCarAction(car);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Connected to the target VM, address: &apos;127.0.0.1:64995&apos;, transport: &apos;socket&apos;</span><br><span class="line">汽车启动中。</span><br><span class="line">汽车在行驶中。</span><br><span class="line">汽车停止。</span><br><span class="line">Disconnected from the target VM, address: &apos;127.0.0.1:64995&apos;, transport: &apos;socket&apos;</span><br></pre></td></tr></table></figure>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>好处<br>状态控制放到了服务的内部，客户端不用操作具体的状态流转业务逻辑。可以分节点操作，扩展性能比较好。<br>上面这个例子只是很简单的模仿了一下工作流控制状态的跳转。状态模式最主要的好处就是把状态的判断与控制放到了其服务端的内部，使得客户端不需要去写很多代码判断，来控制自己的节点跳转，而且这样实现的话，我们可以把每个节点都分开来处理，当流程流转到某个节点的时候，可以去写自己的节点流转方法。</p>
</li>
<li><p>坏处<br>状态类要同时实现。耦合度会高。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>状态模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列:访问者模式</title>
    <url>/2020/04/07/java/patterndesign/patterndesign_21/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>访问者模式有点复杂。一般不轻易使用。他的主要任务是通过不同的访问器，访问问相同的对象，得到不同的信息<br>生成不同的报表等。  </p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://images.lilhui.com/26a86d206f0003f09670a3d4d9fcc987" alt="图片"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li>Coputer被访问者</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Computer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/7 18:20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> <span class="keyword">implements</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ComputerPart[] parts;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        parts = <span class="keyword">new</span> ComputerPart[] &#123;<span class="keyword">new</span> Screen(), <span class="keyword">new</span> Keyboard()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parts.length; i++) &#123;</span><br><span class="line">            parts[i].accept(computerPartVisitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ComputerPart 被访问者，被访问的部分</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ComputerPartVisitor 访问者</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ComputerPartVisitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Screen screen)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Keyboard keyboard)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Keyboard ,Screen 具体的电脑访问部分对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Keyboard</span> <span class="keyword">implements</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> </span>&#123;</span><br><span class="line">        computerPartVisitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Screen</span> <span class="keyword">implements</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> </span>&#123;</span><br><span class="line">        computerPartVisitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>访问接口 Visitor</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ComputerPart computerPart)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Client客户端调用方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ComputerPart computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        computer.accept(<span class="keyword">new</span> ComputerPartDisplayVisitor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connected to the target VM, address: &apos;127.0.0.1:51341&apos;, transport: &apos;socket&apos;</span><br><span class="line">this is computer screen</span><br><span class="line">this is computer keyboard</span><br><span class="line">Disconnected from the target VM, address: &apos;127.0.0.1:51341&apos;, transport: &apos;socket&apos;</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>访问者模式一般用于当对象属性或者信息太多，太杂的时候，通过不同的访问器（观察角度），访问不同的信息。<br>并且可以对信息进行二次加工。具体场景如：<br>1：员工的绩效评估，工程师和HR评估的角度不同。访问角度不同，这时候<br>访问者模式就比较适合。<br>2：报表，老板看到的报表和团队看到的项目报表肯定不一样。这时就满足访问者模式场景。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来讲，访问者模式提供多角度对同个对象的观测方式。对其理解不深很深刻，总结可能不到位，以后再总结。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>访问者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列:备忘录模式</title>
    <url>/2020/01/08/java/patterndesign/patterndesign_19/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p> 备忘录保存的是类内部状态。在适当的时候可以用来恢复当时的类状态。还原现场。  </p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://images.lilhui.com/d70b44ea3e5dab7e1dbb801c9828f31f" alt="图片"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li><p>Originator<br>执行者，封装备忘录具体属性信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.memoto;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Originator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/7 14:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个新的备忘录对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将发起者的状态恢复到备忘录的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Caretaker<br>备忘录管理者。包含一个备忘录具体对象，可以是list。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.memoto;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Caretaker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/7 14:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Memento mMemento;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">restoreMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMemento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">storeMemengto</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mMemento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Memento<br>备忘录的具体类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.memoto;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Memento</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/7 14:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Client<br>执行流程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.memoto;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/7 14:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发起 并初始化</span></span><br><span class="line">        Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">        originator.setState(<span class="string">"state1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//备忘录管理</span></span><br><span class="line">        Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line">        caretaker.storeMemengto(originator.createMemento());</span><br><span class="line">        originator.setState(<span class="string">"state2"</span>);</span><br><span class="line">        System.out.println(originator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//备忘录 恢复</span></span><br><span class="line">        originator.restore(caretaker.restoreMemento());</span><br><span class="line">        System.out.println(originator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>比如在玩游戏保存游戏进度的时候可以用来实现回退功能。回退到上一个保存点。等等</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>优点<br>备忘录模式存在的意义也是在于他的回复机制。并且其特点是在用户不必关心类的内部细节情况下完成了。<br>实现了信息封装。</p>
</li>
<li><p>缺点<br>由于备忘录的保存需要额外的存储空间，所以在类属性多的情况下，多次的备忘录操作比较消耗资源。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>备忘录模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列:中介者模式</title>
    <url>/2020/04/07/java/patterndesign/patterndesign_22/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>定义一个中介者对象, 封装一系列对象的交互关系, 使得各对象不必显示的相互引用,<br>从而使其耦合松散, 而且可以独立的改变它们的交互.  </p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>以智能家居为例，小爱控制只能家居。</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://images.lilhui.com/299215d0c0e1d6d6b58df5792de489c5" alt="图片"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li>SmartDevice 智能设备抽象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.mediator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> SmartDevice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/9 18:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SmartDevice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operateDevice</span><span class="params">(String instruction, SmartMediator mediator)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">readyState</span><span class="params">(String instruction)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>SmartMediator 中介者</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.mediator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> SmartMediator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/9 18:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SmartMediator</span> </span>&#123;</span><br><span class="line">    SmartDevice bd;</span><br><span class="line">    SmartDevice md;</span><br><span class="line">    SmartDevice cd;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmartMediator</span><span class="params">(SmartDevice bd, SmartDevice md, SmartDevice cd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.bd = bd;</span><br><span class="line">        <span class="keyword">this</span>.md = md;</span><br><span class="line">        <span class="keyword">this</span>.cd = cd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">music</span><span class="params">(String instruction)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">curtain</span><span class="params">(String instruction)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">bath</span><span class="params">(String instruction)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>MusicDevice 智能播放器 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.mediator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> MusicDevice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/9 18:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MusicDevice</span> <span class="keyword">extends</span> <span class="title">SmartDevice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operateDevice</span><span class="params">(String instruction,SmartMediator mediator)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"音乐设备"</span>+instruction);</span><br><span class="line">        mediator.music(instruction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readyState</span><span class="params">(String instruction)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"音乐设备准备"</span>+instruction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CurtainDevice 智能窗帘</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.mediator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> CurtainDevice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/9 18:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurtainDevice</span> <span class="keyword">extends</span> <span class="title">SmartDevice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operateDevice</span><span class="params">(String instruction, SmartMediator mediator)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"窗帘已"</span>+instruction);</span><br><span class="line">        mediator.curtain(instruction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readyState</span><span class="params">(String instruction)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"窗帘设备准备"</span>+instruction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>BathDevice 洗浴室</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.mediator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> BathDevice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/9 18:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BathDevice</span> <span class="keyword">extends</span> <span class="title">SmartDevice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operateDevice</span><span class="params">(String instruction, SmartMediator mediator)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"洗浴设备"</span>+instruction);</span><br><span class="line">        mediator.bath(instruction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readyState</span><span class="params">(String instruction)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"洗浴设备正在准备"</span>+instruction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Xiaoai 具体中介者 小爱</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.mediator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Xiaoai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/9 18:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Xiaoai</span> <span class="keyword">extends</span> <span class="title">SmartMediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Xiaoai</span><span class="params">(SmartDevice bd, SmartDevice md, SmartDevice cd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(bd, md, cd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">music</span><span class="params">(String instruction)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小爱操作音乐音乐"</span>);</span><br><span class="line">        cd.readyState(instruction);</span><br><span class="line">        bd.readyState(instruction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">curtain</span><span class="params">(String instruction)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小爱操作窗帘"</span>);</span><br><span class="line">        md.readyState(instruction);</span><br><span class="line">        bd.readyState(instruction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bath</span><span class="params">(String instruction)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小爱操作浴室"</span>);</span><br><span class="line">        cd.readyState(instruction);</span><br><span class="line">        md.readyState(instruction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Client 客户端</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.mediator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/9 18:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmartDevice bd = <span class="keyword">new</span> BathDevice();</span><br><span class="line">        SmartDevice cd = <span class="keyword">new</span> CurtainDevice();</span><br><span class="line">        SmartDevice md = <span class="keyword">new</span> MusicDevice();</span><br><span class="line">        SmartMediator sm = <span class="keyword">new</span> Xiaoai(bd, cd, md);</span><br><span class="line">        cd.operateDevice(<span class="string">"open"</span>,sm);</span><br><span class="line">        md.operateDevice(<span class="string">"close"</span>,sm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connected to the target VM, address: &apos;127.0.0.1:60536&apos;, transport: &apos;socket&apos;</span><br><span class="line">窗帘已open</span><br><span class="line">小爱操作窗帘</span><br><span class="line">窗帘设备准备open</span><br><span class="line">洗浴设备正在准备open</span><br><span class="line">音乐设备已close</span><br><span class="line">小爱操作音乐音乐</span><br><span class="line">音乐设备准备close</span><br><span class="line">洗浴设备正在准备close</span><br><span class="line">Disconnected from the target VM, address: &apos;127.0.0.1:60536&apos;, transport: &apos;socket&apos;</span><br></pre></td></tr></table></figure>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>当有多个对象彼此间相互交互的时候，自然就会想到对象间的耦合度过高，解决办法就是封装对象间的交互行为，因此就能想到中介者模式就是干这行的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 中介者的核心是抽离依赖关系。通过依赖关系来描述整个业务场景。使得复杂的逻辑可以内聚。</p>
<ul>
<li>中介者模式优点  <ol>
<li>通过让对象彼此解耦，增加对象的复用性</li>
<li>通过将控制逻辑集中，可以简化系统维护<br>通过中介者使一对所变成了一堆一，便于理解</li>
</ol>
</li>
<li>缺点  <ol>
<li>如果设计不好，引入中介者会使程序变的复杂</li>
<li>中介者承担过多责任，维护不好会出大事</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>中介者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列：适配器模式</title>
    <url>/2017/11/09/java/patterndesign/patterndesign_6/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>适配器模式是将一个类的接口，转换成客户期望 的另一个接口。适配器让原来接口不兼容的类可以合作。</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>类图：</li>
</ul>
<p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1516185172545.png?imageView2/2/w/418/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<p>对象适配器<br><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1516002365236.png?imageView2/2/w/402/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<p>类适配器<br><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1516002398491.png?imageView2/2/w/404/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<p>Target:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.adapter.target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2017/11/9.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTargetThings</span><span class="params">(String value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Adapter<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.adapter.source;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.littlehui.design.adapter.target.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2017/11/9.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTargetThings</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        adaptee.doSourceThings(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Adaptee<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.adapter.source;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2017/11/9.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSourceThings</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"value is : "</span> + value + <span class="string">"adaptee"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ConcreteTarget<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.adapter.target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2017/11/9.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteTarget</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTargetThings</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"value is:"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Client:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.adapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.littlehui.design.adapter.source.Adaptee;</span><br><span class="line"><span class="keyword">import</span> com.littlehui.design.adapter.source.Adapter;</span><br><span class="line"><span class="keyword">import</span> com.littlehui.design.adapter.target.ConcreteTarget;</span><br><span class="line"><span class="keyword">import</span> com.littlehui.design.adapter.target.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2017/11/9.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Target target = <span class="keyword">new</span> ConcreteTarget();</span><br><span class="line">        Target adaTarget = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adaptee());</span><br><span class="line">        target.doTargetThings(<span class="string">"意外"</span>);</span><br><span class="line">        adaTarget.doTargetThings(<span class="string">"意外"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上利用组合的方式，以修改的接口包装适配者。这种实现方式称之为对象的适配器。它带来的有点是：被适配者的任意子类，都可以搭配适配器使用。</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>以Java举例，早先JDK里使用了枚举器（Enumeration)随着版本的更迭后来被 迭代器(Iterator)取代了。为了兼容之前的接口，枚举器仍然被保留着。<br>并且枚举器添加了删除元素的接口。如果遇到保留着 枚举器的客户端代码，依赖于枚举接口，完全可以使用适配器模式将迭代器转换成枚举。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>设计模式的原则有一条：组合优于继承。体现在适配器模式上就有两种适配方式。组合的称之为 对象时适配模式，继承的称之为对象适配模式。组合的有点是<br>不仅可以适配某个类，还可以适配这个类的子类属于垂直扩展。类适配器不需要重新实现整个适配者。必要的时候覆盖被适配行为就可以。两种各有优劣。站在<br>java的角度思考，类适配多更需要多继承的方式（虽然也可以用接口）。java不支持多继承。所以 建议使用对象适配。既组合。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列：装饰器模式</title>
    <url>/2017/11/09/java/patterndesign/patterndesign_7/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>类图：</li>
</ul>
<p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1516185047356.png?imageView2/2/w/545/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<p>Money:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.decorator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/15.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Money</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">totalMoney</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Wages:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.decorator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/15.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wages</span> <span class="keyword">implements</span> <span class="title">Money</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">totalMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>D;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"基础工资，"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Reward:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.decorator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/15.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reward</span> <span class="keyword">implements</span> <span class="title">Money</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Money money;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reward</span><span class="params">(Money money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">totalMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>d + money.totalMoney();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"加上额外奖励"</span> + money.getDescription();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Bonuses:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.decorator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/15.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bonuses</span> <span class="keyword">implements</span> <span class="title">Money</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Money money;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bonuses</span><span class="params">(Money money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">totalMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>d + money.totalMoney();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"加上奖金"</span> + money.getDescription();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Client:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.decorator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2017/11/9.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Money wages = <span class="keyword">new</span> Wages();</span><br><span class="line">        <span class="comment">//奖金装饰它</span></span><br><span class="line">        wages = <span class="keyword">new</span> Bonuses(wages);</span><br><span class="line">        <span class="comment">//额外奖励装饰它</span></span><br><span class="line">        wages = <span class="keyword">new</span> Reward(wages);</span><br><span class="line">        System.out.println(<span class="string">"工资："</span> + wages.getDescription() + wages.totalMoney());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>Java.io包里就使用了装饰器。<br>BufferedInputStream及LineNumberInputStream都扩展自FilterInputStream，而FilterInputStream是一个抽象的装饰类。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>装饰器模式体现了设计模式里的 开放-关闭原则。</p>
<ol>
<li>装饰者和被装饰者对象有相同的父类</li>
<li>可以使用一个或者多个装饰者包装一个对象。</li>
<li>在任何需要原始对象他们可以相互替换。</li>
<li>装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的。</li>
<li>对象可以在任何时候被装饰，所以可以在运行时动态，不限量地使用。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列:观察者模式</title>
    <url>/2018/01/23/java/patterndesign/patterndesign_15/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>观察者模式也被称为 Model-View模式。观察者的状态依赖于被观察者的行为。一旦被观察者的行为发生改变<br>观察者的状态也随之发生改变。是一种对象间的信息交互方式。</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>类图</li>
</ul>
<p><img src="https://images.lilhui.com/c89ba804c63bfc05515550ff9a72fe58" alt="图片"></p>
<ul>
<li>Observer</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.littlehui.design.observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Observer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/9 16:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ConcreteObserver</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.littlehui.design.observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> ConcreteObserver</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/9 16:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"观察者1："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ConcreteObserver2</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> ConcreteObserver2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/9 16:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"观察者2："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Subject</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.littlehui.design.observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Subject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/9 16:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ConcreteSubject</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> ConcreteSubject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/9 16:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Client</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/9 16:42</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Observer observer1 = <span class="keyword">new</span> ConcreteObserver();</span><br><span class="line">        Observer observer2 = <span class="keyword">new</span> ConcreteObserver2();</span><br><span class="line"></span><br><span class="line">        Subject subject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        subject.register(observer1);</span><br><span class="line">        subject.register(observer2);</span><br><span class="line"></span><br><span class="line">        subject.notify(<span class="string">"呼叫司令。"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Connected to the target VM, address: <span class="string">'127.0.0.1:51436'</span>, transport: <span class="string">'socket'</span></span><br><span class="line">观察者1：呼叫司令。</span><br><span class="line">观察者2：呼叫司令。</span><br><span class="line">Disconnected from the target VM, address: <span class="string">'127.0.0.1:51436'</span>, transport: <span class="string">'socket'</span></span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>观察者模式功能是用于信息广播。观察者在得到广播信息后进行一系列的状态变更。比如前端菜单面板的应用，面板上的<br>按钮，图标观察面板的状态。一旦面板发生关闭或者取消，面板上的按钮，图标随之也可能发生变更，比如取消或者重新绘制等等。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>观察者模式提供了一种对象设计,让主题和观察者之间耦合度降得很低,为什么呢?关于观察者的一切,主题只知道观察者实现了Observer接口,并不需要观察者具体的类是谁,做了什么或者其他细节.<br>这样的话,由于松耦合,改变主题或者观察者其中一方,并不会影响另一方,只要他们之间的接口仍被遵守,就可以自由地改变它.<br>降低对象之间的耦合度,也是面设对象设计的一个很重要的原则.　　</p>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列:命令模式</title>
    <url>/2020/01/08/java/patterndesign/patterndesign_18/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>命令模式将命令的执行和发送命令的责任分隔开，委派给不同的对象执行。</p>
</blockquote>
<ul>
<li>###涉及角色</li>
</ul>
<ol>
<li>客户端(Client)角色：创建一个具体命令(ConcreteCommand)对象并确定其接收者。</li>
<li>命令(Command)角色：声明了一个给所有具体命令类的抽象接口。</li>
<li>具体命令(ConcreteCommand)角色：定义一个接收者和行为之间的弱耦合；实现execute()方法，负责调用接收者的相应操作。execute()方法通常叫做执行方法。</li>
<li>请求者(Invoker)角色：负责调用命令对象执行请求，相关的方法叫做行动方法。</li>
<li>接收者(Receiver)角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://images.lilhui.com/6d1454b9046f34f6d1a20dc0de9eb98b" alt="图片"></p>
<p><img src="https://images.lilhui.com/35c615bb6cee34ebf6f8ad578a7c57e0" alt="图片"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li><p>客户端<br>FishCommander</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.command;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 鱼长官</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/1/8 16:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FishCommander</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FishSoldier fishSoldier = <span class="keyword">new</span> FishSoldier();</span><br><span class="line">        Command huntingFishCommand = <span class="keyword">new</span> HuntingFishCommand(fishSoldier);</span><br><span class="line">        Command cookingFishCommand = <span class="keyword">new</span> CookingFishCommand(fishSoldier);</span><br><span class="line">        CommandBrodCast commandBrodCast = <span class="keyword">new</span> CommandBrodCast();</span><br><span class="line">        commandBrodCast.setCookingFishCommand(cookingFishCommand);</span><br><span class="line">        commandBrodCast.setHuntingFishCommand(huntingFishCommand);</span><br><span class="line">        commandBrodCast.huntingFish();</span><br><span class="line">        commandBrodCast.cookingFish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令<br>Command接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.littlehui.design.command;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>HuntingFishCommand<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.command;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> HuntingFish</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/1/8 16:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuntingFishCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    FishSoldier fishSoldier;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HuntingFishCommand</span><span class="params">(FishSoldier fishSoldier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fishSoldier = fishSoldier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fishSoldier.doHuntingFish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CookingFishCommand<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.command;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> CookingFishCommand</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/1/8 16:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookingFishCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    FishSoldier fishSoldier;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CookingFishCommand</span><span class="params">(FishSoldier fishSoldier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fishSoldier = fishSoldier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fishSoldier.doCookingFish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>命令发送者请求者</li>
</ul>
<p>CommandBrodCast<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.command;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> CommandInvoder</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/1/8 16:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandBrodCast</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Command huntingFishCommand;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Command cookingFishCommand;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCookingFishCommand</span><span class="params">(Command cookingFishCommand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cookingFishCommand = cookingFishCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHuntingFishCommand</span><span class="params">(Command huntingFishCommand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.huntingFishCommand = huntingFishCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cookingFish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cookingFishCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">huntingFish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        huntingFishCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>命令接收者</li>
</ul>
<p>FishSoldier<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.command;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Soldier</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/1/8 16:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FishSoldier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHuntingFish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hunting fish"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doCookingFish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cooking fish"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>命令模式的场景经常用在对外系统调用的时候使用。比如一个http请求封装成一个命模式。<br>不同的参数也可以封装成不同的命令。命令执行端，服务端的业务发生改变时或者url调用<br>方式发生改变时，客户端不需要调整。只要修改相应的命令封装器就好了。有效地做到<br>了修改的隔离。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>命令模式的最大特点就是隔离了命令的发送端和执行端。命令的发送端无需知道命令<br>执行端具体怎么执行。这种隔离方式的好处是调用的透明化。具有更好的扩展性。<br>由于命令是一个个相互独立的，所以可以很自然的做到复合命令。命令已经是封装<br>过的，所以可以对他进行有效的参数化。综合以上他有几种特点：</p>
<ol>
<li>更松散的耦合</li>
<li>更动态的控制</li>
<li>支持复合命令</li>
<li>更好的扩展性</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>命令模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列:解释器模式</title>
    <url>/2020/04/07/java/patterndesign/patterndesign_23/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>解释器模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。</p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://images.lilhui.com/fc3cc988c12ee33d2ad48d9de91582cd" alt="图片"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li>Expression</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Expression</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/10 09:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>OrExpression</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> OrExpress</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/10 10:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Expression expr1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Expression expr2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrExpression</span><span class="params">(Expression expr1, Expression expr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.expr1 = expr1;</span><br><span class="line">        <span class="keyword">this</span>.expr2 = expr2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expr1.interpret(context) || expr2.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>AndExpression</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> AndExpression</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/10 10:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Expression expr1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Expression expr2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndExpression</span><span class="params">(Expression expr1, Expression expr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.expr1 = expr1;</span><br><span class="line">        <span class="keyword">this</span>.expr2 = expr2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expr1.interpret(context) &amp;&amp; expr2.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Client</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> littlehui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/10 10:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//规则：Robert 和 John 是男性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Expression <span class="title">getMaleExpression</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Expression robert = <span class="keyword">new</span> TerminalExpression(<span class="string">"Robert"</span>);</span><br><span class="line">        Expression john = <span class="keyword">new</span> TerminalExpression(<span class="string">"John"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrExpression(robert, john);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//规则：Julie 是一个已婚的女性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Expression <span class="title">getMarriedWomanExpression</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Expression julie = <span class="keyword">new</span> TerminalExpression(<span class="string">"Julie"</span>);</span><br><span class="line">        Expression married = <span class="keyword">new</span> TerminalExpression(<span class="string">"Married"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AndExpression(julie, married);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Expression isMale = getMaleExpression();</span><br><span class="line">        Expression isMarriedWoman = getMarriedWomanExpression();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"John is male? "</span> + isMale.interpret(<span class="string">"John"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Julie is a married women? "</span></span><br><span class="line">                + isMarriedWoman.interpret(<span class="string">"Married Julie"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connected to the target VM, address: &apos;127.0.0.1:61783&apos;, transport: &apos;socket&apos;</span><br><span class="line">John is male? true</span><br><span class="line">Julie is a married women? true</span><br><span class="line">Disconnected from the target VM, address: &apos;127.0.0.1:61783&apos;, transport: &apos;socket&apos;</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul>
<li>可以将一个需要解释执行的语言中的句子表示为一个抽象语法树</li>
<li>一些重复出现的问题可以用一种简单的语言来表达</li>
<li>一个简单语法需要解释的场景</li>
</ul>
<p>在一些编译器，运算表达式，正则表达式经常有使用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>优点：<br>1、可扩展性比较好，灵活。<br>2、增加了新的解释表达式的方式。<br>3、易于实现简单文法。</p>
</li>
<li><p>缺点：<br>1、可利用场景比较少。<br>2、对于复杂的文法比较难维护。<br>3、解释器模式会引起类膨胀。<br>4、解释器模式采用递归调用方法。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>解释器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列：外观模式</title>
    <url>/2017/11/09/java/patterndesign/patterndesign_9/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>外观模式用于简化系统中一个或者多个复杂的类。外观模式相当直接，容易理解。它提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个<br>高层接口，让子同更容易使用。</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1516004360353.png?imageView2/2/w/322/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<ul>
<li>类图：</li>
</ul>
<p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1516184786908.png?imageView2/2/w/527/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<p>MyOneDay:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.facade;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/16.</span></span><br><span class="line"><span class="comment"> * 我的一天</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyOneDay</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Morning morning;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Road road;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Back back;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Office office;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rest rest;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyOneDay</span><span class="params">(Morning morning, Office office, Back back, Road road, Rest rest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.morning = morning;</span><br><span class="line">        <span class="keyword">this</span>.office = office;</span><br><span class="line">        <span class="keyword">this</span>.back = back;</span><br><span class="line">        <span class="keyword">this</span>.road = road;</span><br><span class="line">        <span class="keyword">this</span>.rest = rest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在家起床</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        morning.morningStepA();</span><br><span class="line">        morning.morningStepB();</span><br><span class="line">        morning.moringStepC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 去公司</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goToOffice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        road.onLoadA();</span><br><span class="line">        road.onLoadB();</span><br><span class="line">        road.onLoadC();</span><br><span class="line">        road.onLoadE();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作，coding</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        office.officeA();</span><br><span class="line">        office.officeB();</span><br><span class="line">        office.officeC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backToHome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        back.backStepA();</span><br><span class="line">        back.backStepB();</span><br><span class="line">        back.backStepC();</span><br><span class="line">        back.backStepD();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rest.restA();</span><br><span class="line">        rest.restB();</span><br><span class="line">        rest.restC();</span><br><span class="line">        rest.restD();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myWholeDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        morning();</span><br><span class="line">        goToOffice();</span><br><span class="line">        work();</span><br><span class="line">        backToHome();</span><br><span class="line">        rest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Morning:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.facade;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Morning</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morningStepA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"起床刷牙洗脸"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morningStepB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃早饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moringStepC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"带上背包出门"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Office:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.facade;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Office</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">officeA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"放下背包"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">officeB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"去除电脑开机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">officeC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开IDEA 愉快地codeing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Client:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.facade;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyOneDay myOneDay = <span class="keyword">new</span> MyOneDay(<span class="keyword">new</span> Morning(), <span class="keyword">new</span> Office(), <span class="keyword">new</span> Back(), <span class="keyword">new</span> Road(), <span class="keyword">new</span> Rest());</span><br><span class="line">        myOneDay.myWholeDay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上其他类略：<br>详情github链接： <a href="https://github.com/littlehui/designpattern" target="_blank" rel="noopener">设计模式</a></p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>外观模式体现了设计模式中 最少知识原则。不让太多的类耦合在一起。</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>电商项目数据高可用架构设计</title>
    <url>/2022/12/01/java/practice/trade_1/</url>
    <content><![CDATA[<h2 id="缓存数据库一致"><a href="#缓存数据库一致" class="headerlink" title="缓存数据库一致"></a>缓存数据库一致</h2><p>Canal : 基于Binlog的同步中间件。</p>
<p>Canal伪装成Mysql的从节点。收到Binlog 解析变更的binlog。</p>
<p>Canal Server - 接收Mysql 日志流。<br>Canal Client - 处理解析后的操作。可以在业务进行实现。</p>
<p>Canal也可以推送到Mq,kafka等。</p>
<p>RabbitMq不支持。Rocket可以支持。</p>
<h2 id="Mysql检查"><a href="#Mysql检查" class="headerlink" title="Mysql检查"></a>Mysql检查</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show VARIABLES like %bin_log%</span><br><span class="line">show VARIABLES like %binlog_format%</span><br><span class="line">show VARIABLES like %server_id%</span><br></pre></td></tr></table></figure>
<ul>
<li>修改：</li>
</ul>
<p>my.conf</p>
<h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>创建canal用户，用来复制Mysql权限。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mysql.user;</span><br></pre></td></tr></table></figure>
<h2 id="canal配置文件"><a href="#canal配置文件" class="headerlink" title="canal配置文件"></a>canal配置文件</h2><p>几个关键配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//支持的表，支持正则表达黑丝</span><br><span class="line">canal.instance.filter.regex =</span><br><span class="line">canal.destination =</span><br></pre></td></tr></table></figure>
<ul>
<li>启动canal server</li>
<li>启动canal client</li>
</ul>
<h2 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h2><h3 id="Binlog的格式"><a href="#Binlog的格式" class="headerlink" title="Binlog的格式"></a>Binlog的格式</h3><ol>
<li>Row:幂等操作，所以canal选择这种。</li>
<li>Sql:可以幂等也可能非幂等。</li>
<li>Mix</li>
</ol>
<p>Canal 适用 Row格式Mysql Binlog</p>
]]></content>
      <categories>
        <category>practice</category>
      </categories>
      <tags>
        <tag>电商，数据高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>shardingsphere简单源码解析</title>
    <url>/2022/02/14/java/shardingsphere/shardingsphere_2/</url>
    <content><![CDATA[<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>解析-&gt;路由-&gt;改写-&gt;执行-&gt;归并</p>
<ol>
<li>初始化过程</li>
</ol>
<p>ShardingDataSourceFactory.createDataSource</p>
<blockquote>
<p>ShardingRule 分片规则通过配置加载到内存中</p>
</blockquote>
<ol start="2">
<li>SQL执行过程<br>(上下文)<br>ShardingStatement.executeQuery<blockquote>
<p>Statement   SqlRoute<br>statementEngine.route<br>StanndardRoutingEngine<br>SQLRewriteEngine<br>SQLRewriteEngine.generateSQL<br>SQLExecuteCallback.executeSQL //StatmentExecutor.executeQuery()多线程执行，同时执行多个sql</p>
</blockquote>
</li>
</ol>
<p>关键类<br>ShardingRouter.route</p>
<blockquote>
<p>ParsingSQLRouter.parse</p>
</blockquote>
<ul>
<li><p>SQL 语法解析<br>LexerEngine</p>
</li>
<li><p>SQL解析引擎<br>RoutingEngineFactory.</p>
</li>
<li><p>改写引擎<br>SQLRewritEngine</p>
</li>
</ul>
<p>比如 *** DESC limit 1,2<br>要改写成 limit 0,3<br>因为是倒序。直接用原来的limit可能会将需要到的结果截断。</p>
<ul>
<li><p>执行引擎<br>ShardingExecuteEngine</p>
</li>
<li><p>归并引擎<br>MergeEngine</p>
</li>
</ul>
<p>简单的 归并，获取limit x,y</p>
<p>优先队列。<br>每个分表获取的结果形成一个有序队列。然后用每个队列的第一个进行比较，每次需要就弹出一个。没有对其进行所有的合并。</p>
<p>clear 清空<br>sqlRoute(sql)<br>initStatementExecutor()</p>
<ul>
<li>读写分离<br>MasterSLave路由</li>
</ul>
<p>MasterSlaveRouter.route<br>-&gt; SQLJudgeEngine.judge</p>
]]></content>
      <categories>
        <category>shardingsphere</category>
      </categories>
      <tags>
        <tag>分表</tag>
      </tags>
  </entry>
  <entry>
    <title>分库分表垂直详解与框架介绍</title>
    <url>/2022/02/14/java/shardingsphere/shardingsphere_1/</url>
    <content><![CDATA[<h1 id="什么是分库分表"><a href="#什么是分库分表" class="headerlink" title="什么是分库分表"></a>什么是分库分表</h1><p>性能瓶颈一般在数据库。</p>
<h1 id="为什么要分库分表"><a href="#为什么要分库分表" class="headerlink" title="为什么要分库分表"></a>为什么要分库分表</h1><p>增加性能。</p>
<h1 id="分库分表带来的问题"><a href="#分库分表带来的问题" class="headerlink" title="分库分表带来的问题"></a>分库分表带来的问题</h1><p>分库分表：<br>增加了维护成本<br>分布式事务问题<br>跨库join<br>分布式全局唯一ID</p>
<h1 id="分库分表算法"><a href="#分库分表算法" class="headerlink" title="分库分表算法"></a>分库分表算法</h1><p>取模  hash<br>解决数据热点问题，但是扩展麻烦<br>范围区分  range<br>解决扩展问题，仍然有数据热点问题。<br>预定义  固定编码<br>1 亿</p>
<h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><p>读多写少，分离主库的压力</p>
<h2 id="读写分离的问题"><a href="#读写分离的问题" class="headerlink" title="读写分离的问题"></a>读写分离的问题</h2><p>主从同步，数据一致性，网络延迟问题</p>
<p>强制路由：强制去访问master。下单的过程中</p>
]]></content>
      <categories>
        <category>shardingsphere</category>
      </categories>
      <tags>
        <tag>分表</tag>
      </tags>
  </entry>
  <entry>
    <title>【深入理解Spring系列1】自动装配Bean初始化</title>
    <url>/2021/11/17/java/spring/spring_deep_1/</url>
    <content><![CDATA[<h2 id="4种自动装配-注入）模型"><a href="#4种自动装配-注入）模型" class="headerlink" title="4种自动装配(注入）模型"></a>4种自动装配(注入）模型</h2><ul>
<li>@Autowired </li>
<li>@Resource</li>
</ul>
<ol>
<li>no: AUTOWIRE_NO(NO,不使用自动转配)</li>
<li>byName：AUTOWIRE_BY_NAME </li>
<li>byType: AUTOWIRE_BY_TYPE</li>
<li>byConstructor: AUTOWIRE_CONSTRUCTOR</li>
</ol>
<h2 id="2种注入方式"><a href="#2种注入方式" class="headerlink" title="2种注入方式"></a>2种注入方式</h2><p>注入方式可以理解成寻找Bean方式</p>
<ol>
<li>byType</li>
<li>byName</li>
</ol>
<h2 id="7个后置处理器"><a href="#7个后置处理器" class="headerlink" title="7个后置处理器"></a>7个后置处理器</h2><ol>
<li>AutowiredAnnotationBeanPostProcessor</li>
<li>CommonAnnotationBeanPostProcessor</li>
</ol>
<h2 id="Bean生命周期里的回调"><a href="#Bean生命周期里的回调" class="headerlink" title="Bean生命周期里的回调"></a>Bean生命周期里的回调</h2><p>Bean生命周期里的回调<br>lifeCycle Callback</p>
<h3 id="实现接口InitializingBean"><a href="#实现接口InitializingBean" class="headerlink" title="实现接口InitializingBean"></a>实现接口InitializingBean</h3><ol>
<li>xml配置 initial-method A </li>
<li>实现initializingBean接口 B </li>
<li>注解@PostConstruct C</li>
</ol>
<p>三种方法先后顺序<br>C-&gt;B-&gt;A</p>
<h3 id="Spring初始化方法"><a href="#Spring初始化方法" class="headerlink" title="Spring初始化方法"></a>Spring初始化方法</h3><p>一个后置处理器，2个初始化方法。<br>执行构造方法后，</p>
<ul>
<li>callback</li>
</ul>
<ol>
<li>Spring一个对象被Spring实例化后就执行某些逻辑。</li>
<li>当Spring容器初始化完成后立马执行，使用SmartLifeCycle </li>
</ol>
<p><strong>问题</strong>：Spring中属性注入和和初始化方法 @PostConstruct 谁先执行？<br>回答：属性注入先执行。</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>自动装配</tag>
      </tags>
  </entry>
  <entry>
    <title>【深入理解Spring系列2】自动装配Bean初始化</title>
    <url>/2021/12/02/java/spring/spring_deep_2/</url>
    <content><![CDATA[<p>Spring 四中bean装配模型</p>
<p>NO<br>byType<br>byName<br>byConstructor</p>
<p>官网说是针对 xml配置的。其实不完全正确。<br>应该是：xml提供了配置入口。</p>
<p>@Autowire 这个可以通过后置处理器，在beandefinitioan里设置autowireMode(int)</p>
<p>@Autowired与上面四种的区别是，他可以通过field.set 反射来装配。其他的需要 setXXX方法。</p>
<p>populaBan</p>
<p>spring 生命周期中，先拿到后置处理器处理，处理<br>@PostConstruct<br>注解，再处理<br>initMethod。initMethod会依次处理（afterPropertiesSet） 接口方法，和xml配置 的方法。</p>
<ul>
<li>smartlifeCycle</li>
</ul>
<p>isAutoStartUp 一旦容器开始就调用start()方法<br>容器停止会调用stop(runnalble callback )</p>
<p>包：<br>spring-context-indxer<br>容器索引<br>在大型项目的时候用于加载预处理。</p>
<p>javax.inject<br>@Inject @Name</p>
<ul>
<li>FactoryBean 与Bean的区别</li>
</ul>
<p>初始化时机不同。</p>
<p>什么是 factoryBean？</p>
<ol>
<li>本身是一个Bean，getObject()也是一个bean<br>2</li>
</ol>
<p>问题： 如何将一个对象放到spring容器中？</p>
<ol>
<li>factoryBean (一般跟第三方jar包结合 ： nacosDataSourceFactoryBean)</li>
<li>@Bean (手动业务类操作放到spring里。)</li>
<li>applicationContext.getBeanFactory().registerSingleTon(“”, Object); –（有依赖的时候作用比较大。）</li>
</ol>
<p>applicationContext.getBean(“factoryBean”); 获取的 是这个bean中getObject()的对象。</p>
<p>applicationContext.getBean(“&amp;factoryBean”); 获取的是factoryBean </p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>自动装配</tag>
      </tags>
  </entry>
  <entry>
    <title>【深入理解Spring系列2】动态代理</title>
    <url>/2022/04/28/java/spring/spring_deep_3/</url>
    <content><![CDATA[<h2 id="Spring-动态代理"><a href="#Spring-动态代理" class="headerlink" title="Spring 动态代理"></a>Spring 动态代理</h2><p>以mybatis-spring为例子讲下Spring的动态代理过程。<br>mybatis官网：<a href="https://mybatis.org/mybatis-3/zh" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh</a></p>
<ul>
<li>动态代理的关键</li>
</ul>
<ol>
<li>新建</li>
</ol>
<p>JDK的动态代理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br></pre></td></tr></table></figure>
<p>mapperProxy实现了InvocationHanlder<br>mapperInterface是这个new出来的类接口。接口与实现是分开的。<br>mybatis的关键点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br></pre></td></tr></table></figure>
<p>sqlSession在这里传入 MapperProxy<br>MapperProxy又调用MapperMethod<br>Mybatis Mapper具体的代理方法的实现在这里<br>MybatisMapperRegistry.addMapper(Class)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MybatisMapperAnnotationBuilder parser = new MybatisMapperAnnotationBuilder(config, type);</span><br></pre></td></tr></table></figure>
<p>MybatisMapperAnnotationBuilder</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public void parse() &#123;</span><br><span class="line">    String resource = type.toString();</span><br><span class="line">    if (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">        loadXmlResource();</span><br><span class="line">        configuration.addLoadedResource(resource);</span><br><span class="line">        assistant.setCurrentNamespace(type.getName());</span><br><span class="line">        parseCache();</span><br><span class="line">        parseCacheRef();</span><br><span class="line">        Method[] methods = type.getMethods();</span><br><span class="line">        // TODO 注入 CURD 动态 SQL (应该在注解之前注入)</span><br><span class="line">        if (GlobalConfigUtils.getSuperMapperClass(configuration).isAssignableFrom(type)) &#123;</span><br><span class="line">            GlobalConfigUtils.getSqlInjector(configuration).inspectInject(assistant, type);</span><br><span class="line">        &#125;</span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // issue #237</span><br><span class="line">                if (!method.isBridge()) &#123;</span><br><span class="line">                    parseStatement(method);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * 使用 MybatisMethodResolver 而不是 MethodResolver</span><br><span class="line">                 */</span><br><span class="line">                configuration.addIncompleteMethod(new MybatisMethodResolver(this, method));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parsePendingMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mybatis两种：</p>
<ul>
<li><p>初始化</p>
</li>
<li><p>执行过程</p>
</li>
</ul>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>【深入理解Spring系列4】BeanDefinition</title>
    <url>/2022/07/12/java/spring/spring_deep_4/</url>
    <content><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>Spring Bean的 四种装配模式外，还有一种自动策略。</p>
<p>当只有一个 构造方法，并且构造方法里有参数。<br>会进行 aurowireConstructor(beanName, mdb, ctors, args)</p>
<ul>
<li>spring扫描不能直接new的方法</li>
</ul>
<p>@DependsOn</p>
<p>@Prototype 执行的时候new</p>
<p>所以需要先解析验证。</p>
<p>scan-parse（会变成BeaDefinition）-validate(info)-new(开始spring的生命周期)</p>
<p>可以这么理解：</p>
<p>beanDefinition之于Spring<br>相当于class之于java对象</p>
<ul>
<li>常量（BeanDefinition)<br>-<br>SCOPE_SINGLETON</li>
</ul>
<p>ROLE_APPLICATION</p>
<p>setParentName</p>
<p>//自动装配候选对象 ，被装配<br>setAutowireCandidate<br>//候选对象最高级<br>setPrimary</p>
<p>BeanDefinition所有属性都能找到与之匹配的 xml配置。</p>
<p>ac.getBean(XXX);是从DefaultSingletonBeanRegistry.singletonObjects.get(XXX)</p>
<ul>
<li>abstractApplicationContext</li>
</ul>
<p>abstractApplicationContext.refresh()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//这里初始化对象。还未装配</span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">//这里装配。</span><br><span class="line">finishRefresh()</span><br></pre></td></tr></table></figure>
<ol>
<li>扫描</li>
<li>parse</li>
<li>validate</li>
<li>life  遍历map得到BeanDefinition实例化。</li>
</ol>
<h2 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h2><p>各方法说明：</p>
<p>setPrimary:<br>多个接口实现的时候，自动注入候选的时候排第一。</p>
<ul>
<li>关键父类<br>AbstractBeanDefinition</li>
</ul>
<p>ChildBeanDefinition,RootBeanDefinition Spring 2.5的时候用</p>
<p>GenericBeanDefinition<br>现在常用。</p>
<p>xml 配置里的<bean></bean>描述的就是 beanDefinition的属性。<br>spring容器会进行扫描。扫描后会根据bendefinition里描述的进行实例化。</p>
<p>abstract = true 必须要有 beanClass</p>
<ul>
<li>RootBeanDefinition</li>
</ul>
<p>减少不同 bean配置多种相同相同属性值的 工作量 abstract=true</p>
<p>parent = ‘xxx’</p>
<p>spring 2.5之前有这种写法。后面更方便了用扫描，用标签。</p>
<p>问题：RootBeanDefinition也有 setParentName()，为什么要多一个ChildBeanDefinition ?</p>
<p>RootBeanDefinition一般作为父出现，或者一般BD出现。但是不作为子BD出现。<br>为什么要这样规定？为什么设置Root的Parent要抛出异常？</p>
<p>合并BeanDefinition？</p>
<ul>
<li>AnnotatedBeanDefinitionReader</li>
</ul>
<p>作用：解析@Configuration 这标签会去扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public AnnotationConfigApplicationContext() &#123;</span><br><span class="line">	this.reader = new AnnotatedBeanDefinitionReader(this);</span><br><span class="line">	this.scanner = new ClassPathBeanDefinitionScanner(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>beanReader = AnnotatedBeanDefinitionReader(this);<br>把 配置的AppConfig 变成 BeanDefinition</p>
<p>其他的 要完成扫描的时候去new 其他BD.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.reader = new AnnotatedBeanDefinitionReader(this);  这么写是为了后面能通过 context.register.registBean(标签) 来扩展自定义标签。</span><br></pre></td></tr></table></figure></p>
<p>注意这里是为了扩展，spring启动的时候并不是用这个scaner去扫描。<br>实际上用的是,在BeanDefinitionRegistry这个后置处理器。</p>
<p>ConfigutationClassPostProcessor.postProcessBanDefinitionRegistry(registry)</p>
<p>-&gt;<br>这里找到 registry里初始化的BeanDefinition，进行parse<br>ConfigurationClassParser.parse(Set<beandefinitionholder> candidates)<br>这个方法里会判断 参数是否实现了 AnnotatedBeanDefinition</beandefinitionholder></p>
<p>bd instanceof AnnotatedBeanDefinition</p>
<p>-</p>
<p>ConfigurationClassParser.processConfigurationClass</p>
<p>//这段很有意思，扫描结束后会将sourceClass设置为null。说明所有的BeanDefinition都扫描出来了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">	sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">&#125;</span><br><span class="line">while (sourceClass != null);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)</span><br></pre></td></tr></table></figure>
<p>doProcessConfigurationClass<br>这里是实现。<br>实际识别了@Component  @ComponentScan @ImportSource 等标签。</p>
<p>然后在<br>ComponentScanAnnotationParser<br>类里的<br>public Set<beandefinitionholder> parse(AnnotationAttributes componentScan, final String declaringClass)</beandefinitionholder></p>
<p>进行实际的扫描，先new 出了<br>ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,</p>
<p>再判断各种includerFilter excluderFilter<br>最后根据 标签配置的 包路径进行文件扫描。<br>从而扫描出Beandefinition 放到BeanDeinitionMap</p>
<p>小总结：<br>Beandefinition决定了spring 中Bean的各种特征。<br>class-beandefinition-springbean。<br>通过beandefinition spring定义了一套 spring bean的属性特征。</p>
<p>GenericBeanDefinition追加了setBeanClass</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>bean</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用场景集锦</title>
    <url>/2018/05/07/tools/tools_0/</url>
    <content><![CDATA[<h3 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h3><h4 id="安装之后第一步"><a href="#安装之后第一步" class="headerlink" title="安装之后第一步"></a>安装之后第一步</h4><p>安装 Git 之后，你要做的第一件事情就是去配置你的名字和邮箱，因为每一次提交都需要这些信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;bukas&quot;</span><br><span class="line">git config --global user.email &quot;bukas@gmail.com&quot;</span><br></pre></td></tr></table></figure>
<p>获取Git配置信息，执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>
<h4 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h4><p>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir testgit &amp;&amp; cd testgit</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>瞬间Git就把仓库建好了，细心的读者可以发现当前目录下多了一个.git的目录，默认是隐藏的，用ls -ah命令就可以看见。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git-init</span><br></pre></td></tr></table></figure>
<h4 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch readme.md</span><br><span class="line">git add readme.md</span><br></pre></td></tr></table></figure>
<p>然后用命令git commit告诉Git把文件提交到仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;wrote a readme file&quot;</span><br></pre></td></tr></table></figure>
<p>简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<p>一次可以add多个不同的文件，以空格分隔：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add a.txt b.txt c.txt</span><br></pre></td></tr></table></figure>
<h4 id="仓库状态"><a href="#仓库状态" class="headerlink" title="仓库状态"></a>仓库状态</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>git status命令可以让我们时刻掌握仓库当前的状态。</p>
<p>但如果能看看具体修改了什么内容就更好了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff readme.md</span><br></pre></td></tr></table></figure>
<h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>每次提交git都会形成以个commit。我们通过git log可以查看到各个提交的历史。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></p>
<p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1525681039891.png?imageView2/2/w/666/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<p>git log –pretty=oneline 参数可以简化显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure>
<p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1525681121417.png?imageView2/2/w/672/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<p>在 Git中，用HEAD表示当前版本，也就是最新的提交commit id，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p>
<p>现在我们要把当前版本回退到上一个版本，就可以使用git reset命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>
<p>然我们用git log再看看现在版本库的状态，最新的那个版本已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p>
<p>git-reset</p>
<p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，假设找到那个commit id是2e70fdf…，于是就可以指定回到未来的某个版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard 2e70fdf</span><br></pre></td></tr></table></figure>
<p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p>
<p>Git提供了一个命令git reflog用来记录你的每一次命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>
<p>终于舒了口气，于是你看到的commit id是2e70fdf，现在，你又可以乘坐时光机回到未来了。</p>
<h4 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h4><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p>
<p>工作区就是你在电脑里能看到的目录，比如我的testgit文件夹就是一个工作区。</p>
<p>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向 master的一个指针叫HEAD。</p>
<p>前面讲了我们把文件往 Git 版本库里添加的时候，是分两步执行的：</p>
<p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</p>
<p>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以现在git commit就是往master分支上提交更改。</p>
<p>你可以简单理解为，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后执行git commit就可以一次性把暂存区的所有修改提交到分支。</p>
<p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。</p>
<h4 id="修改与撤销"><a href="#修改与撤销" class="headerlink" title="修改与撤销"></a>修改与撤销</h4><p>用git diff HEAD – readme.md命令可以查看工作区和版本库里面最新版本的区别。</p>
<p>git checkout – file可以丢弃工作区的修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- readme.md</span><br></pre></td></tr></table></figure>
<p>命令git checkout – readme.md意思就是，把readme.md文件在工作区的修改全部撤销，即让这个文件回到最近一次git commit或git add时的状态。</p>
<p>当然也可以用git reset命令。</p>
<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm readme.md</span><br></pre></td></tr></table></figure>
<p>这个时候，Git 知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了。</p>
<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm readme.md</span><br><span class="line">git commit -m &quot;remove readme.md&quot;</span><br></pre></td></tr></table></figure>
<p>现在，文件就从版本库中被删除了。</p>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- readme.md</span><br></pre></td></tr></table></figure>
<h4 id="生成SSH-key"><a href="#生成SSH-key" class="headerlink" title="生成SSH key"></a>生成SSH key</h4><p>创建 SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开 Shell（Windows下打开Git Bash），创建SSH Key：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure>
<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可。</p>
<p>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>
<p>然后登录GitHub（或者其它Git代码托管平台），打开Account settings，SSH Keys页面，点Add SSH Key，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。</p>
<p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p>
<p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>
<p>远程服务器<br>Git 最强大的功能之一是可以有一个以上的远程服务器（另一个事实，你总是可以运行一个本地仓库）。你不一定总是需要写访问权限，你可以从多个服务器中读取（用于合并），然后写到另一个服务器中。添加一个远程服务器很简单：</p>
<p>git remote add origin(别名，根据爱好命名) <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:bukas/bukas.git<br>如果你想查看远程服务器的相关信息，你可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># shows URLs of each remote server</span><br><span class="line">git remote -v</span><br><span class="line">	</span><br><span class="line"># gives more details about origin</span><br><span class="line">git remote show origin(别名)</span><br></pre></td></tr></table></figure>
<p>下一步，就可以把本地库的所有内容推送到远程库上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。</p>
<p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>从现在起，只要本地作了提交，就可以通过命令把本地master分支的最新修改推送至GitHub：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<h4 id="SSH警告"><a href="#SSH警告" class="headerlink" title="SSH警告"></a>SSH警告</h4><p>当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The authenticity of host ‘github.com (xx.xx.xx.xx)’ can’t be established.</span><br><span class="line"></span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line"></span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>
<p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认 GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。</p>
<p>从远程库克隆</p>
<p>当已经有一个远程库的时候，我们可以用命令git clone克隆一个本地库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:test/testgit.git</span><br></pre></td></tr></table></figure>
<p>你也许还注意到，GitHub给出的地址不止一个，还可以用<a href="https://github.com/test/testgit.git这样的地址。实际上Git支持多种协议，默认的git://使用ssh，但也可以使用" target="_blank" rel="noopener">https://github.com/test/testgit.git这样的地址。实际上Git支持多种协议，默认的git://使用ssh，但也可以使用</a> https等其他协议。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</p>
<p>创建与合并分支<br>首先我们创建dev分支，然后切换到dev分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure>
<p>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch dev</span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure>
<p>然后用git branch命令查看当前分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<p>我们在dev分支上进行添加修改操作，然后我们把dev分支的工作成果合并到master分支上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge dev</span><br></pre></td></tr></table></figure>
<p>git merge命令用于合并指定分支到当前分支。</p>
<p>注意到git merge的信息里面可能有Fast-forward字样，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p>
<p>当然也不是每次合并都能Fast-forward。</p>
<p>合并完成后，就可以放心地删除dev分支了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure>
<p>如果要丢弃一个没有被合并过的分支，可以通过git branch -D <branch>强行删除。</branch></p>
<p>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</p>
<p>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；</p>
<p>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p>
<h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p>
<p>有时候我们进行合并的时候，会提示有冲突出现CONFLICT (content)，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件。</p>
<p>打开冲突文件我们会看到Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改后提交：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add readme.md</span><br><span class="line">git commit -m &quot;conflict fixed&quot;</span><br></pre></td></tr></table></figure>
<p>用带参数的git log也可以看到分支的合并情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure>
<h4 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h4><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p>下面我们实战一下–no-ff方式的git merge：</p>
<p>首先，仍然创建并切换dev分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure>
<p>修改readme.md文件，并提交一个新的commit：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add readme.md</span><br><span class="line">git commit -m &quot;add merge&quot;</span><br></pre></td></tr></table></figure>
<p>现在，我们切换回master：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>
<p>准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure>
<h4 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h4><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交。</p>
<p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p>
<p>幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>
<p>现在，用git status查看工作区，就是干净的（除非有没有被 Git 管理的文件），因此可以放心地创建分支来修复bug。</p>
<p>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git checkout -b issue-101</span><br></pre></td></tr></table></figure>
<p>现在修复bug，然后提交：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add readme.md</span><br><span class="line">git commit -m &quot;fix bug 101&quot;</span><br></pre></td></tr></table></figure>
<p>修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git checkout master</span><br><span class="line">git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</span><br></pre></td></tr></table></figure>
<p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure>
<p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>
<p>一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</p>
<p>另一种方式是用git stash pop，恢复的同时把stash内容也删了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure>
<p>再用git stash list查看，就看不到任何stash内容了。</p>
<p>你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>
<h4 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h4><p>发布一个版本时，我们通常先在版本库中打一个标签，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<p>命令git tag <tagname>用于新建一个标签，默认为HEAD，也可以指定一个commit id。</tagname></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息。</span><br></pre></td></tr></table></figure>
<p>还可以通过-s用私钥签名一个标签：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -s v0.5 -m &quot;signed version 0.2 released&quot; fec145a</span><br></pre></td></tr></table></figure>
<p>git tag可以查看所有标签。</p>
<p>用命令git show <tagname>可以查看某个标签的详细信息。</tagname></p>
<p>如果标签打错了，也可以删除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -d v0.1</span><br></pre></td></tr></table></figure>
<p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>
<p>如果要推送某个标签到远程，使用命令git push origin <tagname>：</tagname></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin v1.0</span><br></pre></td></tr></table></figure>
<p>或者，一次性推送全部尚未推送到远程的本地标签：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure></p>
<p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -d v0.9</span><br></pre></td></tr></table></figure>
<p>然后，从远程删除。删除命令也是push，但是格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin :refs/tags/v0.9</span><br></pre></td></tr></table></figure>
<p>####忽略特殊文件</p>
<p>在安装Git一节中，我们已经配置了user.name 和user.email，实际上，Git还有很多可配置项。</p>
<p>比如，让Git显示颜色，会让命令输出看起来更醒目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global color.ui true</span><br></pre></td></tr></table></figure>
<p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次git status都会显示Untracked files…，有强迫症的童鞋心里肯定不爽。</p>
<p>好在Git考虑到了大家的感受，这个问题解决起来也很简单，在 Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<p>不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p>
<p>当然也可以配置全局忽略的文件，这样就不用每个项目都加gitignore了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global core.excludesfile &apos;~/.gitignore&apos;</span><br></pre></td></tr></table></figure>
<h4 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h4><p>有没有经常敲错命令？比如git status？status这个单词真心不好记。</p>
<p>如果敲git st就表示git status那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p>
<p>我们只需要敲一行命令，告诉Git，以后st就表示status：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure></p>
<p>当然还有别的命令可以简写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.br branch</span><br></pre></td></tr></table></figure>
<p>–global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p>
<p>在撤销修改一节中，我们知道，命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global alias.unstage &apos;reset HEAD&apos;</span><br></pre></td></tr></table></figure>
<p>配置一个git last，让其显示最后一次提交信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global alias.last &apos;log -1&apos;</span><br></pre></td></tr></table></figure>
<p>甚至还有人把lg配置成了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</span><br></pre></td></tr></table></figure>
<p>####配置文件</p>
<p>配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p>
<p>配置文件放哪了？每个仓库的Git配置文件都放在.git/config文件中。</p>
<p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>【Dubbo源码系列3】Duboo 可扩展机制SPI源码解析</title>
    <url>/2022/02/16/java/dubbo/dubbo_3/</url>
    <content><![CDATA[<h2 id="Dubbo-SPI架构图"><a href="#Dubbo-SPI架构图" class="headerlink" title="Dubbo SPI架构图"></a>Dubbo SPI架构图</h2><p><img src="https://images.lilhui.com/8920bd45bf8beedd17b1bab7339363cc" alt="图片"></p>
<ul>
<li>Demo获取Dubbo的protocol扩展点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExtensionLoader&lt;Protocol&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Protocol http = extensionLoader.getExtension(<span class="string">"dubbo"</span>);</span><br><span class="line">System.out.println(http);</span><br></pre></td></tr></table></figure>
<p>在ExtensionLoader类的内部有一个static的ConcurrentHashMap，用来缓存某个接口类型所对应的ExtensionLoader实例.</p>
<h2 id="ExtensionLoader"><a href="#ExtensionLoader" class="headerlink" title="ExtensionLoader"></a>ExtensionLoader</h2><p>ExtensionLoader表示某个接口的扩展点加载器，可以用来加载某个扩展点实例。<br>在ExtensionLoader中除开有上文的static的Map外，还有两个非常重要的属性：</p>
<ol>
<li>Class&lt;?&gt; type：表示当前ExtensionLoader实例是哪个接口的扩展点加载器</li>
<li>ExtensionFactory objectFactory：扩展点工厂（对象工厂），可以获得某个对象</li>
</ol>
<p>ExtensionLoader和ExtensionFactory的区别在于：</p>
<ol>
<li>ExtensionLoader最终所得到的对象是Dubbo SPI机制产生的</li>
<li>ExtensionFactory最终所得到的对象可能是Dubbo SPI机制所产生的，也可能是从Spring容器中所获得的对象</li>
</ol>
<p>在ExtensionLoader中有三个常用的方法：</p>
<ol>
<li>getExtension(“dubbo”)：表示获取名字为dubbo的扩展点实例</li>
<li>getAdaptiveExtension()：表示获取一个自适应的扩展点实例</li>
<li>getActivateExtension(URL url, String[] values, String group)：表示一个可以被url激活的扩展点实例，后文详细解释</li>
</ol>
<p>其中，什么是自适应扩展点实例？它其实就是当前这个接口的一个代理对象。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExtensionLoader&lt;Protocol&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Protocol protocol = extensionLoader.getExtension(<span class="string">"dubbo"</span>);</span><br></pre></td></tr></table></figure></p>
<p>当我们调用上述代码，我们会将得到一个DubboProtocol的实例对象，但在getExtension()方法中，Dubbo会对DubboProtocol对象进行依赖注入（也就是自动给属性赋值，属性的类型为一个接口，记为A接口），这个时候，对于Dubbo来说它并不知道该给这个属性赋什么值，换句话说，Dubbo并不知道在进行依赖注入时该找一个什么的的扩展点对象给这个属性，这时就会预先赋值一个A接口的自适应扩展点实例，也就是A接口的一个代理对象。</p>
<p>后续，在A接口的代理对象被真正用到时，才会结合URL信息找到真正的A接口对应的扩展点实例进行调用。</p>
<p><img src="https://images.lilhui.com/d917674e8a07d8f91ed5a9e4ebf49e04" alt="图片"></p>
<h3 id="getExtension-String-name-方法"><a href="#getExtension-String-name-方法" class="headerlink" title="getExtension(String name)方法"></a>getExtension(String name)方法</h3><p>在调用getExtension去获取一个扩展点实例后，会对实例进行缓存，下次再获取同样名字的扩展点实例时就会从缓存中拿了。</p>
<h3 id="createExtension-String-name-方法"><a href="#createExtension-String-name-方法" class="headerlink" title="createExtension(String name)方法"></a>createExtension(String name)方法</h3><p>在调用createExtension(String name)方法去创建一个扩展点实例时，要经过以下几个步骤：</p>
<ol>
<li>根据name找到对应的扩展点实现类</li>
<li>根据实现类生成一个实例，把实现类和对应生成的实例进行缓存</li>
<li>对生成出来的实例进行依赖注入（给实例的属性进行赋值）</li>
<li>对依赖注入后的实例进行AOP（Wrapper）,把当前接口类的所有的Wrapper全部一层一层包裹在实例对象上，没包裹个Wrapper后，也会对Wrapper对象进行依赖注入</li>
<li>返回最终的Wrapper对象</li>
</ol>
<p><img src="https://images.lilhui.com/265316c207746d158fcfe520beebd065" alt="图片"></p>
<h3 id="getExtensionClasses"><a href="#getExtensionClasses" class="headerlink" title="getExtensionClasses"></a>getExtensionClasses</h3><p>getExtensionClasses()是用来加载当前接口所有的扩展点实现类的，返回一个Map。之后可以从这个Map中按照指定的name获取对应的扩展点实现类。</p>
<p>当把当前接口的所有扩展点实现类都加载出来后也会进行缓存，下次需要加载时直接拿缓存中的。</p>
<p>Dubbo在加载一个接口的扩展点时，思路是这样的：</p>
<ol>
<li>根据接口的全限定名去META-INF/dubbo/internal/目录下寻找对应的文件，调用loadResource方法进行加载</li>
<li>根据接口的全限定名去META-INF/dubbo/目录下寻找对应的文件，调用loadResource方法进行加载</li>
<li>根据接口的全限定名去META-INF/services/目录下寻找对应的文件，调用loadResource方法进行加载</li>
</ol>
<p>这里其实会设计到老版本兼容的逻辑，不解释了。</p>
<h3 id="loadResource方法"><a href="#loadResource方法" class="headerlink" title="loadResource方法"></a>loadResource方法</h3><p>loadResource方法就是完成对文件内容的解析，按行进行解析，会解析出”=”两边的内容，”=”左边的内容就是扩展点的name，右边的内容就是扩展点实现类，并且会利用ExtensionLoader类的类加载器来加载扩展点实现类。</p>
<p>然后调用loadClass方法对name和扩展点实例进行详细的解析，并且最终把他们放到Map中去。</p>
<h3 id="loadClass方法"><a href="#loadClass方法" class="headerlink" title="loadClass方法"></a>loadClass方法</h3><p>loadClass方法会做如下几件事情：</p>
<ol>
<li>当前扩展点实现类上是否存在@Adaptive注解，如果存在则把该类认为是当前接口的默认自适应类（接口代理类），并把该类存到cachedAdaptiveClass属性上。</li>
<li>当前扩展点实现是否是一个当前接口的一个Wrapper类，如果判断的？就是看当前类中是否存在一个构造方法，该构造方法只有一个参数，参数类型为接口类型，如果存在这一的构造方法，那么这个类就是该接口的Wrapper类，如果是，则把该类添加到cachedWrapperClasses中去， cachedWrapperClasses是一个set。</li>
<li>如果不是自适应类，或者也不是Wrapper类，则判断是有存在name，如果没有name，则报错。</li>
<li>如果有多个name，则判断一下当前扩展点实现类上是否存在@Activate注解，如果存在，则把该类添加到cachedActivates中，cachedWrapperClasses是一个map。</li>
<li>最后，遍历多个name，把每个name和对应的实现类存到extensionClasses中去，extensionClasses就是上文所提到的map。</li>
</ol>
<p>至此，加载类就走完了。<br>回到createExtension(String name)方法中的逻辑，当前这个接口的所有扩展点实现类都扫描完了之后，就可以根据用户所指定的名字，找到对应的实现类了，然后进行实例化，然后进行IOC(依赖注入)和AOP。</p>
<h2 id="Dubbo中的IOC"><a href="#Dubbo中的IOC" class="headerlink" title="Dubbo中的IOC"></a>Dubbo中的IOC</h2><ol>
<li>根据当前实例的类，找到这个类中的setter方法，进行依赖注入</li>
<li>先分析出setter方法的参数类型pt</li>
<li>在截取出setter方法所对应的属性名property</li>
<li>调用objectFactory.getExtension(pt, property)得到一个对象，这里就会从Spring容器或通过DubboSpi机制得到一个对象，比较特殊的是，如果是通过DubboSpi机制得到的对象，是pt这个类型的一个自适应对象(代理对象)。</li>
<li>再反射调用setter方法进行注入</li>
</ol>
<h2 id="Dubbo中的AOP"><a href="#Dubbo中的AOP" class="headerlink" title="Dubbo中的AOP"></a>Dubbo中的AOP</h2><p>dubbo中也实现了一套非常简单的AOP，就是利用Wrapper，如果一个接口的扩展点中包含了多个Wrapper类，那么在实例化完某个扩展点后，就会利用这些Wrapper类对这个实例进行包裹，比如：现在有一个DubboProtocol的实例，同时对于Protocol这个接口还有很多的Wrapper，比如ProtocolFilterWrapper、ProtocolListenerWrapper，那么，当对DubboProtocol的实例完成了IOC之后，就会先调用new ProtocolFilterWrapper(DubboProtocol实例)生成一个新的Protocol的实例，再对此实例进行IOC，完了之后，会再调用new ProtocolListenerWrapper(ProtocolFilterWrapper实例)生成一个新的Protocol的实例，然后进行IOC，从而完成DubboProtocol实例的AOP。</p>
<h2 id="自适应扩展点补充"><a href="#自适应扩展点补充" class="headerlink" title="自适应扩展点补充"></a>自适应扩展点补充</h2><p>上面提到的自适应扩展点对象，也就是某个接口的代理对象是通过Dubbo内部生成代理类，然后生成代理对象的。</p>
<p>额外的，在Dubbo中还设计另外一种机制来生成自适应扩展点，这种机制就是可以通过@Adaptive注解来指定某个类为某个接口的代理类，如果指定了，Dubbo在生成自适应扩展点对象时实际上生成的就是@Adaptive注解所注解的类的实例对象。</p>
<p>如果是由Dubbo默认实现的，那么我们就看看Dubbo是如何生成代理类的。</p>
<h3 id="createAdaptiveExtensionClass方法"><a href="#createAdaptiveExtensionClass方法" class="headerlink" title="createAdaptiveExtensionClass方法"></a>createAdaptiveExtensionClass方法</h3><p>createAdaptiveExtensionClass方法就是Dubbo中默认生成Adaptive类实例的逻辑。说白了，这个实例就是当前这个接口的一个代理对象。比如下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExtensionLoader&lt;Protocol&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Protocol protocol = extensionLoader.getAdaptiveExtension();</span><br></pre></td></tr></table></figure>
<p>这个代码就是Protocol接口的一个代理对象，那么代理逻辑就是在new AdaptiveClassCodeGenerator(type, cachedDefaultName).generate()方法中。</p>
<ol>
<li>type就是接口</li>
<li>cacheDefaultName就是该接口默认的扩展点实现的名字</li>
</ol>
<p>看个例子，Protocol接口的Adaptive类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.rpc;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Protocol</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">rpc</span>.<span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"The method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"The method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Exporter <span class="title">export</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument == null"</span>);</span><br><span class="line">		<span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument getUrl() == null"</span>);</span><br><span class="line">		</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">		</span><br><span class="line">        String extName = ( url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol() );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url ("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        </span><br><span class="line">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">extName</span>)</span>;</span><br><span class="line"> 		</span><br><span class="line">        <span class="keyword">return</span> extension.export(arg0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Invoker <span class="title">refer</span><span class="params">(java.lang.Class arg0, org.apache.dubbo.common.URL arg1)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arg1 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line"></span><br><span class="line">        org.apache.dubbo.common.URL url = arg1;</span><br><span class="line"></span><br><span class="line">        String extName = ( url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol() );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url ("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line"></span><br><span class="line">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">extName</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> extension.refer(arg0, arg1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，Protocol接口中有四个方法，但是只有export和refer两个方法进行代理。为什么？因为Protocol接口中在export方法和refer方法上加了@Adaptive注解。但是，不是只要在方法上加了@Adaptive注解就可以进行代理，还有其他条件，比如：</p>
<ol>
<li>该方法如果是无参的，那么则会报错</li>
<li>该方法有参数，可以有多个，并且其中某个参数类型是URL，那么则可以进行代理</li>
<li>该方法有参数，可以有多个，但是没有URL类型的参数，那么则不能进行代理</li>
<li>该方法有参数，可以有多个，没有URL类型的参数，但是如果这些参数类型，对应的类中存在getUrl方法（返回值类型为URL），那么也可以进行代理</li>
</ol>
<p>所以，可以发现，某个接口的Adaptive对象，在调用某个方法时，是通过该方法中的URL参数，通过调用ExtensionLoader.getExtensionLoader(com.luban.Car.class).getExtension(extName);得到一个扩展点实例，然后调用该实例对应的方法。</p>
<h3 id="Activate扩展点"><a href="#Activate扩展点" class="headerlink" title="Activate扩展点"></a>Activate扩展点</h3><p>上文说到，每个扩展点都有一个name，通过这个name可以获得该name对应的扩展点实例，但是有的场景下，希望一次性获得多个扩展点实例</p>
<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight plain"><figcaption><span>extensionLoader </span></figcaption><table><tr><td class="code"><pre><span class="line">URL url = new URL(&quot;http://&quot;, &quot;localhost&quot;, 8080);</span><br><span class="line">url = url.addParameter(&quot;cache&quot;, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">List&lt;Filter&gt; activateExtensions = extensionLoader.getActivateExtension(url, </span><br><span class="line">                                                      new String[]&#123;&quot;validation&quot;&#125;,</span><br><span class="line">                                                      CommonConstants.CONSUMER);</span><br><span class="line">for (Filter activateExtension : activateExtensions) &#123;</span><br><span class="line">	System.out.println(activateExtension);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会找到5个Filter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.apache.dubbo.rpc.filter.ConsumerContextFilter@<span class="number">4566e5</span>bd</span><br><span class="line">org.apache.dubbo.rpc.protocol.dubbo.filter.FutureFilter@<span class="number">1</span>ed4004b</span><br><span class="line">org.apache.dubbo.monitor.support.MonitorFilter<span class="meta">@ff</span>5b51f</span><br><span class="line">org.apache.dubbo.cache.filter.CacheFilter@<span class="number">25</span>bbe1b6</span><br><span class="line">org.apache.dubbo.validation.filter.ValidationFilter@<span class="number">5702</span>b3b1</span><br></pre></td></tr></table></figure>
<p>前三个是通过CommonConstants.CONSUMER找到的<br>CacheFilter是通过url中的参数找到的<br>ValidationFilter是通过指定的name找到的</p>
<p>在一个扩展点类上，可以添加@Activate注解，这个注解的属性有：</p>
<ol>
<li>String[] group()：表示这个扩展点是属于哪组的，这里组通常分为PROVIDER和CONSUMER，表示该扩展点能在服务提供者端，或者消费端使用</li>
<li>String[] value()：表示的是URL中的某个参数key，当利用getActivateExtension方法来寻找扩展点时，如果传入的url中包含的参数的所有key中，包括了当前扩展点中的value值，那么则表示当前url可以使用该扩展点</li>
</ol>
]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>SPI</tag>
      </tags>
  </entry>
  <entry>
    <title>【分布式事务问题】TCC模式常见问题以及解决</title>
    <url>/2021/12/03/java/distributed/distributed_2/</url>
    <content><![CDATA[<h2 id="TCC的异常场景"><a href="#TCC的异常场景" class="headerlink" title="TCC的异常场景"></a>TCC的异常场景</h2><p>在分布式系统中，随时随地都需要面对网络超时，网络重发和服务器宕机等问题。所以分布式事务框架作为搭载在分布式系统之上的一个框架型应用也绕不开这些问题。具体而言，有以下常见问题：</p>
<ol>
<li>幂等处理</li>
<li>空回滚</li>
<li>资源悬挂</li>
</ol>
<p>这些异常的应对需要TCC框架的支持和解决方案。</p>
<h2 id="幂等处理"><a href="#幂等处理" class="headerlink" title="幂等处理"></a>幂等处理</h2><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>因为网络抖动等原因，分布式事务框架可能会<strong>重复调用同一个分布式事务中的一个分支事务的二阶段接口</strong>。所以分支事务的二阶段接口Confirm/Cancel需要能够保证幂等性。如果二阶段接口不能保证幂等性，则会产生严重的问题，造成资源的重复使用或者重复释放，进而导致业务故障。（多次执行cancel confirm   重试操作）</p>
<p><img src="https://images.lilhui.com/010edd2e9bfc776ea7ff279c73ad3720" alt="图片"></p>
<p>从上图中红色部分可以看到：如果当TC调用参与者的二阶段方法时，发生了异常(TC本身异常或者网络异常丢失结果)。此时TC无法感知到调用的结果。为了保证分布式事务能够走到终态，此时TC会按照一定的规则重复调用参与者的二阶段方法。</p>
<h3 id="应对策略"><a href="#应对策略" class="headerlink" title="应对策略"></a>应对策略</h3><p>对于幂等类型的问题，通常的手段是引入幂等字段进行防重放攻击。对于分布式事务框架中的幂等问题，同样可以祭出这一利器。我们可以通过增加一张<strong>事务状态控制表</strong>来实现，这个表的关键字段有以下几个：</p>
<ol>
<li>主事务ID</li>
<li>分支事务ID</li>
<li>分支事务状态</li>
</ol>
<p>其中1和2构成表的联合主键来唯一标识一笔分布式事务中的一条分支事务。3用来标识该分支事务的状态，一共有3种状态：<br>INIT(I) - 初始化<br>CONFIRMED© - 已提交<br>ROLLBACKED® - 已回滚  </p>
<p>幂等记录的插入时机是参与者的Try方法，此时的分支事务状态会被初始化为INIT。然后当二阶段的Confirm/Cancel执行时会将其状态置为CONFIRMED/ROLLBACKED。</p>
<p>当TC重复调用二阶段接口时，参与者会先获取事务状态控制表的对应记录查看其事务状态。如果状态已经为CONFIRMED/ROLLBACKED，那么表示参与者已经处理完其分内之事，不需要再次执行，可以直接返回幂等成功的结果给TC，帮助其推进分布式事务。增加了幂等记录的写入和读取判断后，时序图如下(蓝色部分)：</p>
<p><img src="https://images.lilhui.com/c77b3d00cd350f897ccac0d16dc47974" alt="图片"></p>
<h2 id="空回滚"><a href="#空回滚" class="headerlink" title="空回滚"></a>空回滚</h2><h3 id="产生原因-1"><a href="#产生原因-1" class="headerlink" title="产生原因"></a>产生原因</h3><p>先来说定义，当没有调用参与方Try方法的情况下，就调用了二阶段的Cancel方法，Cancel方法需要有办法识别出此时Try有没有执行。如果Try还没执行，表示这个Cancel操作是无效的，即本次Cancel属于空回滚；如果Try已经执行，那么执行的是正常的回滚逻辑。</p>
<p><img src="https://images.lilhui.com/df780906ab4661d139ee0b75dab41057" alt="图片"></p>
<p>如上图所示，红色部分的一阶段Try可能失败。</p>
<p>首先发起方在调用参与者之前，会向TC申请开始一笔分布式事务。然后发起方调用参与者的一阶段方法，在调用实际发生之前，一般会有切面拦截器感知到此次Try调用，然后写入一条分支事务记录。紧接着，在实际调用参与者的Try方法时发生了异常。异常原因可以是发起方宕机，网络抖动等。</p>
<p>总而言之，就是Try方法没有执行成功，然而此时这笔分布式事务和分支事务已经落库。有两种情况会触发分布式事务的回滚：</p>
<ol>
<li>发起方认为当前分布式事务无法成功，主动通知TC回滚</li>
<li>TC发现分布式事务超时，被动触发回滚</li>
</ol>
<p>触发回滚操作后，TC会对该分布式事务关联的分支事务调用其二阶段Cancel。在执行Cancel时，Try还未执行成功，触发空回滚。如果不对空回滚加以防范的话，可能会造成资源的无效释放。即在没有预留资源的情况下就释放资源，造成故障。</p>
<h3 id="应对策略-1"><a href="#应对策略-1" class="headerlink" title="应对策略"></a>应对策略</h3><p>可以发现，要应对空回滚的问题，就需要让参与者在二阶段的Cancel方法中有办法识别到一阶段的Try是否已经执行。<br>很显然，可以继续利用<strong>事务状态控制</strong>表来实现这个功能。</p>
<p>前面提到过为了保证幂等性，当Try方法被成功执行后，会插入一条记录，标识该分支事务处于INIT状态。所以后续当二阶段的Cancel方法被调用时，可以通过查询控制表的对应记录进行判断。如果记录存在且状态为INIT，就表示一阶段已成功执行，可以正常执行回滚操作，释放预留的资源；如果记录不存在则表示一阶段未执行，本次为空回滚，不释放任何资源。</p>
<p>时序图如下所示：</p>
<p><img src="https://images.lilhui.com/5cdd703d498a93fb68ad70771ab9d439" alt="图片"></p>
<h2 id="资源悬挂（try-cancel-–try-循环执行，cancel在try之前）"><a href="#资源悬挂（try-cancel-–try-循环执行，cancel在try之前）" class="headerlink" title="资源悬挂（try - cancel –try  循环执行，cancel在try之前）"></a>资源悬挂（try - cancel –try  循环执行，cancel在try之前）</h2><h3 id="产生原因-2"><a href="#产生原因-2" class="headerlink" title="产生原因"></a>产生原因</h3><p>悬挂，顾名思义，是有一些资源被悬挂起来后续无法处理了。那么什么场景下才会出现这种现象呢？</p>
<p>上一节中提到过空回滚，指的是当一阶段Try未执行成功，而二阶段Cancel就因TC回滚整个分布式事务而被调用。</p>
<p>但是考虑一种极端情况，当分布式事务到终态后，参与者的一阶段Try才被执行，此时参与者会根据业务需求预留相关资源。预留资源只有当前事务才能使用，然而此时分布式事务已经走到终态，后续再没有任何手段能够处理这些预留资源。至此，就形成了资源悬挂。</p>
<p>这种一阶段比二阶段执行的还晚的情况看似不可能，但是仔细考虑RPC调用的时序，其实这种情况在复杂多变的网络中是完全可能的，下面的时序展示了这种可能性：</p>
<ol>
<li>发起方通过RPC调用参与者一阶段Try，但是发生网络阻塞导致RPC超时</li>
<li>RPC超时后，TC会回滚分布式事务(可能是发起方主动通知TC回滚或者是TC发现事务超时后回滚)，调用已注册的各个参与方的二阶段Cancel</li>
<li>参与方空回滚后，发起方对参与者的一阶段Try才开始执行，进行资源预留从而形成悬挂</li>
</ol>
<p>使用时序图来描述，红色部分为产生资源悬挂的关键步骤：</p>
<p><img src="https://images.lilhui.com/2c269f2d9a233c752b935b3ce59f6d5e" alt="图片"></p>
<h3 id="应对策略-2"><a href="#应对策略-2" class="headerlink" title="应对策略"></a>应对策略</h3><p>资源悬挂的本质原因在于，一阶段和二阶段的执行顺序没有被严格地保证。所以相应的解决方案还是通过读取事务状态控制表的事务状态。</p>
<p>前面在幂等方案的讨论中说过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">幂等记录的插入时机是参与者的Try方法，此时的分支事务状态会被初始化为INIT。然后当二阶段的Confirm/Cancel执行时会将其状态置为CONFIRMED/ROLLBACKED。</span><br></pre></td></tr></table></figure>
<p>由于悬挂的产生背景是一阶段方法根本就未执行，所以此时事务控制记录是不存在的，需要在二阶段中处理ROLLBACK的情况(因为超时后触发回滚不可能存在二阶段为CONFIRM)。</p>
<p>处理方案为在判断为空回滚的场景下(体现在对应一阶段事务控制记录不存在)，插入一条状态为ROLLBACKED的控制记录。</p>
<p>那么下次当一阶段Try抵达执行的时候，首先会尝试插入状态为INIT的事务控制记录。如果插入失败，表示当前分支事务的记录已经存在，Try无需继续执行。有几种可能性会导致此情形：</p>
<ol>
<li>一阶段Try重复请求，网络抖动情况可能发生，可以理解为命中幂等</li>
<li>二阶段插入了防悬挂记录，一阶段不可继续执行</li>
</ol>
<p>时序图描述如下，蓝色部分为防止资源悬挂增加的检查项：</p>
<p><img src="https://images.lilhui.com/200bc9ff36e970c062980826f14a6550" alt="图片"></p>
<h2 id="三种异常总结"><a href="#三种异常总结" class="headerlink" title="三种异常总结"></a>三种异常总结</h2><p>前面讨论了分布式事务三种典型的异常类型，它们的解决方案都依赖于一张<strong>事务状态控制表</strong>。我们来尝试总结一下它们各自的特点。</p>
<h3 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h3><p><strong>问题</strong>:TC重复调用二阶段<br><strong>解决</strong>:事务状态控制记录作为控制手段，只有存在INIT记录时蔡执行，存在CONFIRMED/ROLLBACKED记录时不再执行</p>
<h3 id="空回滚-1"><a href="#空回滚-1" class="headerlink" title="空回滚"></a>空回滚</h3><p><strong>问题</strong>：TC回滚事务调用二阶段，但一阶段尚未执行<br><strong>解决</strong>：事务状态控制记录作为控制手段，无记录时即为空回滚</p>
<h3 id="资源悬挂"><a href="#资源悬挂" class="headerlink" title="资源悬挂"></a>资源悬挂</h3><p><strong>问题</strong>：TC回滚事务调用二阶段完成空回滚后，一阶段执行成功<br><strong>解决</strong>：事务状态控制记录作为控制手段，二阶段发现无记录时插入记录，一阶段执行时检查记录是否存在</p>
<h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><ol>
<li>核心的解决方案就是事务状态控制表  </li>
<li>幂等控制作为最基础的异常处理手段；资源悬挂的前置条件是空回滚，所以发生空回滚时会插入一条状态为ROLLBACKED的控制记录</li>
</ol>
]]></content>
      <categories>
        <category>电商</category>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>分布式事务</tag>
        <tag>亿级流量</tag>
        <tag>TCC</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列：JVM内存优化建议</title>
    <url>/2017/10/09/java/jvm/jvm_2/</url>
    <content><![CDATA[<h3 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h3><p>JAVA程序在运行时  </p>
<ol>
<li>加快GC速度</li>
<li>减少FullGC</li>
<li>减少停顿</li>
<li>杜绝GC出错<blockquote>
<p>GC优化的策略本质上JVM运行中通过参数的变换调和达到运行平衡的过程。it is an art.</p>
</blockquote>
<h3 id="经验配置"><a href="#经验配置" class="headerlink" title="经验配置"></a>经验配置</h3></li>
</ol>
<h4 id="垃圾搜集器"><a href="#垃圾搜集器" class="headerlink" title="垃圾搜集器"></a>垃圾搜集器</h4><p>新生代收集器：有Serial收集器、ParNew收集器、Parallel Scavenge收集器<br>老生代收集器：Serial Old收集器、Parallel Old收集器、CMS收集器、G1收集器<br>以上所有的垃圾收集器都会发生STW，只不过FGC的STW时间更长。</p>
<h5 id="常用搜集器："><a href="#常用搜集器：" class="headerlink" title="常用搜集器："></a>常用搜集器：</h5><ul>
<li>CMSGC<br>  CMS(Concurrent Mark-Sweep)是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合，因此我们又叫它低延迟垃圾收集器。在启动JVM参数加上-XX:+UseConcMarkSweepGC ，这个参数表示对于老年代的回收采用CMS，注意此时新生代默认使用的是ParNew。CMS采用的基础算法是：标记—清除。</li>
<li>MSCGC vs CMSGC<br>  和普通序列化整理（MSC）区别在于有三个mark阶段（实际上还有个预清理过程，但对于解释清楚CMSGC没有帮助就忽略了）。CMSGC的精髓在于因为做到了不STW的情况下进行mark，我们得到了更短的总STW时间，代价是因为并行mark产生了『脏数据』即在mark的同时又生成了需要mark的对象，我们必须再进行一次STW，并收尾（remark）。<br>同时，我们要注意到得到更短的STW的同时，我们牺牲了系统吞吐量，CMSGC总吞吐量比ParOld要更低。</li>
<li>G1GC<br>  作为最新的垃圾收集器，有可能在jdk9中成为默认的垃圾收集器。<br>主要思路是将新生代老生代进一步分为多个region，每次gc可以针对部分region而不是整个堆内存。由此可以降低stw的单次最长时间，代价是可能在总时间上会更高。<br>G1GC让系统在整体吞吐量略降的情况下变得更加平滑稳定。</li>
</ul>
<h4 id="响应时间优先的应用"><a href="#响应时间优先的应用" class="headerlink" title="响应时间优先的应用"></a>响应时间优先的应用</h4><ul>
<li>年轻代选择<br>尽可能设大,直到接近系统的最低响应时间限制(根据实际情况选择).在此种情况下,年轻代收集发生的频率也是最小的.同时,减少到达年老代的对象.</li>
<li>年老代选择<br>年老代使用并发收集器,所以其大小需要小心设置,一般要考虑并发会话率和会话持续时间等一些参数.如果堆设置小了,可以会造成内存碎片,高回收频率以及应用暂停而使用传统的标记清除方式;如果堆大了,则需要较长的收集时间.最优化的方案,一般需要参考以下数据获得:<ol>
<li>并发垃圾收集信息.</li>
<li>持久代并发收集次数.</li>
<li>传统GC信息.</li>
<li>花在年轻代和年老代回收上的时间比例。<h4 id="吞吐量优先的应用"><a href="#吞吐量优先的应用" class="headerlink" title="吞吐量优先的应用"></a>吞吐量优先的应用</h4></li>
</ol>
</li>
<li>年轻代选择<br>尽可能的设置大,可能到达Gbit的程度.因为对响应时间没有要求,垃圾收集可以并行进行,一般适合8CPU以上的应用.<br>避免设置过小.当新生代设置过小时会导致:<ol>
<li>YGC次数更加频繁 </li>
<li>可能导致YGC对象直接进入旧生代,如果此时旧生代满了,会触发FGC.</li>
</ol>
</li>
<li>年老代选择<br>一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代.这样可以尽可能回收掉大部分短期对象,减少中期的对象,而年老代尽存放长期存活对象.</li>
</ul>
<h4 id="碎片问题"><a href="#碎片问题" class="headerlink" title="碎片问题"></a>碎片问题</h4><p>因为年老代的并发收集器使用标记,清除算法,所以不会对堆进行压缩.当收集器回收时,他会把相邻的空间进行合并,这样可以分配给较大的对象.但是,当堆空间较小时,运行一段时间以后,就会出现”碎片”,如果并发收集器找不到足够的空间,那么并发收集器将会停止,然后使用传统的标记,清除方式进行回收.如果出现”碎片”,可能需要进行如下配置:</p>
<blockquote>
<p>-XX:+UseCMSCompactAtFullCollection:使用并发收集器时,开启对年老代的压缩.<br>-XX:CMSFullGCsBeforeCompaction=0:上面配置开启的情况下,这里设置多少次Full GC后,对年老代进行压缩</p>
</blockquote>
<h4 id="promotion-failed问题"><a href="#promotion-failed问题" class="headerlink" title="promotion failed问题"></a>promotion failed问题</h4><p>可能是两种原因产生：</p>
<pre><code>1. 第一个原因是救助空间不够，救助空间里的对象还不应该被移动到年老代，但年轻代又有很多对象需要放入救助空间。
2. 第二个原因是年老代没有足够的空间接纳来自年轻代的对象；这两种情况都会转向Full GC，网站停顿时间较长。
</code></pre><p>用64位操作系统，Linux下64位的jdk比32位jdk要慢一些，但是吃得内存更多，吞吐量更大<br>XMX和XMS设置一样大，MaxPermSize和MinPermSize设置一样大，这样可以减轻伸缩堆大小带来的压力</p>
<ul>
<li>使用CMS的好处是用尽量少的新生代，经验值是128M－256M， 老生代利用CMS并行收集，这样能保证系统低延迟的吞吐效率。 </li>
<li>cms的收集停顿时间非常的短，2G的内存， 大约20－80ms的应用程序停顿时间<br>系统停顿的时候可能是GC的问题也可能是程序的问题，多用jmap和jstack查看，或者killall -3 java，然后查看java控制台日志，能看出很多问题。</li>
<li>如果用了缓存，那么年老代应该大一些，缓存的HashMap不应该无限制长，建议采用LRU算法的Map做缓存，LRUMap的最大长度也要根据实际情况设定。</li>
<li>采用并发回收时，年轻代小一点，年老代要大，因为年老大用的是并发回收，即使时间长点也不会影响其他程序继续运行，网站不会停顿<br>JVM参数的设置(特别是 –Xmx –Xms –Xmn -XX:SurvivorRatio  -XX:MaxTenuringThreshold等参数的设置没有一个固定的公式，需要根据PV old区实际数据 YGC次数等多方面来衡量。为了避免promotion faild可能会导致xmn设置偏小，也意味着YGC的次数会增多，处理并发访问的能力下降等问题。每个参数的调整都需要经过详细的性能测试，才能找到特定应用的最佳配置。</li>
</ul>
<p>解决方方案一：<br>    第一个原因最终解决办法是去掉救助空间，设置-XX:SurvivorRatio=65536 -XX:MaxTenuringThreshold=0即可，<br>    第二个原因我的解决办法是设置CMSInitiatingOccupancyFraction为某个值（假设70），这样年老代空间到70%时就开始执行CMS，年老代有足够的空间接纳来自年轻代的对象。<br>解决方案一的改进方案：</p>
<p>又有改进了，上面方法不太好，因为没有用到救助空间，所以年老代容易满，CMS执行会比较频繁。我改善了一下，还是用救助空间，但是把救助空间加大，这样也不会有promotion failed。具体操作上，32位Linux和64位Linux好像不一样，64位系统似乎只要配置MaxTenuringThreshold参数，CMS还是有暂停。为了解决暂停问题和promotion failed问题，最后我设置-XX:SurvivorRatio=1 ，并把MaxTenuringThreshold去掉，这样即没有暂停又不会有promotoin failed，而且更重要的是，年老代和永久代上升非常慢（因为好多对象到不了年老代就被回收了），所以CMS执行频率非常低，好几个小时才执行一次，这样，服务器都不用重启了。</p>
<p>-Xmx4000M -Xms4000M -Xmn600M -XX:PermSize=500M -XX:MaxPermSize=500M -Xss256K -XX:+DisableExplicitGC -XX:SurvivorRatio=1 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSClassUnloadingEnabled -XX:LargePageSizeInBytes=128M -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=80 -XX:SoftRefLRUPolicyMSPerMB=0 -XX:+PrintClassHistogram -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -Xloggc:log/gc.log</p>
<p>CMSInitiatingOccupancyFraction值与Xmn的关系公式</p>
<p>上面介绍了promontion faild产生的原因是EDEN空间不足的情况下将EDEN与From survivor中的存活对象存入To survivor区时,To survivor区的空间不足，再次晋升到old gen区，而old gen区内存也不够的情况下产生了promontion faild从而导致full gc.那可以推断出：eden+from survivor &lt; old gen区剩余内存时，不会出现promontion faild的情况，即：<br>(Xmx-Xmn)*(1-CMSInitiatingOccupancyFraction/100)&gt;=(Xmn-Xmn/(SurvivorRatior+2))  进而推断出：</p>
<p>CMSInitiatingOccupancyFraction &lt;=((Xmx-Xmn)-(Xmn-Xmn/(SurvivorRatior+2)))/(Xmx-Xmn)*100</p>
<p>例如：</p>
<p>当xmx=128 xmn=36 SurvivorRatior=1时 CMSInitiatingOccupancyFraction&lt;=((128.0-36)-(36-36/(1+2)))/(128-36)*100 =73.913</p>
<p>当xmx=128 xmn=24 SurvivorRatior=1时 CMSInitiatingOccupancyFraction&lt;=((128.0-24)-(24-24/(1+2)))/(128-24)*100=84.615…</p>
<p>当xmx=3000 xmn=600 SurvivorRatior=1时  CMSInitiatingOccupancyFraction&lt;=((3000.0-600)-(600-600/(1+2)))/(3000-600)*100=83.33</p>
<p>CMSInitiatingOccupancyFraction低于70% 需要调整xmn或SurvivorRatior值。</p>
<p>令：</p>
<p>网上一童鞋推断出的公式是：:(Xmx-Xmn)*(100-CMSInitiatingOccupancyFraction)/100&gt;=Xmn 这个公式个人认为不是很严谨，在内存小的时候会影响xmn的计算。</p>
<p>参考：<br><a href="http://www.cnblogs.com/redcreen/archive/2011/05/05/2038331.html" target="_blank" rel="noopener">http://www.cnblogs.com/redcreen/archive/2011/05/05/2038331.html</a><br><a href="http://www.jianshu.com/p/c9ac99b87d56" target="_blank" rel="noopener">http://www.jianshu.com/p/c9ac99b87d56</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm调优</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列：基础概念</title>
    <url>/2017/09/28/java/jvm/jvm_1/</url>
    <content><![CDATA[<blockquote>
<p>jvm内存区域分三种：栈，堆，方法区。设计上Java还可以使用到直接内存，在Java NIO包里使用DirectBuffer可以显示地调用申请堆外内存。</p>
</blockquote>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>   栈是基于线程执行而言的，它描述的是一个线程执行的流程路线。并且在整个业务执行流程中需要用到的各种局部变量（简单类型保存值，对象保存地址），以及基本类型。<br>    这个路线可以认为是通过方法区的程序执行流程，按照帧（Stack Frame)的方式一压入内存，在JVM内存<br>    看起来就是Stack的存储。</p>
<h4 id="栈的配置"><a href="#栈的配置" class="headerlink" title="栈的配置"></a>栈的配置</h4><p>   JVM通过 -XSS指定配置每个线程所拥有栈大小。默认值随着虚拟机版本以及操作系统影响，官网上指定：</p>
<blockquote>
<p>In Java SE 6, the default on Sparc is 512k in the 32-bit VM, and 1024k in the 64-bit VM. On x86 Solaris/Linux it is 320k in the 32-bit VM and 1024k in the 64-bit VM.<br>     。  </p>
</blockquote>
<p>   栈的大小直接影响可以创建的线程数量。</p>
<pre><code>线程数 = （系统空闲内存-堆内存（-Xms, -Xmx）- perm方法区内存(-XX:MaxPermSize)) / 线程栈大小(-Xss)
</code></pre><p>   如上我们可知栈设置越小，可以创建的线程数就越多，但是也是有限制的。限制有两个方便：</p>
<p>   操作系统配置也可以限制数量。例如ubuntu里/proc/sys/kernel/threads-max设置最大线程数。</p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>   调用链太长，栈不够时会抛出StackOverFlow。一般是发生了递归而产生。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>   堆是JVM最大的内存部分，它负责存放对象实例，JVM所有对象实例都在这里。（变量，对象属性但是不包括方法里的简单类型变量）。它保存了执行所需要的<br>   各种东西。</p>
<h3 id="堆的配置"><a href="#堆的配置" class="headerlink" title="堆的配置"></a>堆的配置</h3><table>
<thead>
<tr>
<th>参数名称</th>
<th>含义</th>
<th>默认值</th>
<th>其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>-Xms</td>
<td>初始堆大小</td>
<td>物理内存的1/64(&lt;1GB)</td>
<td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td>
</tr>
<tr>
<td>-Xmx</td>
<td>最大堆大小</td>
<td>物理内存的1/4(&lt;1GB)</td>
<td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td>
</tr>
<tr>
<td>-Xmn</td>
<td>年轻代大小</td>
<td>(1.4or lator)</td>
<td>注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td>
</tr>
<tr>
<td>-XX:NewSize</td>
<td>设置年轻代大小(for 1.3/1.4)</td>
<td></td>
</tr>
<tr>
<td>-XX:MaxNewSize</td>
<td>年轻代最大值(for 1.3/1.4)</td>
<td></td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>设置持久代(perm gen)初始值</td>
<td>物理内存的1/64     </td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>设置持久代最大值</td>
<td>物理内存的1/4     </td>
</tr>
<tr>
<td>-Xss</td>
<td>每个线程的堆栈大小</td>
<td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右</td>
<td>一般小的应用，如果栈不很深， 应该是128k够用的大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:”-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了</td>
</tr>
<tr>
<td>-XX:ThreadStackSize</td>
<td>Thread Stack Size</td>
<td>(0 means use default stack size) [Sparc: 512; Solaris x86: 320 (was 256 prior in 5.0 and earlier); Sparc 64 bit: 1024; Linux amd64: 1024 (was 0 in 5.0 and earlier); all others 0.]</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td>
<td>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5</td>
<td>Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>Eden区与Survivor区的大小比值</td>
<td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td>
</tr>
<tr>
<td>-XX:LargePageSizeInBytes</td>
<td>内存页的大小</td>
<td>不可设置过大， 会影响Perm的大小         =128m</td>
</tr>
<tr>
<td>-XX:+UseFastAccessorMethods</td>
<td>原始类型的快速优化</td>
<td></td>
</tr>
<tr>
<td>-XX:+DisableExplicitGC</td>
<td>关闭System.gc()</td>
<td>这个参数需要严格的测试</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>垃圾最大年龄</td>
<td>如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率该参数只有在串行GC时才有效.</td>
</tr>
<tr>
<td>-XX:+AggressiveOpts</td>
<td>加快编译          </td>
</tr>
<tr>
<td>-XX:+UseBiasedLocking</td>
<td>锁机制的性能改善          </td>
</tr>
<tr>
<td>-Xnoclassgc</td>
<td>禁用垃圾回收          </td>
</tr>
<tr>
<td>-XX:SoftRefLRUPolicyMSPerMB</td>
<td>每兆堆空闲空间中SoftReference的存活时间</td>
<td>1s    softly reachable objects will remain alive for some amount of time after the last time they were referenced. The default value is one second of lifetime per free megabyte in the heap</td>
</tr>
<tr>
<td>-XX:PretenureSizeThreshold</td>
<td>对象超过多大是直接在旧生代分配</td>
<td>0</td>
<td>单位字节 新生代采用Parallel Scavenge GC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td>
</tr>
<tr>
<td>-XX:TLABWasteTargetPercent</td>
<td>TLAB占eden区的百分比</td>
<td>1%     </td>
</tr>
<tr>
<td>-XX:+CollectGen0First</td>
<td>FullGC时是否先YGC</td>
<td>false     </td>
</tr>
</tbody>
</table>
<h4 id="并行收集器相关参数"><a href="#并行收集器相关参数" class="headerlink" title="并行收集器相关参数"></a>并行收集器相关参数</h4><table>
<thead>
<tr>
<th>参数名称</th>
<th>含义</th>
<th>默认值</th>
<th>其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>-XX:+UseParallelGC</td>
<td>Full GC采用parallel MSC</td>
<td></td>
<td>选择垃圾收集器为并行收集器.此配置仅对年轻代有效.即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集.(此项待验证)</td>
</tr>
<tr>
<td>-XX:+UseParNewGC</td>
<td>设置年轻代为并行收集</td>
<td>可与CMS收集同时使用</td>
<td>JDK5.0以上,JVM会根据系统配置自行设置,所以无需再设置此值</td>
</tr>
<tr>
<td>-XX:ParallelGCThreads</td>
<td>并行收集器的线程数</td>
<td>此值最好配置与处理器数目相等</td>
<td>同样适用于CMS</td>
</tr>
<tr>
<td>-XX:+UseParallelOldGC</td>
<td>年老代垃圾收集方式为并行收集(Parallel Compacting)</td>
<td></td>
<td>这个是JAVA 6出现的参数选项</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis</td>
<td>每次年轻代垃圾回收的最长时间(最大暂停时间)</td>
<td></td>
<td>如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.</td>
</tr>
<tr>
<td>-XX:+UseAdaptiveSizePolicy</td>
<td>自动选择年轻代区大小和相应的Survivor区比例</td>
<td></td>
<td>设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例,以达到目标系统规定的最低相应时间或者收集频率等,此值建议使用并行收集器时,一直打开.</td>
</tr>
<tr>
<td>-XX:GCTimeRatio</td>
<td>设置垃圾回收时间占程序运行时间的百分比</td>
<td>公式为1/(1+n)</td>
</tr>
<tr>
<td>-XX:+ScavengeBeforeFullGC</td>
<td>Full GC前调用YGC</td>
<td>true</td>
<td>Do young generation GC prior to a full GC. (Introduced in 1.4.1.)</td>
</tr>
</tbody>
</table>
<h4 id="CMS相关参数"><a href="#CMS相关参数" class="headerlink" title="CMS相关参数"></a>CMS相关参数</h4><table>
<thead>
<tr>
<th>参数名称</th>
<th>含义</th>
<th>默认值</th>
<th>其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>使用CMS内存收集</td>
<td></td>
<td>测试中配置这个以后,-XX:NewRatio=4的配置失效了,原因不明.所以,此时年轻代大小最好用-Xmn设置.???</td>
</tr>
<tr>
<td>-XX:+AggressiveHeap</td>
<td>试图是使用大量的物理内存</td>
<td></td>
<td>长时间大内存使用的优化，能检查计算资源（内存， 处理器数量）至少需要256MB内存大量的CPU／内存， （在1.4.1在4CPU的机器上已经显示有提升）</td>
</tr>
<tr>
<td>-XX:CMSFullGCsBeforeCompaction</td>
<td>多少次后进行内存压缩</td>
<td></td>
<td>由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生”碎片”,使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理.</td>
</tr>
<tr>
<td>-XX:+CMSParallelRemarkEnabled</td>
<td>降低标记停顿</td>
<td></td>
</tr>
<tr>
<td>-XX+UseCMSCompactAtFullCollection</td>
<td>在FULL GC的时候， 对年老代的压缩         CMS是不会移动内存的， 因此， 这个非常容易产生碎片， 导致内存不够用， 因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。</td>
<td></td>
<td>可能会影响性能,但是可以消除碎片</td>
</tr>
<tr>
<td>-XX:+UseCMSInitiatingOccupancyOnly</td>
<td>使用手动定义初始化定义开始CMS收集         禁止hostspot自行触发CMS GC</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:CMSInitiatingOccupancyFraction=70</td>
<td>使用cms作为垃圾回收</td>
</tr>
<tr>
<td>使用70％后开始CMS收集</td>
<td>92</td>
<td>为了保证不出现promotion failed(见下面介绍)错误,该值的设置需要满足以下公式CMSInitiatingOccupancyFraction计算公式</td>
</tr>
<tr>
<td>-XX:CMSInitiatingPermOccupancyFraction</td>
<td>设置Perm Gen使用到达多少比率时触发</td>
<td>92     </td>
</tr>
<tr>
<td>-XX:+CMSIncrementalMode</td>
<td>设置为增量模式</td>
<td>用于单CPU情况</td>
</tr>
<tr>
<td>-XX:+CMSClassUnloadingEnabled</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="辅助信息"><a href="#辅助信息" class="headerlink" title="辅助信息"></a>辅助信息</h4><table>
<thead>
<tr>
<th>参数名称</th>
<th>含义</th>
<th>默认值</th>
<th>其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>-XX:+PrintGC</td>
<td></td>
<td></td>
<td>输出形式:[GC 118250K-&gt;113543K(130112K), 0.0094143secs][Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td></td>
<td></td>
<td>输出形式:[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs][GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs]</td>
</tr>
<tr>
<td>-XX:+PrintGCTimeStamps</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:+PrintGC:PrintGCTimeStamps</td>
<td>可与-XX:+PrintGC -XX:+PrintGCDetails混合使用</td>
<td></td>
<td>输出形式:11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs]</td>
</tr>
<tr>
<td>-XX:+PrintGCApplicationStoppedTime</td>
<td>打印垃圾回收期间程序暂停的时间.可与上面混合使用</td>
<td></td>
<td>输出形式:Total time for which application threads were stopped: 0.0468229 seconds</td>
</tr>
<tr>
<td>-XX:+PrintGCApplicationConcurrentTime</td>
<td>打印每次垃圾回收前,程序未中断的执行时间.可与上面混合使用</td>
<td></td>
<td>输出形式:Application time: 0.5291524 seconds</td>
</tr>
<tr>
<td>-XX:+PrintHeapAtGC</td>
<td>打印GC前后的详细堆栈信息          </td>
</tr>
<tr>
<td>-Xloggc:filename</td>
<td>把相关日志信息记录到文件以便分析.与上面几个配合使用          </td>
</tr>
<tr>
<td>-XX:+PrintClassHistogram</td>
<td>garbage collects before printing the histogram.         </td>
</tr>
<tr>
<td>-XX:+PrintTLAB</td>
<td>查看TLAB空间的使用情况          </td>
</tr>
<tr>
<td>XX:+PrintTenuringDistribution</td>
<td>查看每次minor GC后新的存活周期的阈值</td>
<td>Desired survivor size 1048576 bytes, new threshold 7 (max 15)</td>
<td>new threshold 7即标识新的存活周期的阈值为7。</td>
</tr>
</tbody>
</table>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>   又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量；方法区中包含的都是在程序中永远的唯一的元素。特别说明的是枚举<br>   是存放在方法区，而单例是某个类在内存中唯一的对象实例，是存放在堆中的。</p>
<h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><p> -XX:PermSize=10M -XX:MaxPermSize=10M</p>
<ul>
<li>值得一提的是 JAVA8 将方法区 改成了 MateSpace (元数据区。) 同时 PerSize MaxPermSize参数也移除了。<br>带来了几个新的参数：<ol>
<li>-XX:MetaspaceSize，class metadata的初始空间配额，以bytes为单位，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当的降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize（如果设置了的话），适当的提高该值。</li>
<li>-XX:MaxMetaspaceSize，可以为class metadata分配的最大空间。默认是没有限制的。</li>
<li>-XX:MinMetaspaceFreeRatio,在GC之后，最小的Metaspace剩余空间容量的百分比，减少为class metadata分配空间导致的垃圾收集</li>
<li>-XX:MaxMetaspaceFreeRatio,在GC之后，最大的Metaspace剩余空间容量的百分比，减少为class metadata释放空间导致的垃圾收集XX:MaxMetaspaceSize<h3 id="总结图"><a href="#总结图" class="headerlink" title="总结图"></a>总结图</h3></li>
</ol>
</li>
</ul>
<p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1507544256116.png?imageView2/2/w/730/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm调优</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列：代理模式</title>
    <url>/2017/11/09/java/patterndesign/patterndesign_8/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>为另外一个对象提供一个替身或者占位符以控制对这个对象的访问。</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><ul>
<li>类图：</li>
</ul>
<p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1516184950018.png?imageView2/2/w/334/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<p>Car：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.proxy.statics;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Bus:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.proxy.statics;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bus run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BusProxy:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.proxy.statics;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusProxy</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"car proxy"</span>);</span><br><span class="line">        Car bus = <span class="keyword">new</span> Bus();</span><br><span class="line">        bus.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Client:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.proxy.statics;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car bus = <span class="keyword">new</span> BusProxy();</span><br><span class="line">        bus.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>car为接口</li>
<li>Bus实现car的run方法</li>
<li>BusProxy负责控制Bus访问方法。</li>
</ul>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><ul>
<li>类图：</li>
</ul>
<p><img src="http://ovuanu0c3.bkt.clouddn.com/hexo/1516184994403.png?imageView2/2/w/531/h/640/format/jpg/q/100|watermark/2/text/d3d3LmxpbGh1aS5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/Izk2OEM4Qw==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="图片"></p>
<p>动态代理是JDK支持的一种方式 实现例子如下：</p>
<p>Car<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.proxy.dymatic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Bus:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.proxy.dymatic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"car run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BusProxyFactory:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.proxy.dymatic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusProxyFactory</span><span class="params">(Object car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNewInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"开始事务"</span>);</span><br><span class="line">                        <span class="comment">//执行目标对象方法</span></span><br><span class="line">                        Object returnValue = method.invoke(target, args);</span><br><span class="line">                        System.out.println(<span class="string">"提交事务"</span>);</span><br><span class="line">                        <span class="keyword">return</span> returnValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Client:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.proxy.dymatic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car bus = <span class="keyword">new</span> Bus();</span><br><span class="line">        Car newBus = (Car) <span class="keyword">new</span> BusProxyFactory(bus).getNewInstance();</span><br><span class="line">        System.out.println(newBus.getClass());</span><br><span class="line">        newBus.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CGLIB动态代理，引入包spring-core-XX.jar<br>BusProxyFactoryCglib<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.proxy.dymatic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusProxyFactoryCglib</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;<span class="comment">//业务类对象，供代理方法中进行真正的业务方法调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//相当于JDK动态代理中的绑定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target; </span><br><span class="line">        <span class="comment">//创建加强器，用来创建动态代理类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer(); </span><br><span class="line">        <span class="comment">//为加强器指定要代理的业务类（即：为下面生成的代理类指定父类）</span></span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());  </span><br><span class="line">        <span class="comment">//设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 创建动态代理类对象并返回</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CGLIB的特有方式，不指定 具体对象，只指定类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstanceByClass</span><span class="params">(Class targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建加强器，用来创建动态代理类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer(); </span><br><span class="line">        <span class="comment">//为加强器指定要代理的业务类（即：为下面生成的代理类指定父类）</span></span><br><span class="line">        enhancer.setSuperclass(targetClass);  </span><br><span class="line">        <span class="comment">//设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 创建动态代理类对象并返回</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"预处理"</span>);</span><br><span class="line">        methodProxy.invokeSuper(o, objects); <span class="comment">//调用业务类（父类中）的方法</span></span><br><span class="line">        System.out.println(<span class="string">"调用后操作"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Client:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littlehui.design.proxy.dymatic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by littlehui on 2018/1/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car bus = <span class="keyword">new</span> Bus();</span><br><span class="line">        Car newBus = (Car) <span class="keyword">new</span> BusProxyFactory(bus).getNewInstance();</span><br><span class="line">        System.out.println(newBus.getClass());</span><br><span class="line">        newBus.run();</span><br><span class="line">        System.out.println(<span class="string">"-----------cglib------------"</span>);</span><br><span class="line">        Car cglibBus = (Car)<span class="keyword">new</span> BusProxyFactoryCglib().getInstanceByClass(Bus<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        cglibBus.run();</span><br><span class="line">        System.out.println(cglibBus.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>result:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/bin/java -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:62751,suspend=y,server=n -Dfile.encoding=UTF-8 -classpath &quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/lib/tools.jar:/Users/littlehui/WorkSpaces/Home/pattern/proxy/target/classes:/Users/littlehui/software/repository/org/springframework/spring-core/5.0.0.RC3/spring-core-5.0.0.RC3.jar:/Users/littlehui/software/repository/org/springframework/spring-jcl/5.0.0.RC3/spring-jcl-5.0.0.RC3.jar:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar&quot; com.littlehui.design.proxy.dymatic.Client</span><br><span class="line">Connected to the target VM, address: &apos;127.0.0.1:62751&apos;, transport: &apos;socket&apos;</span><br><span class="line">class com.sun.proxy.$Proxy0</span><br><span class="line">开始事务</span><br><span class="line">car run</span><br><span class="line">提交事务</span><br><span class="line">-----------cglib------------</span><br><span class="line">预处理</span><br><span class="line">Disconnected from the target VM, address: &apos;127.0.0.1:62751&apos;, transport: &apos;socket&apos;</span><br><span class="line">car run</span><br><span class="line">调用后操作</span><br><span class="line">class com.littlehui.design.proxy.dymatic.Bus$$EnhancerByCGLIB$$1e8a65c7</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></p>
<p>Cglib生成的动态代理类是业务类的子类，重写业务方法进行代理。<br>可以看到CGLIB调用的 class是 class com.littlehui.design.proxy.dymatic.Bus  这个在Spring类的装配和其他涉及获取Class的地方相当有用。</p>
<ul>
<li>car为接口</li>
<li>Bus实现Car的run方法</li>
<li>Bus对象的访问交给了BusProxyFactory控制。</li>
<li>BusProxyFactory执行中动态地加入了run方法执行前后的标识。<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3></li>
<li>Spring AOP </li>
</ul>
<ol>
<li>如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP </li>
<li>如果目标对象实现了接口，可以强制使用CGLIB实现AOP </li>
<li>如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>代理和装饰模式看起来很相似，但是深入理解，本质上是有区别的 主要的区别是：<br>使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。也就是那句话：代理模式可以控制被代理的对象<br>可以控制被代理对象的访问，而装饰模式是被装饰对象的增强。不体现在控制上。</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>swagger2 注解说明</title>
    <url>/2018/04/04/spring/swagger/swagger_1/</url>
    <content><![CDATA[<h3 id="整体说明"><a href="#整体说明" class="headerlink" title="整体说明"></a>整体说明</h3><blockquote>
<p>swagger2的在线文档功能异常强大。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Api：用在请求的类上，表示对类的说明</span><br><span class="line">    tags=&quot;说明该类的作用，可以在UI界面上看到的注解&quot;</span><br><span class="line">    value=&quot;该参数没什么意义，在UI界面上也看到，所以不需要配置&quot;</span><br><span class="line"></span><br><span class="line">@ApiOperation：用在请求的方法上，说明方法的用途、作用</span><br><span class="line">    value=&quot;说明方法的用途、作用&quot;</span><br><span class="line">    notes=&quot;方法的备注说明&quot;</span><br><span class="line"></span><br><span class="line">@ApiImplicitParams：用在请求的方法上，表示一组参数说明</span><br><span class="line">    @ApiImplicitParam：用在@ApiImplicitParams注解中，指定一个请求参数的各个方面</span><br><span class="line">        name：参数名</span><br><span class="line">        value：参数的汉字说明、解释</span><br><span class="line">        required：参数是否必须传</span><br><span class="line">        paramType：参数放在哪个地方</span><br><span class="line">            · header --&gt; 请求参数的获取：@RequestHeader</span><br><span class="line">            · query --&gt; 请求参数的获取：@RequestParam</span><br><span class="line">            · path（用于restful接口）--&gt; 请求参数的获取：@PathVariable</span><br><span class="line">            · body（不常用）</span><br><span class="line">            · form（不常用）    </span><br><span class="line">        dataType：参数类型，默认String，其它值dataType=&quot;Integer&quot;       </span><br><span class="line">        defaultValue：参数的默认值</span><br><span class="line"></span><br><span class="line">@ApiResponses：用在请求的方法上，表示一组响应</span><br><span class="line">    @ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息</span><br><span class="line">        code：数字，例如400</span><br><span class="line">        message：信息，例如&quot;请求参数没填好&quot;</span><br><span class="line">        response：抛出异常的类</span><br><span class="line"></span><br><span class="line">@ApiModel：用于响应类上，表示一个返回响应数据的信息</span><br><span class="line">            （这种一般用在post创建的时候，使用@RequestBody这样的场景，</span><br><span class="line">            请求参数无法使用@ApiImplicitParam注解进行描述的时候）</span><br><span class="line">    @ApiModelProperty：用在属性上，描述响应类的属性</span><br></pre></td></tr></table></figure>
<h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><ol>
<li>@Api：用在请求的类上，说明该类的作用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Api：用在请求的类上，说明该类的作用</span><br><span class="line">    tags=&quot;说明该类的作用&quot;</span><br><span class="line">    value=&quot;该参数没什么意义，所以不需要配置&quot;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>@ApiOperation：用在请求的方法上，说明方法的作用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiOperation：&quot;用在请求的方法上，说明方法的作用&quot;</span><br><span class="line">    value=&quot;说明方法的作用&quot;</span><br><span class="line">    notes=&quot;方法的备注说明</span><br></pre></td></tr></table></figure>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiOperation(value=&quot;用户注册&quot;,notes=&quot;手机号、密码都是必输项，年龄随边填，但必须是数字&quot;)</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>@ApiImplicitParams：用在请求的方法上，包含一组参数说明</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiImplicitParams：用在请求的方法上，包含一组参数说明</span><br><span class="line">    @ApiImplicitParam：用在 @ApiImplicitParams 注解中，指定一个请求参数的配置信息       </span><br><span class="line">        name：参数名</span><br><span class="line">        value：参数的汉字说明、解释</span><br><span class="line">        required：参数是否必须传</span><br><span class="line">        paramType：参数放在哪个地方</span><br><span class="line">            · header --&gt; 请求参数的获取：@RequestHeader</span><br><span class="line">            · query --&gt; 请求参数的获取：@RequestParam</span><br><span class="line">            · path（用于restful接口）--&gt; 请求参数的获取：@PathVariable</span><br><span class="line">            · body（不常用）</span><br><span class="line">            · form（不常用）    </span><br><span class="line">        dataType：参数类型，默认String，其它值dataType=&quot;Integer&quot;       </span><br><span class="line">        defaultValue：参数的默认值</span><br></pre></td></tr></table></figure>
<p>示列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiImplicitParams(&#123;</span><br><span class="line">    @ApiImplicitParam(name=&quot;mobile&quot;,value=&quot;手机号&quot;,required=true,paramType=&quot;form&quot;),</span><br><span class="line">    @ApiImplicitParam(name=&quot;password&quot;,value=&quot;密码&quot;,required=true,paramType=&quot;form&quot;),</span><br><span class="line">    @ApiImplicitParam(name=&quot;age&quot;,value=&quot;年龄&quot;,required=true,paramType=&quot;form&quot;,dataType=&quot;Integer&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>@ApiResponses：用于请求的方法上，表示一组响应</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiResponses：用于请求的方法上，表示一组响应</span><br><span class="line">    @ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息</span><br><span class="line">        code：数字，例如400</span><br><span class="line">        message：信息，例如&quot;请求参数没填好&quot;</span><br><span class="line">        response：抛出异常的类</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiOperation(value = &quot;select1请求&quot;,notes = &quot;多个参数，多种的查询参数类型&quot;)</span><br><span class="line">@ApiResponses(&#123;</span><br><span class="line">    @ApiResponse(code=400,message=&quot;请求参数没填好&quot;),</span><br><span class="line">    @ApiResponse(code=404,message=&quot;请求路径没有或页面跳转路径不对&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>@ApiModel：用于响应类上，表示一个返回响应数据的信息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiModel：用于响应类上，表示一个返回响应数据的信息</span><br><span class="line">            （这种一般用在post创建的时候，使用@RequestBody这样的场景，</span><br><span class="line">            请求参数无法使用@ApiImplicitParam注解进行描述的时候）</span><br><span class="line">    @ApiModelProperty：用在属性上，描述响应类的属性</span><br></pre></td></tr></table></figure>
<p>示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiModel</span>(description= <span class="string">"返回响应数据"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestMessage</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"是否成功"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> success=<span class="keyword">true</span>;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"返回对象"</span>)</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"错误编号"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer errCode;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"错误信息"</span>)</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* getter/setter */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring</category>
        <category>swagger</category>
      </categories>
      <tags>
        <tag>swagger</tag>
      </tags>
  </entry>
</search>
